#ifndef ARCHINPUTDIALOG_H
#define ARCHINPUTDIALOG_H

#include "DialogBox.h"

class XComApp;

class ArchInputDialog : public DialogBox
{
    FXDECLARE(ArchInputDialog)
protected:
    FXTextField*  input;
    FXPopup*      popup;
    FXOptionMenu* optionmenu;
    FXOption*     option_tgz;
    FXOption*     option_zip;
    FXOption*     option_7zip;
    FXOption*     option_tbz2;
    FXOption*     option_txz;
    FXOption*     option_tar;
    FXOption*     option_taz;
    FXOption*     option_gz;
    FXOption*     option_bz2;
    FXOption*     option_xz;
    FXOption*     option_z;

private:
    ArchInputDialog() : input(NULL), popup(NULL), optionmenu(NULL), option_tgz(NULL),
                        option_zip(NULL), option_7zip(NULL), option_tbz2(NULL), option_txz(NULL), option_tar(NULL),
                        option_taz(NULL), option_gz(NULL), option_bz2(NULL), option_xz(NULL), option_z(NULL)
    {}
public:
    enum
    {
        ID_BROWSE_PATH=DialogBox::ID_LAST,
        ID_FORMAT_TAR_GZ,
        ID_FORMAT_ZIP,
        ID_FORMAT_7ZIP,
        ID_FORMAT_TAR_BZ2,
        ID_FORMAT_TAR_XZ,
        ID_FORMAT_TAR,
        ID_FORMAT_TAR_Z,
        ID_FORMAT_GZ,
        ID_FORMAT_BZ2,
        ID_FORMAT_XZ,
        ID_FORMAT_Z,
        ID_LAST
    };
    ArchInputDialog(FXWindow*, FXString);
    virtual void create();

    virtual ~ArchInputDialog();
    long onCmdKeyPress(FXObject*, FXSelector, void*);
    long onCmdBrowsePath(FXObject*, FXSelector, void*);
    long onCmdOption(FXObject*, FXSelector, void*);
    long onUpdOption(FXObject*, FXSelector, void*);
    FXString getText()
    {
        return(input->getText());
    }

    void setText(const FXString& text)
    {
        input->setText(text);
    }

    void selectAll()
    {
        input->setSelection(0, (input->getText()).length());
    }

    void CursorEnd()
    {
        input->onCmdCursorEnd(0, 0, 0);
    }
};
#endif
#ifndef BOOKMARKS_H
#define BOOKMARKS_H

class FXAPI Bookmarks : public FXObject
{
    FXDECLARE(Bookmarks)
protected:
    FXString   group;           // MRU File group
    FXObject*  target;          // Target object to send message
    FXSelector message;         // Message to send
    int        maxbookmarks;    // Maximum number of bookmarks to track
private:
    Bookmarks(const Bookmarks&);
    Bookmarks& operator=(const Bookmarks&);

public:
    long onCmdClear(FXObject*, FXSelector, void*);
    long onCmdBookmark(FXObject*, FXSelector, void*);
    long onUpdBookmark(FXObject*, FXSelector, void*);
    long onUpdAnyBookmarks(FXObject*, FXSelector, void*);
public:
    enum
    {
        ID_CLEAR,
        ID_ANYBOOKMARKS,
        ID_BOOKMARK_1,
        ID_BOOKMARK_2,
        ID_BOOKMARK_3,
        ID_BOOKMARK_4,
        ID_BOOKMARK_5,
        ID_BOOKMARK_6,
        ID_BOOKMARK_7,
        ID_BOOKMARK_8,
        ID_BOOKMARK_9,
        ID_BOOKMARK_10,
        ID_BOOKMARK_11,
        ID_BOOKMARK_12,
        ID_BOOKMARK_13,
        ID_BOOKMARK_14,
        ID_BOOKMARK_15,
        ID_BOOKMARK_16,
        ID_BOOKMARK_17,
        ID_BOOKMARK_18,
        ID_BOOKMARK_19,
        ID_BOOKMARK_20
    };
public:

    // Make new Bookmarks Group with default groupname
    Bookmarks();

    // Make new Bookmarks Group with groupname gp
    Bookmarks(const FXString& gp, FXObject* tgt = NULL, FXSelector sel = 0);

    // Change number of bookmarks we're tracking
    void setMaxBookmarks(int mx)
    {
        maxbookmarks = mx;
    }

    // Return the maximum number of bookmarks being tracked
    int getMaxBookmarks() const
    {
        return(maxbookmarks);
    }

    // Set group name
    void setGroupName(const FXString& name)
    {
        group = name;
    }

    // Return group name
    FXString getGroupName() const
    {
        return(group);
    }

    // Change the target
    void setTarget(FXObject* t)
    {
        target = t;
    }

    // Get the target
    FXObject* getTarget() const
    {
        return(target);
    }

    // Change the message
    void setSelector(FXSelector sel)
    {
        message = sel;
    }

    // Return the message id
    FXSelector getSelector() const
    {
        return(message);
    }

    // Obtain the bookmark name at index
    FXString getBookmark(int index) const;

    // Change the bookmark name at index
    void setBookmark(int index, const FXString& filename);

    // Append a bookmark
    void appendBookmark(const FXString& filename);

    // Remove a bookmark
    void removeBookmark(const FXString& filename);

    // Clear the list of bookmarks
    void clear();

    // Destructor
    virtual ~Bookmarks();
};


#endif
#ifndef BROWSEINPUTDIALOG_H
#define BROWSEINPUTDIALOG_H

#include "TextLabel.h"
#include "DialogBox.h"

// Browse types
enum
{
    BROWSE_INPUT_FILE,
    BROWSE_INPUT_FOLDER,
    BROWSE_INPUT_MIXED
};

class XComApp;

class BrowseInputDialog : public DialogBox
{
    FXDECLARE(BrowseInputDialog)
protected:
    FXTextField*       input;
    TextLabel*         msg;
    FXLabel*           iconlabel;
    FXHorizontalFrame* checkbutton;
    FXuint             browsetype;
    FXString           initialdir;
private:
    BrowseInputDialog() : input(NULL), msg(NULL), iconlabel(NULL), checkbutton(NULL), browsetype(0)
    {}
public:
    enum
    {
        ID_BROWSE_PATH=DialogBox::ID_LAST,
        ID_LAST
    };
    BrowseInputDialog(FXWindow*, FXString, FXString, FXString, FXString label = "", FXIcon* ic = NULL, FXuint browse = BROWSE_INPUT_FILE, FXbool option = false, FXString = FXString::null);
    virtual void create();

    virtual ~BrowseInputDialog();
    long onCmdKeyPress(FXObject*, FXSelector, void*);
    long onCmdBrowsePath(FXObject*, FXSelector, void*);
    void setMessage(FXString);
    void setIcon(FXIcon*);
    void setDirectory(const FXString&);
    FXString getText();
    void setText(const FXString&);
    void selectAll();
    void CursorEnd();
    void setSelection(int, int);
};
#endif
#ifndef COMMANDWINDOW_H
#define COMMANDWINDOW_H

#include "DialogBox.h"


class CommandWindow : public DialogBox
{
    FXDECLARE(CommandWindow)
protected:

    int     pid;                     // Proccess ID of child (valid if busy).
    int     pipes[2];                // Pipes to communicate with child process.
    FXText* text;

    FXString command;                  // Command string
    FXbool   killed;                   // True if the cancel button was pressed
    FXbool   closed;                   // True if the closed button was pressed

private:
    CommandWindow() : pid(0), text(NULL), killed(false), closed(false)
    {}
    CommandWindow(const CommandWindow&);
public:
    enum
    {
        ID_CLOSE=DialogBox::ID_LAST,
        ID_WATCHPROCESS,
        ID_KILLPROCESS,
        ID_LAST
    };
public:
    long onCmdKillProcess(FXObject*, FXSelector, void*);
    long onUpdKillProcess(FXObject*, FXSelector, void*);
    long onWatchProcess(FXObject*, FXSelector, void*);
    long onUpdClose(FXObject* sender, FXSelector, void*);
    virtual void create();

    virtual ~CommandWindow();
    int execCmd(FXString);
    CommandWindow(FXWindow* owner, const FXString& name, FXString strcmd, int nblines, int nbcols);
    CommandWindow(FXApp* a, const FXString& name, FXString strcmd, int nblines, int nbcols);
    long onCmdClose(FXObject*, FXSelector, void*);
    void setText(const char*);
    void appendText(const char* str);
    void scrollToLastLine(void);
    int getLength(void);
};

#endif
#ifndef DIALOGBOX_H
#define DIALOGBOX_H


// Dialog Box window
class FXAPI DialogBox : public FXTopWindow
{
    FXDECLARE(DialogBox)
protected:
    DialogBox() : _option(0)
    {}
    DialogBox(const DialogBox&)
    {}
public:
    long onKeyPress(FXObject*, FXSelector, void*);
    long onKeyRelease(FXObject*, FXSelector, void*);
    long onClose(FXObject*, FXSelector, void*);
    long onCmdAccept(FXObject*, FXSelector, void*);
    long onCmdCancel(FXObject*, FXSelector, void*);
    long onCmdToggleOption(FXObject*, FXSelector, void*);
public:
    enum
    {
        ID_CANCEL=FXTopWindow::ID_LAST,
        ID_ACCEPT,
        ID_TOGGLE_OPTION,
        ID_LAST
    };
public:
    DialogBox(FXWindow* win, const FXString& name, FXuint opts = DECOR_TITLE|DECOR_BORDER, int x = 0, int y = 0, int w = 0, int h = 0, int pl = 10, int pr = 10, int pt = 10, int pb = 10, int hs = 4, int vs = 4);
    DialogBox(FXApp* a, const FXString& name, FXuint opts = DECOR_TITLE|DECOR_BORDER, int x = 0, int y = 0, int w = 0, int h = 0, int pl = 10, int pr = 10, int pt = 10, int pb = 10, int hs = 4, int vs = 4);
    virtual void show(FXuint placement = PLACEMENT_CURSOR);
    virtual void create();
    FXuint execute(FXuint placement = PLACEMENT_CURSOR);
    FXuint getOption();

protected:
    FXuint _option;
};


#endif
#ifndef DIRHISTBOX_H
#define DIRHISTBOX_H

#ifndef DIRHISTBOX_H
#include "DirHistBox.h"
#endif


#include "DialogBox.h"


class FXAPI DirHistBox : public DialogBox
{
    FXDECLARE(DirHistBox)
protected:
    FXList* list;
protected:
    DirHistBox() : list(NULL)
    {}
private:
    DirHistBox(const DirHistBox&);
    DirHistBox& operator=(const DirHistBox&);

public:
    long onCmdClicked(FXObject*, FXSelector, void*);
    long onCmdClose(FXObject*, FXSelector, void*);
    long onKeyPress(FXObject*, FXSelector, void*);
    long onKeyRelease(FXObject*, FXSelector, void*);
public:
    enum
    {
        ID_CLICKED=DialogBox::ID_LAST,
        ID_CLOSE,
        ID_LAST
    };
public:

    // Construct list box with given caption, icon, message text, and with choices from array of strings
    DirHistBox(FXWindow* owner, const char** choices, FXuint opts = 0, int x = 0, int y = 0, int w = 0, int h = 0);

    // Construct list box with given caption, icon, message text, and with choices from newline separated strings
    DirHistBox(FXWindow* owner, const FXString& choices, FXuint opts = 0, int x = 0, int y = 0, int w = 0, int h = 0);

    // Show a modal list dialog. Prompt the user using a dialog with given caption, icon, message text, and with choices from newline array of strings.
    // The return value is -1 if cancelled, or the given choice
    static int box(FXWindow* owner, FXuint opts, const char** choices, int x = 0, int y = 0, int w = 0, int h = 0);

    // Show a modal list dialog. Prompt the user using a dialog with given caption, icon, message text, and with choices from newline separated strings.
    // The return value is -1 if cancelled, or the given choice
    static int box(FXWindow* owner, FXuint opts, const FXString& choices, int x = 0, int y = 0, int w = 0, int h = 0);

    // Destroy list box
    virtual ~DirHistBox();
};

#endif
#ifndef DIRLIST_H
#define DIRLIST_H

struct FileAssoc;
class FileDict;
class DirList;

// Tree item
class FXAPI TreeItem : public FXTreeItem
{
    FXDECLARE(TreeItem)
    friend class DirList;
protected:
    TreeItem()
    {}
public:
    // Constructor
    TreeItem(const FXString& text, FXIcon* oi = NULL, FXIcon* ci = NULL, void* ptr = NULL) : FXTreeItem(text, oi, ci, ptr)
    {}
};

// Directory item
class FXAPI DirItem : public FXTreeItem
{
    FXDECLARE(DirItem)
    friend class DirList;
protected:
    FileAssoc* assoc;               // File association
    DirItem*   link;                // Link to next item
    DirItem*   list;                // List of child items
    FXulong    size;                // File size (if a file)
    FXTime     date;                // Time of item
    FXString   tdata;               // Tooltip data
protected:
    DirItem() : assoc(NULL), link(NULL), list(NULL), size(0L), date(0)
    {}
protected:
    enum
    {
        FOLDER      = 512,                // Directory item
        EXECUTABLE  = 1024,               // Executable item
        SYMLINK     = 2048,               // Symbolic linked item
        CHARDEV     = 4096,               // Character special item
        BLOCKDEV    = 8192,               // Block special item
        FIFO        = 16384,              // FIFO item
        SOCK        = 32768               // Socket item
    };
public:
    // Constructor
    DirItem(const FXString& text, FXIcon* oi = NULL, FXIcon* ci = NULL, void* ptr = NULL) : FXTreeItem(text, oi, ci, ptr), assoc(NULL), link(NULL), list(NULL), size(0), date(0)
    {
        state = HASITEMS;
        tdata = "";
    }

    FXbool isDirectory() const
    {
        return((state&FOLDER) != 0);
    }

    FXbool isExecutable() const
    {
        return((state&EXECUTABLE) != 0);
    }

    FXbool isSymlink() const
    {
        return((state&SYMLINK) != 0);
    }

    FXbool isChardev() const
    {
        return((state&CHARDEV) != 0);
    }

    FXbool isBlockdev() const
    {
        return((state&BLOCKDEV) != 0);
    }

    FXbool isFifo() const
    {
        return((state&FIFO) != 0);
    }

    FXbool isSocket() const
    {
        return((state&SOCK) != 0);
    }

    FileAssoc* getAssoc() const
    {
        return(assoc);
    }

    FXulong getSize() const
    {
        return(size);
    }

    FXTime getDate() const
    {
        return(date);
    }

    FXString getTooltipData() const
    {
        if (getData() != NULL)
        {
            return(tdata);
        }
        else
        {
            return("");
        }
    }
};


// Directory tree List
class FXAPI DirList : public FXTreeList
{
    FXDECLARE(DirList)
protected:
    TreeItem*    prevSelItem;
    DirItem*     list;                      // Root item list
    FileDict*    associations;              // Association table
    FXString     dropdirectory;             // Drop directory
    FXDragAction dropaction;                // Drop action
    FXString     dragfiles;                 // Dragged files
    FXString     pattern;                   // Pattern of file names
    FXuint       matchmode;                 // File wildcard match mode
    FXuint       counter;                   // Refresh counter
    FXString     trashfileslocation;        // Location of the trash files directory
    FXString     trashinfolocation;         // Location of the trash info directory
    FXWindow*    focuswindow;               // Window used to test focus
protected:
    DirList() : prevSelItem(NULL), list(NULL), associations(NULL), dropaction(DRAG_MOVE), matchmode(0), counter(0), focuswindow(NULL)
    {}
    virtual TreeItem* createItem(const FXString& text, FXIcon* oi, FXIcon* ci, void* ptr);
    TreeItem* getitem(char* pathname);
    void listRootItems();
    void listChildItems(DirItem* par);

private:
    DirList(const DirList&);
    DirList& operator=(const DirList&);

public:
    long onCmdRefresh(FXObject*, FXSelector, void*);
    long onCmdRefreshTimer(FXObject*, FXSelector, void*);
#if defined(linux)
    long onMtdevicesRefresh(FXObject*, FXSelector, void*);
    long onUpdevicesRefresh(FXObject*, FXSelector, void*);
#endif
    long onExpandTimer(FXObject*, FXSelector, void*);
    long onBeginDrag(FXObject*, FXSelector, void*);
    long onEndDrag(FXObject*, FXSelector, void*);
    long onDragged(FXObject*, FXSelector, void*);
    long onDNDEnter(FXObject*, FXSelector, void*);
    long onDNDLeave(FXObject*, FXSelector, void*);
    long onDNDMotion(FXObject*, FXSelector, void*);
    long onDNDDrop(FXObject*, FXSelector, void*);
    long onDNDRequest(FXObject*, FXSelector, void*);
    long onOpened(FXObject*, FXSelector, void*);
    long onClosed(FXObject*, FXSelector, void*);
    long onExpanded(FXObject*, FXSelector, void*);
    long onCollapsed(FXObject*, FXSelector, void*);
    long onCmdToggleHidden(FXObject*, FXSelector, void*);
    long onUpdToggleHidden(FXObject*, FXSelector, void*);
    long onCmdShowHidden(FXObject*, FXSelector, void*);
    long onUpdShowHidden(FXObject*, FXSelector, void*);
    long onCmdHideHidden(FXObject*, FXSelector, void*);
    long onUpdHideHidden(FXObject*, FXSelector, void*);
    long onCmdToggleFiles(FXObject*, FXSelector, void*);
    long onUpdToggleFiles(FXObject*, FXSelector, void*);
    long onCmdShowFiles(FXObject*, FXSelector, void*);
    long onUpdShowFiles(FXObject*, FXSelector, void*);
    long onCmdHideFiles(FXObject*, FXSelector, void*);
    long onUpdHideFiles(FXObject*, FXSelector, void*);
    long onCmdSetPattern(FXObject*, FXSelector, void*);
    long onUpdSetPattern(FXObject*, FXSelector, void*);
    long onCmdSortReverse(FXObject*, FXSelector, void*);
    long onUpdSortReverse(FXObject*, FXSelector, void*);
    long onCmdSortCase(FXObject*, FXSelector, void*);
    long onUpdSortCase(FXObject*, FXSelector, void*);
    long onCmdDragCopy(FXObject* sender, FXSelector, void*);
    long onCmdDragMove(FXObject* sender, FXSelector, void*);
    long onCmdDragLink(FXObject* sender, FXSelector, void*);
    long onCmdDragReject(FXObject* sender, FXSelector, void*);
    long onUpdRefreshTimers(FXObject*, FXSelector, void*);
public:
    static int compareItem(const FXTreeItem*, const FXTreeItem*, FXbool, FXbool);
    static int ascending(const FXTreeItem*, const FXTreeItem*);
    static int descending(const FXTreeItem*, const FXTreeItem*);
    static int ascendingCase(const FXTreeItem*, const FXTreeItem*);
    static int descendingCase(const FXTreeItem*, const FXTreeItem*);

public:
    enum
    {
        ID_REFRESH_TIMER=FXTreeList::ID_LAST,
        ID_SHOW_FILES,
        ID_HIDE_FILES,
        ID_TOGGLE_FILES,
        ID_SHOW_HIDDEN,
        ID_HIDE_HIDDEN,
        ID_TOGGLE_HIDDEN,
        ID_SET_PATTERN,
        ID_SORT_REVERSE,
        ID_SORT_CASE,
        ID_EXPAND_TIMER,
#if defined(linux)
        ID_UPDEVICES_REFRESH,
        ID_MTDEVICES_REFRESH,
#endif
        ID_DRAG_COPY,
        ID_DRAG_MOVE,
        ID_DRAG_LINK,
        ID_DRAG_REJECT,
        ID_REFRESH,
        ID_LAST
    };
public:

    // Construct a directory list
    DirList(FXWindow* focuswin, FXComposite* p, FXObject* tgt = NULL, FXSelector sel = 0, FXuint opts = 0, int x = 0, int y = 0, int w = 0, int h = 0);

    // Create server-side resources
    virtual void create();

    // Scan the directories and update the items if needed, or if force is true
    void scan(FXbool force = true);

    // Return true if item is a directory
    FXbool isItemDirectory(const TreeItem* item) const;

    // Return true if item is a file
    FXbool isItemFile(const TreeItem* item) const;

    // Return true if item is executable
    FXbool isItemExecutable(const TreeItem* item) const;

    // Collapse tree
    virtual FXbool collapseTree(TreeItem* tree, FXbool notify = false);

    // Expand tree
    virtual FXbool expandTree(TreeItem* tree, FXbool notify = false);

    // Set current file
    void setCurrentFile(const FXString& file, FXbool notify = false);

    // Return current file
    FXString getCurrentFile() const;

    // Set current directory
    void setDirectory(const FXString& pathname, FXbool notify);

    // Return current directory
    FXString getDirectory() const;

    // Return name of item
    FXString getItemFilename(const TreeItem* item) const;

    // Return absolute pathname of item
    FXString getItemPathname(const TreeItem* item) const;

    // Return the item from the absolute pathname
    TreeItem* getPathnameItem(const FXString& path);

    // Change wildcard matching pattern
    void setPattern(const FXString& ptrn);

    // Return wildcard pattern
    FXString getPattern() const
    {
        return(pattern);
    }

    // Return wildcard matching mode
    FXuint getMatchMode() const
    {
        return(matchmode);
    }

    // Change wildcard matching mode
    void setMatchMode(FXuint mode);

    // Return true if showing files as well as directories
    FXbool showFiles() const;

    // Show or hide normal files
    void showFiles(FXbool showing);

    // Return true if showing hidden files and directories
    FXbool shownHiddenFiles() const;

    // Show or hide hidden files and directories
    void showHiddenFiles(FXbool showing);

    // Change file associations
    void setAssociations(FileDict* assoc);

    // Return file associations
    FileDict* getAssociations() const
    {
        return(associations);
    }

    // Destructor
    virtual ~DirList();
};


#endif
#ifndef DIRPANEL_H
#define DIRPANEL_H
#include "DirList.h"
#include "Properties.h"
#include "InputDialog.h"
#include "ArchInputDialog.h"
#include "BrowseInputDialog.h"


#include <sys/types.h>



class DirPanel : public FXVerticalFrame
{
    FXDECLARE(DirPanel)
protected:
    DirList*           list;
    FXPacker*          statusbar;
    FXLabel*           status;
    FXButton*          activeicon;
    FXString           trashlocation;
    FXString           trashfileslocation;
    FXString           trashinfolocation;
    FXString           startlocation;
    FXDragType         urilistType;      // Standard uri-list type
    FXDragType         xfelistType;      // Xfe, Gnome and XFCE list type
    FXDragType         kdelistType;      // KDE list type
    FXDragType         utf8Type;         // UTF-8 text type
    FXbool             clipboard_locked; // Clipboard locked to prevent changes when viewing it
    InputDialog*       newdirdialog;
    ArchInputDialog*   archdialog;
    BrowseInputDialog* operationdialog;
    InputDialog*       operationdialogrename;
    FXbool             fromPaste;
    FXWindow*          focuswindow;
    FXbool             ctrlflag;            // Flag to select the right click control menu
    TextLabel*         paneltitle;          // Panel title
    //FXLabel*           paneltitle;          // Panel title
    //TextLabel*         paneltitlespacer;    // Panel title spacer
    FXbool             isactive;            // Flag to indicate is panel has keyboard focus
    FXbool             stopListRefresh;     // To stop refreshing in some cases
    time_t             curr_mtime;          // Current directory mtime
    FXString           curr_dirpath;        // Current directory path
    FXbool             allowDirsizeRefresh; // Allow or avoid directory size refresh


public:
    DirPanel(FXWindow* owner, FXComposite* p, FXColor listbackcolor = FXRGB(255, 255, 255), FXColor listforecolor = FXRGB(0, 0, 0),
             FXbool smoothscroll = true, FXuint opts = 0, int x = 0, int y = 0, int w = 0, int h = 0);
    DirPanel() : list(NULL), statusbar(NULL), status(NULL), activeicon(NULL), urilistType(0), xfelistType(0), kdelistType(0),
                 utf8Type(0), clipboard_locked(false), newdirdialog(NULL), archdialog(NULL), operationdialog(NULL), operationdialogrename(NULL),
                 fromPaste(false), focuswindow(NULL), ctrlflag(false), paneltitle(NULL), isactive(false), stopListRefresh(false), curr_mtime(0),
                 allowDirsizeRefresh(false)
    {}
    virtual void create();

    ~DirPanel();
    enum
    {
        ID_FILELIST=FXVerticalFrame::ID_LAST,
        ID_STOP_LIST_REFRESH_TIMER,
        ID_EXPANDTREE,
        ID_TOGGLE_HIDDEN,
        ID_COLLAPSEDIR,
        ID_COLLAPSETREE,
        ID_PROPERTIES,
        ID_ARCHIVE,
        ID_DIR_COPY,
        ID_DIR_CUT,
        ID_DIR_COPYTO,
        ID_DIR_MOVETO,
        ID_DIR_RENAME,
        ID_DIR_SYMLINK,
        ID_DIR_DELETE,
        ID_DIR_TRASH,
        ID_DIR_RESTORE,
        ID_NEW_DIR,
        ID_XTERM,
        ID_COPY_CLIPBOARD,
        ID_CUT_CLIPBOARD,
        ID_ADDCOPY_CLIPBOARD,
        ID_ADDCUT_CLIPBOARD,
        ID_CLOSE_TREE,
        ID_PASTE_CLIPBOARD,
        ID_TOGGLE_TREE,
        ID_TITLE,
        ID_DIRSIZE_REFRESH,
        ID_POPUP_MENU,
#if defined(linux)
        ID_MOUNT,
        ID_UMOUNT,
#endif
        ID_LAST,
    };
    long exploreUp(DirItem* item, const DirItem* rootitem, const int task);
    long exploreDown(DirItem* item, const DirItem* rootitem, const int task);

public:
    long onClipboardGained(FXObject*, FXSelector, void*);
    long onClipboardLost(FXObject*, FXSelector, void*);
    long onClipboardRequest(FXObject*, FXSelector, void*);
    long onCmdToggleHidden(FXObject*, FXSelector, void*);
    long onUpdToggleHidden(FXObject* sender, FXSelector, void*);
    long onCmdPopupMenu(FXObject*, FXSelector, void*);
    long onExpandTree(FXObject*, FXSelector, void*);
    long onCollapseTree(FXObject*, FXSelector, void*);
    long onCmdProperties(FXObject*, FXSelector, void*);
    long onCmdAddToArch(FXObject*, FXSelector, void*);
    long onCmdDirMan(FXObject*, FXSelector, void*);
    long onCmdDirDelete(FXObject*, FXSelector, void*);
    long onCmdDirTrash(FXObject*, FXSelector, void*);
    long onCmdDirRestore(FXObject*, FXSelector, void*);
    long onCmdNewDir(FXObject*, FXSelector, void*);
    long onCmdXTerm(FXObject*, FXSelector, void*);
    long onCmdCopyCut(FXObject*, FXSelector, void*);
    long onCmdPaste(FXObject*, FXSelector, void*);
    long onUpdPaste(FXObject*, FXSelector, void*);
    long onCmdDirectory(FXObject*, FXSelector, void*);
    long onCmdToggleTree(FXObject*, FXSelector sel, void*);
    long onCmdCloseTree(FXObject*, FXSelector sel, void*);

    long onCmdDirsizeRefresh(FXObject*, FXSelector, void*);
    long onUpdToggleTree(FXObject*, FXSelector, void*);
    long onUpdMount(FXObject*, FXSelector, void*);
    long onUpdUnmount(FXObject*, FXSelector, void*);
    long onCmdShowPanels(FXObject*, FXSelector, void*);
    long onUpdMenu(FXObject*, FXSelector, void*);
    long onUpdDirTrash(FXObject*, FXSelector, void*);
    long onUpdDirRestore(FXObject*, FXSelector, void*);
    long onUpdDirDelete(FXObject*, FXSelector, void*);
    long onUpdTitle(FXObject*, FXSelector, void*);
    long onUpdStatus(FXObject*, FXSelector, void*);
    long onExpand(FXObject*, FXSelector, void*);
    long onKeyPress(FXObject*, FXSelector, void*);
    long onCmdFocus(FXObject*, FXSelector, void*);
    long onCmdStopListRefreshTimer(FXObject*, FXSelector, void*);
    long onUpdDirsizeRefresh(FXObject*, FXSelector, void*);
#if defined(linux)
    long onCmdMount(FXObject*, FXSelector, void*);
#endif
public:

    void setActive();
    void setInactive();

    // Toggle dirsize refresh and force refresh if flag is true
    void setAllowDirsizeRefresh(FXbool flag);

    // Change sort function
    void setSortFunc(FXTreeListSortFunc func)
    {
        list->setSortFunc(func);
    }

    // Return sort function
    FXTreeListSortFunc getSortFunc() const
    {
        return(list->getSortFunc());
    }

    // Change default cursor
    void setDefaultCursor(FXCursor* cur)
    {
        list->setDefaultCursor(cur);
    }

    // Set current directory
    void setDirectory(const FXString& pathname, FXbool notify = false)
    {
        list->setDirectory(pathname, notify);
    }

    // Get current directory
    FXString getDirectory(void) const
    {
        return(list->getDirectory());
    }

    // Get current item
    DirItem* getCurrentItem(void) const
    {
        return((DirItem*)list->getCurrentItem());
    }

    // Get current path name
    FXString getItemPathname(const DirItem* item) const
    {
        return(list->getItemPathname((TreeItem*)item));
    }

    // Hidden files shown?
    FXbool shownHiddenFiles() const
    {
        return(list->shownHiddenFiles());
    }

    // Show hidden files
    void showHiddenFiles(FXbool shown)
    {
        list->showHiddenFiles(shown);
    }

    // Set focus on list
    void setFocusOnList(void)
    {
        list->setFocus();
    }

    // Is panel active?
    FXbool isActive(void)
    {
        return(isactive);
    }

    // Force dir panel refresh
    void forceRefresh(void)
    {
        list->onCmdRefresh(0, 0, 0);
    }

    DirList* getList(void)
    {
        return(list);
    }

#if defined(linux)
    // Force devices refresh
    void forceDevicesRefresh(void)
    {
        list->onMtdevicesRefresh(0, 0, 0);
        list->onUpdevicesRefresh(0, 0, 0);
    }

#endif

    // Toggle status bar
    void toggleStatusbar(void)
    {
        statusbar->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_TOGGLESHOWN), NULL);
    }
};
#endif
#ifndef EXECUTEBOX_H
#define EXECUTEBOX_H


#include "DialogBox.h"

// Return values
enum ExecuteBoxReturn
{
    EXECBOX_CLICKED_CANCEL       = 0,
    EXECBOX_CLICKED_EXECUTE      = 1,
    EXECBOX_CLICKED_CONSOLE      = 2,
    EXECBOX_CLICKED_EDIT         = 3,
};


// Message box
class FXAPI ExecuteBox : public DialogBox
{
    FXDECLARE(ExecuteBox)
protected:
    ExecuteBox()
    {}
    ExecuteBox(const ExecuteBox&)
    {}
public:
    long onCmdClicked(FXObject*, FXSelector, void*);
public:
    enum
    {
        ID_CLICKED_CANCEL=DialogBox::ID_LAST,
        ID_CLICKED_EXECUTE,
        ID_CLICKED_CONSOLE,
        ID_CLICKED_EDIT,
        ID_LAST
    };
public:
    ExecuteBox(FXWindow* win, const FXString& name, const FXString& text, FXuint opts = DECOR_TITLE|DECOR_BORDER, int x = 0, int y = 0);
};

#endif
#ifndef FILE_H
#define FILE_H


#include <fx.h>
#include "DialogBox.h"
#include "OverwriteBox.h"
#include "MessageBox.h"


// File operations
enum
{
    COPY,
    RENAME,
    MOVE,
    SYMLINK,
    DELETE,
    CHMOD,
    CHOWN,
    EXTRACT,
    ARCHIVE,
#if defined(linux)
    PKG_INSTALL,
    PKG_UNINSTALL,
    MOUNT,
    UNMOUNT
#endif
};

// To search visited inodes
struct inodelist
{
    ino_t      st_ino;
    inodelist* next;
};


class File : public DialogBox
{
    FXDECLARE(File)

private:
    FXWindow* ownerwin;

protected:

    // Inline function
    // Force check of timeout for progress dialog (to avoid latency problems)
    int checkTimeout(void)
    {
        if (getApp()->hasTimeout(this, File::ID_TIMEOUT))
        {
            if (getApp()->remainingTimeout(this, File::ID_TIMEOUT) == 0)
            {
                getApp()->removeTimeout(this, File::ID_TIMEOUT);
                show(PLACEMENT_OWNER);

                getApp()->forceRefresh();
                getApp()->flush();
                return(1);
            }
        }
        return(0);
    }

    void forceTimeout(void);
    void restartTimeout(void);
    FXlong fullread(int fd, FXuchar* ptr, FXlong len);
    FXlong fullwrite(int fd, const FXuchar* ptr, FXlong len);

    FXuint getOverwriteAnswer(FXString, FXString);
    int copyfile(const FXString& source, const FXString& target, const FXbool preserve_date);
    int copyrec(const FXString& source, const FXString& target, inodelist* inodes, const FXbool preserve_date);
    int copydir(const FXString& source, const FXString& target, struct stat& parentstatus, inodelist* inodes, const FXbool preserve_date);
    int rchmod(char* path, char* file, mode_t mode, const FXbool dironly, const FXbool fileonly);
    int rchown(char* path, char* file, uid_t uid, gid_t gid, const FXbool dironly, const FXbool fileonly);

    FXLabel*       uplabel;
    FXLabel*       downlabel;
    FXString       datatext;
    FXLabel*       datalabel;
    FXProgressBar* progressbar;
    FXButton*      cancelButton;
    FXbool         overwrite;
    FXbool         overwrite_all;
    FXbool         skip_all;
    FXbool         cancelled;
    MessageBox*    mbox;
    FXlong         totaldata;
    FXuint		   numsel;
public:
    File() : uplabel(NULL), downlabel(NULL), datalabel(NULL), progressbar(NULL), cancelButton(NULL), overwrite(false),
             overwrite_all(false), skip_all(false), cancelled(false), mbox(NULL), totaldata(0)
    {}
    ~File();
    void create();

    File(FXWindow* owner, FXString title, const FXuint operation, const FXuint num=1);

    enum
    {
        ID_CANCEL_BUTTON=DialogBox::ID_LAST,
        ID_TIMEOUT,
        ID_LAST
    };

    FXbool isCancelled()
    {
        return(cancelled);
    }

    void hideProgressDialog()
    {
        forceTimeout();
    }

    void showProgressDialog()
    {
        restartTimeout();
    }

    int copy(const FXString& source, const FXString& target, const FXbool confirm_dialog = true, const FXbool preserve_date = true);
    int rename(const FXString& source, const FXString& target);
    int move(const FXString& source, const FXString& target, const FXbool restore = false);
    int symlink(const FXString& source, const FXString& target);
    int remove(const FXString& file);

    int chmod(char* path, char* file, mode_t mode, const FXbool rec, const FXbool dironly = false, const FXbool fileonly = false);
    int chown(char* path, char* file, uid_t uid, gid_t gid, const FXbool rec, const FXbool dironly = false, const FXbool fileonly = false);
    int extract(const FXString name, const FXString dir, const FXString cmd);
    int archive(const FXString name, const FXString cmd);

#if defined(linux)
    int mount(const FXString dir, const FXString msg, const FXString cmd, const FXuint op);
    int pkgInstall(const FXString name, const FXString cmd);
    int pkgUninstall(const FXString name, const FXString cmd);

#endif
    long onCmdCancel(FXObject*, FXSelector, void*);
    long onTimeout(FXObject*, FXSelector, void*);
};
#endif
#ifndef FILEDIALOG_H
#define FILEDIALOG_H

#include "DialogBox.h"
#include "FileList.h"
#include "PathLinker.h"

class FileSelector;
class FileList;


// Additional mode for file selection : same as SELECTFILE_DIRECTORY but with the ability to also select files
enum
{
    SELECT_FILE_ANY,             // A single file, existing or not (to save to)
    SELECT_FILE_EXISTING,        // An existing file (to load), but not '.' and '..'
    SELECT_FILE_MULTIPLE,        // Multiple existing files
    SELECT_FILE_MULTIPLE_ALL,    // Multiple existing files or directories, but not '.' and '..'
    SELECT_FILE_DIRECTORY,       // Existing directory, including '.' or '..'
    SELECT_FILE_MIXED,           // An existing file or directory, including '.' and '..'
};


// File selection widget
class FXAPI FileSelector : public FXPacker
{
    FXDECLARE(FileSelector)
protected:
    FileList*      list;            // File list widget
    FXDirBox       *dirbox;            // Directory hierarchy list
    FXTextField*   filename;        // File name entry field
    FXComboBox*    filefilter;      // Combobox for pattern list
    FXCheckButton* readonly;        // Open file as read only
    FXButton*      accept;          // Accept button
    FXButton*      cancel;          // Cancel button
    FXuint         selectmode;      // Select mode
    FXArrowButton* btnbackhist;     // Back history
    FXArrowButton* btnforwardhist;  // Forward history
    PathLinker*    pathlink;
    TextLabel*     pathtext;
protected:
    FileSelector() : list(NULL), filename(NULL), filefilter(NULL), readonly(NULL), accept(NULL), cancel(NULL),
                     selectmode(0), btnbackhist(NULL), btnforwardhist(NULL), pathlink(NULL), pathtext(NULL)
    {}
    virtual void create();
    static FXString patternFromText(const FXString& pattern);
    static FXString extensionFromPattern(const FXString& pattern);

private:
    FileSelector(const FileSelector&);
    FileSelector& operator=(const FileSelector&);

public:
    long onCmdAccept(FXObject*, FXSelector, void*);
    long onCmdFilter(FXObject*, FXSelector, void*);
    long onCmdItemDoubleClicked(FXObject*, FXSelector, void*);
    long onCmdItemClicked(FXObject*, FXSelector, void*);
    long onCmdItemSelected(FXObject*, FXSelector, void*);
    long onCmdItemDeselected(FXObject*, FXSelector, void*);
    long onCmdDirUp(FXObject*, FXSelector, void*);
    long onUpdDirUp(FXObject*, FXSelector, void*);
    long onCmdDirBack(FXObject*, FXSelector, void*);
    long onUpdDirBack(FXObject*, FXSelector, void*);
    long onCmdDirForward(FXObject*, FXSelector, void*);
    long onUpdDirForward(FXObject*, FXSelector, void*);
    long onCmdDirBackHist(FXObject*, FXSelector, void*);
    long onUpdDirBackHist(FXObject*, FXSelector, void*);
    long onCmdDirForwardHist(FXObject*, FXSelector, void*);
    long onUpdDirForwardHist(FXObject*, FXSelector, void*);
    long onCmdHome(FXObject*, FXSelector, void*);
    long onCmdWork(FXObject*, FXSelector, void*);
    long onCmdNewDir(FXObject*, FXSelector, void*);
    long onCmdNewFile(FXObject*, FXSelector, void*);
    long onCmdPopupMenu(FXObject*, FXSelector, void*);
	long onCmdKeyPress(FXObject*, FXSelector, void*);
	long onCmdKeyRelease(FXObject*, FXSelector, void*);
    long onCmdDirTree(FXObject*,FXSelector,void*);
public:
    enum
    {
        ID_FILEFILTER=FXPacker::ID_LAST,
        ID_ACCEPT,
        ID_DIRTREE,
        ID_FILELIST,
        ID_POPUP_MENU,
        ID_DIR_UP,
        ID_DIR_BACK,
        ID_DIR_FORWARD,
        ID_DIR_BACK_HIST,
        ID_DIR_FORWARD_HIST,
        ID_HOME,
        ID_WORK,
        ID_NEWDIR,
        ID_NEWFILE,
        ID_LAST
    };
public:

    // Constructor
    FileSelector(FXComposite* p, FXObject* tgt = NULL, FXSelector sel = 0, FXuint opts = 0, int x = 0, int y = 0, int w = 0, int h = 0);

    // Return a pointer to the "Accept" button
    FXButton* acceptButton() const
    {
        return(accept);
    }

    // Return a pointer to the "Cancel" button
    FXButton* cancelButton() const
    {
        return(cancel);
    }

    // Change file name
    void setFilename(const FXString& path);

    // Return file name, if any
    FXString getFilename() const;

    // Return array of strings containing the selected file names, terminated
    // by an empty string.  This string array must be freed using delete [].
    // If no files were selected, a NULL is returned.
    FXString* getFilenames() const;

    // Change file pattern
    void setPattern(const FXString& ptrn);

    // Return file pattern
    FXString getPattern() const;

    // Change the list of file patterns shown in the file dialog.
    // Each pattern comprises an optional name, followed by a pattern in
    // parentheses.  The patterns are separated by newlines.
    // For example,
    //
    //  "*\n*.cpp,*.cc\n*.hpp,*.hh,*.h"
    //
    // and
    //
    //  "All Files (*)\nC++ Sources (*.cpp,*.cc)\nC++ Headers (*.hpp,*.hh,*.h)"
    //
    // will set the same three patterns, but the former shows no pattern names.
    void setPatternList(const FXString& patterns);

    // Set list of patterns as name,pattern pairs.
    // The list should be terminated with a final NULL string.
    // (DEPRECATED)
    void setPatternList(const char** ptrns);

    // Return list of patterns
    FXString getPatternList() const;

    // After setting the list of patterns, this call will
    // initially select pattern n as the active one.
    void setCurrentPattern(int n);

    // Return current pattern number
    int getCurrentPattern() const;

    // Get pattern text for given pattern number
    FXString getPatternText(int patno) const;

    // Change pattern text for pattern number
    void setPatternText(int patno, const FXString& text);

    // Change directory
    void setDirectory(const FXString& path);

    // Return directory
    FXString getDirectory() const;

    // Set the inter-item spacing (in pixels)
    void setItemSpace(int s);

    // Return the inter-item spacing (in pixels)
    int getItemSpace() const;

    // Change file list style
    void setFileBoxStyle(FXuint style);

    // Return file list style
    FXuint getFileBoxStyle() const;

    // Change file selection mode
    void setSelectMode(FXuint mode);

    // Return file selection mode
    FXuint getSelectMode() const
    {
        return(selectmode);
    }

    // Show readonly button
    void showReadOnly(FXbool show);

    // Return true if readonly is shown
    FXbool shownReadOnly() const;

    // Set initial state of readonly button
    void setReadOnly(FXbool state);

    // Get readonly state
    FXbool getReadOnly() const;

    // Return true if hidden files are shown
    FXbool shownHiddenFiles() const;

    // Return true if thumbnails are shown
    FXbool shownThumbnails() const;

    // Change show hidden files mode
    void showHiddenFiles(FXbool shown);

    // Change show thumbnails files mode
    void showThumbnails(FXbool shown);

    // Destructor
    virtual ~FileSelector();
};


// File Dialog object
class FXAPI FileDialog : public DialogBox
{
    FXDECLARE(FileDialog)
protected:
    FileSelector* list;
protected:
    FileDialog() : list(NULL)
    {}
private:
    FileDialog(const FileDialog&);
    FileDialog& operator=(const FileDialog&);

public:

    // Construct File Dialog Box
    FileDialog(FXWindow* owner, const FXString& name, FXuint opts = 0, int x = 0, int y = 0, int w = 500, int h = 300);

    // Change file name
    void setFilename(const FXString& path);

    // Return file name, if any
    FXString getFilename() const;

    // Return empty-string terminated list of selected file names, or NULL if none selected
    FXString* getFilenames() const;

    // Change file pattern
    void setPattern(const FXString& ptrn);

    // Return file pattern
    FXString getPattern() const;

    // Change the list of file patterns shown in the file dialog.
    // Each pattern comprises an optional name, followed by a pattern in
    // parentheses.  The patterns are separated by newlines.
    // For example,
    //
    //  "*\n*.cpp,*.cc\n*.hpp,*.hh,*.h"
    //
    // and
    //
    //  "All Files (*)\nC++ Sources (*.cpp,*.cc)\nC++ Headers (*.hpp,*.hh,*.h)"
    //
    // will set the same three patterns, but the former shows no pattern names.
    void setPatternList(const FXString& patterns);

    // Set list of patterns as name,pattern pairs.
    // The list should be terminated with a final NULL string.
    // (DEPRECATED)
    void setPatternList(const char** ptrns);

    // Return list of patterns
    FXString getPatternList() const;

    // After setting the list of patterns, this call will
    // initially select pattern n as the active one.
    void setCurrentPattern(int n);

    // Return current pattern number
    int getCurrentPattern() const;

    // Get pattern text for given pattern number
    FXString getPatternText(int patno) const;

    // Change pattern text for pattern number
    void setPatternText(int patno, const FXString& text);

    // Change directory
    void setDirectory(const FXString& path);

    // Return directory
    FXString getDirectory() const;

    // Set the inter-item spacing (in pixels)
    void setItemSpace(int s);

    // Return the inter-item spacing (in pixels)
    int getItemSpace() const;

    // Change File List style
    void setFileBoxStyle(FXuint style);

    // Return File List style
    FXuint getFileBoxStyle() const;

    // Change file selection mode
    void setSelectMode(FXuint mode);

    // Return file selection mode
    FXuint getSelectMode() const;

    // Show readonly button
    void showReadOnly(FXbool show);

    // Return true if readonly is shown
    FXbool shownReadOnly() const;

    // Return true if hidden files are shown
    FXbool shownHiddenFiles() const;

    // Return true if thumbnails are shown
    FXbool shownThumbnails() const;

    // Change show hidden files mode
    void showHiddenFiles(FXbool shown);

    // Change show thumbnails files mode
    void showThumbnails(FXbool shown);

    // Set initial state of readonly button
    void setReadOnly(FXbool state);

    // Get readonly state
    FXbool getReadOnly() const;

    // Open existing filename
    static FXString getOpenFilename(FXWindow* owner, const FXString& caption, const FXString& path, const FXString& patterns = "*", int initial = 0);

    // Open multiple existing files
    static FXString* getOpenFilenames(FXWindow* owner, const FXString& caption, const FXString& path, const FXString& patterns = "*", int initial = 0);

    // Save to filename
    static FXString getSaveFilename(FXWindow* owner, const FXString& caption, const FXString& path, const FXString& patterns = "*", int initial = 0);

    // Open directory name
    static FXString getOpenDirectory(FXWindow* owner, const FXString& caption, const FXString& path);

    // Destructor
    virtual ~FileDialog();
};


#endif
#ifndef FILEDICT_H
#define FILEDICT_H

#include "xfedefs.h"

// Registers stuff to know about the extension
struct FileAssoc
{
    FXString   key;               // Key extension (ex: zip, cpp, ...)
    FXString   command;           // Command to execute
    FXString   extension;         // Full extension name (ex: ZIP Archive, C++ Source, ...)
    FXString   mimetype;          // Mime type name
    FXIcon*    bigicon;           // Big normal icon
    FXIcon*    bigiconopen;       // Big open icon
    FXIcon*    miniicon;          // Mini normal icon
    FXIcon*    miniiconopen;      // Mini open icon
    FXDragType dragtype;          // Registered drag type
    FXuint     flags;             // Flags
};


// Icon dictionary
class FXAPI IconDict : public FXDict
{
    FXDECLARE(IconDict)
private:
    FXApp*        app;            // Application object
    FXIconSource* source;         // Icon source
    FXString      path;           // Where to search icons
protected:
    IconDict() : app(NULL), source(NULL)
    {}
    virtual void* createData(const void*);
    virtual void deleteData(void*);

private:
    IconDict(const IconDict&);
    IconDict& operator=(const IconDict&);

public:

    // Default icon search path
    static const char defaultIconPath[];

public:

    // Construct an icon dictionary, with given path
    IconDict(FXApp* a, const FXString& p = defaultIconPath);

    // Get application
    FXApp* getApp() const
    {
        return(app);
    }

    // Change icon source
    void setIconSource(FXIconSource* src)
    {
        source = src;
    }

    // Return icon source
    FXIconSource* getIconSource() const
    {
        return(source);
    }

    // Set icon search path
    void setIconPath(const FXString& p)
    {
        path = p;
    }

    // Return current icon search path
    FXString getIconPath() const
    {
        return(path);
    }

    // Insert unique icon loaded from filename into dictionary
    FXIcon* insert(const char* name)
    {
        return((FXIcon*)FXDict::insert(name, name));
    }

    // Remove icon from dictionary
    FXIcon* remove
        (const char* name)
    {
        return((FXIcon*)FXDict::remove
                   (name));
    }

    // Find icon by name
    FXIcon* find(const char* name)
    {
        return((FXIcon*)FXDict::find(name));
    }

    // Save to stream
    virtual void save(FXStream& store) const;

    // Load from stream
    virtual void load(FXStream& store);

    // Destructor
    virtual ~IconDict();
};


/*
 * The File Association dictionary associates a file extension
 * with a FileAssoc record which contains command name, mime type,
 * icons, and other information about the file type.
 * The Registry is used as source of the file bindings; an alternative
 * Settings database may be specified however.
 */
class FXAPI FileDict : public FXDict
{
    FXDECLARE(FileDict)
private:
    FXApp*      app;              // Application object
    FXSettings* settings;         // Settings database where to get bindings
    IconDict*   icons;            // Icon table
protected:
    FileDict() : app(NULL), settings(NULL), icons(NULL)
    {}
    virtual void* createData(const void*);
    virtual void deleteData(void*);

private:
    FileDict(const FileDict&);
    FileDict& operator=(const FileDict&);

public:

    // Registry key used to find fallback executable icons
    static const char defaultExecBinding[];

    // Registry key used to find fallback directory icons
    static const char defaultDirBinding[];

    // Registry key used to find fallback document icons
    static const char defaultFileBinding[];
public:

    /*
     * Construct a dictionary mapping file-extension to file associations,
     * using the application registry settings as a source for the bindings.
     */
    FileDict(FXApp* a);

    /*
     * Construct a dictionary mapping file-extension to file associations,
     * using the specified settings database as a source for the bindings.
     */
    FileDict(FXApp* a, FXSettings* db);

    // Get application
    FXApp* getApp() const
    {
        return(app);
    }

    // Change icon dictionary
    void setIconDict(IconDict* icns)
    {
        icons = icns;
    }

    // Return icon dictionary
    IconDict* getIconDict() const
    {
        return(icons);
    }

    // Set icon search path
    void setIconPath(const FXString& path);

    // Return current icon search path
    FXString getIconPath() const;

    /*
     * Replace file association.
     * The new association is written into the settings database under the
     * FILETYPES section; the format of the association is as follows:
     *
     * <extension> = "<command> ; <type> ; <bigicon> [ : <bigopenicon> ] ; <smallicon> [ : <smalliconopen> ] ; <mimetype>"
     *
     * Where <command> is the command used to launch the application (e.g. "xv %s &"),
     * and <type> is the file type string (e.g. "GIF Image"),
     * <bigicon> and <bigiconopen> are the large icons shown in "Icons" mode,
     * <smallicon> and <smalliconopen> are the small icons shown in "Details" mode,
     * and <mimetype> is the RFC2045 mime type of the file.
     *
     * For example:
     *
     * [FILETYPES]
     * gif="xv %s &;GIF Image;big.xpm:bigopen.xpm;mini.xpm:miniopen.xpm;image/gif"
     * /home/jeroen=";Home;home.xpm;minihome.xpm;application/x-folder"
     *
     */
    FileAssoc* replace(const char* ext, const char* str);

    // Remove file association
    FileAssoc* remove(const char* ext);

    // Find file association already in dictionary
    FileAssoc* find(const char* ext)
    {
        return((FileAssoc*)FXDict::find(ext));
    }

    // Find file association from registry
    FileAssoc* associate(const char* key);

    /*
     * Determine binding for the given file.
     * The default implementation tries the whole filename first,
     * then tries the extensions.
     * For example, for a file "source.tar.gz":
     *
     *  "source.tar.gz",
     *  "tar.gz",
     *  "gz"
     *
     * are tried in succession.  If no association is found the
     * key "defaultfilebinding" is tried as a fallback association.
     * A NULL is returned if no association of any kind is found.
     */
    virtual FileAssoc* findFileBinding(const char* pathname);

    /*
     * Find directory binding from registry.
     * The default implementation tries the whole pathname first,
     * then tries successively smaller parts of the path.
     * For example, a pathname "/usr/people/jeroen":
     *
     *   "/usr/people/jeroen"
     *   "/people/jeroen"
     *   "/jeroen"
     *
     * are tried in succession.  If no bindings are found, the
     * key "defaultdirbinding" is tried as a fallback association.
     * A NULL is returned if no association of any kind is found.
     */
    virtual FileAssoc* findDirBinding(const char* pathname);

    /*
     * Determine binding for the given executable.
     * The default implementation returns the fallback binding associated with
     * the key "defaultexecbinding".
     * A NULL is returned if no association of any kind is found.
     */
    virtual FileAssoc* findExecBinding(const char* pathname);

    // Destructor
    virtual ~FileDict();
};


#endif
#ifndef FILELIST_H
#define FILELIST_H

#include "StringList.h"
#include "IconList.h"


struct FileAssoc;
class FileDict;
class FileList;

// File List options (prefixed by underscore to avoid conflict with the FOX library)
enum
{
    _FILELIST_SHOWHIDDEN   = 0x04000000, // Show hidden files or directories
    _FILELIST_SHOWDIRS     = 0x08000000, // Show only directories
    _FILELIST_SEARCH       = 0x10000000, // File list is a search list (must be the same value as in IconList)
};

// File item
class FXAPI FileItem : public IconItem
{
    FXDECLARE(FileItem)
    friend class FileList;
    friend class SearchPanel;
protected:
    FileAssoc* assoc;                       // File association record
    FileItem*  link;                        // Link to next item
    FXulong    size;                        // File size
    FXTime     date;                        // File date (mtime)
    FXTime     cdate;                       // Changed date (ctime)
    FXTime     deldate;                     // Deletion date
protected:
    FileItem() : assoc(NULL), link(NULL), size(0), date(0), cdate(0), deldate(0)
    {}
protected:
    enum
    {
        FOLDER     = 64,                        // Directory item
        EXECUTABLE = 128,                       // Executable item
        SYMLINK    = 256,                       // Symbolic linked item
        CHARDEV    = 512,                       // Character special item
        BLOCKDEV   = 1024,                      // Block special item
        FIFO       = 2048,                      // FIFO item
        SOCK       = 4096                       // Socket item
    };
public:
    // Constructor
    FileItem(const FXString& text, FXIcon* bi = NULL, FXIcon* mi = NULL, void* ptr = NULL) : IconItem(text, bi, mi, ptr), assoc(NULL),
                                                                                             link(NULL), size(0), date(0), cdate(0), deldate(0)
    {}

    // Return true if this is a file item
    FXbool isFile() const
    {
        return((state&(FOLDER|BLOCKDEV|CHARDEV|FIFO|SOCK)) == 0);
    }

    // Return true if this is a directory item
    FXbool isDirectory() const
    {
        return((state&FOLDER) != 0);
    }

    // Return true if this is an executable item
    FXbool isExecutable() const
    {
        return((state&EXECUTABLE) != 0);
    }

    // Return true if this is a symbolic link item
    FXbool isSymlink() const
    {
        return((state&SYMLINK) != 0);
    }

    // Return true if this is a character device item
    FXbool isChardev() const
    {
        return((state&CHARDEV) != 0);
    }

    // Return true if this is a block device item
    FXbool isBlockdev() const
    {
        return((state&BLOCKDEV) != 0);
    }

    // Return true if this is an FIFO item
    FXbool isFifo() const
    {
        return((state&FIFO) != 0);
    }

    // Return true if this is a socket
    FXbool isSocket() const
    {
        return((state&SOCK) != 0);
    }

    // Return the file-association object for this item
    FileAssoc* getAssoc() const
    {
        return(assoc);
    }

    // Return the file size for this item
    FXulong getSize() const
    {
        return(size);
    }

    // Return the date for this item
    FXTime getDate() const
    {
        return(date);
    }
};


// File List object
class FXAPI FileList : public IconList
{
    FXDECLARE(FileList)
protected:
    FileItem*    list;               // File item list
    int          prevIndex;
    FXString     directory;          // Current directory
    FXString     orgdirectory;       // Original directory
    FXString     dropdirectory;      // Drop directory
    FXDragAction dropaction;         // Drop action
    FXString     dragfiles;          // Dragged files
    FileDict*    associations;       // Association table
    FXString     pattern;            // Pattern of file names
    FXuint       matchmode;          // File wildcard match mode
    FXTime       timestamp;          // Time when last refreshed
    FXuint       counter;            // Refresh counter
    FXbool       allowrefresh;       // Allow or disallow periodic refresh
    FXbool       displaythumbnails;  // Display thumbnails
    FXString     trashfileslocation; // Location of the trash files directory
    FXString     trashinfolocation;  // Location of the trash info directory
    FXbool       dirsfirst;          // Sort directories first
    int          deldatesize;
    int          origpathsize;
    FXWindow*    focuswindow;          // Window used to test focus
public:
    StringList* backhist;              // Back history
    StringList* forwardhist;           // Forward history

protected:
    FileList() : list(NULL), prevIndex(0), dropaction(DRAG_MOVE), associations(NULL),
                 matchmode(0), timestamp(0), counter(0), allowrefresh(false), displaythumbnails(false), dirsfirst(false),
                 deldatesize(0), origpathsize(0), focuswindow(NULL), backhist(NULL), forwardhist(NULL)
    {}
    virtual IconItem* createItem(const FXString& text, FXIcon* big, FXIcon* mini, void* ptr);

    FXbool updateItems(FXbool);
    void   listItems(FXbool);

private:
    FileList(const FileList&);
    FileList& operator=(const FileList&);

public:
    long onCmdRefresh(FXObject*, FXSelector, void*);
    long onCmdRefreshTimer(FXObject*, FXSelector, void*);
    long onOpenTimer(FXObject*, FXSelector, void*);
    long onDNDEnter(FXObject*, FXSelector, void*);
    long onDNDLeave(FXObject*, FXSelector, void*);
    long onDNDMotion(FXObject*, FXSelector, void*);
    long onDNDDrop(FXObject*, FXSelector, void*);
    long onDNDRequest(FXObject*, FXSelector, void*);
    long onBeginDrag(FXObject*, FXSelector, void*);
    long onEndDrag(FXObject*, FXSelector, void*);
    long onDragged(FXObject*, FXSelector, void*);
    long onCmdDirectoryUp(FXObject*, FXSelector, void*);
    long onUpdDirectoryUp(FXObject*, FXSelector, void*);
    long onCmdSortByName(FXObject*, FXSelector, void*);
    long onCmdSortByDirName(FXObject*, FXSelector, void*);
    long onUpdSortByName(FXObject*, FXSelector, void*);
    long onUpdSortByDirName(FXObject*, FXSelector, void*);
    long onCmdSortByType(FXObject*, FXSelector, void*);
    long onUpdSortByType(FXObject*, FXSelector, void*);
    long onCmdSortBySize(FXObject*, FXSelector, void*);
    long onUpdSortBySize(FXObject*, FXSelector, void*);
    long onCmdSortByExt(FXObject*, FXSelector, void*);
    long onUpdSortByExt(FXObject*, FXSelector, void*);
    long onCmdSortByTime(FXObject*, FXSelector, void*);
    long onUpdSortByTime(FXObject*, FXSelector, void*);
    long onCmdSortByUser(FXObject*, FXSelector, void*);
    long onUpdSortByUser(FXObject*, FXSelector, void*);
    long onCmdSortByGroup(FXObject*, FXSelector, void*);
    long onUpdSortByGroup(FXObject*, FXSelector, void*);
    long onCmdSortByPerm(FXObject*, FXSelector, void*);
    long onUpdSortByPerm(FXObject*, FXSelector, void*);
    long onCmdSortByDeltime(FXObject*, FXSelector, void*);
    long onUpdSortByDeltime(FXObject*, FXSelector, void*);
    long onCmdSortByOrigpath(FXObject*, FXSelector, void*);
    long onUpdSortByOrigpath(FXObject*, FXSelector, void*);
    long onCmdSortReverse(FXObject*, FXSelector, void*);
    long onUpdSortReverse(FXObject*, FXSelector, void*);
    long onCmdSortCase(FXObject*, FXSelector, void*);
    long onUpdSortCase(FXObject*, FXSelector, void*);
    long onCmdSetPattern(FXObject*, FXSelector, void*);
    long onUpdSetPattern(FXObject*, FXSelector, void*);
    long onCmdToggleHidden(FXObject*, FXSelector, void*);
    long onUpdToggleHidden(FXObject*, FXSelector, void*);
    long onCmdShowHidden(FXObject*, FXSelector, void*);
    long onUpdShowHidden(FXObject*, FXSelector, void*);
    long onCmdHideHidden(FXObject*, FXSelector, void*);
    long onUpdHideHidden(FXObject*, FXSelector, void*);
    long onCmdHeader(FXObject*, FXSelector, void*);
    long onUpdHeader(FXObject*, FXSelector, void*);
    long onCmdToggleThumbnails(FXObject*, FXSelector, void*);
    long onUpdToggleThumbnails(FXObject* sender, FXSelector, void*);
    long onCmdDirsFirst(FXObject*, FXSelector, void*);
    long onUpdDirsFirst(FXObject*, FXSelector, void*);
    long onCmdDragCopy(FXObject* sender, FXSelector, void*);
    long onCmdDragMove(FXObject* sender, FXSelector, void*);
    long onCmdDragLink(FXObject* sender, FXSelector, void*);
    long onCmdDragReject(FXObject* sender, FXSelector, void*);
    long onUpdRefreshTimer(FXObject* sender, FXSelector, void*);
public:
    static int compare(const IconItem*, const IconItem*, FXbool, FXbool, FXbool, FXuint);
    static int ascending(const IconItem*, const IconItem*);
    static int descending(const IconItem*, const IconItem*);
    static int ascendingCase(const IconItem*, const IconItem*);
    static int descendingCase(const IconItem*, const IconItem*);
    static int ascendingDir(const IconItem*, const IconItem*);
    static int descendingDir(const IconItem*, const IconItem*);
    static int ascendingDirCase(const IconItem*, const IconItem*);
    static int descendingDirCase(const IconItem*, const IconItem*);
    static int ascendingType(const IconItem*, const IconItem*);
    static int descendingType(const IconItem*, const IconItem*);
    static int ascendingSize(const IconItem*, const IconItem*);
    static int descendingSize(const IconItem*, const IconItem*);
    static int ascendingExt(const IconItem*, const IconItem*);
    static int descendingExt(const IconItem*, const IconItem*);
    static int ascendingTime(const IconItem*, const IconItem*);
    static int descendingTime(const IconItem*, const IconItem*);
    static int ascendingUser(const IconItem*, const IconItem*);
    static int descendingUser(const IconItem*, const IconItem*);
    static int ascendingGroup(const IconItem*, const IconItem*);
    static int descendingGroup(const IconItem*, const IconItem*);
    static int ascendingPerm(const IconItem*, const IconItem*);
    static int descendingPerm(const IconItem*, const IconItem*);
    static int ascendingDeltime(const IconItem*, const IconItem*);
    static int descendingDeltime(const IconItem*, const IconItem*);
    static int ascendingOrigpath(const IconItem*, const IconItem*);
    static int descendingOrigpath(const IconItem*, const IconItem*);
    static int ascendingMix(const IconItem*, const IconItem*);
    static int descendingMix(const IconItem*, const IconItem*);
    static int ascendingCaseMix(const IconItem*, const IconItem*);
    static int descendingCaseMix(const IconItem*, const IconItem*);
    static int ascendingDirMix(const IconItem*, const IconItem*);
    static int descendingDirMix(const IconItem*, const IconItem*);
    static int ascendingDirCaseMix(const IconItem*, const IconItem*);
    static int descendingDirCaseMix(const IconItem*, const IconItem*);
    static int ascendingTypeMix(const IconItem*, const IconItem*);
    static int descendingTypeMix(const IconItem*, const IconItem*);
    static int ascendingSizeMix(const IconItem*, const IconItem*);
    static int descendingSizeMix(const IconItem*, const IconItem*);
    static int ascendingExtMix(const IconItem*, const IconItem*);
    static int descendingExtMix(const IconItem*, const IconItem*);
    static int ascendingTimeMix(const IconItem*, const IconItem*);
    static int descendingTimeMix(const IconItem*, const IconItem*);
    static int ascendingUserMix(const IconItem*, const IconItem*);
    static int descendingUserMix(const IconItem*, const IconItem*);
    static int ascendingGroupMix(const IconItem*, const IconItem*);
    static int descendingGroupMix(const IconItem*, const IconItem*);
    static int ascendingPermMix(const IconItem*, const IconItem*);
    static int descendingPermMix(const IconItem*, const IconItem*);
    static int ascendingDeltimeMix(const IconItem*, const IconItem*);
    static int descendingDeltimeMix(const IconItem*, const IconItem*);
    static int ascendingOrigpathMix(const IconItem*, const IconItem*);
    static int descendingOrigpathMix(const IconItem*, const IconItem*);

public:
    enum
    {
        // Note : the order of the 10 following sort IDs must be kept
        ID_SORT_BY_NAME=IconList::ID_LAST,
        ID_SORT_BY_SIZE,
        ID_SORT_BY_TYPE,
        ID_SORT_BY_EXT,
        ID_SORT_BY_TIME,
        ID_SORT_BY_USER,
        ID_SORT_BY_GROUP,
        ID_SORT_BY_PERM,
        ID_SORT_BY_ORIGPATH,
        ID_SORT_BY_DELTIME,
        ID_SORT_BY_DIRNAME,
        ID_SORT_REVERSE,
        ID_SORT_CASE,
        ID_DIRS_FIRST,
        ID_DIRECTORY_UP,
        ID_SET_PATTERN,
        ID_SET_DIRECTORY,
        ID_SHOW_HIDDEN,
        ID_HIDE_HIDDEN,
        ID_TOGGLE_HIDDEN,
        ID_TOGGLE_THUMBNAILS,
        ID_REFRESH_TIMER,
        ID_REFRESH,
        ID_OPEN_TIMER,
        ID_DRAG_COPY,
        ID_DRAG_MOVE,
        ID_DRAG_LINK,
        ID_DRAG_REJECT,
        ID_LAST
    };
public:

    // Construct a file list
    FileList(FXWindow* focuswin, FXComposite* p, FXObject* tgt = NULL, FXSelector sel = 0, FXbool showthumbs = false, FXuint opts = 0, int x = 0, int y = 0, int w = 0, int h = 0);

    // Create server-side resources
    virtual void create();

    // Scan the current directory and update the items if needed, or if force is true
    void scan(FXbool force = true);

    // Set current file
    void setCurrentFile(const FXString& file);

    // Return current file
    FXString getCurrentFile() const;

    // Set current directory
    void setDirectory(const FXString& path, const FXbool histupdate = true, FXString prevpath = "");

    // Return current directory
    FXString getDirectory() const
    {
        return(directory);
    }

    // Change wildcard matching pattern
    void setPattern(const FXString& ptrn);

    // Return wildcard pattern
    FXString getPattern() const
    {
        return(pattern);
    }

    // Return true if item is a directory
    FXbool isItemDirectory(int index) const;

    // Return true if item is a file
    FXbool isItemFile(int index) const;

    // Return true if item is executable
    FXbool isItemExecutable(int index) const;

    // Return true if item is a symbolic link
    FXbool isItemLink(int index) const;

    // Get number of selected items
    int getNumSelectedItems(void) const
    {
        int num = 0;

        for (int u = 0; u < getNumItems(); u++)
        {
            if (isItemSelected(u))
            {
                num++;
            }
        }
        return(num);
    }

    // Get number of selected items and index of first selected item
    int getNumSelectedItems(int* index) const
    {
        int num = 0, itm = -1;

        for (int u = 0; u < getNumItems(); u++)
        {
            if (isItemSelected(u))
            {
                if (itm == -1)
                {
                    itm = u;
                }
                num++;
            }
        }
        (*index) = itm;
        return(num);
    }

    // Return name of item at index
    FXString getItemFilename(int index) const;

    // Get pathname from item at index, relatively to the current directory
    FXString getItemPathname(int index) const;

    // Get full pathname from item at index, as obtained from the label string
    FXString getItemFullPathname(int index) const;

    // Return file association of item
    FileAssoc* getItemAssoc(int index) const;

    // Return file size of the item
    FXulong getItemFileSize(int index) const;

    // Return wildcard matching mode
    FXuint getMatchMode() const
    {
        return(matchmode);
    }

    // Return directory first state for file name sorting
    FXbool getDirsFirst() const
    {
        return(dirsfirst);
    }

    // Set directory first state for file name sorting
    void setDirsFirst(const FXbool dfirst)
    {
        dirsfirst = dfirst;
    }

    int getHeaderSize(int index) const;

    void setHeaderSize(int index, int size);

    // Allow or disallow periodic refresh
    void setAllowRefresh(const FXbool allow);

    // Change wildcard matching mode
    void setMatchMode(FXuint mode);

    // Return true if showing hidden files
    FXbool shownHiddenFiles() const;

    // Show or hide hidden files
    void showHiddenFiles(FXbool showing);

    // Return true if displaying thumbnails
    FXbool shownThumbnails() const;

    // Display or not thumbnails
    void showThumbnails(FXbool display);

    // Return true if showing directories only
    FXbool showOnlyDirectories() const;

    // Show directories only
    void showOnlyDirectories(FXbool shown);

    // Change file associations
    void setAssociations(FileDict* assoc);

    // Return file associations
    FileDict* getAssociations() const
    {
        return(associations);
    }

#if defined(linux)
    // Force mtdevices list refresh
    void refreshMtdevices(void);

#endif

    // Destructor
    virtual ~FileList();
};

#endif
#ifndef FILEPANEL_H
#define FILEPANEL_H

#include <map>

#include "Properties.h"
#include "FileList.h"
#include "PathLinker.h"
#include "InputDialog.h"
#include "BrowseInputDialog.h"
#include "HistInputDialog.h"
#include "ArchInputDialog.h"

// Clipboard operations
enum
{
    COPY_CLIPBOARD,
    CUT_CLIPBOARD,
};

extern FXMainWindow* mainWindow;


// Typedef for the map between program string identifiers and integer indexes
typedef std::map<FXString, int>   progsmap;


class FilePanel : public FXVerticalFrame
{
    FXDECLARE(FilePanel)
protected:
    FilePanel*             current;
    FileList*              list;
    FilePanel*             next;
    DirPanel*              dirpanel;
    PathLinker*            pathlink;
    FXPacker*              statusbar;
    FXLabel*               statuslabel;
    FXLabel*               sizestatusct;
    FXLabel*               locationlabel;
    FXLabel*               filterlabel;
    FXLabel*               webviewtext;
    FXHorizontalSeparator* panelsep;
    FXButton*               activeicon;
    FXString               name;
    FXbool                 ctrlkey;
    FXbool                 selmult;
    FXString               trashlocation;
    FXString               trashfileslocation;
    FXString               trashinfolocation;
    FXString               startlocation;
    FXDragCorner*          realcorner;
    FXPacker*              corner;
    //FXLabel*               corner;
    FXDragType             urilistType;      // Standard uri-list type
    FXDragType             xfelistType;      // Xfe, Gnome and XFCE list type
    FXDragType             kdelistType;      // KDE list type
    FXDragType             utf8Type;         // UTF-8 text type
    FXbool                 clipboard_locked; // Clipboard locked to prevent changes when viewing it
    InputDialog*           newfiledialog;
    InputDialog*           newdirdialog;
    InputDialog*           newlinkdialog;
    HistInputDialog*       opendialog;
    ArchInputDialog*       archdialog;
    HistInputDialog*       filterdialog;
    BrowseInputDialog*     operationdialogsingle;
    InputDialog*           operationdialogrename;
    BrowseInputDialog*     operationdialogmultiple;
    BrowseInputDialog*     comparedialog;
    FXbool                 fromPaste;
    FXbool                 ctrl;        // Flag to select the right click control menu
    FXbool                 shiftf10;    // Flag indicating that Shift-F10 was pressed
    TextLabel*             pathtext;
    FXbool                 isactive;
    FXbool                 stopListRefresh;
    FXColor                attenclr;
    progsmap               progs;       // Map between program string identifiers and integer indexes
    FXbool                 show_pathlink;
    FXVerticalFrame*       verticalFrame;

public:

    FilePanel(FXWindow* owner, const char*, FXComposite*, DirPanel*, FXuint name_size = 200, FXuint size_size = 60, FXuint type_size = 100, FXuint ext_size = 100,
              FXuint modd_size = 150, FXuint user_size = 50, FXuint grou_size = 50, FXuint attr_size = 100, FXuint deldate_size = 150, FXuint origpath_size = 200, FXbool showthumbs = false,
              FXColor listbackcolor = FXRGB(255, 255, 255), FXColor listforecolor = FXRGB(0, 0, 0), FXColor attentioncolor = FXRGB(255, 0, 0), FXbool smoothscroll = true,
              FXuint opts = 0, int x = 0, int y = 0, int w = 0, int h = 0);

    FilePanel() : current(NULL), list(NULL), next(NULL), dirpanel(NULL), pathlink(NULL), statusbar(NULL), statuslabel(NULL), locationlabel(NULL), filterlabel(NULL),
                  panelsep(NULL), activeicon(NULL), ctrlkey(false), selmult(false), corner(NULL), urilistType(0), xfelistType(0),
                  kdelistType(0), utf8Type(0), clipboard_locked(false), newfiledialog(NULL), newdirdialog(NULL), newlinkdialog(NULL),
                  opendialog(NULL), archdialog(NULL), filterdialog(NULL), operationdialogsingle(NULL), operationdialogrename(NULL),
                  operationdialogmultiple(NULL), comparedialog(NULL), fromPaste(false), ctrl(false), shiftf10(false), pathtext(NULL),
                  isactive(false), stopListRefresh(false), attenclr(FXRGB(0, 0, 0))
    {}
    virtual void create();

    ~FilePanel();

    void setActive();

    void setInactive(FXbool = true);

    void Next(FilePanel*);
    void updateLocation();
    void showCorner(FXbool show);
    void showActiveIcon(FXbool show);
    void execFile(FXString pathname);
    int readScriptDir(FXMenuPane* scriptsmenu, FXString dir);

    enum
    {
        ID_FILELIST=FXVerticalFrame::ID_LAST,
        ID_STOP_LIST_REFRESH_TIMER,
        ID_DIRECTORY_UP,
        ID_VIEW,
        ID_EDIT,
        ID_COMPARE,
        ID_PROPERTIES,
        ID_FILE_COPY,
        ID_FILE_CUT,
        ID_FILE_COPYTO,
        ID_FILE_MOVETO,
        ID_FILE_RENAME,
        ID_FILE_SYMLINK,
        ID_FILE_DELETE,
        ID_FILE_TRASH,
        ID_FILE_RESTORE,
        ID_FILE_ASSOC,
        ID_POPUP_MENU,
        ID_XTERM,
        ID_EXTRACT,
        ID_RUN_SCRIPT,
        ID_GO_SCRIPTDIR,
        ID_EXTRACT_TO_FOLDER,
        ID_EXTRACT_HERE,
        ID_DIR_USAGE,
        ID_NEW_DIR,
        ID_NEW_FILE,
        ID_NEW_SYMLINK,
        ID_ADD_TO_ARCH,
        ID_GO_HOME,
        ID_GO_TRASH,
        ID_COPY_CLIPBOARD,
        ID_CUT_CLIPBOARD,
        ID_ADDCOPY_CLIPBOARD,
        ID_ADDCUT_CLIPBOARD,
        ID_PASTE_CLIPBOARD,
        ID_OPEN,
        ID_OPEN_WITH,
        ID_FILTER,
        ID_FILTER_CURRENT,
        ID_STATUS,
        ID_LABEL,
        ID_REFRESH,
        ID_SELECT_ALL,
        ID_DESELECT_ALL,
        ID_SELECT_INVERSE,
        ID_SHOW_BIG_ICONS,
        ID_SHOW_MINI_ICONS,
        ID_SHOW_DETAILS,
        ID_TOGGLE_HIDDEN,
        ID_TOGGLE_THUMBNAILS,
#if defined(linux)
        ID_MOUNT,
        ID_UMOUNT,
        ID_PKG_QUERY,
        ID_PKG_INSTALL,
        ID_PKG_UNINSTALL,
#endif
        ID_LAST,
    };
public:
    long onClipboardGained(FXObject*, FXSelector, void*);
    long onClipboardLost(FXObject*, FXSelector, void*);
    long onClipboardRequest(FXObject*, FXSelector, void*);
    long onUpdStatus(FXObject*, FXSelector, void*);
    long onCmdItemDoubleClicked(FXObject*, FXSelector, void*);
    long onCmdItemClicked(FXObject*, FXSelector, void*);
    long onCmdFocus(FXObject*, FXSelector, void*);
    long onCmdItemFilter(FXObject*, FXSelector, void*);
    long onCmdCopyCut(FXObject*, FXSelector, void*);
    long onCmdPaste(FXObject*, FXSelector, void*);
    long onCmdDirectoryUp(FXObject*, FXSelector, void*);
    long onCmdGoHome(FXObject*, FXSelector, void*);
    long onCmdGoTrash(FXObject*, FXSelector, void*);
    long onCmdEdit(FXObject*, FXSelector, void*);
    long onCmdCompare(FXObject*, FXSelector, void*);
    long onCmdProperties(FXObject*, FXSelector, void*);
    long onCmdFileMan(FXObject*, FXSelector, void*);
    long onCmdFileTrash(FXObject*, FXSelector, void*);
    long onCmdFileRestore(FXObject*, FXSelector, void*);
    long onCmdFileDelete(FXObject*, FXSelector, void*);
    long onCmdFileAssoc(FXObject*, FXSelector, void*);
    long onCmdNewDir(FXObject*, FXSelector, void*);
    long onCmdNewFile(FXObject*, FXSelector, void*);
    long onCmdNewSymlink(FXObject*, FXSelector, void*);
    long onCmdOpen(FXObject*, FXSelector, void*);
    long onCmdOpenWith(FXObject*, FXSelector, void*);
    long onCmdXTerm(FXObject*, FXSelector, void*);
    long onCmdExtract(FXObject*, FXSelector, void*);
    long onCmdExtractToFolder(FXObject*, FXSelector, void*);
    long onCmdExtractHere(FXObject*, FXSelector, void*);
    long onCmdRefresh(FXObject*, FXSelector, void*);
    long onCmdSelect(FXObject*, FXSelector, void*);
    long onCmdPopupMenu(FXObject*, FXSelector, void*);
    long onCmdShow(FXObject*, FXSelector, void*);
    long onUpdShow(FXObject*, FXSelector, void*);
    long onUpdUp(FXObject*, FXSelector, void*);
    long onUpdPaste(FXObject*, FXSelector, void*);
    long onCmdToggleHidden(FXObject*, FXSelector, void*);
    long onUpdToggleHidden(FXObject*, FXSelector, void*);
    long onCmdToggleThumbnails(FXObject*, FXSelector, void*);
    long onCmdRunScript(FXObject*, FXSelector, void*);
	long onCmdDirUsage(FXObject*, FXSelector, void*);

    long onUpdDirUsage(FXObject*, FXSelector, void*);
    long onUpdToggleThumbnails(FXObject*, FXSelector, void*);
    long onCmdAddToArch(FXObject*, FXSelector, void*);
    long onUpdMenu(FXObject*, FXSelector, void*);
    long onUpdOpen(FXObject*, FXSelector, void*);
    long onUpdAddToArch(FXObject*, FXSelector, void*);
    long onUpdSelMult(FXObject*, FXSelector, void*);
    long onUpdCompare(FXObject*, FXSelector, void*);
    long onUpdFileDelete(FXObject*, FXSelector, void*);
    long onUpdFileTrash(FXObject*, FXSelector, void*);
    long onUpdFileRestore(FXObject*, FXSelector, void*);
    long onUpdGoTrash(FXObject*, FXSelector, void*);
    void updatePath();

    long onCmdStopListRefreshTimer(FXObject*, FXSelector, void*);
    long onUpdRunScript(FXObject*, FXSelector, void*);
    long onCmdGoScriptDir(FXObject*, FXSelector, void*);

#if defined(linux)
    long onCmdMount(FXObject*, FXSelector, void*);
    long onUpdMount(FXObject*, FXSelector, void*);
    long onUpdUnmount(FXObject*, FXSelector, void*);
    long onCmdPkgQuery(FXObject*, FXSelector, void*);
    long onUpdPkgQuery(FXObject*, FXSelector, void*);
    long onCmdPkgInstall(FXObject*, FXSelector, void*);
    long onCmdPkgUninstall(FXObject*, FXSelector, void*);
#endif
public:

    // Change path text
    void setPathText(FXString title)
    {
        pathtext->setText(title);
    }

    // Toggle FileList refresh
    void setAllowRefresh(FXbool flag)
    {
        list->setAllowRefresh(flag);
    }

    // Change sort function
    void setSortFunc(IconListSortFunc func)
    {
        list->setSortFunc(func);
    }

    // Return sort function
    IconListSortFunc getSortFunc() const
    {
        return(list->getSortFunc());
    }

    // Change default cursor
    void setDefaultCursor(FXCursor* cur)
    {
        list->setDefaultCursor(cur);
    }

	// Deselect all items
	void deselectAll(void)
	{
		list->onCmdDeselectAll(0,0,0);
	}

    // Redraw file list
    void redraw(void)
    {
        list->recalc();
    }

    // Return a pointer on the current panel
    FilePanel* getCurrent(void) const
    {
        return(current);
    }

    // Return a pointer on the next panel
    FilePanel* getNext(void) const
    {
        return(next);
    }

    // Set current directory
    void setDirectory(FXString pathname, FXbool notify = false)
    {
        list->setDirectory(pathname, notify);
    }

    // Get current directory
    FXString getDirectory(void) const
    {
        return(list->getDirectory());
    }

    // Get associations
    FileDict* getAssociations(void)
    {
        return(list->getAssociations());
    }

    // Get header size given its index
    int getHeaderSize(int index) const
    {
        return(list->getHeaderSize(index));
    }

    // Hidden files shown?
    FXbool shownHiddenFiles(void) const
    {
        return(list->shownHiddenFiles());
    }

    // Show hidden files
    void showHiddenFiles(FXbool shown)
    {
        list->showHiddenFiles(shown);
    }

    // Thumbnails shown?
    FXbool shownThumbnails(void) const
    {
        return(list->shownThumbnails());
    }

    // Show thumbnails
    void showThumbnails(FXbool shown)
    {
        list->showThumbnails(shown);
    }

    // Get the current icon list style
    FXuint getListStyle(void) const
    {
        return(list->getListStyle());
    }

    // Get the current icon list style
    void setListStyle(FXuint style)
    {
        list->setListStyle(style);
    }

    // Return pointer on the file list
    FileList* getList(void) const
    {
        return(list);
    }

    // Set ignore case
    void setIgnoreCase(FXbool ignorecase)
    {
        list->setIgnoreCase(ignorecase);
    }

    // Get ignore case
    FXbool getIgnoreCase(void)
    {
        return(list->getIgnoreCase());
    }

    // Set directory first
    void setDirsFirst(FXbool dirsfirst)
    {
        list->setDirsFirst(dirsfirst);
    }

    // Set directory first
    FXbool getDirsFirst(void)
    {
        return(list->getDirsFirst());
    }

    // Set focus on file list
    void setFocusOnList(void)
    {
        list->setFocus();
    }

    // Is panel active?
    FXbool isActive(void)
    {
        return(isactive);
    }

    // Get current item
    int getCurrentItem(void) const
    {
        return(list->getCurrentItem());
    }

    // Set current item
    void setCurrentItem(int item)
    {
        list->setCurrentItem(item);
        list->makeItemVisible(item);
    }

    // Select item
    void selectItem(int item)
    {
        list->selectItem(item);
    }

    // Deselect item
    void deselectItem(int item)
    {
        list->deselectItem(item);
    }

    // Is item selected?
    FXbool isItemSelected(int item)
    {
        return(list->isItemSelected(item));
    }

    // Get number od selected items
    int getNumSelectedItems(void)
    {
        return(list->getNumSelectedItems());
    }

    // Status bar is shown?
    FXbool statusbarShown(void)
    {
        return(statusbar->shown());
    }

    // Toggle status bar
    void toggleStatusbar(void)
    {
        statusbar->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_TOGGLESHOWN), NULL);
    }

    // Set path of the path linker
    void setPathLink(FXString pathname)
    {
        pathlink->setPath(pathname);
    }

    // Get back history first item
    StringItem* backhistGetFirst(void)
    {
        return(list->backhist->getFirst());
    }

    // Get forward history first item
    StringItem* forwardhistGetFirst(void)
    {
        return(list->forwardhist->getFirst());
    }

    // Get back history next item
    StringItem* backhistGetNext(StringItem* item)
    {
        return(list->backhist->getNext(item));
    }

    // Get forward history next item
    StringItem* forwardhistGetNext(StringItem* item)
    {
        return(list->forwardhist->getNext(item));
    }

    // Get back history string from item
    FXString backhistGetString(StringItem* item)
    {
        return(list->backhist->getString(item));
    }

    // Get forward history string from item
    FXString forwardhistGetString(StringItem* item)
    {
        return(list->forwardhist->getString(item));
    }

    // Remove back history first item
    void backhistRemoveFirstItem(void)
    {
        list->backhist->removeFirstItem();
    }

    // Remove forward history first item
    void forwardhistRemoveFirstItem(void)
    {
        list->forwardhist->removeFirstItem();
    }

    // Insert back history first item
    void backhistInsertFirstItem(FXString item)
    {
        list->backhist->insertFirstItem(item);
    }

    // Insert forward history first item
    void forwardhistInsertFirstItem(FXString item)
    {
        list->forwardhist->insertFirstItem(item);
    }

    // Get back history number of items
    int backhistGetNumItems(void)
    {
        if (list->backhist)
        {
            return(list->backhist->getNumItems());
        }
        else
        {
            return(0);
        }
    }

    // Get forward history number of items
    int forwardhistGetNumItems(void)
    {
        if (list->forwardhist)
        {
            return(list->forwardhist->getNumItems());
        }
        else
        {
            return(0);
        }
    }

    // Remove all back history items
    void backhistRemoveAllItems(void)
    {
        list->backhist->removeAllItems();
    }

    // Remove all forward history items
    void forwardhistRemoveAllItems(void)
    {
        list->forwardhist->removeAllItems();
    }

    // Remove all back history items before item
    void backhistRemoveAllItemsBefore(StringItem* item)
    {
        list->backhist->removeAllItemsBefore(item);
    }

    // Remove all forward history items before item
    void forwardhistRemoveAllItemsBefore(StringItem* item)
    {
        list->forwardhist->removeAllItemsBefore(item);
    }

    // Get back history item at position pos
    StringItem* backhistGetItemAtPos(int pos)
    {
        return(list->backhist->getItemAtPos(pos));
    }

    // Get forward history item at position pos
    StringItem* forwardhistGetItemAtPos(int pos)
    {
        return(list->forwardhist->getItemAtPos(pos));
    }

    // Show panel separator
    void showPanelSeparator(void)
    {
        panelsep->setSeparatorStyle(SEPARATOR_GROOVE);
    }

    // Hide panel separator
    void hidePanelSeparator(void)
    {
        panelsep->setSeparatorStyle(SEPARATOR_NONE);
    }

    // Return the address box (location bar)
    FXLabel* getWebViewText(void)
    {
        return(webviewtext);
    }
};
#endif
#ifndef FONTDIALOG_H
#define FONTDIALOG_H

#include "DialogBox.h"

class FontSelector;

// Font selection widget
class FXAPI FontSelector : public FXPacker
{
    FXDECLARE(FontSelector)
protected:
    FXTextField*   family;
    FXList*        familylist;
    FXTextField*   weight;
    FXList*        weightlist;
    FXTextField*   style;
    FXList*        stylelist;
    FXTextField*   size;
    FXList*        sizelist;
    FXComboBox*    charset;
    FXComboBox*    setwidth;
    FXComboBox*    pitch;
    FXCheckButton* scalable;
    FXCheckButton* allfonts;
    FXButton*      accept;
    FXButton*      cancel;
    FXLabel*       preview;
    FXFont*        previewfont;
    FXFontDesc     selected;
protected:
    FontSelector() : family(NULL), familylist(NULL), weight(NULL), weightlist(NULL), style(NULL), stylelist(NULL), size(NULL),
                     sizelist(NULL), charset(NULL), setwidth(NULL), pitch(NULL), scalable(NULL), allfonts(NULL), accept(NULL),
                     cancel(NULL), preview(NULL), previewfont(NULL), selected()
    {}
    void listFontFaces();
    void listWeights();
    void listSlants();
    void listFontSizes();
    void previewFont();

private:
    FontSelector(const FontSelector&);
    FontSelector& operator=(const FontSelector&);

public:
    long onCmdFamily(FXObject*, FXSelector, void*);
    long onCmdWeight(FXObject*, FXSelector, void*);
    long onCmdStyle(FXObject*, FXSelector, void*);
    long onCmdStyleText(FXObject*, FXSelector, void*);
    long onCmdSize(FXObject*, FXSelector, void*);
    long onCmdSizeText(FXObject*, FXSelector, void*);
    long onCmdCharset(FXObject*, FXSelector, void*);
    long onUpdCharset(FXObject*, FXSelector, void*);
    long onCmdSetWidth(FXObject*, FXSelector, void*);
    long onUpdSetWidth(FXObject*, FXSelector, void*);
    long onCmdPitch(FXObject*, FXSelector, void*);
    long onUpdPitch(FXObject*, FXSelector, void*);
    long onCmdScalable(FXObject*, FXSelector, void*);
    long onUpdScalable(FXObject*, FXSelector, void*);
    long onCmdAllFonts(FXObject*, FXSelector, void*);
    long onUpdAllFonts(FXObject*, FXSelector, void*);
public:
    enum
    {
        ID_FAMILY=FXPacker::ID_LAST,
        ID_WEIGHT,
        ID_STYLE,
        ID_STYLE_TEXT,
        ID_SIZE,
        ID_SIZE_TEXT,
        ID_CHARSET,
        ID_SETWIDTH,
        ID_PITCH,
        ID_SCALABLE,
        ID_ALLFONTS,
        ID_LAST
    };
public:

    // Constructor
    FontSelector(FXComposite* p, FXObject* tgt = NULL, FXSelector sel = 0, FXuint opts = 0, int x = 0, int y = 0, int w = 0, int h = 0);

    // Create server-side resources
    virtual void create();

    // Return a pointer to the "Accept" button
    FXButton* acceptButton() const
    {
        return(accept);
    }

    // Return a pointer to the "Cancel" button
    FXButton* cancelButton() const
    {
        return(cancel);
    }

    // Set font selection
    void setFontSelection(const FXFontDesc& fontdesc);

    // Get font selection
    void getFontSelection(FXFontDesc& fontdesc) const;

    // Save to a stream
    virtual void save(FXStream& store) const;

    // Load from a stream
    virtual void load(FXStream& store);

    // Destructor
    virtual ~FontSelector();
};



// Font selection dialog
class FXAPI FontDialog : public DialogBox
{
    FXDECLARE(FontDialog)
protected:
    FontSelector* fontbox;
protected:
    FontDialog() : fontbox(NULL)
    {}
private:
    FontDialog(const FontDialog&);
    FontDialog& operator=(const FontDialog&);

public:
    // Constructor
    FontDialog(FXWindow* owner, const FXString& name, FXuint opts = 0, int x = 0, int y = 0, int w = 750, int h = 480);

    // Save dialog to a stream
    virtual void save(FXStream& store) const;

    // Load dialog from a stream
    virtual void load(FXStream& store);

    // Set the current font selection
    void setFontSelection(const FXFontDesc& fontdesc);

    // Get the current font selection
    void getFontSelection(FXFontDesc& fontdesc) const;

    // Destructor
    virtual ~FontDialog();
};


#endif
#ifndef HISTINPUTDIALOG_H
#define HISTINPUTDIALOG_H

#include "DialogBox.h"

// Browse types
enum
{
    HIST_INPUT_FILE,
    HIST_INPUT_EXECUTABLE_FILE,
    HIST_INPUT_FOLDER,
    HIST_INPUT_MIXED
};

class XComApp;

class ComboBox : public FXComboBox
{
    FXDECLARE(ComboBox)
private:
    ComboBox()
    {
    }

public:
    FXTextField* getTextEntry()
    {
        return(field);
    }

    void CursorEnd()
    {
        field->onCmdCursorEnd(0, 0, 0);
        field->setFocus();
    }

    ComboBox(FXComposite* p, int cols, FXObject* tgt = NULL, FXSelector sel = 0, FXuint opts = COMBOBOX_NORMAL);
    virtual void create();
};

class HistInputDialog : public DialogBox
{
    FXDECLARE(HistInputDialog)
protected:
    FXHorizontalFrame* buttons;
    FXHorizontalFrame* checkbutton;
    ComboBox*          input;
    FXuint             browsetype;
    FXString           initialdir;
private:
    HistInputDialog() : buttons(NULL), checkbutton(NULL), input(NULL), browsetype(0)
    {}
public:
    enum
    {
        ID_BROWSE_PATH=DialogBox::ID_LAST,
        ID_LAST
    };
    HistInputDialog(FXWindow*, FXString, FXString, FXString, FXString label = "", FXIcon* ic = NULL, FXuint browse = HIST_INPUT_FILE, FXbool option = false, FXString = FXString::null);
    virtual void create();

    long onCmdKeyPress(FXObject*, FXSelector, void*);
    long onCmdBrowsePath(FXObject*, FXSelector, void*);
    FXString getText()
    {
        return(input->getText());
    }

    void setText(const FXString& text)
    {
        input->setText(text);
    }

    void CursorEnd();
    void selectAll();

    void appendItem(char* str)
    {
        input->appendItem(str);
    }

    void clearItems()
    {
        input->clearItems();
    }

    FXString getHistoryItem(int pos)
    {
        return(input->getItemText(pos));
    }

    int getHistorySize()
    {
        return(input->getNumItems());
    }

    void setDirectory(const FXString&);

    void sortItems()
    {
        input->setSortFunc(FXList::ascendingCase);
        input->sortItems();
    }

};
#endif
#ifndef _ICONLIST_H
#define _ICONLIST_H

#ifndef FXSCROLLAREA_H
#include "FXScrollArea.h"
#endif


class IconList;
class FileList;


// Icon List options (prefixed with an underscore to avoid conflict with the FOX library)
enum
{
    _ICONLIST_EXTENDEDSELECT = 0,                // Extended selection mode
    _ICONLIST_SINGLESELECT   = 0x00100000,       // At most one selected item
    _ICONLIST_BROWSESELECT   = 0x00200000,       // Always exactly one selected item
    _ICONLIST_MULTIPLESELECT = 0x00300000,       // Multiple selection mode
    _ICONLIST_AUTOSIZE       = 0x00400000,       // Automatically size item spacing
    _ICONLIST_DETAILED       = 0,                // List mode
    _ICONLIST_MINI_ICONS     = 0x00800000,       // Mini Icon mode
    _ICONLIST_BIG_ICONS      = 0x01000000,       // Big Icon mode
    _ICONLIST_ROWS           = 0,                // Row-wise mode
    _ICONLIST_COLUMNS        = 0x02000000,       // Column-wise mode
    _ICONLIST_SEARCH         = 0x10000000,       // Icon list is a search list (must be the same value as in FileList)
    _ICONLIST_STANDARD       = 0x20000000,       // Icon list is a not a file list and not a search list
    _ICONLIST_NORMAL         = _ICONLIST_EXTENDEDSELECT
};


// Icon item
class FXAPI IconItem : public FXObject
{
    FXDECLARE(IconItem)
    friend class IconList;
protected:
    FXString label;       // Text of item
    FXIcon*  bigIcon;     // Icon of item
    FXIcon*  miniIcon;    // Icon of item
    void*    data;        // Item user data pointer
    FXuint   state;       // Item state flags
private:
    IconItem(const IconItem&);
    IconItem& operator=(const IconItem&);

protected:
    IconItem() : bigIcon(NULL), miniIcon(NULL), data(NULL), state(0) {}
    virtual void draw(IconList* list, FXDC& dc, int x, int y, int w, int h) const;
    virtual int hitItem(const IconList* list, int rx, int ry, int rw = 1, int rh = 1) const;

protected:
    virtual void drawBigIcon(const IconList* list, FXDC& dc, int x, int y, int w, int h) const;
    virtual void drawMiniIcon(const IconList* list, FXDC& dc, int x, int y, int w, int h) const;
    FXbool isOdd(int i) const;
    virtual void drawDetails(IconList* list, FXDC& dc, int x, int y, int w, int h) const;

public:
    enum
    {
        SELECTED      = 1,  // Selected
        FOCUS         = 2,  // Focus
        DISABLED      = 4,  // Disabled
        DRAGGABLE     = 8,  // Draggable
        BIGICONOWNED  = 16, // Big icon owned by item
        MINIICONOWNED = 32  // Mini icon owned by item
    };
public:

    // Construct new item with given text, icons, and user-data
    IconItem(const FXString& text, FXIcon* bi = NULL, FXIcon* mi = NULL, void* ptr = NULL) : label(text), bigIcon(bi), miniIcon(mi), data(ptr), state(0) {}

    // Change item's text label
    virtual void setText(const FXString& txt);

    // Return item's text label
    const FXString& getText() const
    {
        return(label);
    }

    // Change item's big icon, deleting the old icon if it was owned
    virtual void setBigIcon(FXIcon* icn, FXbool owned = false);

    // Return item's big icon
    FXIcon* getBigIcon() const
    {
        return(bigIcon);
    }

    // Change item's mini icon, deleting the old icon if it was owned
    virtual void setMiniIcon(FXIcon* icn, FXbool owned = false);

    // Return item's mini icon
    FXIcon* getMiniIcon() const
    {
        return(miniIcon);
    }

    // Change item's user data
    void setData(void* ptr)
    {
        data = ptr;
    }

    // Get item's user data
    void* getData() const
    {
        return(data);
    }

    // Make item draw as focused
    virtual void setFocus(FXbool focus);

    // Return true if item has focus
    FXbool hasFocus() const
    {
        return((state&FOCUS) != 0);
    }

    // Select item
    virtual void setSelected(FXbool selected);

    // Return true if this item is selected
    FXbool isSelected() const
    {
        return((state&SELECTED) != 0);
    }

    // Enable or disable item
    virtual void setEnabled(FXbool enabled);

    // Return true if this item is enabled
    FXbool isEnabled() const
    {
        return((state&DISABLED) == 0);
    }

    // Make item draggable
    virtual void setDraggable(FXbool draggable);

    // Return true if this item is draggable
    FXbool isDraggable() const
    {
        return((state&DRAGGABLE) != 0);
    }

    // Return width of item as drawn in list
    virtual int getWidth(const IconList* list) const;

    // Return height of item as drawn in list
    virtual int getHeight(const IconList* list) const;

    // Create server-side resources
    virtual void create();

    // Detach server-side resources
    virtual void detach();

    // Destroy server-side resources
    virtual void destroy();

    // Save to stream
    virtual void save(FXStream& store) const;

    // Load from stream
    virtual void load(FXStream& store);

    // Destroy item and free icons if owned
    virtual ~IconItem();
};


// Icon item collate function
typedef int (*IconListSortFunc)(const IconItem*, const IconItem*);


// List of IconItem's
typedef FXObjectListOf<IconItem>   IconItemList;


// A Icon List Widget displays a list of items, each with a text and
// optional icon.  Icon List can display its items in essentially three
// different ways; in big-icon mode, the bigger of the two icons is used
// for each item, and the text is placed underneath the icon. In mini-
// icon mode, the icons are listed in rows and columns, with the smaller
// icon preceding the text.  Finally, in detail mode the icons are listed
// in a single column, and all fields of the text are shown under a
// header control with one button for each subfield.
// When an item's selected state changes, the icon list sends
// a SEL_SELECTED or SEL_DESELECTED message.  A change of the current
// item is signified by the SEL_CHANGED message.
// The icon list sends SEL_COMMAND messages when the user clicks on an item,
// and SEL_CLICKED, SEL_DOUBLECLICKED, and SEL_TRIPLECLICKED when the user
// clicks once, twice, or thrice, respectively.
// When items are added, replaced, or removed, the icon list sends messages
// of the type SEL_INSERTED, SEL_REPLACED, or SEL_DELETED.
// In each of these cases, the index to the item, if any, is passed in the
// 3rd argument of the message.

class FXAPI IconList : public FXScrollArea
{
    FXDECLARE(IconList)
protected:
    FXHeader*        header;             // Header control
    IconItemList     items;              // Item list
    int              nrows;              // Number of rows
    int              ncols;              // Number of columns
    int              anchor;             // Anchor item
    int              current;            // Current item
    int              extent;             // Extent item
    int              cursor;             // Cursor item
    int              viewable;           // Visible item
    FXFont*          font;               // Font
    IconListSortFunc sortfunc;           // Item sort function
    FXColor          textColor;          // Text color
    FXColor          selbackColor;       // Selected back color
    FXColor          seltextColor;       // Selected text color
    FXColor          highlightColor;     // Highlight color
    FXColor          sortColor;          // Sort color
    FXColor          highlightSortColor; // Highlight sort color
    int              itemWidth;          // Item width
    int              itemHeight;         // Item height
    int              itemSpace;          // Space for item label
    int              anchorx;            // Rectangular selection
    int              anchory;
    int              currentx;
    int              currenty;
    int              grabx;           // Grab point x
    int              graby;           // Grab point y
    FXString         lookup;          // Lookup string
    FXString         help;            // Help text
    FXbool           state;           // State of item
    FXbool           allowTooltip;    // Allow tooltip in single click mode
    FXuint           numsortheader;   // Index of the sorted column
    double           headerpct[10];   // Header sizes, relatively to the list width (in percent)
    int              count;           // Counter used to properly initialize the relative header sizes
    FXbool           ignorecase;      // Case sensitivity for file name sorting
    FXbool           initheaderpct;   // Indicates we have to initialize the headerpct for the deletion columns
protected:
    IconList() : header(NULL), nrows(0), ncols(0), anchor(0), current(0), extent(0), cursor(0), viewable(0), font(NULL),
                 sortfunc(NULL), textColor(FXRGB(0, 0, 0)), selbackColor(FXRGB(0, 0, 0)),
                 seltextColor(FXRGB(0, 0, 0)), highlightColor(FXRGB(0, 0, 0)), sortColor(FXRGB(0, 0, 0)), highlightSortColor(FXRGB(0, 0, 0)),
                 itemWidth(0), itemHeight(0), itemSpace(0), anchorx(0), anchory(0), currentx(0), currenty(0), grabx(0), graby(0), state(false),
                 allowTooltip(false), numsortheader(0), count(0), ignorecase(false), initheaderpct(false)
    {}
    void recompute();
    void getrowscols(int& nr, int& nc, int w, int h) const;
    void drawLasso(int x0, int y0, int x1, int y1);
    void lassoChanged(int ox, int oy, int ow, int oh, int nx, int ny, int nw, int nh, FXbool notify);
    virtual void moveContents(int x, int y);
    virtual IconItem* createItem(const FXString& text, FXIcon* big, FXIcon* mini, void* ptr);
    static int compareSection(const char* p, const char* q, int s);
    static int compareSectionCase(const char* p, const char* q, int s);

private:
    IconList(const IconList&);
    IconList& operator=(const IconList&);

public:
    long onConfigure(FXObject*, FXSelector, void*);
    long onPaint(FXObject*, FXSelector, void*);
    long onEnter(FXObject*, FXSelector, void*);
    long onLeave(FXObject*, FXSelector, void*);
    long onUngrabbed(FXObject*, FXSelector, void*);
    long onKeyPress(FXObject*, FXSelector, void*);
    long onKeyRelease(FXObject*, FXSelector, void*);
    long onLeftBtnPress(FXObject*, FXSelector, void*);
    long onLeftBtnRelease(FXObject*, FXSelector, void*);
    long onRightBtnPress(FXObject*, FXSelector, void*);
    long onRightBtnRelease(FXObject*, FXSelector, void*);
    long onMotion(FXObject*, FXSelector, void*);
    long onQueryTip(FXObject*, FXSelector, void*);
    long onQueryHelp(FXObject*, FXSelector, void*);
    long onTipTimer(FXObject*, FXSelector, void*);
    long onCmdselectAll(FXObject*, FXSelector, void*);
    long onCmdDeselectAll(FXObject*, FXSelector, void*);
    long onCmdSelectInverse(FXObject*, FXSelector, void*);
    long onCmdArrangeByRows(FXObject*, FXSelector, void*);
    long onUpdArrangeByRows(FXObject*, FXSelector, void*);
    long onCmdArrangeByColumns(FXObject*, FXSelector, void*);
    long onUpdArrangeByColumns(FXObject*, FXSelector, void*);
    long onCmdShowDetails(FXObject*, FXSelector, void*);
    long onUpdShowDetails(FXObject*, FXSelector, void*);
    long onCmdShowBigIcons(FXObject*, FXSelector, void*);
    long onUpdShowBigIcons(FXObject*, FXSelector, void*);
    long onCmdShowMiniIcons(FXObject*, FXSelector, void*);
    long onUpdShowMiniIcons(FXObject*, FXSelector, void*);
    long onHeaderChanged(FXObject*, FXSelector, void*);
    long onHeaderResize(FXObject*, FXSelector, void*);
    long onFocusIn(FXObject*, FXSelector, void*);
    long onFocusOut(FXObject*, FXSelector, void*);
    long onClicked(FXObject*, FXSelector, void*);
    long onDoubleClicked(FXObject*, FXSelector, void*);
    long onTripleClicked(FXObject*, FXSelector, void*);
    long onCommand(FXObject*, FXSelector, void*);
    long onAutoScroll(FXObject*, FXSelector, void*);
    long onLookupTimer(FXObject*, FXSelector, void*);
    long onCmdSetValue(FXObject*, FXSelector, void*);
    long onCmdGetIntValue(FXObject*, FXSelector, void*);
    long onCmdSetIntValue(FXObject*, FXSelector, void*);
    long onCmdToggleAutosize(FXObject*, FXSelector, void*);
    long onUpdToggleAutosize(FXObject*, FXSelector, void*);
    long onCmdHeaderClicked(FXObject*, FXSelector, void*);
public:
    static int ascending(const IconItem* a, const IconItem* b);
    static int descending(const IconItem* a, const IconItem* b);
    static int ascendingCase(const IconItem* a, const IconItem* b);
    static int descendingCase(const IconItem* a, const IconItem* b);

public:
    enum
    {
        ID_SHOW_DETAILS=FXScrollArea::ID_LAST,
        ID_SHOW_MINI_ICONS,
        ID_SHOW_BIG_ICONS,
        ID_ARRANGE_BY_ROWS,
        ID_ARRANGE_BY_COLUMNS,
        ID_HEADER_CHANGE,
        ID_LOOKUPTIMER,
        ID_SELECT_ALL,
        ID_DESELECT_ALL,
        ID_SELECT_INVERSE,
        ID_AUTOSIZE,
        ID_LAST
    };
public:

    // Construct icon list with no items in it initially
    IconList(FXComposite* p, FXObject* tgt = NULL, FXSelector sel = 0, FXuint opts = _ICONLIST_NORMAL, int x = 0, int y = 0, int w = 0, int h = 0);

    // Create server-side resources
    virtual void create();

    // Detach server-side resources
    virtual void detach();

    // Recalculate layout
    virtual void recalc();

    // Perform layout
    virtual void layout();

    // Compute and return content width
    virtual int getContentWidth();

    // Return content height
    virtual int getContentHeight();

    // Icon list can receive focus
    virtual bool canFocus() const;

    // Move the focus to this window
    virtual void setFocus();

    // Remove the focus from this window
    virtual void killFocus();

    // Return viewport size
    virtual int getViewportHeight();

    // Resize this window to the specified width and height
    virtual void resize(int w, int h);

    // Move and resize this window in the parent's coordinates
    virtual void position(int x, int y, int w, int h);

    // Return ignore case flag
    FXbool getIgnoreCase() const
    {
        return(ignorecase);
    }

    // Set ignore case flag
    void setIgnoreCase(const FXbool);

    // Return number of items
    int getNumItems() const
    {
        return(items.no());
    }

    // Return number of rows
    int getNumRows() const
    {
        return(nrows);
    }

    // Return number of columns
    int getNumCols() const
    {
        return(ncols);
    }

    // Return header control
    FXHeader* getHeader() const
    {
        return(header);
    }

    // Set headers from array of strings
    void setHeaders(const char** strings, int size = 1);

    // Set headers from newline separated strings
    void setHeaders(const FXString& strings, int size = 1);

    // Append header with given text and optional icon
    void appendHeader(const FXString& text, FXIcon* icon = NULL, int size = 1);

    // Remove header at index
    void removeHeader(int index);

    // Change text of header at index
    void setHeaderText(int index, const FXString& text);

    // Return text of header at index
    FXString getHeaderText(int index) const;

    // Change icon of header at index
    void setHeaderIcon(int index, FXIcon* icon);

    // Return icon of header at index
    FXIcon* getHeaderIcon(int index) const;

    // Change size of header at index
    void setHeaderSize(int index, int size);

    // Return width of header at index
    int getHeaderSize(int index) const;

    // Return number of headers
    int getNumHeaders() const;

    // Return the item at the given index
    IconItem* getItem(int index) const;

    // Replace the item with a [possibly subclassed] item
    int setItem(int index, IconItem* item, FXbool notify = false);

    // Replace items text, icons, and user-data pointer
    int setItem(int index, const FXString& text, FXIcon* big = NULL, FXIcon* mini = NULL, void* ptr = NULL, FXbool notify = false);

    // Fill list by appending items from array of strings
    int fillItems(const char** strings, FXIcon* big = NULL, FXIcon* mini = NULL, void* ptr = NULL, FXbool notify = false);

    // Fill list by appending items from newline separated strings
    int fillItems(const FXString& strings, FXIcon* big = NULL, FXIcon* mini = NULL, void* ptr = NULL, FXbool notify = false);

    // Insert a new [possibly subclassed] item at the give index
    int insertItem(int index, IconItem* item, FXbool notify = false);

    // Insert item at index with given text, icons, and user-data pointer
    int insertItem(int index, const FXString& text, FXIcon* big = NULL, FXIcon* mini = NULL, void* ptr = NULL, FXbool notify = false);

    // Append a [possibly subclassed] item to the end of the list
    int appendItem(IconItem* item, FXbool notify = false);

    // Append new item with given text and optional icons, and user-data pointer
    int appendItem(const FXString& text, FXIcon* big = NULL, FXIcon* mini = NULL, void* ptr = NULL, FXbool notify = false);

    // Prepend a [possibly subclassed] item to the end of the list
    int prependItem(IconItem* item, FXbool notify = false);

    // Prepend new item with given text and optional icons, and user-data pointer
    int prependItem(const FXString& text, FXIcon* big = NULL, FXIcon* mini = NULL, void* ptr = NULL, FXbool notify = false);

    // Move item from oldindex to newindex
    int moveItem(int newindex, int oldindex, FXbool notify = false);

    // Extract item from list
    IconItem* extractItem(int index, FXbool notify = false);

    // Remove item from list
    void removeItem(int index, FXbool notify = false);

    // Remove all items from list
    void clearItems(FXbool notify = false);

    // Return item width
    int getItemWidth() const
    {
        return(itemWidth);
    }

    // Return item height
    int getItemHeight() const
    {
        return(itemHeight);
    }

    // Return index of item at x,y, or -1 if none
    virtual int getItemAt(int x, int y);

    // Search items by name, beginning from item start.  If the start
    // item is -1 the search will start at the first item in the list.
    // Flags may be SEARCH_FORWARD or SEARCH_BACKWARD to control the
    // search direction; this can be combined with SEARCH_NOWRAP or SEARCH_WRAP
    // to control whether the search wraps at the start or end of the list.
    // The option SEARCH_IGNORECASE causes a case-insensitive match.  Finally,
    // passing SEARCH_PREFIX causes searching for a prefix of the item name.
    // Return -1 if no matching item is found.
    int findItem(const FXString& text, int start = -1, FXuint flags = SEARCH_FORWARD|SEARCH_WRAP) const;


    // Search items by associated user data, beginning from item start. If the
    // start item is -1 the search will start at the first item in the list.
    // Flags may be SEARCH_FORWARD or SEARCH_BACKWARD to control the
    // search direction; this can be combined with SEARCH_NOWRAP or SEARCH_WRAP
    // to control whether the search wraps at the start or end of the list.
    int findItemByData(const void* ptr, int start = -1, FXuint flags = SEARCH_FORWARD|SEARCH_WRAP) const;

    // Scroll to make item at index visible
    virtual void makeItemVisible(int index);

    // Change item text
    void setItemText(int index, const FXString& text);

    // Return item text
    FXString getItemText(int index) const;

    // Change item big icon
    void setItemBigIcon(int index, FXIcon* icon, FXbool owned = false);

    // Return big icon of item at index
    FXIcon* getItemBigIcon(int index) const;

    // Change item mini icon
    void setItemMiniIcon(int index, FXIcon* icon, FXbool owned = false);

    // Return mini icon of item at index
    FXIcon* getItemMiniIcon(int index) const;

    // Change item user-data pointer
    void setItemData(int index, void* ptr);

    // Return item user-data pointer
    void* getItemData(int index) const;

    // Return true if item is selected
    FXbool isItemSelected(int index) const
    {
        if ((FXuint)index >= (FXuint)items.no())
        {
            fxerror("%s::isItemSelected: index out of range.\n", getClassName());
        }
        return(items[index]->isSelected());
    }

    // Return true if item at index is current
    FXbool isItemCurrent(int index) const;

    // Return true if item at index is visible
    FXbool isItemVisible(int index) const;

    // Return true if item at index is enabled
    FXbool isItemEnabled(int index) const;

    // Return item hit code: 0 outside, 1 icon, 2 text
    int hitItem(int index, int x, int y, int ww = 1, int hh = 1) const;

    // Repaint item at index
    void updateItem(int index) const;

    // Enable item at index
    virtual FXbool enableItem(int index);

    // Disable item at index
    virtual FXbool disableItem(int index);

    // Select item at index
    virtual FXbool selectItem(int index, FXbool notify = false);

    // Deselect item at index
    virtual FXbool deselectItem(int index, FXbool notify = false);

    // Toggle item at index
    virtual FXbool toggleItem(int index, FXbool notify = false);

    // Select items in rectangle
    virtual FXbool selectInRectangle(int x, int y, int w, int h, FXbool notify = false);

    // Extend selection from anchor index to index
    virtual FXbool extendSelection(int index, FXbool notify = false);

    // Deselect all items
    virtual FXbool killSelection(FXbool notify = false);

    // Change current item index
    virtual void setCurrentItem(int index, FXbool notify = false);

    // Return current item index, or -1 if none
    int getCurrentItem() const
    {
        return(current);
    }

    // Change anchor item index
    void setAnchorItem(int index);

    // Return anchor item index, or -1 if none
    int getAnchorItem() const
    {
        return(anchor);
    }

    // Return index of item under cursor, or -1 if none
    int getCursorItem() const
    {
        return(cursor);
    }

    // Sort items
    void sortItems();

    // Return sort function
    IconListSortFunc getSortFunc() const
    {
        return(sortfunc);
    }

    // Change sort function
    void setSortFunc(IconListSortFunc func)
    {
        sortfunc = func;
    }

    // Set sort header
    void setSortHeader(const FXuint num)
    {
        numsortheader = num;
    }

    // Get sort header
    FXuint getSortHeader()
    {
        return(numsortheader);
    }

    // Change text font
    void setFont(FXFont* fnt);

    // Return text font
    FXFont* getFont() const
    {
        return(font);
    }

    // Return normal text color
    FXColor getTextColor() const
    {
        return(textColor);
    }

    // Change normal text color
    void setTextColor(FXColor clr);

    // Return selected text background
    FXColor getSelBackColor() const
    {
        return(selbackColor);
    }

    // Change selected text background
    void setSelBackColor(FXColor clr);

    // Return selected text color
    FXColor getSelTextColor() const
    {
        return(seltextColor);
    }

    // Return highlight color
    FXColor getHighlightColor() const
    {
        return(highlightColor);
    }

    // Return sort color
    FXColor getSortColor() const
    {
        return(sortColor);
    }

    // Return highlight sort color
    FXColor getHighlightSortColor() const
    {
        return(highlightSortColor);
    }

    // Change selected text color
    void setSelTextColor(FXColor clr);

    // Change maximum item space for each item
    void setItemSpace(int s);

    // Return maximum item space
    int getItemSpace() const
    {
        return(itemSpace);
    }

    // Get the current icon list style
    FXuint getListStyle() const;

    // Set the current icon list style.
    void setListStyle(FXuint style);

    // Set the status line help text for this widget
    void setHelpText(const FXString& text);

    // Get the status line help text for this widget
    const FXString& getHelpText() const
    {
        return(help);
    }

    // Save list to a stream
    virtual void save(FXStream& store) const;

    // Load list from a stream
    virtual void load(FXStream& store);

    // Destructor
    virtual ~IconList();
};


#endif
#ifndef INPUTDIALOG_H
#define INPUTDIALOG_H

#include "DialogBox.h"

class XComApp;

class InputDialog : public DialogBox
{
    FXDECLARE(InputDialog)
protected:
    FXTextField*       input;
    FXHorizontalFrame* checkbutton;
    FXLabel*           msg;
private:
    InputDialog() : input(NULL), checkbutton(NULL), msg(NULL)
    {}
public:
    InputDialog(FXWindow*, FXString, FXString, FXString, FXString label = "", FXIcon* icon = NULL, FXbool option = false, FXString = FXString::null);
    virtual void create();

    long onCmdKeyPress(FXObject*, FXSelector, void*);
    FXString getText()
    {
        return(input->getText());
    }

    void setText(const FXString& text)
    {
        input->setText(text);
    }

	void setMessage(const FXString& text)
	{
		msg->setText(text);
	}

    void selectAll()
    {
        input->setSelection(0, (input->getText()).length());
    }

    void CursorEnd()
    {
        input->onCmdCursorEnd(0, 0, 0);
    }

    void setSelection(int pos, int len)
    {
        input->setSelection(pos, len);
    }
};
#endif
#ifndef KEYBINDINGS_H
#define KEYBINDINGS_H

#include "DialogBox.h"
#include "IconList.h"


class KeybindingsBox : public DialogBox
{
    FXDECLARE(KeybindingsBox)
protected:
    IconList*     glbBindingsList;
    IconList*     xfeBindingsList;
    IconList*     xfiBindingsList;
    IconList*     xfwBindingsList;
    FXStringDict* glbBindingsDict;
    FXStringDict* xfeBindingsDict;
    FXStringDict* xfiBindingsDict;
    FXStringDict* xfwBindingsDict;
    FXStringDict* glbBindingsDict_prev;
    FXStringDict* xfeBindingsDict_prev;
    FXStringDict* xfiBindingsDict_prev;
    FXStringDict* xfwBindingsDict_prev;
    FXbool        changed;

private:
    KeybindingsBox() : glbBindingsList(NULL), xfeBindingsList(NULL), xfiBindingsList(NULL), xfwBindingsList(NULL),
                       glbBindingsDict(NULL), xfeBindingsDict(NULL), xfiBindingsDict(NULL), xfwBindingsDict(NULL),
                       glbBindingsDict_prev(NULL), xfeBindingsDict_prev(NULL), xfiBindingsDict_prev(NULL),
                       xfwBindingsDict_prev(NULL), changed(false)
    {}
public:
    enum
    {
        ID_ACCEPT=DialogBox::ID_LAST,
        ID_CANCEL,
        ID_GLB_BINDINGS_LIST,
        ID_XFE_BINDINGS_LIST,
        ID_XFI_BINDINGS_LIST,
        ID_XFW_BINDINGS_LIST,
        ID_GLB_SORT_BY_ACTIONNAME,
        ID_GLB_SORT_BY_REGISTRYKEY,
        ID_GLB_SORT_BY_KEYBINDING,
        ID_XFE_SORT_BY_ACTIONNAME,
        ID_XFE_SORT_BY_REGISTRYKEY,
        ID_XFE_SORT_BY_KEYBINDING,
        ID_XFI_SORT_BY_ACTIONNAME,
        ID_XFI_SORT_BY_REGISTRYKEY,
        ID_XFI_SORT_BY_KEYBINDING,
        ID_XFW_SORT_BY_ACTIONNAME,
        ID_XFW_SORT_BY_REGISTRYKEY,
        ID_XFW_SORT_BY_KEYBINDING,
        ID_LAST
    };
    KeybindingsBox(FXWindow*, FXStringDict*, FXStringDict*, FXStringDict*, FXStringDict*);
    virtual void create();

    virtual ~KeybindingsBox();
    FXuint execute(FXuint);
    long   onCmdAccept(FXObject*, FXSelector, void*);
    long   onCmdCancel(FXObject*, FXSelector, void*);
    long   onCmdDefineGlbKeybindings(FXObject*, FXSelector, void*);
    long   onCmdDefineXfeKeybindings(FXObject*, FXSelector, void*);
    long   onCmdDefineXfiKeybindings(FXObject*, FXSelector, void*);
    long   onCmdDefineXfwKeybindings(FXObject*, FXSelector, void*);
    long   onCmdGlbSortByActionName(FXObject*, FXSelector, void*);
    long   onCmdGlbSortByRegistryKey(FXObject*, FXSelector, void*);
    long   onCmdGlbSortByKeyBinding(FXObject*, FXSelector, void*);
    long   onCmdXfeSortByActionName(FXObject*, FXSelector, void*);
    long   onCmdXfeSortByRegistryKey(FXObject*, FXSelector, void*);
    long   onCmdXfeSortByKeyBinding(FXObject*, FXSelector, void*);
    long   onCmdXfiSortByActionName(FXObject*, FXSelector, void*);
    long   onCmdXfiSortByRegistryKey(FXObject*, FXSelector, void*);
    long   onCmdXfiSortByKeyBinding(FXObject*, FXSelector, void*);
    long   onCmdXfwSortByActionName(FXObject*, FXSelector, void*);
    long   onCmdXfwSortByRegistryKey(FXObject*, FXSelector, void*);
    long   onCmdXfwSortByKeyBinding(FXObject*, FXSelector, void*);
    long   onCmdGlbHeaderClicked(FXObject*, FXSelector, void*);
    long   onCmdXfeHeaderClicked(FXObject*, FXSelector, void*);
    long   onCmdXfiHeaderClicked(FXObject*, FXSelector, void*);
    long   onCmdXfwHeaderClicked(FXObject*, FXSelector, void*);
    long   onUpdGlbHeader(FXObject*, FXSelector, void*);
    long   onUpdXfeHeader(FXObject*, FXSelector, void*);
    long   onUpdXfiHeader(FXObject*, FXSelector, void*);
    long   onUpdXfwHeader(FXObject*, FXSelector, void*);
public:
    static int compareSection(const char* p, const char* q, int s);
    static int ascendingActionName(const IconItem* a, const IconItem* b);
    static int descendingActionName(const IconItem* a, const IconItem* b);
    static int ascendingRegistryKey(const IconItem* a, const IconItem* b);
    static int descendingRegistryKey(const IconItem* a, const IconItem* b);
    static int ascendingKeybinding(const IconItem* a, const IconItem* b);
    static int descendingKeybinding(const IconItem* a, const IconItem* b);
};
#endif
#ifndef KEYBINDINGSDIALOG_H
#define KEYBINDINGSDIALOG_H

#include "DialogBox.h"

class XComApp;

class KeybindingsDialog : public DialogBox
{
    FXDECLARE(KeybindingsDialog)
protected:
    FXLabel* keylabel;
private:
    KeybindingsDialog() : keylabel(NULL)
    {}
public:
    KeybindingsDialog(FXWindow*, FXString, FXString, FXString, FXIcon* icon = NULL);
    virtual void create();

    long onCmdKeyPress(FXObject*, FXSelector, void*);
    FXString getKey()
    {
        return(keylabel->getText());
    }
};
#endif
#ifndef MESSAGEBOX_H
#define MESSAGEBOX_H

#include "DialogBox.h"

// Message box buttons
enum
{
    BOX_OK                   = 0x10000000, // Message box has a only an OK button
    BOX_OK_CANCEL            = 0x20000000, // Message box has OK and CANCEL buttons
    BOX_YES_NO               = 0x30000000, // Message box has YES and NO buttons
    BOX_YES_NO_CANCEL        = 0x40000000, // Message box has YES, NO, and CANCEL buttons
    BOX_QUIT_CANCEL          = 0x50000000, // Message box has QUIT and CANCEL buttons
    BOX_QUIT_SAVE_CANCEL     = 0x60000000, // Message box has QUIT, SAVE, and CANCEL buttons
    BOX_YES_NO_ALL_CANCEL    = 0x70000000, // Message box has YES, NO, ALL and CANCEL buttons
    BOX_OK_SU                = 0x80000000  // Message box has OK and SU buttons
};
enum
{
    BOX_CLICKED_YES      = 1,            // The YES button was clicked
    BOX_CLICKED_NO       = 2,            // The NO button was clicked
    BOX_CLICKED_OK       = 3,            // The OK button was clicked
    BOX_CLICKED_CANCEL   = 4,            // The CANCEL button was clicked
    BOX_CLICKED_QUIT     = 5,            // The QUIT button was clicked
    BOX_CLICKED_SAVE     = 6,            // The SAVE button was clicked
    BOX_CLICKED_ALL      = 7,            // The ALL button was clicked
    BOX_CLICKED_SU       = 8             // The SU button was clicked
};


// Message box
class FXAPI MessageBox : public DialogBox
{
    FXDECLARE(MessageBox)
private:
    MessageBox(const MessageBox&);
    MessageBox& operator=(const MessageBox&);

    void     initialize(const FXString &, FXIcon*, FXuint, FXuint);
    FXLabel* msg;
protected:
    MessageBox() : msg(NULL)
    {}
public:
    long onCmdClicked(FXObject*, FXSelector, void*);
    long onCmdCancel(FXObject*, FXSelector, void*);
    long onCmdSu(FXObject*, FXSelector sel, void*);

public:
    enum
    {
        ID_CLICKED_YES=DialogBox::ID_LAST,
        ID_CLICKED_NO,
        ID_CLICKED_OK,
        ID_CLICKED_CANCEL,
        ID_CLICKED_QUIT,
        ID_CLICKED_SAVE,
        ID_CLICKED_ALL,
        ID_CLICKED_SU,
        ID_LAST
    };
public:

    // Construct message box with given caption, icon, and message text
    MessageBox(FXWindow* owner, const FXString& caption, const FXString& text, FXIcon* ic = NULL, FXuint opts = 0,
               FXuint textopts = JUSTIFY_LEFT|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y,
               int x = 0, int y = 0);

    // Construct free floating message box with given caption, icon, and message text
    MessageBox(FXApp* a, const FXString& caption, const FXString& text, FXIcon* ic = NULL, FXuint opts = 0,
               FXuint textopts = JUSTIFY_LEFT|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y,
               int x = 0, int y = 0);

    // Show a modal error message.
    // The text message may contain printf-tyle formatting commands.
    static FXuint error(FXWindow* owner, FXuint opts, const char* caption, const char* message, ...) FX_PRINTF(4, 5);
    static FXuint error(FXApp* app, FXuint opts, const char* caption, const char* message, ...) FX_PRINTF(4, 5);

    // Show a modal warning message
    // The text message may contain printf-tyle formatting commands.
    static FXuint warning(FXWindow* owner, FXuint opts, const char* caption, const char* message, ...) FX_PRINTF(4, 5);
    static FXuint warning(FXApp* app, FXuint opts, const char* caption, const char* message, ...) FX_PRINTF(4, 5);

    // Show a modal question dialog
    // The text message may contain printf-tyle formatting commands.
    static FXuint question(FXWindow* owner, FXuint opts, const char* caption, const char* message, ...) FX_PRINTF(4, 5);
    static FXuint question(FXApp* app, FXuint opts, const char* caption, const char* message, ...) FX_PRINTF(4, 5);

    // Show a modal information dialog
    // The text message may contain printf-tyle formatting commands.
    static FXuint information(FXWindow* owner, FXuint opts, const char* caption, const char* message, ...) FX_PRINTF(4, 5);
    static FXuint information(FXApp* app, FXuint opts, const char* caption, const char* message, ...) FX_PRINTF(4, 5);

    // Get message text
    FXString getText(void)
    {
        return(msg->getText());
    }

    // Set message text
    void setText(FXString);
};

#endif
#ifndef OVERWRITEBOX_H
#define OVERWRITEBOX_H


#include "DialogBox.h"

// Return values
enum OverwriteBoxReturn
{
    OVWBOX_CLICKED_CANCEL       = 0,
    OVWBOX_CLICKED_OVERWRITE    = 1,
    OVWBOX_CLICKED_OVERWRITE_ALL= 2,
    OVWBOX_CLICKED_SKIP         = 3,
    OVWBOX_CLICKED_SKIP_ALL     = 4,
};

// Dialog type
enum OverwriteBoxType
{
    OVWBOX_MULTIPLE_FILES = 0,
    OVWBOX_SINGLE_FILE    = 1,
};

// Message box
class FXAPI OverwriteBox : public DialogBox
{
    FXDECLARE(OverwriteBox)
protected:
    OverwriteBox()
    {}
    OverwriteBox(const OverwriteBox&)
    {}
public:
    long onCmdClicked(FXObject*, FXSelector, void*);
public:
    enum
    {
        ID_CLICKED_CANCEL=DialogBox::ID_LAST,
        ID_CLICKED_OVERWRITE,
        ID_CLICKED_OVERWRITE_ALL,
        ID_CLICKED_SKIP,
        ID_CLICKED_SKIP_ALL,
        ID_LAST
    };
public:
    OverwriteBox(FXWindow* win, const FXString& name, const FXString& text, FXuint type = OVWBOX_MULTIPLE_FILES, FXuint opts = DECOR_TITLE|DECOR_BORDER, int x = 0, int y = 0);

    OverwriteBox(FXWindow* win, const FXString& name, const FXString& text, FXString& srcsize, FXString& srcmtime, FXString& tgtsize,
                 FXString& tgtmtime, FXuint type = OVWBOX_MULTIPLE_FILES, FXuint opts = DECOR_TITLE|DECOR_BORDER, int x = 0, int y = 0);

};

#endif
#ifndef PATHLINKER_H
#define PATHLINKER_H

#include <vector>
#include "TextLabel.h"
#include "FileList.h"
#include "DirPanel.h"
#include "xfedefs.h"

class FXAPI PathLinker : public FXHorizontalFrame
{
    FXDECLARE(PathLinker)

protected:
    typedef std::vector<FXButton*>   vector_FXButton;
    vector_FXButton linkButtons;
    FXuint          nbActiveButtons;
    FXuint          currentButton;
    FXString        visitedPath;
    TextLabel*      focusButton;
    FXFont*         normalFont;
    FXFont*         highlightFont;
    FileList*       filelist;
    DirList*        dirlist;
    PathLinker() : nbActiveButtons(0), currentButton(0), focusButton(NULL), normalFont(NULL), highlightFont(NULL), filelist(NULL), dirlist(NULL)
    {}

private:
    void updatePath(FXString, FXuint);
    void setText(FXuint, FXString);

public:
    enum ButtonIds
    {
        ID_START_LINK = FXHorizontalFrame::ID_LAST,
        // Note: Place any additional id's AFTER ID_END_LINK
        ID_END_LINK = ID_START_LINK + MAX_LINKS - 1,
        ID_FOCUS_BUTTON,
        ID_LAST
    };

    PathLinker(FXComposite* a, FileList* flist, DirList* dlist = NULL, FXuint opts = 0);
    virtual void create();

    virtual ~PathLinker();
    long pathButtonPressed(FXObject*, FXSelector, void*);
    long onCmdFocusButton(FXObject*, FXSelector, void*);
    long onUpdPath(FXObject*, FXSelector, void*);
    void setPath(FXString);
    void focus();
    void unfocus();
};

#endif
#ifndef PREFERENCES_H
#define PREFERENCES_H

#include <string.h>

#include "DialogBox.h"
#include "Keybindings.h"


// Number of modifiable colors
#define NUM_COLORS    12

// Number of themes
#define NUM_THEMES    10


struct Theme
{
    //const char *name;
    FXString name;
    FXColor  color[NUM_COLORS];
    Theme()
    {
        name = "";
    }

    Theme(const char* n, FXColor base = 0, FXColor bdr = 0, FXColor bg = 0, FXColor fg = 0,
          FXColor selbg = 0, FXColor selfg = 0, FXColor listbg = 0, FXColor listfg = 0, FXColor listhl = 0, FXColor pbarfg = 0, FXColor attenfg = 0, FXColor scrollfg = 0)
    {
        name = FXString(n);
        color[0] = base;
        color[1] = bdr;
        color[2] = bg;
        color[3] = fg;
        color[4] = selbg;
        color[5] = selfg;
        color[6] = listbg;
        color[7] = listfg;
        color[8] = listhl;
        color[9] = pbarfg;
        color[10] = attenfg;
        color[11] = scrollfg;
    }

    FXbool operator !=(const Theme&);
};


class PreferencesBox : public DialogBox
{
    FXDECLARE(PreferencesBox)
private:
    FXComboBox*    colorsBox;
    FXComboBox*    themesBox;
    FXList*        themesList;
    FXTextField*   iconpath;
    FXTextField*   txtviewer;
    FXTextField*   txteditor;
    FXTextField*   filecomparator;
    FXTextField*   timeformat;
    FXTextField*   imgviewer;
    FXTextField*   xterm;
    FXTextField*   imgeditor;
    FXTextField*   archiver;
    FXTextField*   pdfviewer;
    FXTextField*   videoplayer;
    FXTextField*   audioplayer;
    FXTextField*   normalfont;
    FXTextField*   textfont;
    FXTextField*   mountcmd;
    FXTextField*   umountcmd;
    FXString       oldiconpath;
    FXString       oldtxtviewer;
    FXString       oldtxteditor;
    FXString       oldfilecomparator;
    FXString       oldtimeformat;
    FXString       oldimgviewer;
    FXString       oldxterm;
    FXString       oldnormalfont;
    FXString       oldtextfont;
    FXString       oldimgeditor;
    FXString       oldarchiver;
    FXString       oldpdfviewer;
    FXString       oldaudioplayer;
    FXString       oldvideoplayer;
    FXString       oldmountcmd;
    FXString       oldumountcmd;
    FXCheckButton* autosave;
    FXCheckButton* savewinpos;
    FXCheckButton* diropen;
    FXCheckButton* fileopen;
    FXCheckButton* filetooltips;
    FXCheckButton* relativeresize;
    FXCheckButton* showpathlink;
    FXCheckButton* rootmode;
    FXCheckButton* trashcan;
    FXCheckButton* trashbypass;
    FXCheckButton* dnd;
    FXCheckButton* trashmv;
    FXCheckButton* del;
    FXCheckButton* properties;
    FXCheckButton* del_emptydir;
    FXCheckButton* overwrite;
    FXCheckButton* exec;
    FXCheckButton* ask;
    FXCheckButton* bg;
    FXCheckButton* folder_warning;
    FXCheckButton* preserve_date_warning;
    FXCheckButton* root_warning;
    FXCheckButton* mount;
    FXCheckButton* show_mount;
    FXCheckButton* scroll;
    FXCheckButton* controls;
    FXDataTarget   startdirtarget;
    int            startdirmode;
    int            oldstartdirmode;
#ifdef STARTUP_NOTIFICATION
    FXCheckButton* usesn;
#endif
    FXColorWell* cwell;
    Theme        Themes[NUM_THEMES];
    Theme        currTheme;
    Theme        currTheme_prev;
    FXbool       use_sudo;
    FXbool       use_sudo_prev;
    FXbool       trashcan_prev;
    FXbool       trashbypass_prev;
    FXbool       autosave_prev;
    FXbool       savewinpos_prev;
    FXbool       diropen_prev;
    FXbool       fileopen_prev;
    FXbool       filetooltips_prev;
    FXbool       relativeresize_prev;
    FXbool       show_pathlink;
    FXbool       show_pathlink_prev;
    FXuint       wheellines_prev;
    FXint        scrollbarsize_prev;
    FXbool       ask_prev;
    FXbool       dnd_prev;
    FXbool       trashmv_prev;
    FXbool       del_prev;
    FXbool       properties_prev;
    FXbool       del_emptydir_prev;
    FXbool       overwrite_prev;
    FXbool       exec_prev;
    FXbool       use_clearlooks;
    FXbool       use_clearlooks_prev;
    FXbool       rootmode_prev;
#ifdef STARTUP_NOTIFICATION
    FXbool usesn_prev;
#endif
#if defined(linux)
    FXbool mount_prev;
    FXbool show_mount_prev;
#endif
    FXbool          root_warning_prev;
    FXbool          folder_warning_prev;
    FXbool          preserve_date_warning_prev;
    FXuint          themelist_prev;
    FXbool          smoothscroll_prev;
    KeybindingsBox* bindingsbox;
    FXStringDict*   glbBindingsDict;
    FXStringDict*   xfeBindingsDict;
    FXStringDict*   xfiBindingsDict;
    FXStringDict*   xfwBindingsDict;

    PreferencesBox() : colorsBox(NULL), themesBox(NULL), themesList(NULL), iconpath(NULL), txtviewer(NULL), txteditor(NULL),
                       filecomparator(NULL), timeformat(NULL), imgviewer(NULL), xterm(NULL), imgeditor(NULL), archiver(NULL),
                       pdfviewer(NULL), videoplayer(NULL), audioplayer(NULL), normalfont(NULL), textfont(NULL), autosave(NULL), savewinpos(NULL),
                       diropen(NULL), fileopen(NULL), filetooltips(NULL), relativeresize(NULL), showpathlink(NULL), rootmode(NULL), trashcan(NULL),
                       trashbypass(NULL), dnd(NULL), trashmv(NULL), del(NULL), properties(NULL), del_emptydir(NULL),
                       overwrite(NULL), exec(NULL), ask(NULL), bg(NULL), folder_warning(NULL), preserve_date_warning(NULL),
                       root_warning(NULL), mount(NULL), show_mount(NULL), scroll(NULL), controls(NULL), startdirmode(0), oldstartdirmode(0),
#ifdef STARTUP_NOTIFICATION
                       usesn(NULL),
#endif
                       cwell(NULL), use_sudo(false), use_sudo_prev(false), trashcan_prev(false), trashbypass_prev(false),
                       autosave_prev(false), savewinpos_prev(false), diropen_prev(false), fileopen_prev(false),
                       filetooltips_prev(false), relativeresize_prev(false), show_pathlink(false), show_pathlink_prev(false),
                       wheellines_prev(0), scrollbarsize_prev(0), ask_prev(false), dnd_prev(false), trashmv_prev(false), del_prev(false), properties_prev(false),
                       del_emptydir_prev(false), overwrite_prev(false), exec_prev(false),
                       use_clearlooks(false), use_clearlooks_prev(false), rootmode_prev(false),
#ifdef STARTUP_NOTIFICATION
                       usesn_prev(false),
#endif
#if defined(linux)
                       mount_prev(false), show_mount_prev(false),
#endif
                       root_warning_prev(false), folder_warning_prev(false), preserve_date_warning_prev(false),
                       themelist_prev(0), smoothscroll_prev(false), bindingsbox(NULL), glbBindingsDict(NULL),
                       xfeBindingsDict(NULL), xfiBindingsDict(NULL), xfwBindingsDict(NULL)
    {}

public:
    enum
    {
        ID_ACCEPT=DialogBox::ID_LAST,
        ID_CANCEL,
        ID_BROWSE_TXTVIEW,
        ID_BROWSE_TXTEDIT,
        ID_BROWSE_FILECOMP,
        ID_BROWSE_IMGVIEW,
        ID_BROWSE_ARCHIVER,
        ID_BROWSE_PDFVIEW,
        ID_BROWSE_VIDEOPLAY,
        ID_BROWSE_AUDIOPLAY,
        ID_BROWSE_XTERM,
        ID_BROWSE_MOUNTCMD,
        ID_BROWSE_UMOUNTCMD,
        ID_COLOR,
        ID_NORMALFONT,
        ID_TEXTFONT,
        ID_THEME,
        ID_BROWSE_ICON_PATH,
        ID_TRASH_BYPASS,
        ID_CONFIRM_TRASH,
        ID_CONFIRM_DEL_EMPTYDIR,
        ID_SU_CMD,
        ID_SUDO_CMD,
        ID_STANDARD_CONTROLS,
        ID_CLEARLOOKS_CONTROLS,
        ID_WHEELADJUST,
        ID_SCROLLBARSIZE,
        ID_SINGLE_CLICK_FILEOPEN,
        ID_FILE_TOOLTIPS,
        ID_RELATIVE_RESIZE,
        ID_SHOW_PATHLINK,
        ID_CHANGE_KEYBINDINGS,
        ID_RESTORE_KEYBINDINGS,
        ID_START_HOMEDIR,
        ID_START_CURRENTDIR,
        ID_START_LASTDIR,
        ID_LAST
    };

public:
    PreferencesBox(FXWindow* win, FXColor listbackcolor = FXRGB(255, 255, 255), FXColor listforecolor = FXRGB(0, 0, 0), FXColor highlightcolor = FXRGB(238, 238, 238), FXColor pbarcolor = FXRGB(0, 0, 255), FXColor attentioncolor = FXRGB(255, 0, 0), FXColor scrollbackcolor = FXRGB(237, 233, 227));
    long   onCmdAccept(FXObject*, FXSelector, void*);
    long   onCmdBrowse(FXObject*, FXSelector, void*);
    long   onCmdColor(FXObject*, FXSelector, void*);
    long   onUpdColor(FXObject*, FXSelector, void*);
    long   onCmdTheme(FXObject*, FXSelector, void*);
    long   onCmdBrowsePath(FXObject*, FXSelector, void*);
    long   onCmdNormalFont(FXObject*, FXSelector, void*);
    long   onCmdTextFont(FXObject*, FXSelector, void*);
    long   onUpdTrash(FXObject*, FXSelector, void*);
    long   onUpdConfirmDelEmptyDir(FXObject*, FXSelector, void*);
    long   onCmdSuMode(FXObject*, FXSelector, void*);
    long   onUpdSuMode(FXObject*, FXSelector, void*);
    long   onCmdWheelAdjust(FXObject*, FXSelector, void*);
    long   onUpdWheelAdjust(FXObject*, FXSelector, void*);
    long   onCmdScrollBarSize(FXObject*, FXSelector, void*);
    long   onUpdScrollBarSize(FXObject*, FXSelector, void*);
    long   onUpdSingleClickFileopen(FXObject*, FXSelector, void*);
    FXuint execute(FXuint);
    long   onCmdCancel(FXObject*, FXSelector, void*);
    long   onCmdControls(FXObject*, FXSelector, void*);
    long   onUpdControls(FXObject*, FXSelector, void*);
    long   onCmdChangeKeyBindings(FXObject*, FXSelector, void*);
    long   onCmdRestoreKeyBindings(FXObject*, FXSelector, void*);
    long   onCmdStartDir(FXObject*, FXSelector, void*);
    long   onUpdStartDir(FXObject*, FXSelector, void*);
};
#endif
#ifndef PROPERTIES_H
#define PROPERTIES_H

#include "TextLabel.h"
#include "DialogBox.h"

class PropertiesBox;

class PermFrame : public FXVerticalFrame
{
    FXDECLARE(PermFrame)
    friend class PropertiesBox;
private:
    FXCheckButton* ur;
    FXCheckButton* uw;
    FXCheckButton* ux;
    FXCheckButton* gr;
    FXCheckButton* gw;
    FXCheckButton* gx;
    FXCheckButton* or_;
    FXCheckButton* ow;
    FXCheckButton* ox;
    FXCheckButton* suid;
    FXCheckButton* sgid;
    FXCheckButton* svtx;
    FXDataTarget   cmd_radiotarget;
    FXDataTarget   flt_radiotarget;
    FXRadioButton* set;
    FXRadioButton* clear;
    FXRadioButton* dironly;
    FXRadioButton* fileonly;
    FXRadioButton* all;
    FXRadioButton* add;
    int            cmd;
    int            flt;
    FXCheckButton* rec;
    FXCheckButton* own;
    FXComboBox*    user;
    FXComboBox*    grp;

    PermFrame() : ur(NULL), uw(NULL), ux(NULL), gr(NULL), gw(NULL), gx(NULL), or_(NULL), ow(NULL), ox(NULL), suid(NULL), sgid(NULL), svtx(NULL),
                  set(NULL), clear(NULL), dironly(NULL), fileonly(NULL), all(NULL), add(NULL), cmd(0), flt(0), rec(NULL), own(NULL), user(NULL), grp(NULL)
    {}

public:
    PermFrame(FXComposite* parent, FXObject* target);
};

class PropertiesBox : public DialogBox
{
    FXDECLARE(PropertiesBox)

private:
    int     pid;                     // Proccess ID of child (valid if busy).
    int     pipes[2];                // Pipes to communicate with child process.

	FXuint 	     totalnbfiles;
	FXuint       totalnbsubdirs;
	FXulong      totaldirsize;
	int          nbseldirs;
    FXLabel*     fileSize;
    FXLabel*     fileSizeDetails;
    TextLabel*   location;
    FXLabel*     origlocation;
    FXLabel*     linkto;
    FXLabel*     deletiondate;
    FXTextField* ext;
    FXString*    files;
    FXString*    paths;
    FXLabel*     name_encoding;
    FXString     source;
    FXString     parentdir;
    FXString     filename;
    FXString     oldusr;
    FXString     oldgrp;
    FXString     descr_prev;
    FXString     open_prev;
    FXString     view_prev;
    FXString     edit_prev;
    FXString     bigic_prev;
    FXString     miniic_prev;
    int          num;
    FXString     trashfileslocation;
    FXString     trashinfolocation;
    FXbool       executable;
#ifdef STARTUP_NOTIFICATION
    FXCheckButton* snbutton;
    FXGroupBox*    sngroup;
    FXbool         sndisable_prev;
#endif
    FXTextField* input;
    FXTextField* username;
    FXTextField* grpname;
    FXTextField* open;
    FXTextField* view;
    FXTextField* edit;
    FXTextField* descr;
    FXTextField* bigic;
    FXButton*    bigicbtn;
    FXTextField* miniic;
    FXButton*    miniicbtn;
    FXbool       isDirectory;
    FXbool       isMountpoint;
    FXbool       recsize;
    mode_t       mode;
    mode_t       orig_mode;
    PermFrame*   perm;

    PropertiesBox() : totalnbfiles(0), totalnbsubdirs(0), totaldirsize(0), nbseldirs(0), fileSize(NULL), fileSizeDetails(NULL), location(NULL), origlocation(NULL), linkto(NULL),
                      deletiondate(NULL), ext(NULL), files(NULL), paths(NULL), name_encoding(NULL), num(0), executable(false),
#ifdef STARTUP_NOTIFICATION
                      snbutton(NULL), sngroup(NULL), sndisable_prev(false),
#endif
                      input(NULL), username(NULL), grpname(NULL), open(NULL), view(NULL), edit(NULL), descr(NULL), bigic(NULL), bigicbtn(NULL),
                      miniic(NULL), miniicbtn(NULL), isDirectory(false), isMountpoint(false), recsize(false), mode(0), orig_mode(0), perm(NULL)
    {}

public:
    enum
    {
        ID_ACCEPT_SINGLE=DialogBox::ID_LAST,
        ID_ACCEPT_MULT,
        ID_CANCEL,
        ID_SET,
        ID_CLEAR,
        ID_ADD,
        ID_DIRONLY,
        ID_FILEONLY,
        ID_SNDISABLE,
        ID_WATCHPROCESS,
        ID_ALL,
        ID_BIG_ICON,
        ID_MINI_ICON,
        ID_BROWSE_OPEN,
        ID_BROWSE_VIEW,
        ID_BROWSE_EDIT,
        ID_RUSR,
        ID_WUSR,
        ID_XUSR,
        ID_RGRP,
        ID_WGRP,
        ID_XGRP,
        ID_ROTH,
        ID_WOTH,
        ID_XOTH,
        ID_SUID,
        ID_SGID,
        ID_SVTX,
        ID_LAST
    };

public:
    virtual void create();

    PropertiesBox(FXWindow* win, FXString file, FXString path);
    PropertiesBox(FXWindow* win, FXString* file, int num, FXString* path);
    long onCmdAcceptSingle(FXObject*, FXSelector, void*);
    long onCmdAcceptMult(FXObject*, FXSelector, void*);
    long onCmdCancel(FXObject*, FXSelector, void*);
    long onCmdCheck(FXObject*, FXSelector, void*);
    long onCmdCommand(FXObject*, FXSelector, void*);
    long onCmdFilter(FXObject*, FXSelector, void*);
    long onCmdBrowseIcon(FXObject*, FXSelector, void*);
    long onCmdBrowse(FXObject*, FXSelector, void*);
    long onUpdSizeAndPerm(FXObject*, FXSelector, void*);
    long onCmdKeyPress(FXObject*, FXSelector, void*);
    long onWatchProcess(FXObject*, FXSelector, void*);
#ifdef STARTUP_NOTIFICATION
    long onUpdSnDisable(FXObject*, FXSelector, void*);
#endif
};

#endif
#ifndef SEARCHPANEL_H
#define SEARCHPANEL_H

#include <map>

#include "HistInputDialog.h"
#include "BrowseInputDialog.h"



// Typedef for the map between program string identifiers and integer indexes
typedef std::map<FXString, int>   progsmap;


// Search panel
class FXAPI SearchPanel : public FXVerticalFrame
{
    FXDECLARE(SearchPanel)
protected:
    FileDict*          associations;
    FileList*          list;                // File list
    ArchInputDialog*   archdialog;
    HistInputDialog*   opendialog;
    BrowseInputDialog* operationdialogsingle;
    InputDialog*       operationdialogrename;
    BrowseInputDialog* operationdialogmultiple;
    BrowseInputDialog* comparedialog;
    FXString           searchdir;
    FXbool             ctrlflag;        // Flag to select the right click control menu
    FXbool             shiftf10;        // Flag indicating that Shift-F10 was pressed
    FXPacker*          statusbar;
    FXLabel*           status;
    FXDragCorner*      corner;
    FXString           trashfileslocation;
    FXString           trashinfolocation;
    FXDragType         urilistType;     // Standard uri-list type
    FXDragType         xfelistType;     // Xfe, Gnome and XFCE list type
    FXDragType         kdelistType;     // KDE list type
    FXDragType         utf8Type;        // UTF-8 text type
    FXButton*          refreshbtn;
    FXButton*          gotodirbtn;
    FXButton*          copybtn;
    FXButton*          cutbtn;
    FXButton*          propbtn;
    FXButton*          trashbtn;
    FXButton*          delbtn;
    FXButton*          bigiconsbtn;
    FXButton*          smalliconsbtn;
    FXButton*          detailsbtn;
    FXToggleButton*    thumbbtn;
    progsmap           progs;           // Map between program string identifiers and integer indexes
protected:
    SearchPanel() : associations(NULL), list(NULL), archdialog(NULL), opendialog(NULL), operationdialogsingle(NULL),
                    operationdialogrename(NULL), operationdialogmultiple(NULL), comparedialog(NULL),
                    ctrlflag(false), shiftf10(false), statusbar(NULL), status(NULL), corner(NULL), urilistType(0), xfelistType(0),
                    kdelistType(0), utf8Type(0), refreshbtn(NULL), gotodirbtn(NULL), copybtn(NULL), cutbtn(NULL), propbtn(NULL),
                    trashbtn(NULL), delbtn(NULL), bigiconsbtn(NULL), smalliconsbtn(NULL), detailsbtn(NULL), thumbbtn(NULL)
    {}
public:
    enum
    {
        ID_CANCEL=FXTopWindow::ID_LAST,
        ID_FILELIST,
        ID_STATUS,
        ID_POPUP_MENU,
        ID_VIEW,
        ID_EDIT,
        ID_COMPARE,
        ID_OPEN,
        ID_OPEN_WITH,
        ID_SELECT_ALL,
        ID_DESELECT_ALL,
        ID_SELECT_INVERSE,
        ID_EXTRACT,
        ID_ADD_TO_ARCH,
        ID_DIR_USAGE,
#if defined(linux)
        ID_PKG_QUERY,
        ID_PKG_INSTALL,
        ID_PKG_UNINSTALL,
#endif
        ID_REFRESH,
        ID_PROPERTIES,
        ID_COPY_CLIPBOARD,
        ID_CUT_CLIPBOARD,
        ID_GO_SCRIPTDIR,
        ID_GOTO_PARENTDIR,
        ID_FILE_COPYTO,
        ID_FILE_MOVETO,
        ID_FILE_RENAME,
        ID_FILE_SYMLINK,
        ID_FILE_DELETE,
        ID_FILE_TRASH,
        ID_LAST
    };
    SearchPanel(FXComposite*, FXuint name_size = 200, FXuint dir_size = 150, FXuint size_size = 60, FXuint type_size = 100, FXuint ext_size = 100,
                FXuint modd_size = 150, FXuint user_size = 50, FXuint grou_size = 50, FXuint attr_size = 100,
                FXColor listbackcolor = FXRGB(255, 255, 255), FXColor listforecolor = FXRGB(0, 0, 0),
                FXuint opts = 0, int x = 0, int y = 0, int w = 0, int h = 0);

    virtual void create();

    virtual ~SearchPanel();
    void execFile(FXString);
    int  readScriptDir(FXMenuPane*, FXString);
    long appendItem(FXString&);

    long onClipboardGained(FXObject*, FXSelector, void*);
    long onClipboardLost(FXObject*, FXSelector, void*);
    long onClipboardRequest(FXObject*, FXSelector, void*);
    long onKeyPress(FXObject*, FXSelector, void*);
    long onCmdItemDoubleClicked(FXObject*, FXSelector, void*);
    long onCmdItemClicked(FXObject*, FXSelector, void*);
    long onCmdSelect(FXObject*, FXSelector, void*);
    long onCmdGotoParentdir(FXObject*, FXSelector, void*);
    long onCmdOpenWith(FXObject*, FXSelector, void*);
    long onCmdOpen(FXObject*, FXSelector, void*);
    long onCmdEdit(FXObject*, FXSelector, void*);
    long onCmdCompare(FXObject*, FXSelector, void*);
    long onCmdRefresh(FXObject*, FXSelector, void*);
    long onCmdProperties(FXObject* sender, FXSelector, void*);
    long onCmdPopupMenu(FXObject*, FXSelector, void*);
    long onCmdCopyCut(FXObject*, FXSelector, void*);
    long onCmdFileMan(FXObject*, FXSelector, void*);
    long onCmdAddToArch(FXObject*, FXSelector, void*);
    long onCmdExtract(FXObject*, FXSelector, void*);
    long onCmdFileTrash(FXObject*, FXSelector, void*);
    long onCmdFileDelete(FXObject*, FXSelector, void*);
    long onCmdGoScriptDir(FXObject*, FXSelector, void*);
    long onCmdDirUsage(FXObject*, FXSelector, void*);
    long onUpdStatus(FXObject*, FXSelector, void*);
    long onUpdSelMult(FXObject*, FXSelector, void*);
    long onUpdCompare(FXObject*, FXSelector, void*);
    long onUpdMenu(FXObject*, FXSelector, void*);
    long onUpdDirUsage(FXObject*, FXSelector, void*);
#if defined(linux)
    long onCmdPkgQuery(FXObject*, FXSelector, void*);
    long onUpdPkgQuery(FXObject*, FXSelector, void*);
#endif
public:
    // Get header size given its index
    int getHeaderSize(int index) const
    {
        return(list->getHeaderSize(index));
    }

    // Change show thumbnails mode
    void showThumbnails(FXbool display)
    {
        list->showThumbnails(display);
    }

    // Thumbnails shown?
    FXbool shownThumbnails(void) const
    {
        return(list->shownThumbnails());
    }

    // Enable toolbar and status bar buttons
    void enableButtons(void)
    {
        refreshbtn->enable();
        gotodirbtn->enable();
        bigiconsbtn->enable();
        smalliconsbtn->enable();
        detailsbtn->enable();
        thumbbtn->enable();
    }

    // Disable toolbar and status bar buttons
    void disableButtons(void)
    {
        refreshbtn->disable();
        gotodirbtn->disable();
        bigiconsbtn->disable();
        smalliconsbtn->disable();
        detailsbtn->disable();
        thumbbtn->disable();
    }

    // Change sort function
    void setSortFunc(IconListSortFunc func)
    {
        list->setSortFunc(func);
    }

    // Return sort function
    IconListSortFunc getSortFunc() const
    {
        return(list->getSortFunc());
    }

    // Set ignore case
    void setIgnoreCase(FXbool ignorecase)
    {
        list->setIgnoreCase(ignorecase);
    }

    // Get ignore case
    FXbool getIgnoreCase(void)
    {
        return(list->getIgnoreCase());
    }

    // Set directory first
    void setDirsFirst(FXbool dirsfirst)
    {
        list->setDirsFirst(dirsfirst);
    }

    // Set directory first
    FXbool getDirsFirst(void)
    {
        return(list->getDirsFirst());
    }

    // Get the current icon list style
    FXuint getListStyle(void) const
    {
        return(list->getListStyle());
    }

    // Get the current icon list style
    void setListStyle(FXuint style)
    {
        list->setListStyle(style);
    }

    // Return number of items
    int getNumItems() const
    {
        return(list->getNumItems());
    }

    // Get current item
    int getCurrentItem(void) const
    {
        return(list->getCurrentItem());
    }

    // Set current item
    void setCurrentItem(int item)
    {
        list->setCurrentItem(item);
        list->makeItemVisible(item);
    }

    // Set status text
    void setStatusText(FXString text)
    {
        status->setText(text);
    }

    // Clear list items and reset panel status
    void clearItems(void);

    // Set search path
    void setSearchPath(FXString);

    // Toggle file list refresh
    void setAllowRefresh(FXbool flag)
    {
        list->setAllowRefresh(flag);
    }

    // Refresh file list
    void forceRefresh(void)
    {
        list->onCmdRefresh(0, 0, 0);
    }

	// Deselect all items
	void deselectAll(void)
	{
		list->onCmdDeselectAll(0,0,0);
	}
};

#endif
#ifndef SEARCHWINDOW_H
#define SEARCHWINDOW_H

#include "SearchPanel.h"

// Search window
class FXAPI SearchWindow : public FXTopWindow
{
    FXDECLARE(SearchWindow)
public:
    enum
    {
        ID_CANCEL=FXTopWindow::ID_LAST,
        ID_START,
        ID_STOP,
        ID_BROWSE_PATH,
        ID_READ_DATA,
        ID_CLOSE,
        ID_MORE_OPTIONS,
        ID_SIZE,
        ID_PERM,
        ID_RESET_OPTIONS,
        ID_LAST
    };
    SearchWindow(FXApp* app, const FXString& name, FXuint opts = DECOR_TITLE|DECOR_BORDER,
                 int x = 0, int y = 0, int w = 0, int h = 0, int pl = 10, int pr = 10, int pt = 10, int pb = 10, int hs = 4, int vs = 4);
    virtual void show(FXuint placement = PLACEMENT_CURSOR);
    virtual void create();

    virtual ~SearchWindow();
protected:
    FXApp*           application;
    FXLabel*         searchresults;
    FXTextField*     findfile;
    FXTextField*     wheredir;
    FXTextField*     greptext;
    FXButton*        dirbutton;
    FXButton*        startbutton;
    FXButton*        stopbutton;
    SearchPanel*     searchpanel;
    TextWindow*      warnwindow;
    int              in[2];              // Input and output pipes
    int              out[2];
    int              pid;                // Proccess ID of child (valid if busy).
    FXuint           count;
    FXbool           running;
    FXString         strprev;
    FXString         searchcommand;
    FXString         uid;
    FXString         gid;
    FXGroupBox*      moregroup;
    FXVerticalFrame* searchframe;
    FXCheckButton*   grepigncase;
    FXCheckButton*   findigncase;
    FXCheckButton*   findhidden;
    FXCheckButton*   moreoptions;
    FXSpinner*       minsize;
    FXSpinner*       maxsize;
    FXSpinner*       mindays;
    FXSpinner*       maxdays;
    FXComboBox*      user;
    FXComboBox*      grp;
    FXComboBox*      type;
    FXTextField*     perm;
    FXCheckButton*   userbtn;
    FXCheckButton*   grpbtn;
    FXCheckButton*   typebtn;
    FXCheckButton*   permbtn;
    FXCheckButton*   emptybtn;
    FXCheckButton*   linkbtn;
    FXCheckButton*   norecbtn;
    FXCheckButton*   nofsbtn;
    FXButton*        resetoptions;

    SearchWindow() : application(NULL), searchresults(NULL), findfile(NULL), wheredir(NULL), greptext(NULL), dirbutton(NULL),
                     startbutton(NULL), stopbutton(NULL), searchpanel(NULL), warnwindow(NULL),
                     pid(0), count(0), running(false), moregroup(NULL), searchframe(NULL), grepigncase(NULL), findigncase(NULL),
                     findhidden(NULL), moreoptions(NULL), minsize(NULL), maxsize(NULL), mindays(NULL), maxdays(NULL), user(NULL),
                     grp(NULL), type(NULL), perm(NULL), userbtn(NULL), grpbtn(NULL), typebtn(NULL), permbtn(NULL), emptybtn(NULL),
                     linkbtn(NULL), norecbtn(NULL), nofsbtn(NULL), resetoptions(NULL)
    {}

    SearchWindow(const SearchWindow&)
    {}
public:
    FXuint execute(FXuint placement = PLACEMENT_CURSOR);

    int execCmd(FXString);
    int readData();

    long onKeyPress(FXObject*, FXSelector, void*);
    long onCmdClose(FXObject*, FXSelector, void*);
    long onCmdStart(FXObject*, FXSelector, void*);
    long onCmdBrowsePath(FXObject*, FXSelector, void*);
    long onReadData(FXObject*, FXSelector, void*);
    long onCmdStop(FXObject*, FXSelector, void*);
    long onPermVerify(FXObject*, FXSelector, void*);
    long onCmdMoreOptions(FXObject*, FXSelector, void*);
    long onCmdResetOptions(FXObject*, FXSelector, void*);
    long onUpdStart(FXObject*, FXSelector, void*);
    long onUpdStop(FXObject*, FXSelector, void*);
    long onUpdPerm(FXObject*, FXSelector, void*);
    long onUpdSize(FXObject*, FXSelector, void*);
public:
    // Change sort function
    void setSortFunc(IconListSortFunc func)
    {
        searchpanel->setSortFunc(func);
    }

    // Return sort function
    IconListSortFunc getSortFunc() const
    {
        return(searchpanel->getSortFunc());
    }

    // More option dialog shown ?
    FXbool shownMoreOptions(void) const
    {
        return(moreoptions->getCheck());
    }

    // Get ignore case in find
    FXbool getFindIgnoreCase(void) const
    {
        return(findigncase->getCheck());
    }

    // Set hidden files in find
    void setFindHidden(FXbool hidden)
    {
        findhidden->setCheck(hidden);
    }

    // Get hidden files in find
    FXbool getFindHidden(void) const
    {
        return(findhidden->getCheck());
    }

    // Set ignore case in find
    void setFindIgnoreCase(FXbool ignorecase)
    {
        findigncase->setCheck(ignorecase);
    }

    // Get ignore case in grep
    FXbool getGrepIgnoreCase(void) const
    {
        return(grepigncase->getCheck());
    }

    // Set ignore case in grep
    void setGrepIgnoreCase(FXbool ignorecase)
    {
        grepigncase->setCheck(ignorecase);
    }

    // Set ignore case
    void setIgnoreCase(FXbool ignorecase)
    {
        searchpanel->setIgnoreCase(ignorecase);
    }

    // Get ignore case
    FXbool getIgnoreCase(void)
    {
        return(searchpanel->getIgnoreCase());
    }

    // Set directory first
    void setDirsFirst(FXbool dirsfirst)
    {
        searchpanel->setDirsFirst(dirsfirst);
    }

    // Set directory first
    FXbool getDirsFirst(void)
    {
        return(searchpanel->getDirsFirst());
    }

    // Get the current icon list style
    FXuint getListStyle(void) const
    {
        return(searchpanel->getListStyle());
    }

    // Get the current icon list style
    void setListStyle(FXuint style)
    {
        searchpanel->setListStyle(style);
    }

    // Thumbnails shown?
    FXbool shownThumbnails(void) const
    {
        return(searchpanel->shownThumbnails());
    }

    // Show thumbnails
    void showThumbnails(FXbool shown)
    {
        searchpanel->showThumbnails(shown);
    }

    // Get header size given its index
    int getHeaderSize(int index) const
    {
        return(searchpanel->getHeaderSize(index));
    }

    // Set search directory
    void setSearchPath(const FXString dir)
    {
        wheredir->setText(dir);
    }
	
	// Deselect all items
	void deselectAll(void)
	{
		searchpanel->deselectAll();
	}
};

#endif
#ifndef STRINGLIST_H
#define STRINGLIST_H


// StringList class : implements a doubly linked list of FXString


class StringItem
{
    friend class StringList;
protected:
    FXString    str;           // FXString stored in the item
    StringItem* next;          // Pointer to next item
    StringItem* prev;          // Pointer to previous item
};

class StringList
{
public:
    StringItem* first;         // Pointer to begin of list
    StringItem* last;          // Pointer to end of list

    StringList()
    {
        first = NULL;
        last = NULL;
    }

    // Get first item
    StringItem* getFirst(void)
    {
        return(this->first);
    }

    // Get last item
    StringItem* getLast(void)
    {
        return(this->last);
    }

    // Get previous item
    StringItem* getPrev(StringItem* item)
    {
        return(item->prev);
    }

    // Get next item
    StringItem* getNext(StringItem* item)
    {
        return(item->next);
    }

    // Get string from item
    FXString getString(StringItem* item)
    {
        return(item->str);
    }

    void insertFirstItem(FXString);
    void insertLastItem(FXString);
    void removeFirstItem();
    void removeLastItem();

    void insertBeforeItem(FXString, StringItem*);
    void insertAfterItem(FXString, StringItem*);
    void removeBeforeItem(StringItem*);
    void removeAfterItem(StringItem*);
    void removeItem(StringItem*);
    int getNumItems(void);
    void removeAllItemsBefore(StringItem*);
    void removeAllItemsAfter(StringItem*);
    void removeAllItems(void);
    StringItem* getItemAtPos(const int);
    void printFromFirst();
    void printFromLast();
};

#endif
#ifndef TEXTLABEL_H
#define TEXTLABEL_H


class FXAPI TextLabel : public FXFrame
{
    FXDECLARE(TextLabel)
protected:
    FXString    contents;       // Edited text
    const char* delimiters;     // Set of delimiters
    FXFont*     font;           // Text font
    FXColor     textColor;      // Text color
    FXColor     selbackColor;   // Selected background color
    FXColor     seltextColor;   // Selected text color
    FXColor     cursorColor;    // Color of the Cursor
    int         cursor;         // Cursor position
    int         anchor;         // Anchor position
    int         columns;        // Number of columns visible
    int         shift;          // Shift amount
    FXString    clipped;        // Clipped text
protected:
    TextLabel() : delimiters(NULL), font(NULL), textColor(FXRGB(0, 0, 0)), selbackColor(FXRGB(0, 0, 0)), seltextColor(FXRGB(0, 0, 0)),
                  cursorColor(FXRGB(0, 0, 0)), cursor(0), anchor(0), columns(0), shift(0)
    {}
    int index(int x) const;
    int coord(int i) const;
    void drawTextRange(FXDCWindow& dc, int fm, int to);
    void drawTextFragment(FXDCWindow& dc, int x, int y, int fm, int to);
    int rightWord(int pos) const;
    int leftWord(int pos) const;
    int wordStart(int pos) const;
    int wordEnd(int pos) const;

private:
    TextLabel(const TextLabel&);
    TextLabel& operator=(const TextLabel&);

public:
    long onPaint(FXObject*, FXSelector, void*);
    long onUpdate(FXObject*, FXSelector, void*);
    long onKeyPress(FXObject*, FXSelector, void*);
    long onKeyRelease(FXObject*, FXSelector, void*);
    long onLeftBtnPress(FXObject*, FXSelector, void*);
    long onLeftBtnRelease(FXObject*, FXSelector, void*);
    long onMotion(FXObject*, FXSelector, void*);
    long onSelectionLost(FXObject*, FXSelector, void*);
    long onSelectionGained(FXObject*, FXSelector, void*);
    long onSelectionRequest(FXObject*, FXSelector, void* ptr);
    long onClipboardLost(FXObject*, FXSelector, void*);
    long onClipboardGained(FXObject*, FXSelector, void*);
    long onClipboardRequest(FXObject*, FXSelector, void*);
    long onFocusSelf(FXObject*, FXSelector, void*);
    long onFocusIn(FXObject*, FXSelector, void*);
    long onFocusOut(FXObject*, FXSelector, void*);
    long onAutoScroll(FXObject*, FXSelector, void*);
    long onCmdCursorHome(FXObject*, FXSelector, void*);
    long onCmdCursorEnd(FXObject*, FXSelector, void*);
    long onCmdCursorRight(FXObject*, FXSelector, void*);
    long onCmdCursorLeft(FXObject*, FXSelector, void*);
    long onCmdCursorWordLeft(FXObject*, FXSelector, void*);
    long onCmdCursorWordRight(FXObject*, FXSelector, void*);
    long onCmdCursorWordStart(FXObject*, FXSelector, void*);
    long onCmdCursorWordEnd(FXObject*, FXSelector, void*);
    long onCmdMark(FXObject*, FXSelector, void*);
    long onCmdExtend(FXObject*, FXSelector, void*);
    long onCmdselectAll(FXObject*, FXSelector, void*);
    long onCmdDeselectAll(FXObject*, FXSelector, void*);
    long onCmdCopySel(FXObject*, FXSelector, void*);
    long onUpdHaveSelection(FXObject*, FXSelector, void*);
    long onUpdselectAll(FXObject*, FXSelector, void*);
public:

    // Default text delimiters
    static const char textDelimiters[];

public:

    enum
    {
        ID_CURSOR_HOME=FXFrame::ID_LAST,
        ID_CURSOR_END,
        ID_CURSOR_RIGHT,
        ID_CURSOR_LEFT,
        ID_CURSOR_WORD_LEFT,
        ID_CURSOR_WORD_RIGHT,
        ID_CURSOR_WORD_START,
        ID_CURSOR_WORD_END,
        ID_MARK,
        ID_EXTEND,
        ID_SELECT_ALL,
        ID_DESELECT_ALL,
        ID_COPY_SEL,
        ID_LAST
    };

public:

    // Construct text field wide enough to display ncols columns
    TextLabel(FXComposite* p, int ncols, FXObject* tgt = NULL, FXSelector sel = 0, FXuint opts = TEXTFIELD_NORMAL, int x = 0, int y = 0, int w = 0, int h = 0, int pl = DEFAULT_PAD, int pr = DEFAULT_PAD, int pt = DEFAULT_PAD, int pb = DEFAULT_PAD);

    // Create server-side resources
    virtual void create();

    // Perform layout
    virtual void layout();

    // Enable text field
    virtual void enable();

    // Disable text field
    virtual void disable();

    // Return default width
    virtual int getDefaultWidth();

    // Return default height
    virtual int getDefaultHeight();

    // Yes, text field may receive focus
    virtual bool canFocus() const;

    // Move the focus to this window
    virtual void setFocus();

    // Remove the focus from this window
    virtual void killFocus();

    // Set cursor position
    void setCursorPos(int pos);

    // Return cursor position
    int getCursorPos() const
    {
        return(cursor);
    }

    // Change anchor position
    void setAnchorPos(int pos);

    // Return anchor position
    int getAnchorPos() const
    {
        return(anchor);
    }

    // Change the text and move cursor to end
    void setText(const FXString& text, FXbool notify = false);

    // Get the text for this label
    FXString getText() const
    {
        return(contents);
    }

    // Set the text font
    void setFont(FXFont* fnt);

    // Get the text font
    FXFont* getFont() const
    {
        return(font);
    }

    // Change text color
    void setTextColor(FXColor clr);

    // Return text color
    FXColor getTextColor() const
    {
        return(textColor);
    }

    // Change selected background color
    void setSelBackColor(FXColor clr);

    // Return selected background color
    FXColor getSelBackColor() const
    {
        return(selbackColor);
    }

    // Change selected text color
    void setSelTextColor(FXColor clr);

    // Return selected text color
    FXColor getSelTextColor() const
    {
        return(seltextColor);
    }

    // Changes the cursor color
    void setCursorColor(FXColor clr);

    // Return the cursor color
    FXColor getCursorColor() const
    {
        return(cursorColor);
    }

    /*
     * Change the default width of the text field in terms of a number
     * of columns times the width of the numeral '8'.
     */
    void setNumColumns(int cols);

    // Return number of columns
    int getNumColumns() const
    {
        return(columns);
    }

    /*
     * Change text justification mode. The justify mode is a combination of
     * horizontal justification (JUSTIFY_LEFT, JUSTIFY_RIGHT, or JUSTIFY_CENTER_X),
     * and vertical justification (JUSTIFY_TOP, JUSTIFY_BOTTOM, JUSTIFY_CENTER_Y).
     * Note that JUSTIFY_CENTER_X can not be set from the constructor since by
     * default text fields are left-justified.
     */
    void setJustify(FXuint mode);

    // Return text justification mode
    FXuint getJustify() const;

    // Change word delimiters
    void setDelimiters(const char* delims = textDelimiters)
    {
        delimiters = delims;
    }

    // Return word delimiters
    const char* getDelimiters() const
    {
        return(delimiters);
    }

    // Select all text
    FXbool selectAll();

    // Select len characters starting at given position pos
    FXbool setSelection(int pos, int len);

    // Extend the selection from the anchor to the given position
    FXbool extendSelection(int pos);

    // Unselect the text
    FXbool killSelection();

    // Return true if position pos is selected
    FXbool isPosSelected(int pos) const;

    // Return true if position is fully visible
    FXbool isPosVisible(int pos) const;

    // Scroll text to make the given position visible
    void makePositionVisible(int pos);

    // Destructor
    virtual ~TextLabel();
};

#endif
#ifndef TEXTWINDOW_H
#define TEXTWINDOW_H

#include "DialogBox.h"

class TextWindow : public DialogBox
{
    FXDECLARE(TextWindow)
protected:
    FXText* text;
private:
    TextWindow() : text(NULL)
    {}
    TextWindow(const TextWindow&);
public:
    enum
    {
        ID_CLOSE=DialogBox::ID_LAST,
        ID_LAST
    };
public:
    TextWindow(FXWindow* owner, const FXString& name, int nblines, int nbcols);
    TextWindow(FXApp* app, const FXString& name, int nblines, int nbcols);
    virtual ~TextWindow();
    void setText(const char*);
    void appendText(const char*);
    void scrollToLastLine(void);
    void setFont(FXFont*);
    int getLength(void);
};

#endif
#ifndef WRITEWINDOW_H
#define WRITEWINDOW_H

#include "InputDialog.h"


class WriteWindow;
class XFileWrite;

// Undo record for text fragment
class FXTextCommand : public FXCommand
{
    FXDECLARE_ABSTRACT(FXTextCommand)
protected:
    FXText* text;   // Text widget
    char*   buffer; // Character buffer
    int     pos;    // Character position
    int     ndel;   // Deleted characters
    int     nins;   // Inserted characters
public:
    FXTextCommand(FXText* txt, int p, int nd, int ni) : text(txt), buffer(NULL), pos(p), ndel(nd), nins(ni)
    {}
    virtual FXuint size() const;

    virtual ~FXTextCommand()
    {
        FXFREE(&buffer);
    }
};


// Insert command
class FXTextInsert : public FXTextCommand
{
    FXDECLARE_ABSTRACT(FXTextInsert)
public:
    FXTextInsert(FXText* txt, int p, int ni, const char* ins);
    virtual FXString undoName() const
    {
        return("Undo insert");
    }

    virtual FXString redoName() const
    {
        return("Redo insert");
    }

    virtual void undo();
    virtual void redo();
};


// Delete command
class FXTextDelete : public FXTextCommand
{
    FXDECLARE_ABSTRACT(FXTextDelete)
public:
    FXTextDelete(FXText* txt, int p, int nd, const char* del);
    virtual FXString undoName() const
    {
        return("Undo delete");
    }

    virtual FXString redoName() const
    {
        return("Redo delete");
    }

    virtual void undo();
    virtual void redo();
};


// Replace command
class FXTextReplace : public FXTextCommand
{
    FXDECLARE_ABSTRACT(FXTextReplace)
public:
    FXTextReplace(FXText* txt, int p, int nd, int ni, const char* del, const char* ins);
    virtual FXString undoName() const
    {
        return("Undo replace");
    }

    virtual FXString redoName() const
    {
        return("Redo replace");
    }

    virtual void undo();
    virtual void redo();
};


class Preferences : public DialogBox
{
    FXDECLARE(Preferences)
protected:
    FXTextField*   wrapmargin;
    FXString       wrapmargin_prev;
    FXTextField*   tabsize;
    FXString       tabsize_prev;
    FXCheckButton* stripcr;
    FXbool         stripcr_prev;
    FXText*        editor;
    WriteWindow*   editwin;
    FXColor        textcolor_prev;
    FXColor        backcolor_prev;
    FXColor        seltextcolor_prev;
    FXColor        selbackcolor_prev;
    FXColor        hilitetextcolor_prev;
    FXColor        hilitebackcolor_prev;
    FXColor        cursorcolor_prev;
    FXColor        barcolor_prev;
    FXColor        numbercolor_prev;
private:
    Preferences() : wrapmargin(NULL), tabsize(NULL), stripcr(NULL), stripcr_prev(false), editor(NULL), editwin(NULL),
                    textcolor_prev(FXRGB(0, 0, 0)), backcolor_prev(FXRGB(0, 0, 0)), seltextcolor_prev(FXRGB(0, 0, 0)), selbackcolor_prev(FXRGB(0, 0, 0)),
                    hilitetextcolor_prev(FXRGB(0, 0, 0)), hilitebackcolor_prev(FXRGB(0, 0, 0)), cursorcolor_prev(FXRGB(0, 0, 0)), barcolor_prev(FXRGB(0, 0, 0)),
                    numbercolor_prev(FXRGB(0, 0, 0))
    {}
    Preferences(const Preferences&);
    Preferences& operator=(const Preferences&);

public:
    enum
    {
        ID_ACCEPT=DialogBox::ID_LAST,
        ID_CANCEL,
        ID_TEXT_BACK,
        ID_TEXT_FORE,
        ID_TEXT_SELBACK,
        ID_TEXT_SELFORE,
        ID_TEXT_HILITEBACK,
        ID_TEXT_HILITEFORE,
        ID_TEXT_CURSOR,
        ID_TEXT_NUMBACK,
        ID_TEXT_NUMFORE,
        ID_LAST
    };
public:

    // Create preferences dialog
    Preferences(WriteWindow* owner);

    // Owner is text window
    XFileWrite* getApp() const
    {
        return((XFileWrite*)DialogBox::getApp());
    }

    FXuint execute(FXuint);
    long   onCmdCancel(FXObject*, FXSelector, void*);
    long   onCmdAccept(FXObject*, FXSelector, void*);
    long   onCmdTextBackColor(FXObject*, FXSelector, void*);
    long   onUpdTextBackColor(FXObject*, FXSelector, void*);
    long   onCmdTextForeColor(FXObject*, FXSelector, void*);
    long   onUpdTextForeColor(FXObject*, FXSelector, void*);
    long   onCmdTextSelBackColor(FXObject*, FXSelector, void*);
    long   onUpdTextSelBackColor(FXObject*, FXSelector, void*);
    long   onCmdTextSelForeColor(FXObject*, FXSelector, void*);
    long   onUpdTextSelForeColor(FXObject*, FXSelector, void*);
    long   onCmdTextHiliteBackColor(FXObject*, FXSelector, void*);
    long   onUpdTextHiliteBackColor(FXObject*, FXSelector, void*);
    long   onCmdTextHiliteForeColor(FXObject*, FXSelector, void*);
    long   onUpdTextHiliteForeColor(FXObject*, FXSelector, void*);
    long   onCmdTextCursorColor(FXObject*, FXSelector, void*);
    long   onUpdTextCursorColor(FXObject*, FXSelector, void*);
    long   onCmdTextBarColor(FXObject*, FXSelector, void*);
    long   onUpdTextBarColor(FXObject*, FXSelector, void*);
    long   onCmdTextNumberColor(FXObject*, FXSelector, void*);
    long   onUpdTextNumberColor(FXObject*, FXSelector, void*);
};

// Editor main window
class WriteWindow : public FXMainWindow
{
    FXDECLARE(WriteWindow)
protected:
    FXToolBarShell*    dragshell;                 // Shell for floating toolbar
    FXMenuPane*        filemenu;                  // File menu
    FXMenuPane*        editmenu;                  // Edit menu
    FXMenuPane*        searchmenu;                // Search menu
    FXMenuPane*        prefsmenu;                 // Preferences menu
    FXMenuPane*        viewmenu;                  // View menu
    FXMenuPane*        windowmenu;                // Window menu
    FXMenuPane*        helpmenu;                  // Help menu
    FXMenuPane*        popupmenu;                 // Popup menu
    FXHorizontalFrame* undoredoblock;             // Undo/redo block on status line
    FXText*            editor;                    // Multiline text widget
    FXMenuBar*         menubar;                   // Menu bar
    FXToolBar*         toolbar;                   // Tool bar
    FXStatusBar*       statusbar;                 // Status bar
    FXHorizontalFrame* statusbarcont;             // Status bar
    FXHorizontalFrame* statusbar2;                // Status bar
    FXFont*            font;                      // Text window font
    FXUndoList         undolist;                  // Undo list
    FXRecentFiles      mrufiles;                  // Recent files list
    FXString           filename;                  // File being edited
    FXTime             filetime;                  // Original modtime of file
    FXbool             filenameset;               // Filename is set
    FXString           searchpath;                // To search for files
    FXbool             stripcr;                   // Strip carriage returns
    FXbool             linesnum;                  // Lines numbering
    FXbool             readonly;                  // Text is read only
    InputDialog*       printdialog;
    Preferences*       prefsdialog;
    FXSearchDialog*    searchdialog;
    FXReplaceDialog*   replacedialog;
    FXbool             smoothscroll;
    FXbool             fromreg;             // Read window size and position from the regsitry
    FXuint             ww;                  // Window width
    FXuint             hh;                  // Window height
    FXuint             xx;                  // Window x position
    FXuint             yy;                  // Window y position
    FXButton*          cut;                 // Cut button
    FXButton*          paste;               // Paste button
    FXMenuCommand*     cutmc;               // Cut menu item
    FXMenuCommand*     pastemc;             // Paste menu item
    FXLabel*           wraplbl;

protected:
    void loadConfig();
    void saveConfig();
    FXString unique() const;
    WriteWindow* findUnused() const;
    WriteWindow* findWindow(const FXString& file) const;
    int backwardByContext(int pos) const;
    int forwardByContext(int pos) const;

protected:
    enum
    {
        MAXUNDOSIZE    = 1000000,               // Don't let the undo buffer get out of hand
        KEEPUNDOSIZE   = 500000                 // When MAXUNDOSIZE was exceeded, trim down to this size
    };
private:
    WriteWindow() : dragshell(NULL), filemenu(NULL), editmenu(NULL), searchmenu(NULL), prefsmenu(NULL), viewmenu(NULL), windowmenu(NULL), helpmenu(NULL),
                    popupmenu(NULL), undoredoblock(NULL), editor(NULL), menubar(NULL), toolbar(NULL), statusbar(NULL), font(NULL),
                    filetime(0), filenameset(false), stripcr(false), linesnum(false), readonly(false), printdialog(NULL),
                    prefsdialog(NULL), searchdialog(NULL), replacedialog(NULL), smoothscroll(false), fromreg(false),
                    ww(0), hh(0), xx(0), yy(0), cut(NULL), paste(NULL), cutmc(NULL), pastemc(NULL)
    {}
    WriteWindow(const WriteWindow&);
    WriteWindow& operator=(const WriteWindow&);

public:
    long onUpdateTitle(FXObject*, FXSelector, void*);
    long onFocusIn(FXObject*, FXSelector, void*);
    long onCmdAbout(FXObject*, FXSelector, void*);
    long onSigHarvest(FXObject*, FXSelector, void*);

    // File management
    long onCmdNew(FXObject*, FXSelector, void*);
    long onCmdOpen(FXObject*, FXSelector, void*);
    long onCmdOpenRecent(FXObject*, FXSelector, void*);
    long onCmdOpenSelected(FXObject*, FXSelector, void*);
    long onCmdSave(FXObject*, FXSelector, void*);
    long onUpdSave(FXObject*, FXSelector, void*);
    long onCmdSaveAs(FXObject*, FXSelector, void*);
    long onCmdFont(FXObject*, FXSelector, void*);
    long onCmdPrint(FXObject*, FXSelector, void*);
    long onUpdReadOnly(FXObject*, FXSelector, void*);

    // Text display
    long onCmdLineNumbers(FXObject*, FXSelector, void*);
    long onUpdLineNumbers(FXObject*, FXSelector, void*);
    long onCmdWrap(FXObject*, FXSelector, void*);
    long onUpdWrap(FXObject*, FXSelector, void*);
    long onCmdLinesNum(FXObject*, FXSelector, void*);
    long onUpdLinesNum(FXObject*, FXSelector, void*);

    // Text changes
    long onTextInserted(FXObject*, FXSelector, void*);
    long onTextReplaced(FXObject*, FXSelector, void*);
    long onTextDeleted(FXObject*, FXSelector, void*);
    long onTextRightMouse(FXObject*, FXSelector, void*);
    long onTextChanged(FXObject*, FXSelector, void*);
    long onEditDNDMotion(FXObject*, FXSelector, void*);
    long onEditDNDDrop(FXObject*, FXSelector, void*);

    // Miscellaneous
    long onUpdOverstrike(FXObject*, FXSelector, void*);
    long onUpdNumRows(FXObject*, FXSelector, void*);
    long onCmdMorePrefs(FXObject*, FXSelector, void*);
    long onCmdWindow(FXObject*, FXSelector, void*);
    long onUpdWindow(FXObject*, FXSelector, void*);
    long onCmdSearch(FXObject*, FXSelector, void*);
    long onCmdReplace(FXObject*, FXSelector, void*);
    long onCmdSearchSel(FXObject*, FXSelector, void*);
    long onCmdGotoLine(FXObject*, FXSelector, void*);
    long onCmdRow(FXObject*, FXSelector, void*);

public:
    enum
    {
        ID_ABOUT=FXMainWindow::ID_LAST,
        ID_NEW,
        ID_OPEN,
        ID_OPEN_TREE,
        ID_OPEN_SELECTED,
        ID_OPEN_RECENT,
        ID_HARVEST,
        ID_SAVE,
        ID_SAVEAS,
        ID_FONT,
        ID_WINDOW,
        ID_PRINT,
        ID_TEXT_LINENUMS,
        ID_SEARCH,
        ID_REPLACE,
        ID_SEARCH_FORW_SEL,
        ID_SEARCH_BACK_SEL,
        ID_GOTO_LINE,
        ID_TOGGLE_WRAP,
        ID_TOGGLE_LINES_NUM,
        ID_TEXT,
        ID_INCLUDE_PATH,
        ID_OVERSTRIKE,
        ID_PREFERENCES,
        ID_NUM_ROWS,
        ID_WINDOW_1,
        ID_WINDOW_2,
        ID_WINDOW_3,
        ID_WINDOW_4,
        ID_WINDOW_5,
        ID_WINDOW_6,
        ID_WINDOW_7,
        ID_WINDOW_8,
        ID_WINDOW_9,
        ID_WINDOW_10,
        ID_WINDOW_11,
        ID_WINDOW_12,
        ID_WINDOW_13,
        ID_WINDOW_14,
        ID_WINDOW_15,
        ID_WINDOW_16,
        ID_WINDOW_17,
        ID_WINDOW_18,
        ID_WINDOW_19,
        ID_WINDOW_20,
        ID_WINDOW_21,
        ID_WINDOW_22,
        ID_WINDOW_23,
        ID_WINDOW_24,
        ID_WINDOW_25,
        ID_WINDOW_26,
        ID_WINDOW_27,
        ID_WINDOW_28,
        ID_WINDOW_29,
        ID_WINDOW_30,
        ID_WINDOW_31,
        ID_WINDOW_32,
        ID_WINDOW_33,
        ID_WINDOW_34,
        ID_WINDOW_35,
        ID_WINDOW_36,
        ID_WINDOW_37,
        ID_WINDOW_38,
        ID_WINDOW_39,
        ID_WINDOW_40,
        ID_WINDOW_41,
        ID_WINDOW_42,
        ID_WINDOW_43,
        ID_WINDOW_44,
        ID_WINDOW_45,
        ID_WINDOW_46,
        ID_WINDOW_47,
        ID_WINDOW_48,
        ID_WINDOW_49,
        ID_WINDOW_50,
        ID_LAST
    };
public:

    // Create new text window
    WriteWindow(XFileWrite* a, const FXString& file, const FXbool readonly);

    // Create window
    virtual void create();

    // Detach window
    virtual void detach();

    // Close the window, return true if actually closed
    virtual FXbool close(FXbool notify = false);

    // Return XFileWrite application
    XFileWrite* getApp() const
    {
        return((XFileWrite*)FXMainWindow::getApp());
    }

    // Return this window's filename
    const FXString& getFilename() const
    {
        return(filename);
    }

    // Change this window's filename
    void setFilename(const FXString& file)
    {
        filename = file;
    }

    // Has a filename been set or is it a new window
    FXbool isFilenameSet() const
    {
        return(filenameset);
    }

    // Obtain a pointer on the text widget
    FXText* getEditor() const
    {
        return(editor);
    }

    // Get the value of the stripcr flag
    FXbool getStripcr() const
    {
        return(stripcr);
    }

    // Set the value of the stripcr flag
    void setStripcr(FXbool val)
    {
        stripcr = val;
    }

    void setSmoothScroll(FXbool smooth)
    {
        smoothscroll = smooth;
    }

    // Is it modified
    FXbool isModified() const;

    // Load text from file
    FXbool loadFile(const FXString& file);

    // Save text to file
    FXbool saveFile(const FXString& file);

    // Return true if changes have been saved
    FXbool saveChanges();

    // Visit given line
    void visitLine(int line);

    // Delete text window
    virtual ~WriteWindow();
};


typedef FXObjectListOf<WriteWindow>   WriteWindowList;

#endif
#ifndef XFILEEXPLORER_H
#define XFILEEXPLORER_H

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>

#include "xfedefs.h"
#include "xfeutils.h"
#include "FileDict.h"
#include "FilePanel.h"
#include "InputDialog.h"
#include "HistInputDialog.h"
#include "BrowseInputDialog.h"
#include "Properties.h"
#include "DirPanel.h"
#include "Bookmarks.h"
#include "Preferences.h"
#include "TextWindow.h"
#include "SearchWindow.h"

// Typedef for the map between program string identifiers and integer indexes
typedef std::map<FXString, int>   progsmap;


// Application object
class XFileExplorer : public FXMainWindow
{
    FXDECLARE(XFileExplorer)
protected:
    enum
    {
        TREE_PANEL,
        ONE_PANEL,
        TWO_PANELS,
        TREE_TWO_PANELS,
        FILEPANEL_FOCUS,
        DIRPANEL_FOCUS,
    };
    int              panel_view;
    int              RunHistSize;
    int              throbymax;
    char             RunHistory[RUN_HIST_SIZE][MAX_COMMAND_SIZE];
    FXbool           vertpanels;
    FXSplitter*      panelsplit;
    FXMenuBar*       menubar;
    FXMenuPane*      toolsmenu;
    FXMenuPane*      filemenu;
    FXMenuPane*      trashmenu;
    FXMenuPane*      editmenu;
    FXMenuPane*      bookmarksmenu;
    FXMenuPane*      viewmenu;
    FXMenuButton*    viewbutton;
    FXMenuPane*      lpanelmenu;
    FXMenuPane*      rpanelmenu;
    FXMenuPane*      helpmenu;
    FXMenuTitle*     toolsmenutitle;
    FXMenuTitle*     filemenutitle;
    FXMenuTitle*     filemenutitle2;
    FXMenuCascade*   trashmenutitle;
    FXMenuTitle*     editmenutitle;
    FXMenuTitle*     bookmarksmenutitle;
    FXMenuTitle*     viewmenutitle;
    FXMenuCascade*   lpanelmenutitle;
    FXMenuCascade*   rpanelmenutitle;
    FXMenuTitle*     helpmenutitle;
    Bookmarks*       bookmarks;
    FXToolBar*       generaltoolbar;
    FXToolBar*       throbbertoolbar;
    FXToolBar*       toolstoolbar;
    FXToolBar*       paneltoolbar;
    FXToolBar*       locationbar;
    FXLabel*         addressicon;
    ComboBox*        address;
    DirPanel*        dirpanel;
    FilePanel*       lpanel;
    FilePanel*       rpanel;
    FXString         trashfileslocation;
    FXString         trashinfolocation;
    FXString         startlocation;
    FXuint           liststyle;
    FXColor          listbackcolor;
    FXColor          listforecolor;
    FXColor          highlightcolor;
    FXColor          pbarcolor;
    FXColor          attentioncolor;
    FXColor          scrollbarcolor;
    //FXArrowButton*   btnbackhist;
    FXButton*        btnbackhist;
    FXButton*        btnforwardhist;
    FXButton*        foldersbtn;
    HistInputDialog* rundialog;
    PreferencesBox*  prefsdialog;
    TextWindow*      helpwindow;
    FXString         message;
    FXuint           panelfocus;
    FXString         startdir1;
    FXString         startdir2;
    vector_FXString  startURIs;
    FXbool           starticonic;
    FXbool           startmaximized;
    FXbool           smoothscroll;
    double           twopanels_lpanel_pct;      // Panel sizes, relatively to the window width (in percent)
    double           treepanel_tree_pct;
    double           treetwopanels_tree_pct;
    double           treetwopanels_lpanel_pct;
    FXString         prevdir;
    int              prev_width;
    FXuint           search_xpos;
    FXuint           search_ypos;
    FXuint           search_width;
    FXuint           search_height;
    FXLabel*         throbber;
    FXLabel*         lpaneltext;
    SearchWindow*    searchwindow;
    progsmap         progs;                     // Map between program string identifiers and integer indexes
    FXbool           winshow;                   // If true, do not show the Xfe window
    FXbool           stop;                      // If true, stop Xfe immediately
    int              nbstartfiles;              // Number of files to open on startup
    int              go_lpad;
    int              go_rpad;
    int              go_tpad;
    int              go_bpad;

public:
    enum
    {
        ID_ABOUT=FXMainWindow::ID_LAST,
        ID_ANIMTHROB,
        ID_REALANIMTHROB,
        ID_ACTTHROB,
        ID_STOPANIMTHROB,
        ID_HELP,
        ID_REFRESH,
        ID_EMPTY_TRASH,
        ID_TRASH_SIZE,
        ID_XTERM,
        ID_DIR_UP,
        ID_DIR_BACK,
        ID_DIR_FORWARD,
        ID_DIR_BACK_HIST,
        ID_DIR_FORWARD_HIST,
        ID_FILE_PROPERTIES,
        ID_FILE_COPY,
        ID_FILE_RENAME,
        ID_FILE_MOVETO,
        ID_FILE_COPYTO,
        ID_FILE_CUT,
        ID_FILE_PASTE,
        ID_FILE_SYMLINK,
        ID_FILE_DELETE,
        ID_FILE_TRASH,
        ID_FILE_RESTORE,
        ID_FILE_ASSOC,
        ID_FILE_SEARCH,
        ID_CLEAR_LOCATION,
        ID_GOTO_LOCATION,
        ID_RUN,
        ID_SU,
        ID_PREFS,
        ID_DIR_BOX,
        ID_TOGGLE_STATUS,
        ID_SHOW_ONE_PANEL,
        ID_SHOW_TWO_PANELS,
        ID_SHOW_TREE_PANEL,
        ID_SHOW_TREE_TWO_PANELS,
        ID_SYNCHRONIZE_PANELS,
        ID_SWITCH_PANELS,
        ID_SWITCH_TREE,
        ID_RESTART,
        ID_NEW_WIN,
        ID_BOOKMARK,
        ID_ADD_BOOKMARK,
        ID_HARVEST,
        ID_QUIT,
        ID_FILE_ADDCOPY,
        ID_FILE_ADDCUT,
        ID_HORZ_PANELS,
        ID_VERT_PANELS,
        ID_KILL_FOCUS,
        ID_LAST
    };
protected:
    XFileExplorer() : panel_view(0), RunHistSize(0), throbymax(0), vertpanels(false), panelsplit(NULL), menubar(NULL), toolsmenu(NULL), filemenu(NULL),
                      trashmenu(NULL), editmenu(NULL), bookmarksmenu(NULL), viewmenu(NULL), lpanelmenu(NULL), rpanelmenu(NULL), helpmenu(NULL),
                      toolsmenutitle(NULL), filemenutitle(NULL), trashmenutitle(NULL), editmenutitle(NULL), bookmarksmenutitle(NULL), viewmenutitle(NULL),
                      lpanelmenutitle(NULL), rpanelmenutitle(NULL), helpmenutitle(NULL), bookmarks(NULL), generaltoolbar(NULL),
                      toolstoolbar(NULL), paneltoolbar(NULL), locationbar(NULL), address(NULL), dirpanel(NULL), lpanel(NULL),
                      rpanel(NULL), liststyle(0), listbackcolor(FXRGB(0, 0, 0)), listforecolor(FXRGB(0, 0, 0)),
                      highlightcolor(FXRGB(0, 0, 0)), pbarcolor(FXRGB(0, 0, 0)), attentioncolor(FXRGB(0, 0, 0)),
                      scrollbarcolor(FXRGB(0, 0, 0)), btnbackhist(NULL), btnforwardhist(NULL), rundialog(NULL), prefsdialog(NULL),
                      helpwindow(NULL), panelfocus(0), starticonic(false), startmaximized(false), smoothscroll(false),
                      twopanels_lpanel_pct(0.0), treepanel_tree_pct(0.0), treetwopanels_tree_pct(0.0), treetwopanels_lpanel_pct(0.0),
                      prev_width(0), search_xpos(0), search_ypos(0), search_width(0), search_height(0), searchwindow(NULL), winshow(false), stop(false), nbstartfiles(0)
    {}
public:
    XFileExplorer(FXApp* app, vector_FXString URIs, const FXbool iconic = false, const FXbool maximized = false, const char* title = "X File Explorer", FXIcon* bigicon = NULL, FXIcon* miniicon = NULL);
    virtual void create();

    ~XFileExplorer();
    void saveConfig();

    void openFiles(vector_FXString);
    long onSigHarvest(FXObject*, FXSelector, void*);
    long onQuit(FXObject*, FXSelector, void*);
    long onKeyPress(FXObject*, FXSelector, void*);
    long onKeyRelease(FXObject*, FXSelector, void*);
    long onCmdHelp(FXObject*, FXSelector, void*);
    long onCmdAnimateThrobber(FXObject*, FXSelector, void*);
    long onCmdActivateThrobber(FXObject*, FXSelector, void*);
    long onCmdStopAnimateThrobber(FXObject*, FXSelector, void*);
    long onCmdAbout(FXObject*, FXSelector, void*);
    long onCmdFileAssoc(FXObject*, FXSelector, void*);
    long onCmdRefresh(FXObject*, FXSelector, void*);
    long onCmdToggleStatus(FXObject*, FXSelector, void*);
    long onCmdPopupMenu(FXObject*, FXSelector, void*);
    long onCmdPrefs(FXObject*, FXSelector, void*);
    long onCmdRun(FXObject*, FXSelector, void*);
    long onCmdSu(FXObject*, FXSelector, void*);
    long onCmdXTerm(FXObject*, FXSelector, void*);
    long onCmdEmptyTrash(FXObject*, FXSelector, void*);
    long onCmdTrashSize(FXObject*, FXSelector, void*);
    long onCmdHorzVertPanels(FXObject*, FXSelector, void*);
    long onCmdShowPanels(FXObject*, FXSelector, void*);
    long onCmdSwitchTree(FXObject*, FXSelector, void*);
    long onCmdRestart(FXObject*, FXSelector, void*);
    long onCmdNewWindow(FXObject*, FXSelector, void*);
    long onCmdBookmark(FXObject*, FXSelector, void*);
    long onCmdGotoLocation(FXObject*, FXSelector, void*);
    long onCmdClearLocation(FXObject*, FXSelector, void*);
    long onUpdToggleStatus(FXObject*, FXSelector, void*);
    long onUpdHorzVertPanels(FXObject*, FXSelector, void*);
    long onUpdShowPanels(FXObject*, FXSelector, void*);
    long onUpdFileLocation(FXObject*, FXSelector, void*);
    long onUpdEmptyTrash(FXObject*, FXSelector, void*);
    long onUpdTrashSize(FXObject*, FXSelector, void*);
    long onCmdFileDelete(FXObject*, FXSelector, void*);
    long onCmdFileTrash(FXObject*, FXSelector, void*);
    long onCmdFileRestore(FXObject*, FXSelector, void*);
    long onUpdFileDelete(FXObject*, FXSelector, void*);
    long onUpdFileTrash(FXObject*, FXSelector, void*);
    long onUpdFileRestore(FXObject*, FXSelector, void*);
    long onCmdFileSearch(FXObject*, FXSelector sel, void*);
    long onCmdDirUp(FXObject*, FXSelector, void*);
    long onCmdDirBack(FXObject*, FXSelector, void*);
    long onUpdDirBack(FXObject*, FXSelector, void*);
    long onCmdDirForward(FXObject*, FXSelector, void*);
    long onUpdDirForward(FXObject*, FXSelector, void*);
    long onCmdDirBackHist(FXObject*, FXSelector, void*);
    long onUpdDirBackHist(FXObject*, FXSelector, void*);
    long onCmdDirForwardHist(FXObject*, FXSelector, void*);
    long onUpdDirForwardHist(FXObject*, FXSelector, void*);
    long onCmdFileCopyClp(FXObject*, FXSelector, void*);
    long onCmdFileCutClp(FXObject*, FXSelector, void*);
    long onCmdFileAddCopyClp(FXObject*, FXSelector, void*);
    long onCmdFileAddCutClp(FXObject*, FXSelector, void*);
    long onCmdFilePasteClp(FXObject*, FXSelector, void*);
    long onCmdFileRename(FXObject*, FXSelector, void*);
    long onCmdFileMoveto(FXObject*, FXSelector, void*);
    long onCmdFileCopyto(FXObject*, FXSelector, void*);
    long onCmdFileSymlink(FXObject*, FXSelector, void*);
    long onUpdFileMan(FXObject*, FXSelector, void*);
    long onUpdFilePaste(FXObject*, FXSelector, void*);
    long onCmdFileProperties(FXObject*, FXSelector, void*);
    long onUpdFileRename(FXObject*, FXSelector, void*);
    long onCmdSynchronizePanels(FXObject*, FXSelector, void*);
    long onUpdSynchronizePanels(FXObject*, FXSelector, void*);
    long onCmdSwitchPanels(FXObject*, FXSelector, void*);
    long onUpdSwitchPanels(FXObject*, FXSelector, void*);
    long onUpdSu(FXObject*, FXSelector, void*);
    long onUpdQuit(FXObject*, FXSelector, void*);
    long onUpdFileSearch(FXObject*, FXSelector, void*);
public:
    // Get associations
    FileDict* getAssociations()
    {
        return(lpanel->getCurrent()->getAssociations());
    }

    // Change to selected directory
    void setDirectory(FXString pathname)
    {
        lpanel->getCurrent()->setDirectory(pathname, false);
        lpanel->getCurrent()->updatePath();
        dirpanel->setDirectory(pathname, true);
    }

    // Change default cursor for file and dir panels
    void setDefaultCursor(FXCursor* cur)
    {
        lpanel->setDefaultCursor(cur);
        rpanel->setDefaultCursor(cur);
        dirpanel->setDefaultCursor(cur);
    }

	// Deselect all items
    void deselectAll(void)
    {
        lpanel->deselectAll();
        rpanel->deselectAll();
        
        if (searchwindow)
        {
			searchwindow->deselectAll();
		}
    }
	 
    // Refresh file panels
    void refreshPanels(void)
    {
        lpanel->onCmdRefresh(0, 0, 0);
        rpanel->onCmdRefresh(0, 0, 0);
    }

    // Return a pointer on the current file panel
    FilePanel* getCurrentPanel(void)
    {
        return(lpanel->getCurrent());
    }

    // Return a pointer on the next file panel
    FilePanel* getNextPanel(void)
    {
        return(lpanel->getNext());
    }

    // Return the address box (location bar)
    FXComboBox* getAddressBox(void)
    {
        return(address);
    }

    // Return a pointer on the directory panel
    DirPanel* getDirPanel(void)
    {
        return(dirpanel);
    }

    FXLabel* getAddressIcon(void)
    {
        return(addressicon);
    }

    FXLabel* getThrobber(void)
    {
        return(throbber);
    }

};
#endif
#ifndef XFILEIMAGE_H
#define XFILEIMAGE_H


#include "InputDialog.h"
#include "PathLinker.h"

class XFileImage : public FXMainWindow
{
    FXDECLARE(XFileImage)
protected:
    FXbool             hiddenfiles;           // Show or hide hidden files
    FXbool             thumbnails;            // Show or hide image thumbnails
    FXuint             fileview;              // File list view
    FXuint             liststyle;             // Icon list style
    FXImageView*       imageview;             // Image viewer
    FXVerticalFrame*   imageviewcontainer;
    FXRecentFiles      mrufiles;              // Recent files
    FXString           filename;              // File being viewed
    FXMenuBar*         menubar;               // Menu bar
    FXToolBar*         toolbar;               // Tool bar
    FXVerticalFrame*   toolbarcont;           // Tool bar container
    FXToolBarShell*    dragshell1;            // Shell for floating menubar
    FXHorizontalFrame* statusbar;             // Status bar
    FXbool             filelistbefore;
    FXbool             vertpanels;
    int                zoomwin;
    FXDragCorner*      realcorner;
    FXPacker*          corner;
    FXSplitter*        splitter;              // Splitter
    FXVerticalFrame*   filebox;               // Box containing directories/files
    FileList*          filelist;              // File List
    FXLabel*           label;                 // Directory path
    FXMenuPane*        filemenu;              // File menu
    FXMenuPane*        viewmenu;              // View menu
    FXMenuPane*        helpmenu;              // Help menu
    FXMenuPane*        imagemenu;             // Image menu
    FXMenuPane*        prefsmenu;             // Preferences menu
    FXTextField*       filter;                // Filter for tree list
    FXImage*           img;                   // Image loaded
    FXImage*           tmpimg;                // Temporary image
    FXColor*           tmpdata;               // Temporary image data
    int                indZoom;               // Zoom index
    int                imgvwidth;
    int                imgvheight;
    double             zoomval;               // Actual zoom factor
    FXbool             fitwin;                // Fit window when opening an image
    FXbool             filterimgs;            // List only image files in file list
    InputDialog*       printdialog;
    FXbool             smoothscroll;
    double             filewidth_pct;
    double             fileheight_pct;
    FXArrowButton*     btnbackhist;           // Back history
    FXArrowButton*     btnforwardhist;        // Forward history
    PathLinker*        pathlink;
    TextLabel*         pathtext;
    int                prev_width;
    int                prev_height;
protected:
    XFileImage() : hiddenfiles(false), thumbnails(false), fileview(0), liststyle(0), imageview(NULL), menubar(NULL), toolbar(NULL), dragshell1(NULL),
                   statusbar(NULL), filelistbefore(false), vertpanels(false), splitter(NULL),
                   filebox(NULL), filelist(NULL), label(NULL), filemenu(NULL), viewmenu(NULL), helpmenu(NULL), imagemenu(NULL),
                   prefsmenu(NULL), filter(NULL), img(NULL), tmpimg(NULL), tmpdata(NULL), indZoom(0),
                   zoomval(0.0), fitwin(false), filterimgs(false), printdialog(NULL), smoothscroll(false), filewidth_pct(0.0), fileheight_pct(0.0),
                   btnbackhist(NULL), btnforwardhist(NULL), pathlink(NULL), pathtext(NULL), prev_width(0), prev_height(0)
    {}
public:
    long onCmdAbout(FXObject*, FXSelector, void*);
    long onCmdOpen(FXObject*, FXSelector, void*);
    long onCmdPrint(FXObject*, FXSelector, void*);
    long onCmdShowMini(FXObject*, FXSelector, void*);
    long onCmdShowBig(FXObject*, FXSelector, void*);
    long onCmdShowDetails(FXObject*, FXSelector, void*);
    long onCmdShowRows(FXObject*, FXSelector, void*);
    long onCmdShowCols(FXObject*, FXSelector, void*);
    long onCmdAutosize(FXObject*, FXSelector, void*);
    long onCmdSave(FXObject*, FXSelector, void*);
    long onSigHarvest(FXObject*, FXSelector, void*);
    long onCmdQuit(FXObject*, FXSelector, void*);
    long onCmdRestart(FXObject*, FXSelector, void*);
    long onUpdTitle(FXObject*, FXSelector, void*);
    long onCmdRecentFile(FXObject*, FXSelector, void*);
    long onCmdRotate(FXObject*, FXSelector, void*);
    long onCmdMirror(FXObject*, FXSelector, void*);
    long onCmdZoomIn(FXObject*, FXSelector, void*);
    long onCmdZoomOut(FXObject*, FXSelector, void*);
    long onCmdZoom100(FXObject*, FXSelector, void*);
    long onCmdZoomWin(FXObject*, FXSelector, void*);
    long onConfigureZoomWin(FXObject*, FXSelector, void*);
    long onLower(FXObject*, FXSelector, void*);
    long onUpdImage(FXObject*, FXSelector, void*);
    long onUpdFileView(FXObject*, FXSelector, void*);
    long onUpdIconView(FXObject*, FXSelector, void*);
    long onCmdToggleHidden(FXObject*, FXSelector, void*);
    long onUpdToggleHidden(FXObject*, FXSelector, void*);
    long onCmdToggleThumbnails(FXObject*, FXSelector, void*);
    long onUpdToggleThumbnails(FXObject*, FXSelector, void*);
    long onCmdItemDoubleClicked(FXObject*, FXSelector, void*);
    long onCmdItemClicked(FXObject*, FXSelector, void*);
    long onCmdToggleFitWin(FXObject*, FXSelector, void*);
    long onUpdToggleFitWin(FXObject*, FXSelector, void*);
    long onCmdPopupMenu(FXObject*, FXSelector, void*);
    long onCmdHome(FXObject*, FXSelector, void*);
    long onCmdWork(FXObject*, FXSelector, void*);
    long onCmdDirUp(FXObject*, FXSelector, void*);
    long onUpdDirUp(FXObject*, FXSelector, void*);
    long onCmdDirBack(FXObject*, FXSelector, void*);
    long onUpdDirBack(FXObject*, FXSelector, void*);
    long onCmdDirForward(FXObject*, FXSelector, void*);
    long onUpdDirForward(FXObject*, FXSelector, void*);
    long onCmdDirBackHist(FXObject*, FXSelector, void*);
    long onUpdDirBackHist(FXObject*, FXSelector, void*);
    long onCmdDirForwardHist(FXObject*, FXSelector, void*);
    long onUpdDirForwardHist(FXObject*, FXSelector, void*);
    long onCmdToggleFilterImages(FXObject*, FXSelector, void*);
    long onUpdToggleFilterImages(FXObject*, FXSelector, void*);
    long onCmdHorzVertPanels(FXObject*, FXSelector, void*);
    long onUpdHorzVertPanels(FXObject*, FXSelector, void*);
    long onCmdToggleFileListBefore(FXObject*, FXSelector, void*);
    long onUpdToggleFileListBefore(FXObject*, FXSelector, void*);
	long onKeyPress(FXObject*, FXSelector, void*);
	long onKeyRelease(FXObject*, FXSelector, void*);
	

public:
    enum
    {
        ID_ABOUT=FXMainWindow::ID_LAST,
        ID_OPEN,
        ID_POPUP_MENU,
        ID_TOGGLE_HIDDEN,
        ID_TOGGLE_THUMBNAILS,
        ID_SHOW_MINI_ICONS,
        ID_SHOW_BIG_ICONS,
        ID_SHOW_DETAILS,
        ID_COLS,
        ID_ROWS,
        ID_AUTO,
        ID_TITLE,
        ID_PRINT,
        ID_HARVEST,
        ID_QUIT,
        ID_RESTART,
        ID_FILELIST,
        ID_RECENTFILE,
        ID_ROTATE_90,
        ID_ROTATE_270,
        ID_MIRROR_HOR,
        ID_MIRROR_VER,
        ID_SCALE,
        ID_ZOOM_IN,
        ID_ZOOM_OUT,
        ID_ZOOM_100,
        ID_ZOOM_WIN,
        ID_TOGGLE_FIT_WIN,
        ID_TOGGLE_FILTER_IMAGES,
        ID_GO_HOME,
        ID_GO_WORK,
        ID_DIR_UP,
        ID_DIR_BACK,
        ID_DIR_FORWARD,
        ID_DIR_BACK_HIST,
        ID_DIR_FORWARD_HIST,
        ID_HORZ_PANELS,
        ID_VERT_PANELS,
        ID_TOGGLE_FILELIST_BEFORE,
        ID_LAST
    };
public:
    XFileImage(FXApp*, FXbool);
    virtual void create();
    FXbool loadimage(const FXString&);
    void saveConfig();

    void start(FXString);
    virtual ~XFileImage();
    void setSmoothScroll(FXbool smooth)
    {
        smoothscroll = smooth;
    }
};
#endif
#ifndef XFILEPACKAGE_H
#define XFILEPACKAGE_H

#include "FileDialog.h"

class XFilePackage : public FXMainWindow
{
    FXDECLARE(XFilePackage)
protected:
    FXMenuBar*  menubar;                    // Menu bar
    FXMenuPane* filemenu;                   // File menu
    FXMenuPane* helpmenu;                   // Help menu
    FXMenuPane* prefsmenu;                  // Preferences menu
    FXToolBar*  toolbar;                    // Toolbar
    FXString    filename;                   // Current package name
    FXTreeList* list;                       // File list
    FXText*     description;                // Package description
    FXbool      smoothscroll;
    FXbool      errorflag;
protected:
    XFilePackage() : menubar(NULL), filemenu(NULL), helpmenu(NULL), prefsmenu(NULL), toolbar(NULL), list(NULL),
                     description(NULL), smoothscroll(false), errorflag(false)
    {}
public:
    enum
    {
        ID_DESCRIPTION=FXMainWindow::ID_LAST,
        ID_FILELIST,
        ID_UNINSTALL,
        ID_INSTALL,
        ID_ABOUT,
        ID_OPEN,
        ID_HARVEST,
        ID_QUIT,
        ID_LAST
    };
    void start(FXString);
    void create();

    XFilePackage(FXApp*);
    ~XFilePackage();
    void setSmoothScroll(FXbool smooth)
    {
        smoothscroll = smooth;
    }

    long onCmdUninstall(FXObject*, FXSelector, void*);
    long onCmdInstall(FXObject*, FXSelector, void*);
    long onCmdAbout(FXObject*, FXSelector, void*);
    long onCmdOpen(FXObject*, FXSelector, void*);
    int readDescription();
    int readFileList();
    void saveConfig();

    long onSigHarvest(FXObject*, FXSelector, void*);
    long onCmdQuit(FXObject*, FXSelector, void*);
    long onUpdWindow(FXObject*, FXSelector, void*);
};

#endif
#ifndef XFILEWRITE_H
#define XFILEWRITE_H



class Preferences;
class WriteWindow;


// Main Application class
class XFileWrite : public FXApp
{
    FXDECLARE(XFileWrite)
public:
    WriteWindowList windowlist;                    // Window list
private:
    XFileWrite()
    {}
    XFileWrite(const XFileWrite&);
    XFileWrite& operator=(const XFileWrite&);

public:
    enum
    {
        ID_CLOSEALL=FXApp::ID_LAST,
        ID_LAST
    };
public:
    long onCmdCloseAll(FXObject*, FXSelector, void*);
public:

    // Construct application object
    XFileWrite(const FXString&, const FXString&);

    // Initialize application
    virtual void init(int& argc, char** argv, bool connect = true);

    // Exit application
    virtual void exit(int code = 0);

    // Delete application object
    virtual ~XFileWrite();
};

#endif
#ifndef HELP_H
#define HELP_H

#include "config.h"
#include "i18n.h"

#define HELP_TEXT    _("\n \
\n \
\n \
                                  XFE, X File Explorer File Manager\n \
\n \
                                    <http://roland65.free.fr/xfe>\n \
                                <http://sourceforge.net/projects/xfe>\n \
\n \
\n \
\n \
 [This help file is best viewed using a fixed text font. You can set it by using the font tab of the Preferences dialog.]\n \
\n \
\n \
\n \
 This program is free software; you can redistribute it and/or modify it under the terms of the GNU\n \
 General Public License as published by the Free Software Foundation; either version 2, or (at your option)\n \
 any later version.\n \
\n \
 This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; \n \
 without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. \n \
 See the GNU General Public License for more details.\n \
\n \
\n \
\n \
  Description\n \
  =-=-=-=-=-=\n \
\n \
 X File Explorer (Xfe) is a lightweight file manager for X11, written using the FOX toolkit.\n \
 It is desktop independent and can easily be customized.\n \
 It has Commander or Explorer styles and it is very fast and small.\n \
 Xfe is based on the popular, but discontinued X Win Commander, originally written by Maxim Baranov.\n \
\n \
\n \
\n \
  Features\n \
  =-=-=-=-=\n \
\n \
    - Very fast graphic user interface\n \
    - UTF-8 support\n \
    - Commander/Explorer interface with four file manager modes : a) one panel, b) a folder tree\n \
      and one panel, c) two panels and d) a folder tree and two panels\n \
    - Horizontal or vertical file panels stacking\n \
    - Panels synchronization and switching\n \
    - Integrated text editor and viewer (X File Write, Xfw)\n \
    - Integrated image viewer (X File Image, Xfi)\n \
    - Integrated package (rpm or deb) viewer / installer / uninstaller (X File Package, Xfp)\n \
    - Custom shell scripts (like Nautilus scripts)\n \
    - Search files and directories\n \
    - Natural sort order (foo10.txt comes after foo2.txt...)\n \
    - Copy/Cut/Paste files from and to your favorite desktop (GNOME/KDE/XFCE/ROX)\n \
    - Drag and Drop files from and to your favorite desktop (GNOME/KDE/XFCE/ROX)\n \
    - Disk usage command \n \
    - Root mode with authentication by su or sudo\n \
    - Status line\n \
    - File associations\n \
    - Optional trash can for file delete operations (compliant with freedesktop.org standards)\n \
    - Auto save registry\n \
    - Double click or single click file and folder navigation\n \
    - Mouse right click pop-up menu in tree list and file list\n \
    - Change file attributes\n \
    - Mount/Unmount devices (Linux only)\n \
    - Warn when mount point are not responding (Linux only)\n \
    - Toolbars\n \
    - Bookmarks\n \
    - Back and forward history lists for folder navigation\n \
    - Color themes (GNOME, KDE, Windows...)\n \
    - Icon themes (Xfe, GNOME, KDE, Tango, Windows...)\n \
    - Control themes (Standard or Clearlooks like)\n \
    - Create archives (tar, compress, zip, gzip, bzip2, xz and 7zip formats are supported)\n \
    - File comparison (through external tool)\n \
    - Extract archives (tar, compress, zip, gzip, bzip2, xz, lzh, rar, ace, arj and 7zip formats are supported)\n \
    - Tooltips with file properties\n \
    - Progress bars or dialogs for lengthy file operations\n \
    - Thumbnails image previews\n \
    - Configurable key bindings\n \
    - Startup notification (optional)\n \
    - and much more...\n \
\n \
\n \
\n \
  Default Key bindings\n \
  =-=-=-=-=-=-=-=-=-=-=\n \
\n \
 Below are the global default key bindings. These key bindings are common to all X File applications.\n \
\n \
    * Select all                         - Ctrl-A\n \
    * Copy to clipboard                  - Ctrl-C\n \
    * Search                             - Ctrl-F\n \
    * Search previous                    - Ctrl-Shift-G\n \
    * Search next                        - Ctrl-G\n \
    * Go to home folder                  - Ctrl-H\n \
    * Invert selection                   - Ctrl-I\n \
    * Open file                          - Ctrl-O\n \
    * Print file                         - Ctrl-P\n \
    * Quit application                   - Ctrl-Q\n \
    * Paste from clipboard               - Ctrl-V\n \
    * Close window                       - Ctrl-W\n \
    * Cut to clipboard                   - Ctrl-X\n \
    * Deselect all                       - Ctrl-Z\n \
    * Display help                       - F1\n \
    * Create new file                    - Ctrl-N\n \
    * Create new folder                  - F7\n \
    * Big icon list                      - F10\n \
    * Small icon list                    - F11\n \
    * Detailed file list                 - F12\n \
    * Toggle display hidden files        - Ctrl-F6\n \
    * Toggle display thumbnails          - Ctrl-F7\n \
    * Vertical panels                    - Ctrl-Shift-F1\n \
    * Horizontal panels                  - Ctrl-Shift-F2\n \
    * Go to working folder               - Shift-F2\n \
    * Go to parent folder                - Backspace\n \
    * Go to previous folder              - Ctrl-Backspace\n \
    * Go to next folder                  - Shift-Backspace\n \
\n \
\n \
 Below are the default X File Explorer key bindings. These key bindings are specific to the Xfe application.\n \
\n \
    * Add bookmark                      - Ctrl-B\n \
    * Filter files                      - Ctrl-D\n \
    * Execute command                   - Ctrl-E\n \
    * Create new symbolic link          - Ctrl-J\n \
    * Switch panels                     - Ctrl-K\n \
    * Clear location bar                - Ctrl-L\n \
    * Mount file system (Linux only)    - Ctrl-M\n \
    * Rename file                       - F2\n \
    * Refresh panels                    - Ctrl-R\n \
    * Symlink files to location         - Ctrl-S\n \
    * Launch terminal                   - Ctrl-T\n \
    * Unmount file system (Linux only)  - Ctrl-U\n \
    * Synchronize panels                - Ctrl-Y\n \
    * Create new window                 - F3\n \
    * Edit                              - F4\n \
    * Copy files to location            - F5\n \
    * Move files to location            - F6\n \
    * File properties                   - F9\n \
    * One panel mode                    - Ctrl-F1\n \
    * Tree and panel mode               - Ctrl-F2\n \
    * Two panels mode                   - Ctrl-F3\n \
    * Tree and two panels mode          - Ctrl-F4\n \
    * Toggle display hidden folders     - Ctrl-F5\n \
    * Go to trash can                   - Ctrl-F8\n \
    * Create new root window            - Shift-F3\n \
    * View                              - Shift-F4\n \
    * Move files to trash can           - Del\n \
    * Restore files from trash can      - Alt-Del\n \
    * Delete files                      - Shift-Del\n \
    * Empty trash can                   - Ctrl-Del\n \
\n \
\n \
 Below are the default X File Image key bindings. These key bindings are specific to the Xfi application.\n \
\n \
    * Zoom to fit window                - Ctrl-F\n \
    * Mirror image horizontally         - Ctrl-H\n \
    * Zoom image to 100%                - Ctrl-I\n \
    * Rotate image to left              - Ctrl-L\n \
    * Rotate image to right             - Ctrl-R\n \
    * Mirror image vertically           - Ctrl-V\n \
\n \
\n \
 Below are the default X File Write key bindings. These key bindings are specific to the Xfw application.\n \
\n \
    * Toggle word wrap mode             - Ctrl-K\n \
    * Goto line                         - Ctrl-L\n \
    * Create new document               - Ctrl-N\n \
    * Replace string                    - Ctrl-R\n \
    * Save changes to file              - Ctrl-S\n \
    * Toggle line numbers mode          - Ctrl-T\n \
    * Toggle upper case mode            - Ctrl-Shift-U\n \
    * Toggle lower case mode            - Ctrl-U\n \
    * Redo last change                  - Ctrl-Y\n \
    * Undo last change                  - Ctrl-Z\n \
\n \
\n \
 X File Package (Xfp) only use some of the global key bindings.\n \
\n \
 Note that all the default key bindings listed above can be customized in the Xfe Preferences dialog. However,\n \
 some key actions are hardcoded an cannot be changed. These include:\n \
\n \
    * Ctrl-+ and Ctrl--                 - zoom in and zoom out image in Xfi\n \
    * Shift-F10                         - display context menus in Xfe\n \
    * Space                             - select an item in file list\n \
    * Return                            - enter folders in file lists, open files, select button actions, etc.\n \
    * Esc                               - close current dialog, unselect files, etc.\n \
\n \
\n \
\n \
  Drag and Drop operations\n \
  =-=-=-=-=-=-=-=-=-=-=-=-=\n \
\n \
 Dragging a file or group or files (by moving the mouse while maintaining the left button pressed)\n \
 to a folder or a file panel optionally opens a dialog that allows one to select the file operation: copy,\n \
 move, link or cancel.\n \
\n \
\n \
\n \
  Trash system\n \
  =-=-=-=-=-=-=\n \
\n \
 Starting with version 1.32, Xfe implements a trash system that is fully compliant with the freedesktop.org standards.\n \
 This allows the user to move files to the trash can and to restore files from within Xfe or your favorite\n \
 desktop.\n \
 Note that the trash files location is now: ~/.local/share/Trash/files\n \
\n \
\n \
\n \
  Configuration\n \
  =-=-=-=-=-=-=\n \
\n \
 You can perform any Xfe customization (layout, file associations, key bindings, etc.) without editing any file\n \
 by hand. However, you may want to understand the configuration principles, because some customizations can also\n \
 easily be done by manually editing the configurations files.\n \
 Be careful to quit Xfe before manually editing any configuration file, otherwise changes could not be taken\n \
 into account.\n \
\n \
 The system-wide configuration file xferc is located in /usr/share/xfe, /usr/local/share/xfe\n \
 or /opt/local/share/xfe, in the given order of precedence.\n \
\n \
 Starting with version 1.32, the location of the local configuration files has changed. This is to be compliant\n \
 with the freedesktop.org standards.\n \
 \n \
 The local configuration files for Xfe, Xfw, Xfi, Xfp are now located in the ~/.config/xfe folder.\n \
 They are named xferc, xfwrc, xfirc and xfprc.\n \
 \n \
 At the very first Xfe run, the system-wide configuration file is copied into the local configuration file\n \
 ~/.config/xfe/xferc which does not exists yet. If the system-wide configuration file is not found\n \
 (in case of an unusal install place), a dialog asks the user to select the right place. It is thus easier to\n \
 customize Xfe (this is particularly true for the file associations) by hand editing because all the local options are\n \
 located in the same file.\n \
\n \
 Default PNG icons are located in /usr/share/xfe/icons/xfe-theme or /usr/local/share/xfe/icons/xfe-theme, depending\n \
 on your installation. You can easily change the icon theme path in Preferences dialog.\n \
\n \
\n \
\n \
  Scripts\n \
  =-=-=-=\n \
\n \
 Custom shell scripts can be executed from within Xfe on the files that are selected in a panel. You have to first\n \
 select the files you want to proceed, then right click on the file list and go to the Scripts sub menu. Last, choose\n \
 the script you want to apply on the selected files.\n \
\n \
 The script files must be located in the ~/.config/xfe/scripts folder and have to be executable. You can organize\n \
 this folder as you like by using sub-folders. You can use the Tools / Go to script folder menu item to directly go\n \
 to the script folder and manage it.\n \
\n \
 Here is an example of a simple shell script that list each selected file on the terminal from where Xfe was launched:\n \
\n \
 #!/bin/sh\n \
 for arg\n \
 do\n \
 /bin/ls -la \"$arg\"\n \
 done\n \
\n \
 You can of course use programs like xmessage, zenity or kdialog to display a window with buttons that allows you to\n \
 interact with the script. Here is a modification of the above example that uses xmessage:\n \
\n \
 #!/bin/sh\n \
 (\n \
 echo  \"ls -la\"\n \
 for arg\n \
 do\n \
 /bin/ls -la \"$arg\"\n \
 done\n \
 ) | xmessage -file -\n \
\n \
 Most often, it is possible to directly use Nautilus scripts found on the Internet without modifications.\n \
\n \
\n \
\n \
 Search files and directories\n \
 =-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n \
\n \
\n \
 Xfe can quickly search files and directories by using find and grep command backends. This is done through the\n \
 Tools / Search files menu item (or by using the Ctrl-F shortcut).\n \
\n \
 In the search window, users can then specify usual search patterns like name and text, but more sophisticated search\n \
 options are also available (size, date, permissions, users, groups, follow symlinks and empty files). Results appear\n \
 in a file list and users can use the right click menu to manage their files, the same way as they do in the file\n \
 panels.\n \
\n \
 The search can be interrupted by clicking on the Stop button or pressing the Escape key.\n \
\n \
\n \
\n \
  Non Latin based languages\n \
  =-=-=-=-=-=-=-=-=-=-=-=-=\n \
\n \
 Xfe can display its user interface and also the file names in non latin character based languages, provided that you\n \
 have selected a Unicode font that supports your character set. To select a suitable font, use the\n \
 Edit / Preferences / Font menu item.\n \
\n \
 Multilingual Unicode TrueType fonts can be found at this address: http://www.slovo.info/unifonts.htm\n \
\n \
\n \
\n \
  Tips\n \
  =-=-=\n \
\n \
 File list\n \
    - Select files and right click to open a context menu on the selected files\n \
    - Press Ctrl + right click to open a context menu on the file panel\n \
    - When dragging a file/folder to a folder, hold on the mouse on the folder to open it\n \
\n \
 Tree list\n \
    - Select a folder and right click to open a context menu on the selected folder\n \
    - Press Ctrl + right click to open a context menu on the tree panel\n \
    - When dragging a file/folder to a folder, hold on the mouse on the folder to expand it\n \
\n \
 Copy/paste file names\n \
    - Select a file and press Ctrl-C to copy its name into the clipboard. Then in a dialog,press Ctrl-V to paste\n \
      the file name.\n \
    - In a file operation dialog, select a filename in the line containing the source name and paste it directly\n \
      to the destination using the middle button of your mouse. Then modify it to suit your needs.\n \
\n \
 Add files to the clipboard\n \
    - You can select files from a directory, copy them to the clipboard by pressing Ctrl-C. This erases the previous\n \
      clipboard content. Then, you can move to another directory, select other files and add them to the clipboard\n \
      content by pressing Shift-Ctrl-C. This does not erase the previous clipboard content. At last, you can move\n \
      to the destination and press Ctrl-V to copy all the files you have in the clipboard. Of course, this also works\n \
      with Ctrl-X and Shift-Ctrl-X to cut and paste the files.\n \
\n \
 Startup notification\n \
    - Startup notification is the process that displays a feedback (a sandbox cursor or whatever) to the user when\n \
      he has started an action (file copying, application launching, etc.). Depending on the system, there can be\n \
      some issues with startup notification. If Xfe was compiled with startup notification support, the user can\n \
      disable it for all applications at the global Preferences level. He can also disable it for individual\n \
      applications, by using the dedicated option in the first tab of the Properties dialog. This latter way is\n \
      only available when the file is an executable. Disabling startup notification can be useful when starting\n \
      an old application that doesn't support the startup notification protocol (e.g. Xterm).\n \
\n \
  Root mode\n \
    - If you use the sudo root mode, it can be useful to add password feedback to the sudo command. For this purpose,\n \
      edit your sudoers file like this:\n \
          sudo visudo -f /etc/suoders\n \
      and then add 'pwfeedback' to the default options, as shown below:\n \
          Defaults         env_reset,pwfeedback\n \
      After that, you should see stars (like *****) when you type your password in the small authentication window.\n \
\n \
\n \
\n \
  Bugs\n \
  =-=-=\n \
\n \
 Please report any found bug to Roland Baudin <roland65@free.fr>. Don't forget to mention the Xfe version you use,\n \
 the FOX library version and your system name and version.\n \
\n \
\n \
\n \
  Translations\n \
  =-=-=-=-=-=-=\n \
 \n \
 Xfe is now available in 24 languages but some translations are only partial. To translate Xfe to your language,\n \
 open the Xfe.pot file located in the po folder of the source tree with a software like poedit, kbabel\n \
 or gtranslator and fill it with your translated strings (be careful to the hotkeys and c-format characters),\n \
 and then send it back to me. I'll be pleased to integrate your work in the next Xfe release.\n \
\n \
\n \
\n \
  Patches\n \
  =-=-=-=\n \
\n \
 If you have coded some interesting patch, please send it to me, I will try to include it in the next release...\n \
\n \
\n \
 Many thanks to Maxim Baranov for his excellent X Win Commander and to all people that have provided useful\n \
 patches, translations, tests and advices.\n \
\n \
 [Last revision: 7/11/2016]\n \
\n \
 ")
;


#endif
#ifndef ICONS_H
#define ICONS_H


// Prototypes
FXbool loadAppIcons(FXApp* app);


// Icons (global variables)
extern FXIcon* archaddicon;
extern FXIcon* archexticon;
extern FXIcon* attribicon;
extern FXIcon* bigattribicon;
extern FXIcon* bigblockdevicon;
extern FXIcon* bigbrokenlinkicon;
extern FXIcon* bigcdromicon;
extern FXIcon* bigchardevicon;
extern FXIcon* bigcompareicon;
extern FXIcon* bigdocicon;
extern FXIcon* bigexecicon;
extern FXIcon* bigfileopenicon;
extern FXIcon* bigfiltericon;
extern FXIcon* bigfloppyicon;
extern FXIcon* bigfolderlockedicon;
extern FXIcon* bigfolderopenicon;
extern FXIcon* bigfoldericon;
extern FXIcon* bigfolderupicon;
extern FXIcon* bigharddiskicon;
extern FXIcon* bigiconsicon;
extern FXIcon* biglinkicon;
extern FXIcon* bignewfileicon;
extern FXIcon* bignewfoldericon;
extern FXIcon* bignewlinkicon;
extern FXIcon* bignfsdriveicon;
extern FXIcon* bignfsdriveumticon;
extern FXIcon* bigpipeicon;
extern FXIcon* bigsocketicon;
extern FXIcon* bigzipicon;
extern FXIcon* cdromicon;
extern FXIcon* charticon;
extern FXIcon* closefileicon;
extern FXIcon* clrbookicon;
extern FXIcon* colltreeicon;
extern FXIcon* copy_bigicon;
extern FXIcon* copy_clpicon;
extern FXIcon* cut_clpicon;
extern FXIcon* delete_big_permicon;
extern FXIcon* delete_bigicon;
extern FXIcon* deselicon;
extern FXIcon* detailsicon;
extern FXIcon* dirupicon;
extern FXIcon* editicon;
extern FXIcon* entericon;
extern FXIcon* errorbigicon;
extern FXIcon* exptreeicon;
extern FXIcon* filedelete_permicon;
extern FXIcon* filedeleteicon;
extern FXIcon* fileopenicon;
extern FXIcon* viewicon;
extern FXIcon* filtericon;
extern FXIcon* compareicon;
extern FXIcon* find_againicon;
extern FXIcon* fliplricon;
extern FXIcon* flipudicon;
extern FXIcon* floppyicon;
extern FXIcon* fontsicon;
extern FXIcon* gotobigicon;
extern FXIcon* gotodiricon;
extern FXIcon* gotolineicon;
extern FXIcon* harddiskicon;
extern FXIcon* helpicon;
extern FXIcon* hidehiddenicon;
extern FXIcon* hidenumbersicon;
extern FXIcon* hidethumbicon;
extern FXIcon* homeicon;
extern FXIcon* infobigicon;
extern FXIcon* invselicon;
extern FXIcon* link_bigicon;
extern FXIcon* locationicon;
extern FXIcon* lowercaseicon;
extern FXIcon* maphosticon;
extern FXIcon* miniappicon;
extern FXIcon* miniblockdevicon;
extern FXIcon* minibrokenlinkicon;
extern FXIcon* minichardevicon;
extern FXIcon* minidocicon;
extern FXIcon* miniexecicon;
extern FXIcon* minifolderclosedicon;
extern FXIcon* minifolderlockedicon;
extern FXIcon* minifolderopenicon;
extern FXIcon* minifoldericon;
extern FXIcon* minifolderupicon;
extern FXIcon* minilinkicon;
extern FXIcon* minipipeicon;
extern FXIcon* minishellicon;
extern FXIcon* minisocketicon;
extern FXIcon* move_bigicon;
extern FXIcon* moveiticon;
extern FXIcon* newfileicon;
extern FXIcon* newfoldericon;
extern FXIcon* nfsdriveicon;
extern FXIcon* nfsdriveumticon;
extern FXIcon* onepanelicon;
extern FXIcon* packageicon;
extern FXIcon* paste_clpicon;
extern FXIcon* prefsicon;
extern FXIcon* printbigicon;
extern FXIcon* printicon;
extern FXIcon* questionbigicon;
extern FXIcon* quiticon;
extern FXIcon* redoicon;
extern FXIcon* reloadicon;
extern FXIcon* renameiticon;
extern FXIcon* replaceicon;
extern FXIcon* reverticon;
extern FXIcon* rotatelefticon;
extern FXIcon* rotaterighticon;
extern FXIcon* runicon;
extern FXIcon* saveasicon;
extern FXIcon* savefileicon;
extern FXIcon* searchnexticon;
extern FXIcon* searchicon;
extern FXIcon* searchprevicon;
extern FXIcon* selallicon;
extern FXIcon* setbookicon;
extern FXIcon* shellicon;
extern FXIcon* showhiddenicon;
extern FXIcon* shownumbersicon;
extern FXIcon* showthumbicon;
extern FXIcon* smalliconsicon;
extern FXIcon* iconsmenuicon;
extern FXIcon* trash_full_bigicon;
extern FXIcon* trash_fullicon;
extern FXIcon* treeonepanelicon;
extern FXIcon* treetwopanelsicon;
extern FXIcon* twopanelsicon;
extern FXIcon* undoicon;
extern FXIcon* unmaphosticon;
extern FXIcon* uppercaseicon;
extern FXIcon* warningbigicon;
extern FXIcon* workicon;
extern FXIcon* wrapofficon;
extern FXIcon* wraponicon;
extern FXIcon* xfeicon;
extern FXIcon* realxfeicon;
extern FXIcon* xfiicon;
extern FXIcon* xfpicon;
extern FXIcon* xfwicon;
extern FXIcon* zipicon;
extern FXIcon* zoom100icon;
extern FXIcon* zoominicon;
extern FXIcon* zoomouticon;
extern FXIcon* zoomwinicon;
extern FXIcon* totrashicon;
extern FXIcon* dirbackicon;
extern FXIcon* dirforwardicon;
extern FXIcon* minixferooticon;
extern FXIcon* minixfeicon;
extern FXIcon* filedialogicon;
extern FXIcon* bigarchaddicon;
extern FXIcon* switchpanelsicon;
extern FXIcon* syncpanelsicon;
extern FXIcon* newlinkicon;
extern FXIcon* greenbuttonicon;
extern FXIcon* graybuttonicon;
extern FXIcon* keybindingsicon;
extern FXIcon* minikeybindingsicon;
extern FXIcon* filerestoreicon;
extern FXIcon* restore_bigicon;
extern FXIcon* horzpanelsicon;
extern FXIcon* vertpanelsicon;
extern FXIcon* comboarrowicon;
extern FXIcon* closeicon;
extern FXIcon* throbicon;
extern FXIcon* throbanimicon;
extern FXIcon* webviewbgicon;

extern FXIcon* tbarchaddicon;
extern FXIcon* tbarchexticon;
extern FXIcon* tbattribicon;
extern FXIcon* tbbigattribicon;
extern FXIcon* tbbigblockdevicon;
extern FXIcon* tbbigbrokenlinkicon;
extern FXIcon* tbbigcdromicon;
extern FXIcon* tbbigchardevicon;
extern FXIcon* tbbigcompareicon;
extern FXIcon* tbbigdocicon;
extern FXIcon* tbbigexecicon;
extern FXIcon* tbbigfileopenicon;
extern FXIcon* tbbigfiltericon;
extern FXIcon* tbbigfloppyicon;
extern FXIcon* tbbigfolderlockedicon;
extern FXIcon* tbbigfolderopenicon;
extern FXIcon* tbbigfoldericon;
extern FXIcon* tbbigfolderupicon;
extern FXIcon* tbbigharddiskicon;
extern FXIcon* tbbigiconsicon;
extern FXIcon* tbbiglinkicon;
extern FXIcon* tbbignewfileicon;
extern FXIcon* tbbignewfoldericon;
extern FXIcon* tbbignewlinkicon;
extern FXIcon* tbbignfsdriveicon;
extern FXIcon* tbbignfsdriveumticon;
extern FXIcon* tbbigpipeicon;
extern FXIcon* tbbigsocketicon;
extern FXIcon* tbbigzipicon;
extern FXIcon* tbcdromicon;
extern FXIcon* tbcharticon;
extern FXIcon* tbclosefileicon;
extern FXIcon* tbclrbookicon;
extern FXIcon* tbcolltreeicon;
extern FXIcon* tbcopy_bigicon;
extern FXIcon* tbcopy_clpicon;
extern FXIcon* tbcut_clpicon;
extern FXIcon* tbdelete_big_permicon;
extern FXIcon* tbdelete_bigicon;
extern FXIcon* tbdeselicon;
extern FXIcon* tbdetailsicon;
extern FXIcon* tbdirupicon;
extern FXIcon* tbediticon;
extern FXIcon* tbentericon;
extern FXIcon* tberrorbigicon;
extern FXIcon* tbexptreeicon;
extern FXIcon* tbfiledelete_permicon;
extern FXIcon* tbfiledeleteicon;
extern FXIcon* tbfileopenicon;
extern FXIcon* tbviewicon;
extern FXIcon* tbfiltericon;
extern FXIcon* tbcompareicon;
extern FXIcon* tbfind_againicon;
extern FXIcon* tbfliplricon;
extern FXIcon* tbflipudicon;
extern FXIcon* tbfloppyicon;
extern FXIcon* tbfontsicon;
extern FXIcon* tbgotobigicon;
extern FXIcon* tbgotodiricon;
extern FXIcon* tbgotolineicon;
extern FXIcon* tbharddiskicon;
extern FXIcon* tbhelpicon;
extern FXIcon* tbhidehiddenicon;
extern FXIcon* tbhidenumbersicon;
extern FXIcon* tbhidethumbicon;
extern FXIcon* tbhomeicon;
extern FXIcon* tbinfobigicon;
extern FXIcon* tbinvselicon;
extern FXIcon* tblink_bigicon;
extern FXIcon* tblocationicon;
extern FXIcon* tblowercaseicon;
extern FXIcon* tbmaphosticon;
extern FXIcon* tbminiappicon;
extern FXIcon* tbminiblockdevicon;
extern FXIcon* tbminibrokenlinkicon;
extern FXIcon* tbminichardevicon;
extern FXIcon* tbminidocicon;
extern FXIcon* tbminiexecicon;
extern FXIcon* tbminifolderclosedicon;
extern FXIcon* tbminifolderlockedicon;
extern FXIcon* tbminifolderopenicon;
extern FXIcon* tbminifoldericon;
extern FXIcon* tbminifolderupicon;
extern FXIcon* tbminilinkicon;
extern FXIcon* tbminipipeicon;
extern FXIcon* tbminishellicon;
extern FXIcon* tbminisocketicon;
extern FXIcon* tbmove_bigicon;
extern FXIcon* tbmoveiticon;
extern FXIcon* tbnewfileicon;
extern FXIcon* tbnewfoldericon;
extern FXIcon* tbnfsdriveicon;
extern FXIcon* tbnfsdriveumticon;
extern FXIcon* tbonepanelicon;
extern FXIcon* tbpackageicon;
extern FXIcon* tbpaste_clpicon;
extern FXIcon* tbprefsicon;
extern FXIcon* tbprintbigicon;
extern FXIcon* tbprinticon;
extern FXIcon* tbquestionbigicon;
extern FXIcon* tbquiticon;
extern FXIcon* tbredoicon;
extern FXIcon* tbreloadicon;
extern FXIcon* tbrenameiticon;
extern FXIcon* tbreplaceicon;
extern FXIcon* tbreverticon;
extern FXIcon* tbrotatelefticon;
extern FXIcon* tbrotaterighticon;
extern FXIcon* tbrunicon;
extern FXIcon* tbsaveasicon;
extern FXIcon* tbsavefileicon;
extern FXIcon* tbsearchnexticon;
extern FXIcon* tbsearchicon;
extern FXIcon* tbsearchprevicon;
extern FXIcon* tbselallicon;
extern FXIcon* tbsetbookicon;
extern FXIcon* tbshellicon;
extern FXIcon* tbshowhiddenicon;
extern FXIcon* tbshownumbersicon;
extern FXIcon* tbshowthumbicon;
extern FXIcon* tbsmalliconsicon;
extern FXIcon* tbiconsmenuicon;
extern FXIcon* tbtrash_full_bigicon;
extern FXIcon* tbtrash_fullicon;
extern FXIcon* tbtreeonepanelicon;
extern FXIcon* tbtreetwopanelsicon;
extern FXIcon* tbtwopanelsicon;
extern FXIcon* tbundoicon;
extern FXIcon* tbunmaphosticon;
extern FXIcon* tbuppercaseicon;
extern FXIcon* tbwarningbigicon;
extern FXIcon* tbworkicon;
extern FXIcon* tbwrapofficon;
extern FXIcon* tbwraponicon;
extern FXIcon* tbxfeicon;
extern FXIcon* tbxfiicon;
extern FXIcon* tbxfpicon;
extern FXIcon* tbxfwicon;
extern FXIcon* tbzipicon;
extern FXIcon* tbzoom100icon;
extern FXIcon* tbzoominicon;
extern FXIcon* tbzoomouticon;
extern FXIcon* tbzoomwinicon;
extern FXIcon* tbtotrashicon;
extern FXIcon* tbdirbackicon;
extern FXIcon* tbdirforwardicon;
extern FXIcon* tbminixferooticon;
extern FXIcon* tbminixfeicon;
extern FXIcon* tbfiledialogicon;
extern FXIcon* tbbigarchaddicon;
extern FXIcon* tbswitchpanelsicon;
extern FXIcon* tbsyncpanelsicon;
extern FXIcon* tbnewlinkicon;
extern FXIcon* tbgreenbuttonicon;
extern FXIcon* tbgraybuttonicon;
extern FXIcon* tbkeybindingsicon;
extern FXIcon* tbminikeybindingsicon;
extern FXIcon* tbfilerestoreicon;
extern FXIcon* tbrestore_bigicon;
extern FXIcon* tbhorzpanelsicon;
extern FXIcon* tbvertpanelsicon;
extern FXIcon* tbcomboarrowicon;
extern FXIcon* tbcloseicon;
extern FXIcon* tbthrobicon;
extern FXIcon* tbthrobanimicon;
extern FXIcon* tbwebviewbgicon;
extern FXIcon* tbcomputericon;
extern FXIcon* webviewxp;


extern FXIcon* resizecorner;

extern FXIcon* arrowicon;
#endif
#ifndef STARTUPNOTIFICATION_H
#define STARTUPNOTIFICATION_H

#include <fx.h>

#ifdef STARTUP_NOTIFICATION

#include "libsn/sn.h"

void startup_completed(void);
Time gettimestamp(Display *display);

int runcmd(FXString, FXString, FXString, FXString, FXbool, FXString);

#else

#include <X11/Xlib.h>

int runcmd(FXString, FXString, FXString);

#endif

#endif
// Common Xfe constants

#ifndef COPYRIGHT
#define COPYRIGHT    "Copyright (C) 2002-2019 Roland Baudin (roland65@free.fr)"
#endif

// Default normal font
#ifndef DEFAULT_NORMAL_FONT
#define DEFAULT_NORMAL_FONT    "Sans,100,normal,regular"
#endif

// Default text font
#ifndef DEFAULT_TEXT_FONT
#define DEFAULT_TEXT_FONT    "Mono,100,normal,regular"
#endif

// Default file and directory list time format
#ifndef DEFAULT_TIME_FORMAT
#define DEFAULT_TIME_FORMAT    "%x %X"
#endif

// Default initial main window width
#ifndef DEFAULT_WINDOW_WIDTH
#define DEFAULT_WINDOW_WIDTH    800
#endif

// Default initial main window heigth
#ifndef DEFAULT_WINDOW_HEIGHT
#define DEFAULT_WINDOW_HEIGHT    600
#endif

// Default initial main window X position
#ifndef DEFAULT_WINDOW_XPOS
#define DEFAULT_WINDOW_XPOS    50
#endif

// Default initial main window Y position
#ifndef DEFAULT_WINDOW_YPOS
#define DEFAULT_WINDOW_YPOS    50
#endif

// Maximum sizes for thumbnail image preview
#ifndef MAX_BIGTHUMB_SIZE
#define MAX_BIGTHUMB_SIZE     64
#endif
#ifndef MAX_MINITHUMB_SIZE
#define MAX_MINITHUMB_SIZE    20
#endif

// Minimum width of a file panel or directory panel
#ifndef MIN_PANEL_WIDTH
#define MIN_PANEL_WIDTH    100
#endif

// Maximum length of a file path
#ifndef MAXPATHLEN
#define MAXPATHLEN    8192
#endif

// Maximum length of a command line
#ifndef MAX_COMMAND_SIZE
#define MAX_COMMAND_SIZE    128
#endif

// Maximum length of a filter pattern
#ifndef MAX_PATTERN_SIZE
#define MAX_PATTERN_SIZE    64
#endif

// Maximum number of characters per line for one line messages
#ifndef MAX_MESSAGE_LENGTH
#define MAX_MESSAGE_LENGTH    96
#endif

// Root directory string
#ifndef ROOTDIR
#define ROOTDIR    "/"
#endif

// Path separator
#ifndef PATHSEPSTRING
#define PATHSEPSTRING    "/"
#endif

// Path separator
#ifndef PATHSEPCHAR
#define PATHSEPCHAR    '/'
#endif

// Maximum number of path links
#ifndef MAX_LINKS
#define MAX_LINKS    128
#endif

// Run history size
#ifndef RUN_HIST_SIZE
#define RUN_HIST_SIZE    30
#endif

// Open with history size
#ifndef OPEN_HIST_SIZE
#define OPEN_HIST_SIZE    30
#endif

// Filter history size
#ifndef FILTER_HIST_SIZE
#define FILTER_HIST_SIZE    30
#endif

#ifdef STARTUP_NOTIFICATION
// If startup notification is used, this is the timeout value (seconds)
#define STARTUP_TIMEOUT    15
#endif

// If startup notification is not used, we use an ugly simulation of a startup time (seconds)
#define SIMULATED_STARTUP_TIME    3

// Local data path
#ifndef DATAPATH
#define DATAPATH    ".local/share"
#endif

// Local config path
#ifndef CONFIGPATH
#define CONFIGPATH    ".config"
#endif

// Xfe config path
#ifndef XFECONFIGPATH
#define XFECONFIGPATH    "xfe"
#endif

// Scripts path
#ifndef SCRIPTPATH
#define SCRIPTPATH    "scripts"
#endif

// Local trashcan directory path
#ifndef TRASHPATH
#define TRASHPATH    "Trash"
#endif

// Local trashcan directory path for files
#ifndef TRASHFILESPATH
#define TRASHFILESPATH    "Trash/files"
#endif

// Local trashcan directory path for infos
#ifndef TRASHINFOPATH
#define TRASHINFOPATH    "Trash/info"
#endif

// Xfe application name
#ifndef XFEAPPNAME
#define XFEAPPNAME    "xfe"
#endif

// Xfe vendor name
#ifndef XFEVDRNAME
#define XFEVDRNAME    "Xfe"
#endif

// Xfe config file name
#ifndef XFECONFIGNAME
#define XFECONFIGNAME    "xferc"
#endif

// Default icon path
#ifndef DEFAULTICONPATH
#define DEFAULTICONPATH    "~/.config/xfe/icons/xfe-theme:/usr/local/share/xfe/icons/xfe-theme:/usr/share/xfe/icons/xfe-theme"
#endif

// Command to launch Xfe as root with sudo or su, using st as a terminal
#ifndef SUDOCMD
#define SUDOCMD    " -g 60x4 -e sudo su -c 'nohup xfe >& /dev/null & sleep 1'"
#endif

#ifndef SUCMD
#define SUCMD    " -g 60x4 -e su -c 'nohup xfe >& /dev/null & sleep 1'"
#endif

// Tooltips setup time and duration
#ifndef TOOLTIP_PAUSE
#define TOOLTIP_PAUSE    500
#endif

#ifndef TOOLTIP_TIME
#define TOOLTIP_TIME    10000
#endif

// Coefficient used to darken the sorted column in detailed mode
#ifndef DARKEN_SORT
#define DARKEN_SORT    0.96
#endif


// Default terminal program
#ifndef DEFAULT_TERMINAL
#define DEFAULT_TERMINAL    "xterm -sb"
#endif


// These have to be the same as in xferc.in

// Default text viewer program
#ifndef DEFAULT_TXTVIEWER
#define DEFAULT_TXTVIEWER    "xfw -r"
#endif

// Default text editor program
#ifndef DEFAULT_TXTEDITOR
#define DEFAULT_TXTEDITOR    "xfw"
#endif

// Default file comparator program
#ifndef DEFAULT_FILECOMPARATOR
#define DEFAULT_FILECOMPARATOR    "meld"
#endif

// Default image editor program
#ifndef DEFAULT_IMGEDITOR
#define DEFAULT_IMGEDITOR    "gimp"
#endif

// Default image viewer program
#ifndef DEFAULT_IMGVIEWER
#define DEFAULT_IMGVIEWER    "xfi"
#endif

// Default archiver program
#ifndef DEFAULT_ARCHIVER
#define DEFAULT_ARCHIVER    "xarchiver"
#endif

// Default PDF viewer program
#ifndef DEFAULT_PDFVIEWER
#define DEFAULT_PDFVIEWER    "xpdf"
#endif

// Default audio player program
#ifndef DEFAULT_AUDIOPLAYER
#define DEFAULT_AUDIOPLAYER    "audacious"
#endif

// Default video player program
#ifndef DEFAULT_VIDEOPLAYER
#define DEFAULT_VIDEOPLAYER    "mplayer"
#endif

// Default mount command
#ifndef DEFAULT_MOUNTCMD
#define DEFAULT_MOUNTCMD    "mount"
#endif

// Default unmount command
#ifndef DEFAULT_UMOUNTCMD
#define DEFAULT_UMOUNTCMD   "umount"
#endif


// FOX hacks

// FXTextField without frame, for clearlooks controls
#define _TEXTFIELD_NOFRAME    0x10000000


// Common macros

// Tab character
#define TAB     (FXString)"\t"
#define TAB2    (FXString)"\t\t"

// Macro to add tab characters before and after a given string
#define TABS(s)    ((FXString)"\t"+(s)+(FXString)"\t")

// Macro to add parentheses before and after a given string
#define PARS(s)    ((FXString)" ("+(s)+(FXString)")")


// Linux specials

#if defined(linux)

// fstab path
#ifndef FSTAB_PATH
#define FSTAB_PATH    "/etc/fstab"
#endif

// mtab path
#ifndef MTAB_PATH
#define MTAB_PATH    "/proc/mounts"
#endif

// Package format
#define DEB_PKG      0
#define RPM_PKG      1
#define OTHER_PKG    2

#endif
#ifndef XFEUTILS_H
#define XFEUTILS_H

// The functions comparenat(), comparewnat(), comparenat_left(), comparenat_right()
// comparewnat_left() and comparewnat_right() for natural sort order
// are adapted from the following software:

/*
 * strnatcmp.c -- Perform 'natural order' comparisons of strings in C.
 * Copyright (C) 2000, 2004 by Martin Pool <mbp sourcefrog net>
 *
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *   claim that you wrote the original software. If you use this software
 *   in a product, an acknowledgment in the product documentation would be
 *   appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *   misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

// The convaccents() function and the accents table are adapted from
// code found here: http://rosettacode.org/wiki/Natural_sorting


#include <errno.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>
#include <ctype.h>
#include <wctype.h>
#include <vector>

#include <fx.h>


// Global variables
#if defined(linux)
extern FXStringDict* mtdevices;
extern FXStringDict* updevices;
#endif


// Vector of strings
typedef std::vector<FXString>   vector_FXString;


// Single click types
enum
{
    SINGLE_CLICK_NONE,
    SINGLE_CLICK_DIR,
    SINGLE_CLICK_DIR_FILE,
};


// Wait cursor states
enum
{
    BEGIN_CURSOR,
    END_CURSOR,
    QUERY_CURSOR
};


// Indexes of default programs
enum
{
    NONE            = 0,
    TXTVIEWER       = 1,
    TXTEDITOR       = 2,
    IMGVIEWER       = 3,
    IMGEDITOR       = 4,
    PDFVIEWER       = 5,
    AUDIOPLAYER     = 6,
    VIDEOPLAYER     = 7,
    ARCHIVER        = 8,
};


// Start directory modes
enum
{
    START_HOMEDIR       = 0,
    START_CURRENTDIR    = 1,
    START_LASTDIR       = 2,
};


// Note : some inline functions must be declared in the header file or they won't compile!


static inline int comparenat_right(const char* a, const char* b)
{
    int bias = 0;

    /* The longest run of digits wins.  That aside, the greatest
     * value wins, but we can't know that it will until we've scanned
     * both numbers to know that they have the same magnitude, so we
     * remember it in BIAS. */
    for ( ; ; a++, b++)
    {
        if (!isdigit(*a) && !isdigit(*b))
        {
            return(bias);
        }
        else if (!isdigit(*a))
        {
            return(-1);
        }
        else if (!isdigit(*b))
        {
            return(+1);
        }
        else if (*a < *b)
        {
            if (!bias)
            {
                bias = -1;
            }
        }
        else if (*a > *b)
        {
            if (!bias)
            {
                bias = +1;
            }
        }
        else if (!*a && !*b)
        {
            return(bias);
        }
    }

    return(0);
}


static inline int comparenat_left(const char* a, const char* b)
{
    /* Compare two left-aligned numbers: the first to have a
     * different value wins. */
    for ( ; ; a++, b++)
    {
        if (!isdigit(*a) && !isdigit(*b))
        {
            return(0);
        }
        else if (!isdigit(*a))
        {
            return(-1);
        }
        else if (!isdigit(*b))
        {
            return(+1);
        }
        else if (*a < *b)
        {
            return(-1);
        }
        else if (*a > *b)
        {
            return(+1);
        }
    }

    return(0);
}


// Perform natural comparison on single byte strings (so foo10 comes after foo2, 0.2foo comes before 10.2foo, etc.)
static inline int comparenat(const char* a, const char* b, FXbool igncase)
{
    int  ai, bi;
    char ca, cb;
    int  fractional, result;

    ai = bi = 0;
    while (1)
    {
        ca = a[ai];
        cb = b[bi];

        if ((ca == '\t') && (cb == '\t'))
        {
            return(0);
        }

        /* skip over leading spaces or zeros */
        while (isspace(ca))
        {
            ca = a[++ai];
        }

        while (isspace(cb))
        {
            cb = b[++bi];
        }

        /* process run of digits */
        if (isdigit(ca) && isdigit(cb))
        {
            fractional = (ca == '0' || cb == '0');

            if (fractional)
            {
                if ((result = comparenat_left(a+ai, b+bi)) != 0)
                {
                    return(result);
                }
            }
            else
            {
                if ((result = comparenat_right(a+ai, b+bi)) != 0)
                {
                    return(result);
                }
            }
        }

        if (!ca && !cb)
        {
            /* The strings compare the same.  Perhaps the caller
             *     will want to call strcmp to break the tie. */
            return(0);
        }

        if (igncase)
        {
            ca = tolower(ca);
            cb = tolower(cb);
        }

        if (ca < cb)
        {
            return(-1);
        }
        else if (ca > cb)
        {
            return(+1);
        }

        ++ai;
        ++bi;
    }
}


// Lookup table of accents and ligatures
// For comparisons,  is converted to A,  to e, etc.
static const wchar_t* const accents[] =   /* copied from Perl6 code */
{
    L"", L"A", L"", L"A", L"", L"A", L"", L"A", L"", L"A", L"", L"A", L"",
    L"a", L"", L"a", L"", L"a", L"", L"a", L"", L"a", L"", L"a",
    L"", L"C", L"", L"c", L"", L"E", L"", L"E", L"", L"E", L"",
    L"E", L"", L"e", L"", L"e", L"", L"e", L"", L"e", L"",
    L"I", L"", L"I", L"", L"I", L"", L"I", L"", L"i", L"",
    L"i", L"", L"i", L"", L"i", L"", L"O", L"", L"O", L"",
    L"O", L"", L"O", L"", L"O", L"", L"O", L"", L"o", L"", L"o",
    L"", L"o", L"", L"o", L"", L"o", L"", L"o", L"", L"N", L"", L"n",
    L"", L"U", L"", L"U", L"", L"U", L"", L"U", L"", L"u", L"", L"u",
    L"", L"u", L"", L"u", L"", L"Y", L"", L"y", L"", L"y",
    L"", L"TH", L"", L"th", L"", L"TH", L"", L"th",
    L"", L"AE", L"", L"ae", L"", L"ss",
    L"", L"ffl", L"", L"ffi", L"", L"fi", L"", L"ff", L"", L"fl",
    L"", L"s", L"", L"z", L"", L"st", L"", L"oe", /* ... come on ... */
};


// Convert accents and ligatures to Ascii for comparison purpose
// So when comparing wide chars,  is evaluated as A,  as e, etc.
static inline wchar_t convaccents(const wchar_t wc, const wchar_t* const* tbl, int len)
{
    // Don't convert an Ascii char
    if (wc < 127)
    {
        return(wc);
    }

    wchar_t wr = wc;

    // Search the lookup table
    // and get the converted char if any
    for (int n = 0; n < len; n += 2)
    {
        if (wc != tbl[n][0])
        {
            continue;
        }
        else
        {
            wr = tbl[n+1][0];
            break;
        }
    }

    return(wr);
}


static inline int comparewnat_right(const wchar_t* wa, const wchar_t* wb)
{
    int bias = 0;

    /* The longest run of digits wins.  That aside, the greatest
     * value wins, but we can't know that it will until we've scanned
     * both numbers to know that they have the same magnitude, so we
     * remember it in BIAS. */
    for ( ; ; wa++, wb++)
    {
        if (!iswdigit(*wa) && !iswdigit(*wb))
        {
            return(bias);
        }
        else if (!iswdigit(*wa))
        {
            return(-1);
        }
        else if (!iswdigit(*wb))
        {
            return(+1);
        }
        else if (*wa < *wb)
        {
            if (!bias)
            {
                bias = -1;
            }
        }
        else if (*wa > *wb)
        {
            if (!bias)
            {
                bias = +1;
            }
        }
        else if (!*wa && !*wb)
        {
            return(bias);
        }
    }

    return(0);
}


static inline int comparewnat_left(const wchar_t* wa, const wchar_t* wb)
{
    /* Compare two left-aligned numbers: the first to have a
     * different value wins. */
    for ( ; ; wa++, wb++)
    {
        if (!iswdigit(*wa) && !iswdigit(*wb))
        {
            return(0);
        }
        else if (!iswdigit(*wa))
        {
            return(-1);
        }
        else if (!iswdigit(*wb))
        {
            return(+1);
        }
        else if (*wa < *wb)
        {
            return(-1);
        }
        else if (*wa > *wb)
        {
            return(+1);
        }
    }

    return(0);
}


// Perform natural comparison on wide strings (so foo10 comes after foo2, 0.2foo comes before 10.2foo, etc.)
static inline int comparewnat(const wchar_t* wa, const wchar_t* wb, int igncase)
{
    wint_t  ai, bi;
    wchar_t wca, wcb;
    int     fractional, result;

    ai = bi = 0;
    while (1)
    {
        wca = wa[ai];
        wcb = wb[bi];

        /* skip over leading spaces or zeros */
        while (iswspace(wca))
        {
            wca = wa[++ai];
        }

        while (iswspace(wcb))
        {
            wcb = wb[++bi];
        }

        /* convert accents  */
        wca = convaccents(wca, accents, sizeof(accents)/sizeof(wchar_t*));
        wcb = convaccents(wcb, accents, sizeof(accents)/sizeof(wchar_t*));

        /* process run of digits */
        if (iswdigit(wca) && iswdigit(wcb))
        {
            fractional = (wca == L'0' || wcb == L'0');

            if (fractional)
            {
                if ((result = comparewnat_left(wa+ai, wb+bi)) != 0)
                {
                    return(result);
                }
            }
            else
            {
                if ((result = comparewnat_right(wa+ai, wb+bi)) != 0)
                {
                    return(result);
                }
            }
        }

        if (!wca && !wcb)
        {
            /* The strings compare the same.  Perhaps the caller
             *     will want to call strcmp to break the tie. */
            return(0);
        }

        if (igncase)
        {
            wca = towlower(wca);
            wcb = towlower(wcb);
        }

        if (wca < wcb)
        {
            return(-1);
        }
        else if (wca > wcb)
        {
            return(+1);
        }

        ++ai;
        ++bi;
    }
}


// Convert a character to lower case
static inline int toLower(int c)
{
    return('A' <= c && c <= 'Z' ? c + 32 : c);
}


// To test if two strings are equal (strcmp replacement, thanks to Francesco Abbate)
static inline int streq(const char* a, const char* b)
{
    if ((a == NULL) || (b == NULL))
    {
        return(0);
    }
    return(strcmp(a, b) == 0);
}


// Convert a string to lower cases and returns the string size
static inline void strlow(char* str)
{
    while (*str)
    {
        *str = ::toLower(*str);
        ++str;
    }
}


// Replacement of the stat function
static inline int statrep(const char* filename, struct stat* buf)
{
#if defined(linux)
    static int ret;

    // It's a mount point
    if (mtdevices->find(filename))
    {
        // Mount point is down
        if (streq(updevices->find(filename), "down"))
        {
            return(-1);
        }

        // Mount point is up
        else
        {
            ret = stat(filename, buf);
            if ((ret == -1) && (errno != EACCES))
            {
                updevices->remove(filename);
                updevices->insert(filename, "down");
            }
            return(ret);
        }
    }

    // It's not a mount point
    else
#endif
    return(stat(filename, buf));
}


// Replacement of the lstat function
static inline int lstatrep(const char* filename, struct stat* buf)
{
#if defined(linux)
    static int ret;

    // It's a mount point
    if (mtdevices->find(filename))
    {
        // Mount point is down
        if (streq(updevices->find(filename), "down"))
        {
            return(-1);
        }

        // Mount point is up
        else
        {
            ret = lstat(filename, buf);
            if ((ret == -1) && (errno != EACCES))
            {
                updevices->remove(filename);
                updevices->insert(filename, "down");
            }
            return(ret);
        }
    }

    // It's not a mount point
    else
#endif
    return(lstat(filename, buf));
}


FXHotKey _parseAccel(const FXString&);
FXbool existCommand(const FXString);
FXString getKeybinding(FXEvent*);

int mkpath(const char*, mode_t);
FXString createTrashpathname(FXString, FXString);
int createTrashinfo(FXString, FXString, FXString, FXString);
FXString mimetype(FXString);
FXString quote(FXString);
FXbool isUtf8(const char*, FXuint);
int statrep(const char*, struct stat*);
int lstatrep(const char*, struct stat*);

#if defined(linux)
int lstatmt(const char*, struct stat*);

#endif
size_t strlcpy(char*, const char*, size_t);
size_t strlcat(char*, const char*, size_t);
FXulong dirsize(const char*);
FXulong pathsize(char*, FXuint*, FXuint*, FXulong*, int* =  NULL);
FXString hSize(char*);
FXString cleanPath(const FXString);
FXString filePath(const FXString);
FXString filePath(const FXString, const FXString);

FXString fileFromURI(FXString);
FXString fileToURI(const FXString&);
FXString buildCopyName(const FXString&);

FXlong deltime(FXString);
int isEmptyDir(const FXString);
int hasSubDirs(const FXString);
FXbool exists(const FXString&);
FXbool isDirectory(const FXString&);
FXbool isFile(const FXString&);

FXbool isGroupMember(gid_t);
FXbool isWritable(const FXString&);
FXbool isReadable(const FXString&);
FXbool isReadExecutable(const FXString&);
FXbool isLink(const FXString&);
FXbool info(const FXString&, struct stat&);

FXString permissions(FXuint);
FXString readLink(const FXString&);
FXbool identical(const FXString&, const FXString&);

int setWaitCursor(FXApp*, FXuint);
int runst(FXString);
FXString getCommandOutput(FXString);
FXIcon* loadiconfile(FXApp*, const FXString, const FXString, FXColor blendcolor = -1, int arrow = 0);
FXIcon* loadxbmiconfile(FXApp*, const FXString, const FXString, FXColor blendcolor = -1);

FXString truncLine(FXString, FXuint);
FXString multiLines(FXString, FXuint);

#endif
// Input dialog for the add to archive command

#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <fxkeys.h>

#include "icons.h"
#include "xfeutils.h"
#include "FileDialog.h"
#include "ArchInputDialog.h"



FXDEFMAP(ArchInputDialog) ArchInputDialogMap[] =
{
    FXMAPFUNC(SEL_KEYPRESS, 0, ArchInputDialog::onCmdKeyPress),
    FXMAPFUNC(SEL_COMMAND, ArchInputDialog::ID_BROWSE_PATH, ArchInputDialog::onCmdBrowsePath),
    FXMAPFUNCS(SEL_COMMAND, ArchInputDialog::ID_FORMAT_TAR_GZ, ArchInputDialog::ID_FORMAT_Z, ArchInputDialog::onCmdOption),
    FXMAPFUNCS(SEL_UPDATE, ArchInputDialog::ID_FORMAT_TAR_GZ, ArchInputDialog::ID_FORMAT_Z, ArchInputDialog::onUpdOption),
};


// Object implementation
FXIMPLEMENT(ArchInputDialog, DialogBox, ArchInputDialogMap, ARRAYNUMBER(ArchInputDialogMap))

// Construct a dialog box
ArchInputDialog::ArchInputDialog(FXWindow* win, FXString inp) :
    DialogBox(win, _("Add To Archive"), DECOR_TITLE|DECOR_BORDER|DECOR_STRETCHABLE|DECOR_MAXIMIZE|DECOR_CLOSE)
{
    // Buttons
    FXHorizontalFrame* buttons = new FXHorizontalFrame(this, PACK_UNIFORM_WIDTH|LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X, 0, 0, 0, 0, 10, 10, 5, 5);

    // Accept
    new FXButton(buttons, _("&Accept"), NULL, this, ID_ACCEPT, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT, 0, 0, 0, 0, 20, 20);

    // Cancel
    new FXButton(buttons, _("&Cancel"), NULL, this, ID_CANCEL, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT, 0, 0, 0, 0, 20, 20);

    // Vertical frame
    FXVerticalFrame* contents = new FXVerticalFrame(this, LAYOUT_SIDE_TOP|FRAME_NONE|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Icon and message line
    FXMatrix* matrix = new FXMatrix(contents, 2, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix, "", bigarchaddicon, LAYOUT_LEFT);
    new FXLabel(matrix, _("New archive name:"), NULL, JUSTIFY_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);

    // Label and input field
    FXMatrix* matrix3 = new FXMatrix(contents, 2, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    input = new FXTextField(matrix3, 40, 0, 0, LAYOUT_CENTER_Y|LAYOUT_CENTER_X|FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    input->setText(inp);
    if (!isUtf8(inp.text(), inp.length()))
    {
        new FXLabel(contents, _("=> Warning: file name is not UTF-8 encoded!"), NULL, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW);
    }
    new FXButton(matrix3, _("\tSelect destination..."), filedialogicon, this, ID_BROWSE_PATH, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);

    // Select archive format
    FXMatrix* matrix4 = new FXMatrix(contents, 2, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix4, _("Format:"), NULL, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW);
    popup = new FXPopup(this);
    option_tgz = new FXOption(popup, _("tar.gz\tArchive format is tar.gz"), NULL, this, ID_FORMAT_TAR_GZ, JUSTIFY_HZ_APART|ICON_AFTER_TEXT);
    option_zip = new FXOption(popup, _("zip\tArchive format is zip"), NULL, this, ID_FORMAT_ZIP, JUSTIFY_HZ_APART|ICON_AFTER_TEXT);
    option_7zip = new FXOption(popup, _("7z\tArchive format is 7z"), NULL, this, ID_FORMAT_7ZIP, JUSTIFY_HZ_APART|ICON_AFTER_TEXT);
    option_tbz2 = new FXOption(popup, _("tar.bz2\tArchive format is tar.bz2"), NULL, this, ID_FORMAT_TAR_BZ2, JUSTIFY_HZ_APART|ICON_AFTER_TEXT);
    option_txz = new FXOption(popup, _("tar.xz\tArchive format is tar.xz"), NULL, this, ID_FORMAT_TAR_XZ, JUSTIFY_HZ_APART|ICON_AFTER_TEXT);
    option_tar = new FXOption(popup, _("tar\tArchive format is tar"), NULL, this, ID_FORMAT_TAR, JUSTIFY_HZ_APART|ICON_AFTER_TEXT);
    option_taz = new FXOption(popup, _("tar.Z\tArchive format is tar.Z"), NULL, this, ID_FORMAT_TAR_Z, JUSTIFY_HZ_APART|ICON_AFTER_TEXT);
    option_gz = new FXOption(popup, _("gz\tArchive format is gz"), NULL, this, ID_FORMAT_GZ, JUSTIFY_HZ_APART|ICON_AFTER_TEXT);
    option_bz2 = new FXOption(popup, _("bz2\tArchive format is bz2"), NULL, this, ID_FORMAT_BZ2, JUSTIFY_HZ_APART|ICON_AFTER_TEXT);
    option_xz = new FXOption(popup, _("xz\tArchive format is xz"), NULL, this, ID_FORMAT_XZ, JUSTIFY_HZ_APART|ICON_AFTER_TEXT);
    option_z = new FXOption(popup, _("Z\tArchive format is Z"), NULL, this, ID_FORMAT_Z, JUSTIFY_HZ_APART|ICON_AFTER_TEXT);
    optionmenu = new FXOptionMenu(matrix4, popup, LAYOUT_TOP|FRAME_RAISED|FRAME_THICK|JUSTIFY_HZ_APART|ICON_AFTER_TEXT);
}


void ArchInputDialog::create()
{
    DialogBox::create();
    input->setFocus();
}


ArchInputDialog::~ArchInputDialog()
{
    delete popup;
}


long ArchInputDialog::onCmdKeyPress(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    switch (event->code)
    {
    case KEY_Escape:
        handle(this, FXSEL(SEL_COMMAND, ID_CANCEL), NULL);
        return(1);

    case KEY_KP_Enter:
    case KEY_Return:
        handle(this, FXSEL(SEL_COMMAND, ID_ACCEPT), NULL);
        return(1);

    default:
        FXTopWindow::onKeyPress(sender, sel, ptr);
        return(1);
    }
    return(0);
}


long ArchInputDialog::onCmdBrowsePath(FXObject* o, FXSelector s, void* p)
{
    // File dialog
    FileDialog browse(this, _("Select a destination folder"));

    const char* patterns[] =
    {
        _("All Files"), "*", NULL
    };
    FXString archname = FXPath::name(input->getText());

    browse.setPatternList(patterns);

    // Browse files in mixed mode
    browse.setSelectMode(SELECT_FILE_DIRECTORY);
    if (browse.execute())
    {
        FXString path = browse.getFilename();
        input->setText(path + PATHSEPSTRING + archname);
    }

    return(1);
}


// Archive option
long ArchInputDialog::onCmdOption(FXObject*, FXSelector sel, void*)
{
    // Get extensions of the archive name
    FXString str = input->getText();
    FXString ext1 = str.rafter('.', 1).lower();
    FXString ext2 = str.rafter('.', 2).lower();

    if (FXSELID(sel) == ID_FORMAT_TAR_GZ)
    {
        // Handle the different archive formats
        if ((ext2 == "tar.gz") || (ext1 == "tgz"))
        {
            input->setText(str);
        }
        else if (ext2 == "tar.bz2")
        {
            str = str.left(str.length()-8);
            str = str+".tar.gz";
            input->setText(str);
        }
        else if (ext2 == "tar.xz")
        {
            str = str.left(str.length()-7);
            str = str+".tar.gz";
            input->setText(str);
        }
        else if (ext2 == "tar.z")
        {
            str = str.left(str.length()-6);
            str = str+".tar.gz";
            input->setText(str);
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            str = str.left(str.length()-5);
            str = str+".tar.gz";
            input->setText(str);
        }
        else if ((ext1 == "txz") || (ext1 == "taz") || (ext1 == "bz2") || (ext1 == "tar") || (ext1 == "zip"))
        {
            str = str.left(str.length()-4);
            str = str+".tar.gz";
            input->setText(str);
        }
        else if ((ext1 == "xz") || (ext1 == "7z") || (ext1 == "gz"))
        {
            str = str.left(str.length()-3);
            str = str+".tar.gz";
            input->setText(str);
        }
        else if (ext1 == "z")
        {
            str = str.left(str.length()-2);
            str = str+".tar.gz";
            input->setText(str);
        }
        else
        {
            str = str+".tar.gz";
            input->setText(str);
        }
    }

    else if (FXSELID(sel) == ID_FORMAT_TAR_BZ2)
    {
        // Handle different archive formats
        if ((ext2 == "tar.bz2") || (ext1 == "tbz2") || (ext1 == "tbz"))
        {
            input->setText(str);
        }
        else if ((ext2 == "tar.gz") || (ext2 == "tar.xz"))
        {
            str = str.left(str.length()-7);
            str = str+".tar.bz2";
            input->setText(str);
        }
        else if (ext2 == "tar.z")
        {
            str = str.left(str.length()-6);
            str = str+".tar.bz2";
            input->setText(str);
        }
        else if ((ext1 == "tgz") || (ext1 == "txz") || (ext1 == "taz") || (ext1 == "bz2") || (ext1 == "tar") || (ext1 == "zip"))
        {
            str = str.left(str.length()-4);
            str = str+".tar.bz2";
            input->setText(str);
        }
        else if ((ext1 == "gz") || (ext1 == "7z") || (ext1 == "xz"))
        {
            str = str.left(str.length()-3);
            str = str+".tar.bz2";
            input->setText(str);
        }
        else if (ext1 == "z")
        {
            str = str.left(str.length()-2);
            str = str+".tar.bz2";
            input->setText(str);
        }
        else
        {
            str = str+".tar.bz2";
            input->setText(str);
        }
    }

    else if (FXSELID(sel) == ID_FORMAT_TAR_XZ)
    {
        // Handle different archive formats
        if ((ext2 == "tar.xz") || (ext1 == "txz"))
        {
            input->setText(str);
        }
        else if (ext2 == "tar.bz2")
        {
            str = str.left(str.length()-8);
            str = str+".tar.xz";
            input->setText(str);
        }
        else if (ext2 == "tar.gz")
        {
            str = str.left(str.length()-7);
            str = str+".tar.xz";
            input->setText(str);
        }
        else if (ext2 == "tar.z")
        {
            str = str.left(str.length()-6);
            str = str+".tar.xz";
            input->setText(str);
        }
        else if ((ext1 == "tgz") || (ext1 == "bz2") || (ext1 == "taz") || (ext1 == "tar") || (ext1 == "zip"))
        {
            str = str.left(str.length()-4);
            str = str+".tar.xz";
            input->setText(str);
        }
        else if ((ext1 == "gz") || (ext1 == "7z") || (ext1 == "xz"))
        {
            str = str.left(str.length()-3);
            str = str+".tar.xz";
            input->setText(str);
        }
        else if (ext1 == "z")
        {
            str = str.left(str.length()-2);
            str = str+".tar.xz";
            input->setText(str);
        }
        else
        {
            str = str+".tar.xz";
            input->setText(str);
        }
    }

    else if (FXSELID(sel) == ID_FORMAT_TAR)
    {
        // Handle different archive formats
        if ((ext1 == "tar") && (ext2 != "tar.gz") && (ext2 != "tar.bz2") && (ext2 != "tar.z") && (ext2 != "tar.xz"))
        {
            input->setText(str);
        }
        else if (ext2 == "tar.bz2")
        {
            str = str.left(str.length()-8);
            str = str+".tar";
            input->setText(str);
        }
        else if ((ext2 == "tar.gz") || (ext2 == "tar.xz"))
        {
            str = str.left(str.length()-7);
            str = str+".tar";
            input->setText(str);
        }
        else if (ext2 == "tar.z")
        {
            str = str.left(str.length()-6);
            str = str+".tar";
            input->setText(str);
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            str = str.left(str.length()-5);
            str = str+".tar";
            input->setText(str);
        }
        else if ((ext1 == "tgz") || (ext1 == "txz") || (ext1 == "taz") || (ext1 == "bz2") || (ext1 == "zip"))
        {
            str = str.left(str.length()-4);
            str = str+".tar";
            input->setText(str);
        }
        else if ((ext1 == "gz") || (ext1 == "7z") || (ext1 == "xz"))
        {
            str = str.left(str.length()-3);
            str = str+".tar";
            input->setText(str);
        }
        else if (ext1 == "z")
        {
            str = str.left(str.length()-2);
            str = str+".tar";
            input->setText(str);
        }
        else
        {
            str = str+".tar";
            input->setText(str);
        }
    }

    else if (FXSELID(sel) == ID_FORMAT_TAR_Z)
    {
        // Handle different archive formats
        if ((ext2 == "tar.Z") || (ext1 == "taz"))
        {
            input->setText(str);
        }
        else if (ext2 == "tar.bz2")
        {
            str = str.left(str.length()-8);
            str = str+".tar.Z";
            input->setText(str);
        }
        else if ((ext2 == "tar.gz") || (ext2 == "tar.xz"))
        {
            str = str.left(str.length()-7);
            str = str+".tar.Z";
            input->setText(str);
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            str = str.left(str.length()-5);
            str = str+".tar.Z";
            input->setText(str);
        }
        else if ((ext1 == "tgz") || (ext1 == "txz") || (ext1 == "bz2") || (ext1 == "tar") || (ext1 == "zip"))
        {
            str = str.left(str.length()-4);
            str = str+".tar.Z";
            input->setText(str);
        }
        else if ((ext1 == "gz") || (ext1 == "7z") || (ext1 == "xz"))
        {
            str = str.left(str.length()-3);
            str = str+".tar.Z";
            input->setText(str);
        }
        else if (ext1 == "z")
        {
            str = str.left(str.length()-2);
            str = str+".tar.Z";
            input->setText(str);
        }
        else
        {
            str = str+".tar.Z";
            input->setText(str);
        }
    }

    else if (FXSELID(sel) == ID_FORMAT_GZ)
    {
        // Handle different archive formats
        if ((ext1 == "gz") && (ext2 != "tar.gz"))
        {
            input->setText(str);
        }
        else if (ext2 == "tar.bz2")
        {
            str = str.left(str.length()-8);
            str = str+".gz";
            input->setText(str);
        }
        else if ((ext2 == "tar.gz") || (ext2 == "tar.xz"))
        {
            str = str.left(str.length()-7);
            str = str+".gz";
            input->setText(str);
        }
        else if (ext2 == "tar.z")
        {
            str = str.left(str.length()-6);
            str = str+".gz";
            input->setText(str);
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            str = str.left(str.length()-5);
            str = str+".gz";
            input->setText(str);
        }
        else if ((ext1 == "tgz") || (ext1 == "txz") || (ext1 == "taz") || (ext1 == "bz2") || (ext1 == "tar") || (ext1 == "zip"))
        {
            str = str.left(str.length()-4);
            str = str+".gz";
            input->setText(str);
        }
        else if ((ext1 == "xz") || (ext1 == "7z"))
        {
            str = str.left(str.length()-3);
            str = str+".gz";
            input->setText(str);
        }
        else if (ext1 == "z")
        {
            str = str.left(str.length()-2);
            str = str+".gz";
            input->setText(str);
        }
        else
        {
            str = str+".gz";
            input->setText(str);
        }
    }

    else if (FXSELID(sel) == ID_FORMAT_XZ)
    {
        // Handle different archive formats
        if ((ext1 == "xz") && (ext2 != "tar.xz"))
        {
            input->setText(str);
        }
        else if (ext2 == "tar.bz2")
        {
            str = str.left(str.length()-8);
            str = str+".xz";
            input->setText(str);
        }
        else if ((ext2 == "tar.gz") || (ext2 == "tar.xz"))
        {
            str = str.left(str.length()-7);
            str = str+".xz";
            input->setText(str);
        }
        else if (ext2 == "tar.z")
        {
            str = str.left(str.length()-6);
            str = str+".xz";
            input->setText(str);
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            str = str.left(str.length()-5);
            str = str+".xz";
            input->setText(str);
        }
        else if ((ext1 == "tgz") || (ext1 == "txz") || (ext1 == "taz") || (ext1 == "bz2") || (ext1 == "tar") || (ext1 == "zip"))
        {
            str = str.left(str.length()-4);
            str = str+".xz";
            input->setText(str);
        }
        else if (ext1 == "7z")
        {
            str = str.left(str.length()-3);
            str = str+".xz";
            input->setText(str);
        }
        else if (ext1 == "z")
        {
            str = str.left(str.length()-2);
            str = str+".xz";
            input->setText(str);
        }
        else
        {
            str = str+".xz";
            input->setText(str);
        }
    }

    else if (FXSELID(sel) == ID_FORMAT_BZ2)
    {
        // Handle different archive formats
        if ((ext1 == "bz2") && (ext2 != "tar.bz2"))
        {
            str = str.left(str.length()-8);
            input->setText(str);
        }
        if (ext2 == "tar.bz2")
        {
            str = str.left(str.length()-8);
            str = str+".bz2";
            input->setText(str);
        }
        else if ((ext2 == "tar.gz") || (ext2 == "tar.xz"))
        {
            str = str.left(str.length()-7);
            str = str+".bz2";
            input->setText(str);
        }
        else if (ext2 == "tar.z")
        {
            str = str.left(str.length()-6);
            str = str+".bz2";
            input->setText(str);
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            str = str.left(str.length()-5);
            str = str+".bz2";
            input->setText(str);
        }
        else if ((ext1 == "tgz") || (ext1 == "txz") || (ext1 == "taz") || (ext1 == "tar") || (ext1 == "zip"))
        {
            str = str.left(str.length()-4);
            str = str+".bz2";
            input->setText(str);
        }
        else if ((ext1 == "gz") || (ext1 == "xz") || (ext1 == "7z"))
        {
            str = str.left(str.length()-3);
            str = str+".bz2";
            input->setText(str);
        }
        else if (ext1 == "z")
        {
            str = str.left(str.length()-2);
            str = str+".bz2";
            input->setText(str);
        }
        else
        {
            str = str+".bz2";
            input->setText(str);
        }
    }

    else if (FXSELID(sel) == ID_FORMAT_Z)
    {
        // Handle different archive formats
        if ((ext1 == "z") && (ext2 != "tar.z"))
        {
            input->setText(str);
        }
        else if (ext2 == "tar.bz2")
        {
            str = str.left(str.length()-8);
            str = str+".Z";
            input->setText(str);
        }
        else if ((ext2 == "tar.gz") || (ext2 == "tar.xz"))
        {
            str = str.left(str.length()-7);
            str = str+".Z";
            input->setText(str);
        }
        else if (ext2 == "tar.z")
        {
            str = str.left(str.length()-6);
            str = str+".Z";
            input->setText(str);
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            str = str.left(str.length()-5);
            str = str+".Z";
            input->setText(str);
        }
        else if ((ext1 == "tgz") || (ext1 == "bz2") || (ext1 == "taz") || (ext1 == "txz") || (ext1 == "tar") || (ext1 == "zip"))
        {
            str = str.left(str.length()-4);
            str = str+".Z";
            input->setText(str);
        }
        else if ((ext1 == "gz") || (ext1 == "7z") || (ext1 == "xz"))
        {
            str = str.left(str.length()-3);
            str = str+".Z";
            input->setText(str);
        }
        else
        {
            str = str+".Z";
            input->setText(str);
        }
    }

    else if (FXSELID(sel) == ID_FORMAT_ZIP)
    {
        // Handle different archive formats
        if (ext1 == "zip")
        {
            input->setText(str);
        }
        else if (ext2 == "tar.bz2")
        {
            str = str.left(str.length()-8);
            str = str+".zip";
            input->setText(str);
        }
        else if ((ext2 == "tar.gz") || (ext2 == "tar.xz"))
        {
            str = str.left(str.length()-7);
            str = str+".zip";
            input->setText(str);
        }
        else if (ext2 == "tar.z")
        {
            str = str.left(str.length()-6);
            str = str+".zip";
            input->setText(str);
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            str = str.left(str.length()-5);
            str = str+".zip";
            input->setText(str);
        }
        else if ((ext1 == "tgz") || (ext1 == "bz2") || (ext1 == "taz") || (ext1 == "txz") || (ext1 == "tar"))
        {
            str = str.left(str.length()-4);
            str = str+".zip";
            input->setText(str);
        }
        else if ((ext1 == "gz") || (ext1 == "7z") || (ext1 == "xz"))
        {
            str = str.left(str.length()-3);
            str = str+".zip";
            input->setText(str);
        }
        else if (ext1 == "z")
        {
            str = str.left(str.length()-2);
            str = str+".zip";
            input->setText(str);
        }
        else
        {
            str = str+".zip";
            input->setText(str);
        }
    }

    else if (FXSELID(sel) == ID_FORMAT_7ZIP)
    {
        // Handle different archive formats
        if (ext1 == "7z")
        {
            input->setText(str);
        }
        else if (ext2 == "tar.bz2")
        {
            str = str.left(str.length()-8);
            str = str+".7z";
            input->setText(str);
        }
        else if ((ext2 == "tar.gz") || (ext2 == "tar.xz"))
        {
            str = str.left(str.length()-7);
            str = str+".7z";
            input->setText(str);
        }
        else if (ext2 == "tar.z")
        {
            str = str.left(str.length()-6);
            str = str+".7z";
            input->setText(str);
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            str = str.left(str.length()-5);
            str = str+".7z";
            input->setText(str);
        }
        else if ((ext1 == "tgz") || (ext1 == "bz2") || (ext1 == "taz") || (ext1 == "txz") || (ext1 == "tar") || (ext1 == "zip"))
        {
            str = str.left(str.length()-4);
            str = str+".7z";
            input->setText(str);
        }
        else if ((ext1 == "gz") || (ext1 == "xz"))
        {
            str = str.left(str.length()-3);
            str = str+".7z";
            input->setText(str);
        }
        else if (ext1 == "z")
        {
            str = str.left(str.length()-2);
            str = str+".7z";
            input->setText(str);
        }
        else
        {
            str = str+".7z";
            input->setText(str);
        }
    }

    return(1);
}


// Option
long ArchInputDialog::onUpdOption(FXObject*, FXSelector sel, void*)
{
    // Get extensions of the archive name
    FXString str = input->getText();
    FXString ext1 = str.rafter('.', 1).lower();
    FXString ext2 = str.rafter('.', 2).lower();

    // Handle the different archive formats
    if ((ext2 == "tar.gz") || (ext1 == "tgz"))
    {
        optionmenu->setCurrent(option_tgz);
    }
    else if ((ext2 == "tar.bz2") || (ext1 == "tbz2") || (ext1 == "tbz"))
    {
        optionmenu->setCurrent(option_tbz2);
    }
    else if ((ext2 == "tar.xz") || (ext1 == "txz"))
    {
        optionmenu->setCurrent(option_txz);
    }
    else if ((ext2 == "tar.z") || (ext1 == "taz"))
    {
        optionmenu->setCurrent(option_taz);
    }
    else if ((ext2 == "") || (ext1 == "tar"))
    {
        optionmenu->setCurrent(option_tar);
    }
    else if (ext1 == "gz")
    {
        optionmenu->setCurrent(option_gz);
    }
    else if (ext1 == "bz2")
    {
        optionmenu->setCurrent(option_bz2);
    }
    else if (ext1 == "xz")
    {
        optionmenu->setCurrent(option_xz);
    }
    else if (ext1 == "z")
    {
        optionmenu->setCurrent(option_z);
    }
    else if (ext1 == "zip")
    {
        optionmenu->setCurrent(option_zip);
    }
    else if (ext1 == "7z")
    {
        optionmenu->setCurrent(option_7zip);
    }
    else
    {
        optionmenu->setCurrent(option_tgz);
    }

    return(1);
}
// Bookmarks list. Taken from the FOX library (FXRecentFiles) and slightly modified.

#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>

#include <fx.h>

#include "MessageBox.h"
#include "Bookmarks.h"


// Maximum bookmarks number
// If modified, also change appropriate items in BookmarksMap
// and in onUpdBookmark and Bookmarks.h
#define MAX_BOOKMARKS    21



// Message map
FXDEFMAP(Bookmarks) BookmarksMap[] =
{
    FXMAPFUNC(SEL_UPDATE, Bookmarks::ID_ANYBOOKMARKS, Bookmarks::onUpdAnyBookmarks),
    FXMAPFUNC(SEL_UPDATE, Bookmarks::ID_CLEAR, Bookmarks::onUpdAnyBookmarks),
    FXMAPFUNC(SEL_COMMAND, Bookmarks::ID_CLEAR, Bookmarks::onCmdClear),
    FXMAPFUNCS(SEL_COMMAND, Bookmarks::ID_BOOKMARK_1, Bookmarks::ID_BOOKMARK_20, Bookmarks::onCmdBookmark),
    FXMAPFUNCS(SEL_UPDATE, Bookmarks::ID_BOOKMARK_1, Bookmarks::ID_BOOKMARK_20, Bookmarks::onUpdBookmark),
};

// Class implementation
FXIMPLEMENT(Bookmarks, FXObject, BookmarksMap, ARRAYNUMBER(BookmarksMap))


// Make new Bookmarks group with default group
Bookmarks::Bookmarks() : group("Bookmarks"), target(NULL), message(0), maxbookmarks(MAX_BOOKMARKS)
{
}


// Make new Bookmarks group
Bookmarks::Bookmarks(const FXString& gp, FXObject* tgt, FXSelector sel) : group(gp), target(tgt), message(sel), maxbookmarks(MAX_BOOKMARKS)
{
}


// Obtain the bookmark at index
FXString Bookmarks::getBookmark(int index) const
{
    char key[20];

    snprintf(key, sizeof(key)-1, "BOOKMARK%d", index);
    return(FXApp::instance()->reg().readStringEntry(group.text(), key, FXString::null));
}


// Change the bookmark at index
void Bookmarks::setBookmark(int index, const FXString& bookname)
{
    char key[20];

    snprintf(key, sizeof(key)-1, "BOOKMARK%d", index);
    FXApp::instance()->reg().writeStringEntry(group.text(), key, bookname.text());
}


// Append a bookmark; its added to the top of the list, and everything else
// is moved down the list one notch; the last one is dropped from the list.
void Bookmarks::appendBookmark(const FXString& bookname)
{
    FXString newname = bookname;
    FXString oldname;
    char     key[20];
    int      i = 1, j = 1;

    FXApp::instance()->reg().read();
    do
    {
        do
        {
            snprintf(key, sizeof(key)-1, "BOOKMARK%d", j++);
            oldname = FXApp::instance()->reg().readStringEntry(group.text(), key, NULL);
        } while (oldname == bookname);
        snprintf(key, sizeof(key)-1, "BOOKMARK%d", i++);
        FXApp::instance()->reg().writeStringEntry(group.text(), key, newname.text());
        newname = oldname;
        if (i > MAX_BOOKMARKS)
        {
            MessageBox::warning(FXApp::instance()->getActiveWindow(), BOX_OK, _("Warning"),
                                _("Bookmarks limit number reached. The last bookmark will be deleted..."));
        }
    } while (!oldname.empty() && i <= maxbookmarks);

    FXApp::instance()->reg().write();
}


// Remove a bookmark
void Bookmarks::removeBookmark(const FXString& bookname)
{
    char     key[20];
    FXString name;
    int      i = 1, j = 1;

    do
    {
        snprintf(key, sizeof(key)-1, "BOOKMARK%d", i++);
        name = FXApp::instance()->reg().readStringEntry(group.text(), key, NULL);
        FXApp::instance()->reg().deleteEntry(group.text(), key);
        if (name.empty())
        {
            break;
        }
        if (name != bookname)
        {
            snprintf(key, sizeof(key)-1, "BOOKMARK%d", j++);
            FXApp::instance()->reg().writeStringEntry(group.text(), key, name.text());
        }
    } while (i <= maxbookmarks);
}


// Remove all bookmarks from the list
void Bookmarks::clear()
{
    FXApp::instance()->reg().read();
    FXApp::instance()->reg().deleteSection(group.text());
    FXApp::instance()->reg().write();
}


// Clear the bookmarks list
long Bookmarks::onCmdClear(FXObject*, FXSelector, void*)
{
    if (BOX_CLICKED_CANCEL == MessageBox::question(FXApp::instance()->getActiveWindow(), BOX_OK_CANCEL,
                                                   _("Confirm Clear Bookmarks"), _("Do you really want to clear all your bookmarks?")))
    {
        return(0);
    }
    else
    {
        clear();
    }

    return(1);
}


// User clicks on one of the bookmark names
long Bookmarks::onCmdBookmark(FXObject*, FXSelector sel, void*)
{
    const char* bookname;
    char        key[20];

    if (target)
    {
        snprintf(key, sizeof(key)-1, "BOOKMARK%d", (FXSELID(sel)-ID_BOOKMARK_1+1));
        bookname = FXApp::instance()->reg().readStringEntry(group.text(), key, NULL);
        if (bookname)
        {
            target->handle(this, FXSEL(SEL_COMMAND, message), (void*)bookname);
        }
    }
    return(1);
}


// Update handler for same
long Bookmarks::onUpdBookmark(FXObject* sender, FXSelector sel, void*)
{
    int         which = FXSELID(sel)-ID_BOOKMARK_1+1;
    const char* bookname = NULL;
    FXString    string;
    char        key[20];
    char        _char[11] = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k' };

    snprintf(key, sizeof(key)-1, "BOOKMARK%d", which);
    bookname = FXApp::instance()->reg().readStringEntry(group.text(), key, NULL);
    if (bookname)
    {
        FXString string;

        // Keyboard shortcut is 1, 2, 3...
        if (which < 10)
        {
            string.format("&%d %s", which, bookname);
        }

        // Keyboard shortcut is a, b, c...
        else if (which < MAX_BOOKMARKS)
        {
            string.format("&%c %s", _char[which-10], bookname);
        }

        // Should not be used
        else
        {
            string.format("2&0 %s", bookname);
        }
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_SETSTRINGVALUE), (void*)&string);
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_SHOW), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_HIDE), NULL);
    }
    return(1);
}


// Show or hide depending on whether there are any bookmarks
long Bookmarks::onUpdAnyBookmarks(FXObject* sender, FXSelector, void*)
{
    FXApp::instance()->reg().deleteSection(group.text());
    FXApp::instance()->reg().read();
    if (FXApp::instance()->reg().readStringEntry(group.text(), "BOOKMARK1", NULL))
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_SHOW), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_HIDE), NULL);
    }

    return(1);
}


// Destructor
Bookmarks::~Bookmarks()
{
    target = (FXObject*)-1L;
}
// Input dialog with file browse icon

#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <fxkeys.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "FileDialog.h"
#include "TextLabel.h"
#include "BrowseInputDialog.h"


extern FXString homedir;


FXDEFMAP(BrowseInputDialog) BrowseInputDialogMap[] =
{
    FXMAPFUNC(SEL_KEYPRESS, 0, BrowseInputDialog::onCmdKeyPress),
    FXMAPFUNC(SEL_COMMAND, BrowseInputDialog::ID_BROWSE_PATH, BrowseInputDialog::onCmdBrowsePath),
};

// Object implementation
FXIMPLEMENT(BrowseInputDialog, DialogBox, BrowseInputDialogMap, ARRAYNUMBER(BrowseInputDialogMap))

// Construct a dialog box
BrowseInputDialog::BrowseInputDialog(FXWindow* win, FXString inp, FXString message, FXString title, FXString label, FXIcon* ic, FXuint browse, FXbool option, FXString optiontext) :
    DialogBox(win, title, DECOR_TITLE|DECOR_BORDER|DECOR_STRETCHABLE|DECOR_MAXIMIZE|DECOR_CLOSE)
{
    // Browse type flag
    browsetype = browse;

    // Buttons
    FXHorizontalFrame* buttons = new FXHorizontalFrame(this, PACK_UNIFORM_WIDTH|LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X, 0, 0, 0, 0, 10, 10, 5, 5);

    // Accept
    new FXButton(buttons, _("&Accept"), NULL, this, ID_ACCEPT, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT, 0, 0, 0, 0, 20, 20);

    // Cancel
    new FXButton(buttons, _("&Cancel"), NULL, this, ID_CANCEL, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT, 0, 0, 0, 0, 20, 20);

    // Optional check box
    checkbutton = new FXHorizontalFrame(this, JUSTIFY_RIGHT|LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X, 0, 0, 0, 0, 10, 10, 0, 0);

    if (option)
    {
        new FXCheckButton(checkbutton, optiontext, this, ID_TOGGLE_OPTION);
    }

    // Vertical frame
    FXVerticalFrame* contents = new FXVerticalFrame(this, LAYOUT_SIDE_TOP|FRAME_NONE|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Icon and text label
    // Note : we display the message in a TextLabel. This allows to copy/paste the file name to the input text field
    FXMatrix* matrix1 = new FXMatrix(contents, 2, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    iconlabel = new FXLabel(matrix1, "", ic, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW);
    msg = new TextLabel(matrix1, 30, 0, 0, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW|FRAME_NONE);
    msg->setText(message);
    msg->setBackColor(getApp()->getBaseColor());

    // Label and input field
    FXMatrix* matrix2 = new FXMatrix(contents, 3, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix2, label, NULL, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW);
    input = new FXTextField(matrix2, 40, 0, 0, LAYOUT_CENTER_Y|LAYOUT_CENTER_X|FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    input->setText(inp);
    new FXButton(matrix2, _("\tSelect destination..."), filedialogicon, this, ID_BROWSE_PATH, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    if (!isUtf8(message.text(), message.length()))
    {
        new FXLabel(contents, _("=> Warning: file name is not UTF-8 encoded!"), NULL, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW);
    }

    // Initial directory for browsing
    initialdir = homedir;
}


void BrowseInputDialog::create()
{
    DialogBox::create();
    input->setFocus();
}


BrowseInputDialog::~BrowseInputDialog()
{
    delete input;
    delete msg;
    delete iconlabel;
}


long BrowseInputDialog::onCmdKeyPress(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    switch (event->code)
    {
    case KEY_Escape:
        handle(this, FXSEL(SEL_COMMAND, ID_CANCEL), NULL);
        return(1);

    case KEY_KP_Enter:
    case KEY_Return:
        handle(this, FXSEL(SEL_COMMAND, ID_ACCEPT), NULL);
        return(1);

    default:
        FXTopWindow::onKeyPress(sender, sel, ptr);
        return(1);
    }
    return(0);
}


long BrowseInputDialog::onCmdBrowsePath(FXObject* o, FXSelector s, void* p)
{
    FXString title;

    if (browsetype == BROWSE_INPUT_FOLDER)
    {
        title = _("Select a destination folder");
    }
    else if (browsetype == BROWSE_INPUT_FILE)
    {
        title = _("Select a file");
    }
    else
    {
        title = _("Select a file or a destination folder");
    }

    // File dialog
    FileDialog browse(this, title);

    const char* patterns[] =
    {
        _("All Files"), "*", NULL
    };

    browse.setDirectory(initialdir);
    browse.setPatternList(patterns);

    // Browse files in directory or mixed mode depending on the flag
    if (browsetype == BROWSE_INPUT_FOLDER)
    {
        browse.setSelectMode(SELECT_FILE_DIRECTORY);
    }
    else if (browsetype == BROWSE_INPUT_FILE)
    {
        browse.setSelectMode(SELECT_FILE_EXISTING);
    }
    else
    {
        browse.setSelectMode(SELECT_FILE_MIXED);
    }

    if (browse.execute())
    {
        FXString path = browse.getFilename();
        input->setText(path);
    }

    return(1);
}


// Adjust message size
void BrowseInputDialog::setMessage(FXString message)
{
    // Compute the equivalent size in number of columns of '8' of the message string,
    // taking into account the real size of the font characters
    FXFont* font = getApp()->getNormalFont();
    int     nbcols = (int)ceil((double)font->getTextWidth(message) / (double)font->getCharWidth('8'));

    // Tricks to adjust the dialog width to the real text size
    this->setWidth(1);
    if (message.length() > MAX_MESSAGE_LENGTH)
    {
        msg->setNumColumns(MAX_MESSAGE_LENGTH);
    }
    else
    {
        msg->setNumColumns(nbcols);
    }
    msg->setText(message);
}


// Set initial directory
void BrowseInputDialog::setDirectory(const FXString& path)
{
    initialdir = path;
}


FXString BrowseInputDialog::getText()
{
    return(input->getText());
}


void BrowseInputDialog::setText(const FXString& text)
{
    input->setText(text);
}


// Change dialog icon
void BrowseInputDialog::setIcon(FXIcon* icon)
{
    iconlabel->setIcon(icon);
}


void BrowseInputDialog::selectAll()
{
    input->setSelection(0, (input->getText()).length());
}


void BrowseInputDialog::CursorEnd()
{
    input->onCmdCursorEnd(0, 0, 0);
}


void BrowseInputDialog::setSelection(int pos, int len)
{
    input->setSelection(pos, len);
}
// Command window object
// Executes a command and returns the results in the command window
// Close button to close the window (but not kill the child process)
// Cancel button to kill the child process (but not close the window)
// The object deletes itself when the close button is pressed
// The command window can be a free-floating window or can be
// a window which will always float over the owner window

#include "config.h"
#include "i18n.h"

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>

#include <fx.h>

#include "xfedefs.h"
#include "icons.h"
#include "MessageBox.h"
#include "CommandWindow.h"
#include "xfedefs.h"
#include "XFileExplorer.h"

// Map
FXDEFMAP(CommandWindow) CommandWindowMap[] =
{
    FXMAPFUNC(SEL_COMMAND, CommandWindow::ID_CLOSE, CommandWindow::onCmdClose),
    FXMAPFUNC(SEL_COMMAND, CommandWindow::ID_KILLPROCESS, CommandWindow::onCmdKillProcess),
    FXMAPFUNC(SEL_UPDATE, CommandWindow::ID_KILLPROCESS, CommandWindow::onUpdKillProcess),
    FXMAPFUNC(SEL_UPDATE, CommandWindow::ID_CLOSE, CommandWindow::onUpdClose),
    FXMAPFUNC(SEL_CHORE, CommandWindow::ID_WATCHPROCESS, CommandWindow::onWatchProcess),
};


// Object implementation
FXIMPLEMENT(CommandWindow, DialogBox, CommandWindowMap, ARRAYNUMBER(CommandWindowMap))


// Construct window which will always float over the owner window
CommandWindow::CommandWindow(FXWindow* owner, const FXString& name, FXString strcmd, int nblines, int nbcols) :
    DialogBox(owner, name, DECOR_TITLE|DECOR_BORDER|DECOR_RESIZE|DECOR_MAXIMIZE|DECOR_CLOSE, 0, 0, 0, 0, 6, 6, 6, 6, 4, 4)
{
    // Get command to execute
    command = strcmd;

    // Bottom part
    FXHorizontalFrame* buttonbox = new FXHorizontalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|PACK_UNIFORM_WIDTH);
    new FXButton(buttonbox, _("Cl&ose"), NULL, this, ID_CLOSE, BUTTON_DEFAULT|LAYOUT_RIGHT|FRAME_RAISED|FRAME_THICK, 0, 0, 0, 0, 20, 20, 5, 5);
    FXButton* cancelbutton = new FXButton(buttonbox, _("&Cancel"), NULL, this, ID_KILLPROCESS, BUTTON_INITIAL|BUTTON_DEFAULT|LAYOUT_RIGHT|FRAME_RAISED|FRAME_THICK, 0, 0, 0, 0, 20, 20, 5, 5);

    // Text part
    FXHorizontalFrame* textbox = new FXHorizontalFrame(this, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_SUNKEN|FRAME_THICK, 0, 0, 0, 0, 0, 0, 0, 0);
    text = new FXText(textbox, NULL, 0, TEXT_READONLY|TEXT_WORDWRAP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    text->setVisibleRows(nblines);
    text->setVisibleColumns(nbcols);

	appendText(_("Please wait...\n\n"));


    cancelbutton->setFocus();

    // Initialize variables
    pid = -1;
    killed = false;
    closed = false;
}


// Construct free-floating window
CommandWindow::CommandWindow(FXApp* a, const FXString& name, FXString strcmd, int nblines, int nbcols) :
    DialogBox(a, name, DECOR_TITLE|DECOR_BORDER|DECOR_RESIZE|DECOR_MAXIMIZE|DECOR_MINIMIZE|DECOR_CLOSE, 0, 0, 0, 0, 6, 6, 6, 6, 4, 4)
{
    // Get command to execute
    command = strcmd;

    // Bottom part
    FXHorizontalFrame* buttonbox = new FXHorizontalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|PACK_UNIFORM_WIDTH);
    new FXButton(buttonbox, _("Cl&ose"), NULL, this, ID_CLOSE, BUTTON_DEFAULT|LAYOUT_RIGHT|FRAME_RAISED|FRAME_THICK, 0, 0, 0, 0, 20, 20, 5, 5);
    FXButton* cancelbutton = new FXButton(buttonbox, _("&Cancel"), NULL, this, ID_KILLPROCESS, BUTTON_INITIAL|BUTTON_DEFAULT|LAYOUT_RIGHT|FRAME_RAISED|FRAME_THICK, 0, 0, 0, 0, 20, 20, 5, 5);

    // Text part
    FXHorizontalFrame* textbox = new FXHorizontalFrame(this, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_SUNKEN|FRAME_THICK, 0, 0, 0, 0, 0, 0, 0, 0);
    text = new FXText(textbox, NULL, 0, TEXT_READONLY|TEXT_WORDWRAP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    text->setVisibleRows(nblines);
    text->setVisibleColumns(nbcols);

	appendText(_("Please wait...\n\n"));

    cancelbutton->setFocus();

    // Initialize variables
    pid = -1;
    killed = false;
    closed = false;
}


// Make window
void CommandWindow::create()
{
    // Set text font
    FXString fontspec;

    fontspec = getApp()->reg().readStringEntry("SETTINGS", "textfont", DEFAULT_TEXT_FONT);
    if (!fontspec.empty())
    {
        FXFont* font = new FXFont(getApp(), fontspec);
        font->create();
        text->setFont(font);
    }

    DialogBox::create();
    show(PLACEMENT_OWNER);

    // Execute command
    execCmd(command.text());
}


// Kill process when clicking on the cancel button
long CommandWindow::onCmdKillProcess(FXObject*, FXSelector, void*)
{
    kill((-1*pid), SIGTERM); // Kills the process group
    killed = true;
    return(0);
}


// Update cancel button
long CommandWindow::onUpdKillProcess(FXObject* sender, FXSelector, void*)
{
    FXButton* btn = (FXButton*)sender;

    if (!getApp()->hasChore(this, ID_WATCHPROCESS))
    {
        btn->disable();
    }
    else
    {
        btn->enable();
    }
    return(1);
}


// Update close button
long CommandWindow::onUpdClose(FXObject* sender, FXSelector, void*)
{
    FXButton* btn = (FXButton*)sender;

    if (!getApp()->hasChore(this, ID_WATCHPROCESS))
    {
        btn->enable();
    }
    else
    {
        btn->disable();
    }
    return(1);
}


// Execute a command and capture its output
int CommandWindow::execCmd(FXString command)
{
    // Open pipes to communicate with child process
    if (pipe(pipes) == -1)
    {
        return(-1);
    }

    // Create child process
    pid = fork();
    if (pid == -1)
    {
        fprintf(stderr, _("Error: Fork failed: %s\n"), strerror(errno));
        return(-1);
    }
    if (pid == 0) // Child
    {
        char* args[4];
        int   ret1 = dup2(pipes[0], STDIN_FILENO);   // Use the pipes as the new channels
        int   ret2 = dup2(pipes[1], STDOUT_FILENO);  // (where stdout and stderr
        int   ret3 = dup2(pipes[1], STDERR_FILENO);  // go to the same pipe!).

        if ((ret1 < 0) || (ret2 < 0) || (ret3 < 0))
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't duplicate pipes: %s"), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't duplicate pipes"));
            }

            return(-1);
        }

        args[0] = (char*)"sh";           // Setup arguments
        args[1] = (char*)"-vc";          // to run command (option -v to display the command to execute)
        args[2] = (char*)command.text(); // in a shell in
        args[3] = NULL;                  // a new process.
        setpgid(0, 0);                   // Allows to kill the whole group
        execvp(args[0], args);           // Start a new process which will execute the command.
        _exit(EXIT_FAILURE);             // We'll get here only if an error occurred.
    }
    else // Parent
    {
        // Make sure we get called so we can check when child has finished
        getApp()->addChore(this, ID_WATCHPROCESS);
    }
    return(0);
}


// Watch progress of child process
long CommandWindow::onWatchProcess(FXObject*, FXSelector, void*)
{
    char buf[1024];
    int  nread;

    if (closed)
    {
        // The close button was pressed : just close the pipes
        // and delete the object

        // Close pipes
        ::close(pipes[0]);
        ::close(pipes[1]);

        // Object deletes itself!
        delete this;
    }

    else if ((waitpid(pid, NULL, WNOHANG) == 0))
    {
        // Child is still running, just wait
        getApp()->addChore(this, ID_WATCHPROCESS);

        // Read data from the running child (first, set I-O to non-blocking)
        int pflags;
        if ((pflags = fcntl(pipes[0], F_GETFL)) >= 0)
        {
            pflags |= O_NONBLOCK;
            if (fcntl(pipes[0], F_SETFL, pflags) >= 0)
            {
                // Now read the data from the pipe
                while ((nread = read(pipes[0], buf, sizeof(buf)-1)) > 0)
                {
                    buf[nread] = '\0';
                    // Remove backspace characters, if any
                    FXString strbuf = buf;
                    strbuf = strbuf.substitute("\b", ".");
                    text->appendText(strbuf.text(), strlen(strbuf.text()));
                    scrollToLastLine();
                    if (nread < (int)(sizeof(buf)-1))
                    {
                        break;
                    }
                }
            }
        }
    }

    else
    {
        // Child has finished.
        // Read data from the finished child
        while ((nread = read(pipes[0], buf, sizeof(buf)-1)) > 0)
        {
            buf[nread] = '\0';
            // Remove backspace characters, if any
            FXString strbuf = buf;
            strbuf = strbuf.substitute("\b", ".");
            text->appendText(strbuf.text(), strlen(strbuf.text()));
            scrollToLastLine();
            if (nread < (int)(sizeof(buf)-1))
            {
                break;
            }
        }
        if (killed)
        {
            appendText(_("\n>>>> COMMAND CANCELLED <<<<"));
        }
        else
        {
            appendText(_("\n>>>> END OF COMMAND <<<<"));
        }
        scrollToLastLine();

        // Close pipes
        ::close(pipes[0]);
        ::close(pipes[1]);
    }

    return(1);
}


// Close dialog when clicking on the close button
long CommandWindow::onCmdClose(FXObject*, FXSelector, void*)
{
    getApp()->stopModal(this, true);
    hide();
    closed = true;

    // Object deletes itself
    delete this;

    return(1);
}


// Change the text in the buffer to new text
void CommandWindow::setText(const char* str)
{
    text->setText(str, strlen(str));
    getApp()->repaint();
}


// Append new text at the end of the buffer
void CommandWindow::appendText(const char* str)
{
    text->appendText(str, strlen(str));
    getApp()->repaint();
}


// Scroll to the last line
void CommandWindow::scrollToLastLine(void)
{
    text->makePositionVisible(text->getLength());
    getApp()->repaint();
}


// Get text length
int CommandWindow::getLength(void)
{
    return(text->getLength());
}


// Clean up
CommandWindow::~CommandWindow()
{
    getApp()->removeChore(this, ID_WATCHPROCESS);

    text = (FXText*)-1;
}
// Dialog Box with additional toggle option
#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <fxkeys.h>

#include "DialogBox.h"



// Map
FXDEFMAP(DialogBox) DialogBoxMap[] =
{
    FXMAPFUNC(SEL_KEYPRESS, 0, DialogBox::onKeyPress),
	FXMAPFUNC(SEL_KEYRELEASE,0,DialogBox::onKeyRelease),
    FXMAPFUNC(SEL_CLOSE, 0, DialogBox::onClose),
    FXMAPFUNC(SEL_COMMAND, DialogBox::ID_CANCEL, DialogBox::onCmdCancel),
    FXMAPFUNC(SEL_COMMAND, DialogBox::ID_ACCEPT, DialogBox::onCmdAccept),
    FXMAPFUNC(SEL_COMMAND, DialogBox::ID_TOGGLE_OPTION, DialogBox::onCmdToggleOption)
};


// Object implementation
FXIMPLEMENT(DialogBox, FXTopWindow, DialogBoxMap, ARRAYNUMBER(DialogBoxMap))


// Contruct dialog which will stay on top of owner
DialogBox::DialogBox(FXWindow* win, const FXString& name, FXuint opts, int x, int y, int w, int h, int pl, int pr, int pt, int pb, int hs, int vs) :
    FXTopWindow(win, name, NULL, NULL, opts, x, y, w, h, pl, pr, pt, pb, hs, vs)
{
    _option = 0;
}


// Contruct free floating dialog
DialogBox::DialogBox(FXApp* a, const FXString& name, FXuint opts, int x, int y, int w, int h, int pl, int pr, int pt, int pb, int hs, int vs) :
    FXTopWindow(a, name, NULL, NULL, opts, x, y, w, h, pl, pr, pt, pb, hs, vs)
{
    _option = 0;
}


// Close window & cancel out of dialog
long DialogBox::onClose(FXObject*, FXSelector, void*)
{
    if (target && target->handle(this, FXSEL(SEL_CLOSE, message), NULL))
    {
        return(1);
    }
    handle(this, FXSEL(SEL_COMMAND, DialogBox::ID_CANCEL), NULL);
    return(1);
}


// Close dialog with an accept
long DialogBox::onCmdAccept(FXObject*, FXSelector, void*)
{
    getApp()->stopModal(this, true);
    hide();
    return(1);
}


// Close dialog with a cancel
long DialogBox::onCmdCancel(FXObject*, FXSelector, void*)
{
    getApp()->stopModal(this, false);
    hide();
    return(1);
}


// Toggle option
long DialogBox::onCmdToggleOption(FXObject*, FXSelector, void*)
{
    _option = !_option;
    return(1);
}


// Get option state
FXuint DialogBox::getOption()
{
    return(_option);
}


// Create window
void DialogBox::create()
{
    FXTopWindow::create();
}


// Show window such that the cursor is in it
void DialogBox::show(FXuint placement)
{
    int    rw, rh, wx, wy, ww, wh, x, y;
    FXuint state;

    // Get dialog size
    translateCoordinatesTo(wx, wy, getRoot(), 0, 0);
    ww = getWidth();
    wh = getHeight();

    // Where's the mouse?
    getRoot()->getCursorPosition(x, y, state);

    // Place such that mouse in the middle
    if ((x < wx) || (y < wy) || (wx+ww <= x) || (wy+wh <= y))
    {
        // Get root window size
        rw = getRoot()->getWidth();
        rh = getRoot()->getHeight();

        // Move by the minimal amount
        if (x < wx)
        {
            wx = x-20;
        }
        else if (wx+ww <= x)
        {
            wx = x-ww+20;
        }
        if (y < wy)
        {
            wy = y-20;
        }
        else if (wy+wh <= y)
        {
            wy = y-wh+20;
        }

        // Adjust so dialog is fully visible
        if (wx < 0)
        {
            wx = 10;
        }
        if (wy < 0)
        {
            wy = 10;
        }
        if (wx+ww > rw)
        {
            wx = rw-ww-10;
        }
        if (wy+wh > rh)
        {
            wy = rh-wh-10;
        }

        move(wx, wy);
    }

    // Pop the window
    FXTopWindow::show(placement);
}


// Keyboard press; handle escape and return to close the dialog
long DialogBox::onKeyPress(FXObject* sender, FXSelector sel, void* ptr)
{
    if (FXTopWindow::onKeyPress(sender, sel, ptr))
    {
        return(1);
    }
    if (((FXEvent*)ptr)->code == KEY_Escape)
    {
        handle(this, FXSEL(SEL_COMMAND, ID_CANCEL), NULL);
        return(1);
    }



    FXEvent* event = (FXEvent*)ptr;

    switch (event->code)
    {
    case KEY_Escape:
        handle(this, FXSEL(SEL_COMMAND, ID_CANCEL), NULL);
        return(1);

    case KEY_KP_Enter:
    case KEY_Return:
        handle(this, FXSEL(SEL_COMMAND, ID_ACCEPT), NULL);
        return(1);

    default:
        FXTopWindow::onKeyPress(sender, sel, ptr);
        return(1);
    }




    return(0);
}

// Keyboard release; handle escape to close the dialog
long DialogBox::onKeyRelease(FXObject* sender,FXSelector sel,void* ptr)
{
	if(FXTopWindow::onKeyRelease(sender,sel,ptr))
	{
		return 1;
	}

	if(((FXEvent*)ptr)->code==KEY_Escape)
	{
		return 1;
	}
	return 0;
}


// Execute dialog box modally
FXuint DialogBox::execute(FXuint placement)
{
    create();
    show(placement);
    getApp()->refresh();
    return(getApp()->runModalFor(this));
}
// Display a history list box and allows the user to select a string
// This is based on FXChoiceBox

#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <fxkeys.h>

#include "xfedefs.h"
#include "DirHistBox.h"


#define VISIBLE_LINES    10


// Map
FXDEFMAP(DirHistBox) DirHistBoxMap[] =
{
    FXMAPFUNC(SEL_KEYPRESS, 0, DirHistBox::onKeyPress),
    FXMAPFUNC(SEL_KEYRELEASE, 0, DirHistBox::onKeyRelease),
    FXMAPFUNC(SEL_FOCUSOUT, 0, DirHistBox::onCmdClose),
    FXMAPFUNC(SEL_COMMAND, DirHistBox::ID_CLOSE, DirHistBox::onCmdClose),
    FXMAPFUNC(SEL_CLICKED, DirHistBox::ID_CLICKED, DirHistBox::onCmdClicked),
};


// Object implementation
FXIMPLEMENT(DirHistBox, DialogBox, DirHistBoxMap, ARRAYNUMBER(DirHistBoxMap))


// Construct list box with given caption, icon, message text, and with choices from array of strings
DirHistBox::DirHistBox(FXWindow* owner, const char** choices, FXuint opts, int x, int y, int w, int h) :
    DialogBox(owner, "", opts, x, y, w, h, 0, 0, 0, 0, 0, 0)
{
    register int       n;
    FXHorizontalFrame* hor = new FXHorizontalFrame(this, FRAME_RAISED|FRAME_THICK|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    list = new FXList(hor, this, ID_CLICKED, LIST_BROWSESELECT|LAYOUT_FILL_Y|LAYOUT_FILL_X|HSCROLLING_OFF);
    list->setBackColor(this->getBackColor());
    n = list->fillItems(choices);
    list->setNumVisible(FXMIN(n, VISIBLE_LINES));
}


// Construct list box with given caption, icon, message text, and with choices from newline separated strings
DirHistBox::DirHistBox(FXWindow* owner, const FXString& choices, FXuint opts, int x, int y, int w, int h) :
    DialogBox(owner, "", opts, x, y, w, h, 0, 0, 0, 0, 0, 0)
{
    register int       n;
    FXHorizontalFrame* hor = new FXHorizontalFrame(this, FRAME_RAISED|FRAME_THICK|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    list = new FXList(hor, this, ID_CLICKED, LIST_BROWSESELECT|LAYOUT_FILL_Y|LAYOUT_FILL_X|HSCROLLING_OFF);
    list->setBackColor(this->getBackColor());
    n = list->fillItems(choices);
    list->setNumVisible(FXMIN(n, VISIBLE_LINES));
}


// Select item when click in list
long DirHistBox::onCmdClicked(FXObject*, FXSelector, void*)
{
    getApp()->stopModal(this, list->getCurrentItem());
    hide();
    return(1);
}


// Close dialog
long DirHistBox::onCmdClose(FXObject*, FXSelector, void*)
{
    getApp()->stopModal(this, -1);
    hide();
    return(1);
}


// Destroy list box
DirHistBox::~DirHistBox()
{
    list = (FXList*)-1L;
}


// Show a modal list dialog
int DirHistBox::box(FXWindow* owner, FXuint opts, const char** choices, int x, int y, int w, int h)
{
    DirHistBox box(owner, choices, opts, x, y, w, h);

    return(box.execute(PLACEMENT_DEFAULT));
}


// Show a modal list dialog
int DirHistBox::box(FXWindow* owner, FXuint opts, const FXString& choices, int x, int y, int w, int h)
{
    DirHistBox box(owner, choices, opts, x, y, w, h);

    return(box.execute(PLACEMENT_DEFAULT));
}


// Keyboard press; handle escape to close the dialog
long DirHistBox::onKeyPress(FXObject* sender, FXSelector sel, void* ptr)
{
    if (FXTopWindow::onKeyPress(sender, sel, ptr))
    {
        return(1);
    }
    if (((FXEvent*)ptr)->code == KEY_Escape)
    {
        handle(this, FXSEL(SEL_COMMAND, ID_CLOSE), NULL);
        return(1);
    }
    return(0);
}


// Keyboard release; handle escape to close the dialog
long DirHistBox::onKeyRelease(FXObject* sender, FXSelector sel, void* ptr)
{
    if (FXTopWindow::onKeyRelease(sender, sel, ptr))
    {
        return(1);
    }
    if (((FXEvent*)ptr)->code == KEY_Escape)
    {
        return(1);
    }
    return(0);
}
// Directory list. Taken from the FOX library and slightly modified.
// The compare(), compare_nolocale() and compare_locale() functions are adapted from a patch
// submitted by Vladimir Tmara Patio

#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <FXPNGIcon.h>
#if defined(linux)
#include <mntent.h>
#endif

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "File.h"
#include "FileDict.h"
#include "InputDialog.h"
#include "MessageBox.h"
#include "XFileExplorer.h"
#include "DirList.h"


#include <wchar.h>
#include <errno.h>
#include <stdbool.h>


// Interval between updevices and mtdevices read (s)
#define UPDEVICES_INTERVAL    300
#define MTDEVICES_INTERVAL    5

// Interval between refreshes (ms)
#define REFRESH_INTERVAL      1000

// File systems not supporting mod-time, refresh every nth time
#define REFRESH_FREQUENCY     30

// Time interval before expanding a folder (ms)
#define EXPAND_INTERVAL       500

// Global variables
#if defined(linux)
extern FXStringDict* fsdevices;
extern FXStringDict* mtdevices;
extern FXStringDict* updevices;
#endif

extern FXbool   allowPopupScroll;
extern FXString xdgdatahome;


// Object implementation
FXIMPLEMENT(DirItem, FXTreeItem, NULL, 0)



// Map
FXDEFMAP(DirList) DirListMap[] =
{
    FXMAPFUNC(SEL_DRAGGED, 0, DirList::onDragged),
    FXMAPFUNC(SEL_TIMEOUT, DirList::ID_REFRESH_TIMER, DirList::onCmdRefreshTimer),
#if defined(linux)
    FXMAPFUNC(SEL_TIMEOUT, DirList::ID_MTDEVICES_REFRESH, DirList::onMtdevicesRefresh),
    FXMAPFUNC(SEL_TIMEOUT, DirList::ID_UPDEVICES_REFRESH, DirList::onUpdevicesRefresh),
#endif
    FXMAPFUNC(SEL_TIMEOUT, DirList::ID_EXPAND_TIMER, DirList::onExpandTimer),
    FXMAPFUNC(SEL_DND_ENTER, 0, DirList::onDNDEnter),
    FXMAPFUNC(SEL_DND_LEAVE, 0, DirList::onDNDLeave),
    FXMAPFUNC(SEL_DND_DROP, 0, DirList::onDNDDrop),
    FXMAPFUNC(SEL_DND_MOTION, 0, DirList::onDNDMotion),
    FXMAPFUNC(SEL_DND_REQUEST, 0, DirList::onDNDRequest),
    FXMAPFUNC(SEL_BEGINDRAG, 0, DirList::onBeginDrag),
    FXMAPFUNC(SEL_ENDDRAG, 0, DirList::onEndDrag),
    FXMAPFUNC(SEL_OPENED, 0, DirList::onOpened),
    FXMAPFUNC(SEL_CLOSED, 0, DirList::onClosed),
    FXMAPFUNC(SEL_EXPANDED, 0, DirList::onExpanded),
    FXMAPFUNC(SEL_COLLAPSED, 0, DirList::onCollapsed),
    FXMAPFUNC(SEL_UPDATE, DirList::ID_SHOW_HIDDEN, DirList::onUpdShowHidden),
    FXMAPFUNC(SEL_UPDATE, DirList::ID_HIDE_HIDDEN, DirList::onUpdHideHidden),
    FXMAPFUNC(SEL_UPDATE, DirList::ID_TOGGLE_HIDDEN, DirList::onUpdToggleHidden),
    FXMAPFUNC(SEL_UPDATE, DirList::ID_SHOW_FILES, DirList::onUpdShowFiles),
    FXMAPFUNC(SEL_UPDATE, DirList::ID_HIDE_FILES, DirList::onUpdHideFiles),
    FXMAPFUNC(SEL_UPDATE, DirList::ID_TOGGLE_FILES, DirList::onUpdToggleFiles),
    FXMAPFUNC(SEL_UPDATE, DirList::ID_SET_PATTERN, DirList::onUpdSetPattern),
    FXMAPFUNC(SEL_UPDATE, DirList::ID_SORT_REVERSE, DirList::onUpdSortReverse),
    FXMAPFUNC(SEL_COMMAND, DirList::ID_SHOW_HIDDEN, DirList::onCmdShowHidden),
    FXMAPFUNC(SEL_COMMAND, DirList::ID_DRAG_COPY, DirList::onCmdDragCopy),
    FXMAPFUNC(SEL_COMMAND, DirList::ID_DRAG_MOVE, DirList::onCmdDragMove),
    FXMAPFUNC(SEL_COMMAND, DirList::ID_DRAG_LINK, DirList::onCmdDragLink),
    FXMAPFUNC(SEL_COMMAND, DirList::ID_DRAG_REJECT, DirList::onCmdDragReject),
    FXMAPFUNC(SEL_COMMAND, DirList::ID_HIDE_HIDDEN, DirList::onCmdHideHidden),
    FXMAPFUNC(SEL_COMMAND, DirList::ID_TOGGLE_HIDDEN, DirList::onCmdToggleHidden),
    FXMAPFUNC(SEL_COMMAND, DirList::ID_SHOW_FILES, DirList::onCmdShowFiles),
    FXMAPFUNC(SEL_COMMAND, DirList::ID_HIDE_FILES, DirList::onCmdHideFiles),
    FXMAPFUNC(SEL_COMMAND, DirList::ID_TOGGLE_FILES, DirList::onCmdToggleFiles),
    FXMAPFUNC(SEL_COMMAND, DirList::ID_SET_PATTERN, DirList::onCmdSetPattern),
    FXMAPFUNC(SEL_COMMAND, DirList::ID_SORT_REVERSE, DirList::onCmdSortReverse),
    FXMAPFUNC(SEL_COMMAND, DirList::ID_REFRESH, DirList::onCmdRefresh),
    FXMAPFUNC(SEL_COMMAND, DirList::ID_SORT_CASE, DirList::onCmdSortCase),
    FXMAPFUNC(SEL_UPDATE, DirList::ID_SORT_CASE, DirList::onUpdSortCase),
    FXMAPFUNC(SEL_UPDATE, 0, DirList::onUpdRefreshTimers),
};


// Object implementation
FXIMPLEMENT(DirList, FXTreeList, DirListMap, ARRAYNUMBER(DirListMap))



// Directory List Widget
DirList::DirList(FXWindow* focuswin, FXComposite* p, FXObject* tgt, FXSelector sel, FXuint opts, int x, int y, int w, int h) :
    FXTreeList(p, tgt, sel, opts, x, y, w, h), pattern("*")
{
    flags |= FLAG_ENABLED|FLAG_DROPTARGET;
    matchmode = FILEMATCH_FILE_NAME|FILEMATCH_NOESCAPE;
    associations = NULL;
    if (!(options&DIRLIST_NO_OWN_ASSOC))
    {
        associations = new FileDict(getApp());
    }
    list = NULL;
    sortfunc = (FXTreeListSortFunc)ascendingCase;
    dropaction = DRAG_MOVE;
    counter = 0;
    prevSelItem = NULL;
    focuswindow = focuswin;

#if defined(linux)
    // Initialize the fsdevices, mtdevices and updevices lists
    struct mntent* mnt;
    if (fsdevices == NULL)
    {
        // To list file system devices
        fsdevices = new FXStringDict();
        FILE* fstab = setmntent(FSTAB_PATH, "r");
        if (fstab)
        {
            while ((mnt = getmntent(fstab)))
            {
                if (!streq(mnt->mnt_type, MNTTYPE_IGNORE) && !streq(mnt->mnt_type, MNTTYPE_SWAP) &&
                    !streq(mnt->mnt_dir, "/"))
                {
                    if (!strncmp(mnt->mnt_fsname, "/dev/fd", 7))
                    {
                        fsdevices->insert(mnt->mnt_dir, "floppy");
                    }
                    else if (!strncmp(mnt->mnt_type, "iso", 3))
                    {
                        fsdevices->insert(mnt->mnt_dir, "cdrom");
                    }
                    else if (!strncmp(mnt->mnt_fsname, "/dev/zip", 8))
                    {
                        fsdevices->insert(mnt->mnt_dir, "zip");
                    }
                    else if (streq(mnt->mnt_type, "nfs"))
                    {
                        fsdevices->insert(mnt->mnt_dir, "nfsdisk");
                    }
                    else if (streq(mnt->mnt_type, "smbfs"))
                    {
                        fsdevices->insert(mnt->mnt_dir, "smbdisk");
                    }
                    else if (streq(mnt->mnt_type, "cifs"))
                    {
                        fsdevices->insert(mnt->mnt_dir, "smbdisk");
                    }
                    else
                    {
                        fsdevices->insert(mnt->mnt_dir, "harddisk");
                    }
                }
            }
            endmntent(fstab);
        }
    }
    if (mtdevices == NULL)
    {
        // To list mounted devices
        mtdevices = new FXStringDict();
        FILE* mtab = setmntent(MTAB_PATH, "r");
        if (mtab)
        {
            while ((mnt = getmntent(mtab)))
            {
                // To fix an issue with some Linux distributions
                FXString mntdir = mnt->mnt_dir;
                if ((mntdir != "/dev/.static/dev") && (mntdir.rfind("gvfs", 4, mntdir.length()) == -1))
                {
                    mtdevices->insert(mnt->mnt_dir, mnt->mnt_type);
                }
            }
            endmntent(mtab);
        }
    }
    if (updevices == NULL)
    {
        // To mark mount points that are up or down
        updevices = new FXStringDict();
        struct stat statbuf;
        FXString    mtstate;
        FILE*       mtab = setmntent(MTAB_PATH, "r");
        if (mtab)
        {
            while ((mnt = getmntent(mtab)))
            {
                // To fix an issue with some Linux distributions
                FXString mntdir = mnt->mnt_dir;
                if ((mntdir != "/dev/.static/dev") && (mntdir.rfind("gvfs", 4, mntdir.length()) == -1))
                {
                    if ((lstatmt(mnt->mnt_dir, &statbuf) == -1) && (errno != EACCES))
                    {
                        mtstate = "down";
                    }
                    else
                    {
                        mtstate = "up";
                    }
                    updevices->insert(mnt->mnt_dir, mtstate.text());
                }
            }
            endmntent(mtab);
        }
    }
#endif

    // Trahscan location
    trashfileslocation = xdgdatahome + PATHSEPSTRING TRASHFILESPATH;
    trashinfolocation = xdgdatahome + PATHSEPSTRING TRASHINFOPATH;
}


// Create the directory list
void DirList::create()
{
    FXTreeList::create();
    if (!deleteType)
    {
        deleteType = getApp()->registerDragType(deleteTypeName);
    }
    if (!urilistType)
    {
        urilistType = getApp()->registerDragType(urilistTypeName);
    }
    getApp()->addTimeout(this, ID_REFRESH_TIMER, REFRESH_INTERVAL);
#if defined(linux)
    getApp()->addTimeout(this, ID_MTDEVICES_REFRESH, MTDEVICES_INTERVAL*1000);
    getApp()->addTimeout(this, ID_UPDEVICES_REFRESH, UPDEVICES_INTERVAL*1000);
#endif
    dropEnable();

    // Scan root directory
    scan(false);
}


// Expand folder tree when hovering long over a folder
long DirList::onExpandTimer(FXObject* sender, FXSelector sel, void* ptr)
{
    int      xx, yy;
    FXuint   state;
    DirItem* item;

    getCursorPosition(xx, yy, state);
    item = (DirItem*)getItemAt(xx, yy);

    if (!(item->state&DirItem::FOLDER))
    {
        return(0);
    }

    // Expand tree item
    expandTree((TreeItem*)item, true);
    scan(true);

    // Set open timer
    getApp()->addTimeout(this, ID_EXPAND_TIMER, EXPAND_INTERVAL);

    return(1);
}


// Create item
TreeItem* DirList::createItem(const FXString& text, FXIcon* oi, FXIcon* ci, void* ptr)
{
    return((TreeItem*)new DirItem(text, oi, ci, ptr));
}


/**
 * Compares fields of p and q, supposing they are single byte strings
 * without using the current locale.
 * @param  igncase	Ignore upper/lower-case?
 * @param  asc		Ascending?  If false is descending order
 * @param  jmp		Field to compare (separated with \t)
 *
 * @return 0 if equal, negative if p<q, positive if p>q
 * If jmp has an invalid value returns 0 and errno will be EINVAL
 */
static inline int compare_nolocale(char* p, char* q, FXbool igncase, FXbool asc)
{
    // Compare names

    register char* pp = p;
    register char* qq = q;

    // Go to next '\t' or '\0'
    while (*pp != '\0' && *pp > '\t')
    {
        pp++;
    }

    while (*qq != '\0' && *qq > '\t')
    {
        qq++;
    }

    // Save characters at current position
    register char pw = *pp;
    register char qw = *qq;

    // Set characters to null, to stop comparison
    *pp = '\0';
    *qq = '\0';

    // Compare strings
    int ret = comparenat(p, q, igncase);

    // Restore saved characters
    *pp = pw;
    *qq = qw;

    // If descending flip
    if (!asc)
    {
        ret = ret * -1;
    }

    return(ret);
}


/**
 * Compares fields of p and q, supposing they are wide strings
 * and using the current locale.
 * @param  igncase	Ignore upper/lower-case?
 * @param  asc		Ascending?  If false is descending order
 * @param  jmp		Field to compare (separated with \t)
 *
 * @return 0 if equal, negative if p<q, positive if p>q
 * If jmp has an invalid value returns 0 and errno will be EINVAL
 */
/* static inline int compare_locale(wchar_t* p, wchar_t* q, FXbool igncase, FXbool asc)
{
    // Compare names

    register wchar_t* pp = p;
    register wchar_t* qq = q;

    // Go to next '\t' or '\0'
    while (*pp != '\0' && *pp > '\t')
    {
        pp++;
    }

    while (*qq != '\0' && *qq > '\t')
    {
        qq++;
    }

    // Save characters at current position
    register wchar_t pw = *pp;
    register wchar_t qw = *qq;

    // Set characters to null, to stop comparison
    *pp = '\0';
    *qq = '\0';

    // Compare wide strings
    int ret = comparewnat(p, q, igncase);

    // Restore saved characters
    *pp = pw;
    *qq = qw;

    // If descending flip
    if (!asc)
    {
        ret = ret * -1;
    }

    return(ret);
} */

static inline int compare_locale(const wchar_t* p, const wchar_t* q, bool igncase, bool asc) {
    // Null-check inputs (optional)
    if (!p || !q) {
        errno = EINVAL;
        return 0;
    }

    // Find the end of fields (up to '\t' or '\0') using pointer arithmetic
    const wchar_t* end_p = p;
    while (*end_p != '\0' && *end_p != '\t') ++end_p;
    
    const wchar_t* end_q = q;
    while (*end_q != '\0' && *end_q != '\t') ++end_q;

    // Calculate field lengths
    size_t len_p = end_p - p;
    size_t len_q = end_q - q;

    // Compare fields (ignoring case if necessary)
    int ret;
    if (igncase) {
        for (size_t i = 0; i < len_p && i < len_q; ++i) {
            wchar_t cp = towlower(p[i]);
            wchar_t cq = towlower(q[i]);
            if (cp != cq) {
                ret = (cp < cq) ? -1 : 1;
                goto flip_result; // Exit loop early
            }
        }
    } else {
        for (size_t i = 0; i < len_p && i < len_q; ++i) {
            if (p[i] != q[i]) {
                ret = (p[i] < q[i]) ? -1 : 1;
                goto flip_result; // Exit loop early
            }
        }
    }

    // If equal so far, compare by length
    ret = (len_p < len_q) ? -1 : (len_p > len_q);

flip_result:
    // Flip result for descending order
    return asc ? ret : -ret;
}



/**
 * Compares a field of pa with the same field of pb, if the fields are
 * equal compare by name
 * @param  igncase	Ignore upper/lower-case?
 * @param  asc		Ascending?  If false is descending order
 *
 * @return 0 if equal, negative if pa<pb, positive if pa>pb
 * Requires to allocate some space, if there is no memory this
 * function returns 0 and errno will be ENOMEM
 * If jmp has an invalid value returns 0 and errno will be EINVAL
 */
int DirList::compareItem(const FXTreeItem* pa, const FXTreeItem* pb, FXbool igncase, FXbool asc)
{
    register const DirItem* a = (DirItem*)pa;
    register const DirItem* b = (DirItem*)pb;
    register char*          p = (char*)a->label.text();
    register char*          q = (char*)b->label.text();

    // Prepare wide char strings
    wchar_t* wa = NULL;
    wchar_t* wb = NULL;
    size_t   an, bn;

    an = mbstowcs(NULL, (const char*)p, 0);
    if (an == (size_t)-1)
    {
        return(compare_nolocale(p, q, igncase, asc)); // If error, fall back to no locale comparison
    }
    wa = (wchar_t*)calloc(an + 1, sizeof(wchar_t));
    if (wa == NULL)
    {
        errno = ENOMEM;
        return(0);
    }
    mbstowcs(wa, p, an + 1);
    bn = mbstowcs(NULL, (const char*)q, 0);
    if (bn == (size_t)-1)
    {
        free(wa);
        return(compare_nolocale(p, q, igncase, asc)); // If error, fall back to no locale comparison
    }
    wb = (wchar_t*)calloc(bn + 1, sizeof(wchar_t));
    if (wb == NULL)
    {
        errno = ENOMEM;
        free(wa);
        free(wb);
        return(0);
    }
    mbstowcs(wb, q, bn + 1);

    // Perform comparison based on the current locale
    int ret = compare_locale(wa, wb, igncase, asc);

    // Free memory
    if (wa != NULL)
    {
        free(wa);
    }
    if (wb != NULL)
    {
        free(wb);
    }

    return(ret);
}


// Sort ascending order, keeping directories first
int DirList::ascending(const FXTreeItem* pa, const FXTreeItem* pb)
{
    return(compareItem(pa, pb, false, true));
}


// Sort descending order, keeping directories first
int DirList::descending(const FXTreeItem* pa, const FXTreeItem* pb)
{
    return(compareItem(pa, pb, false, false));
}


// Sort ascending order, case insensitive, keeping directories first
int DirList::ascendingCase(const FXTreeItem* pa, const FXTreeItem* pb)
{
    return(compareItem(pa, pb, true, true));
}


// Sort descending order, case insensitive, keeping directories first
int DirList::descendingCase(const FXTreeItem* pa, const FXTreeItem* pb)
{
    return(compareItem(pa, pb, true, false));
}


// Handle drag-and-drop enter
long DirList::onDNDEnter(FXObject* sender, FXSelector sel, void* ptr)
{
    FXTreeList::onDNDEnter(sender, sel, ptr);
    return(1);
}


// Handle drag-and-drop leave
long DirList::onDNDLeave(FXObject* sender, FXSelector sel, void* ptr)
{
    // Cancel open up timer
    getApp()->removeTimeout(this, ID_EXPAND_TIMER);

    stopAutoScroll();
    FXTreeList::onDNDLeave(sender, sel, ptr);
    if (prevSelItem)
    {
        if (!isItemCurrent(prevSelItem))
        {
            closeItem(prevSelItem);
        }
        prevSelItem = NULL;
    }
    return(1);
}


// Handle drag-and-drop motion
long DirList::onDNDMotion(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent*  event = (FXEvent*)ptr;
    TreeItem* item;

    // Cancel open up timer
    getApp()->removeTimeout(this, ID_EXPAND_TIMER);

    // Start autoscrolling
    if (startAutoScroll(event, false))
    {
        return(1);
    }

    // Give base class a shot
    if (FXTreeList::onDNDMotion(sender, sel, ptr))
    {
        return(1);
    }

    // Dropping list of filenames
    if (offeredDNDType(FROM_DRAGNDROP, urilistType))
    {
        // Locate drop place
        item = (TreeItem*)getItemAt(event->win_x, event->win_y);

        // We can drop in a directory
        if (item && isItemDirectory(item))
        {
            // Get drop directory
            dropdirectory = getItemPathname(item);

            // What is being done (move,copy,link)
            dropaction = inquireDNDAction();

            // Set open up timer
            getApp()->addTimeout(this, ID_EXPAND_TIMER, EXPAND_INTERVAL);

            // Set icon to open folder icon
            setItemOpenIcon(item, minifolderopenicon);           

            // See if this is writable
            if (::isWritable(dropdirectory))
            {
            	item->setSelected(TRUE);
                acceptDrop(DRAG_ACCEPT);
                int    x, y;
                FXuint state;
                getCursorPosition(x, y, state);
                TreeItem* item = (TreeItem*)getItemAt(x, y);

                if (prevSelItem && (prevSelItem != item))
                {
                    if (!isItemCurrent(prevSelItem))
                    {
                        closeItem(prevSelItem);
            			prevSelItem->setSelected(FALSE);
                    }
                    prevSelItem = NULL;
                }
                if (item && (prevSelItem != item))
                {
                    openItem(item);
                    prevSelItem = item;
                }
            }
        }
        return(1);
    }
    return(0);
}


// Set drag type to copy
long DirList::onCmdDragCopy(FXObject* sender, FXSelector sel, void* ptr)
{
    dropaction = DRAG_COPY;
    return(1);
}


// Set drag type to move
long DirList::onCmdDragMove(FXObject* sender, FXSelector sel, void* ptr)
{
    dropaction = DRAG_MOVE;
    return(1);
}


// Set drag type to symlink
long DirList::onCmdDragLink(FXObject* sender, FXSelector sel, void* ptr)
{
    dropaction = DRAG_LINK;
    return(1);
}


// Cancel drag action
long DirList::onCmdDragReject(FXObject* sender, FXSelector sel, void* ptr)
{
    dropaction = DRAG_REJECT;
    return(1);
}


// Handle drag-and-drop drop
long DirList::onDNDDrop(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuchar* data;
    FXuint   len;
    FXbool   showdialog = true;
    int      ret;
    File*    f = NULL;

    FXbool ask_before_copy = getApp()->reg().readUnsignedEntry("OPTIONS", "ask_before_copy", true);
    FXbool confirm_dnd = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_drag_and_drop", true);

    // Cancel open up timer
    getApp()->removeTimeout(this, ID_EXPAND_TIMER);

    // Stop scrolling
    stopAutoScroll();

    // Perhaps target wants to deal with it
    if (FXTreeList::onDNDDrop(sender, sel, ptr))
    {
        return(1);
    }

    // Check if control key or shift key were pressed
    FXbool ctrlshiftkey = false;
    if (ptr != NULL)
    {
        FXEvent* event = (FXEvent*)ptr;
        if (event->state&CONTROLMASK)
        {
            ctrlshiftkey = true;
        }
        if (event->state&SHIFTMASK)
        {
            ctrlshiftkey = true;
        }
    }

    // Get DND data
    // This is done before displaying the popup menu to fix a drag and drop problem with konqueror and dolphin file managers
    FXbool dnd = getDNDData(FROM_DRAGNDROP, urilistType, data, len);

    int      xx, yy;
    DirItem* item=NULL;

    // Display the dnd dialog if the control or shift key were not pressed
    if (confirm_dnd & !ctrlshiftkey)
    {
		// Get item
		FXuint state;
		getCursorPosition(xx, yy, state);
		item = (DirItem*)getItemAt(xx, yy);

        // Display a popup to select the drag type
        dropaction = DRAG_REJECT;
        FXMenuPane menu(this);
        int        x, y;
        getRoot()->getCursorPosition(x, y, state);
        new FXMenuCommand(&menu, _("Copy here"), copy_clpicon, this, DirList::ID_DRAG_COPY);
        new FXMenuCommand(&menu, _("Move here"), moveiticon, this, DirList::ID_DRAG_MOVE);
        new FXMenuCommand(&menu, _("Link here"), minilinkicon, this, DirList::ID_DRAG_LINK);
        new FXMenuSeparator(&menu);
        new FXMenuCommand(&menu, _("Cancel"), NULL, this, DirList::ID_DRAG_REJECT);
        menu.create();
        allowPopupScroll = true;  // Allow keyboard scrolling
        menu.popup(NULL, x, y);
        getApp()->runModalWhileShown(&menu);
        allowPopupScroll = false;
    }

    // Close item
    if (prevSelItem)
    {
        if (!isItemCurrent(prevSelItem))
        {
            closeItem(prevSelItem);
        }
        prevSelItem = NULL;
    }

    // Get uri-list of files being dropped
    //if (getDNDData(FROM_DRAGNDROP,urilistType,data,len))
    if (dnd)  // See comment upper
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        char* p, *q;
        p = q = (char*)data;

        // Number of selected items
        FXString buf = p;
        int      num = buf.contains('\n')+1;

        // Eventually correct the number of selected items
        // because sometimes there is another '\n' at the end of the string
        int pos = buf.rfind('\n');
        if (pos == buf.length()-1)
        {
            num = num-1;
        }

        // File object
        if (dropaction == DRAG_COPY)
        {
            f = new File(this, _("File copy"), COPY, num);
        }
        else if (dropaction == DRAG_MOVE)
        {
            f = new File(this, _("File move"), MOVE, num);
        }
        else if (dropaction == DRAG_LINK)
        {
            f = new File(this, _("File symlink"), SYMLINK, num);
        }
        else
        {
			// Deselect item
			if (item)
			{
				item->setSelected(FALSE);
			}
            FXFREE(&data);
            return(0);
        }

        // Target directory
        FXString targetdir = dropdirectory;

        while (*p)
        {
            while (*q && *q != '\r')
            {
                q++;
            }
            FXString url(p, q-p);
            FXString source(FXURL::fileFromURL(url));
            FXString target(targetdir);
            FXString sourcedir = FXPath::directory(source);

            // File operation dialog, if needed
            if ( ((!confirm_dnd) | ctrlshiftkey) & ask_before_copy & showdialog)
            {
                FXIcon*  icon = NULL;
                FXString title, message;
                if (dropaction == DRAG_COPY)
                {
                    title = _("Copy");
                    icon = copy_bigicon;
                    if (num == 1)
                    {
                        message = title+source;
                    }
                    else
                    {
                        title.format(_("Copy %s files/folders.\nFrom: %s"), FXStringVal(num).text(), sourcedir.text());
                    }
                }
                else if (dropaction == DRAG_MOVE)
                {
                    title = _("Move");
                    icon = move_bigicon;
                    if (num == 1)
                    {
                        message = title+source;
                    }
                    else
                    {
                        title.format(_("Move %s files/folders.\nFrom: %s"), FXStringVal(num).text(), sourcedir.text());
                    }
                }
                else if ((dropaction == DRAG_LINK) && (num == 1))
                {
                    title = _("Symlink");
                    icon = link_bigicon;
                    message = title+source;
                }

                InputDialog* dialog = new InputDialog(this, targetdir, message, title, _("To:"), icon);
                dialog->CursorEnd();
                int rc = 1;
                rc = dialog->execute();
                target = dialog->getText();
                target = ::filePath(target);
                if (num > 1)
                {
                    showdialog = false;
                }
                delete dialog;
                if (!rc)
                {
                    return(0);
                }
            }

            // Move the source file
            if (dropaction == DRAG_MOVE)
            {
                // Move file
                f->create();

                // If target file is located at trash location, also create the corresponding trashinfo file
                // Do it silently and don't report any error if it fails
                FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);

                if (use_trash_can && (FXPath::directory(target) == trashfileslocation))
                {
                    // Trash files path name
                    FXString trashpathname = createTrashpathname(source, trashfileslocation);

                    // Adjust target name to get the _N suffix if any
                    FXString trashtarget = FXPath::directory(target)+PATHSEPSTRING+FXPath::name(trashpathname);

                    // Create trashinfo file
                    createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                    // Move source to trash target
                    ret = f->move(source, trashtarget);
                }

                // Move source to target
                else
                {
                    //target=FXPath::directory(target);
                    ret = f->move(source, target);
                }

                // If source file is located at trash location, try to also remove the corresponding trashinfo if it exists
                // Do it silently and don't report any error if it fails
                if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
                {
                    FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                    ::unlink(trashinfopathname.text());
                }

                // An error has occurred
                if ((ret == 0) && !f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
                    break;
                }

                // If action is cancelled in progress dialog
                if (f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
                    break;
                }

                // Set directory to the source parent
                setDirectory(sourcedir, false);
            }
            // Copy the source file
            else if (dropaction == DRAG_COPY)
            {
                // Copy file
                f->create();

                // If target file is located at trash location, also create the corresponding trashinfo file
                // Do it silently and don't report any error if it fails
                FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);

                if (use_trash_can && (FXPath::directory(target) == trashfileslocation))
                {
                    // Trash files path name
                    FXString trashpathname = createTrashpathname(source, trashfileslocation);

                    // Adjust target name to get the _N suffix if any
                    FXString trashtarget = FXPath::directory(target)+PATHSEPSTRING+FXPath::name(trashpathname);

                    // Create trashinfo file
                    createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                    // Copy source to trash target
                    ret = f->copy(source, trashtarget);
                }

                // Copy source to target
                else
                {
                    //target=FXPath::directory(target);
                    ret = f->copy(source, target);
                }

                // An error has occurred
                if ((ret == 0) && !f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
                    break;
                }

                // If action is cancelled in progress dialog
                if (f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
                    break;
                }
            }
            // Link the source file (no progress dialog in this case)
            else if (dropaction == DRAG_LINK)
            {
                // Link file
                f->create();
                f->symlink(source, target);
            }
            if (*q == '\r')
            {
                q += 2;
            }
            p = q;
        }
        delete f;
        FXFREE(&data);

        // Force a refresh of the DirList
        onCmdRefresh(0, 0, 0);

        return(1);
    }
    return(0);
}


// Somebody wants our dragged data
long DirList::onDNDRequest(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    FXuchar* data;
    FXuint   len;

    // Perhaps the target wants to supply its own data
    if (FXTreeList::onDNDRequest(sender, sel, ptr))
    {
        return(1);
    }

    // Return list of filenames as a uri-list
    if (event->target == urilistType)
    {
        if (!dragfiles.empty())
        {
            len = dragfiles.length();
            FXMEMDUP(&data, dragfiles.text(), FXuchar, len);
            setDNDData(FROM_DRAGNDROP, event->target, data, len);
        }
        return(1);
    }

    // Delete selected files
    if (event->target == deleteType)
    {
        return(1);
    }

    return(0);
}


// Start a drag operation
long DirList::onBeginDrag(FXObject* sender, FXSelector sel, void* ptr)
{
    register TreeItem* item;

    if (FXTreeList::onBeginDrag(sender, sel, ptr))
    {
        return(1);
    }
    if (beginDrag(&urilistType, 1))
    {
        dragfiles = FXString::null;
        item = (TreeItem*)firstitem;
        while (item)
        {
            if (item->isSelected())
            {
                if (!dragfiles.empty())
                {
                    dragfiles += "\r\n";
                }
                dragfiles += FXURL::encode(::fileToURI(getItemPathname(item)));
            }
            if (item->first)
            {
                item = (TreeItem*)item->first;
            }
            else
            {
                while (!item->next && item->parent)
                {
                    item = (TreeItem*)item->parent;
                }
                item = (TreeItem*)item->next;
            }
        }
        return(1);
    }
    return(0);
}


// End drag operation
long DirList::onEndDrag(FXObject* sender, FXSelector sel, void* ptr)
{
    if (FXTreeList::onEndDrag(sender, sel, ptr))
    {
        return(1);
    }
    endDrag((didAccept() != DRAG_REJECT));
    setDragCursor(getDefaultCursor());

    return(1);
}


// Dragged stuff around
long DirList::onDragged(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent*     event = (FXEvent*)ptr;
    FXDragAction action;

    if (FXTreeList::onDragged(sender, sel, ptr))
    {
        return(1);
    }
    action = DRAG_MOVE;
    if (event->state&CONTROLMASK)
    {
        action = DRAG_COPY;
    }
    if (event->state&SHIFTMASK)
    {
        action = DRAG_MOVE;
    }
    if ((event->state&CONTROLMASK) && (event->state&SHIFTMASK))
    {
        action = DRAG_LINK;
    }
    handleDrag(event->root_x, event->root_y, action);
    if (didAccept() != DRAG_REJECT)
    {
        if (action == DRAG_MOVE)
        {
            setDragCursor(getApp()->getDefaultCursor(DEF_DNDMOVE_CURSOR));
        }
        else if (action == DRAG_LINK)
        {
            setDragCursor(getApp()->getDefaultCursor(DEF_DNDLINK_CURSOR));
        }
        else
        {
            setDragCursor(getApp()->getDefaultCursor(DEF_DNDCOPY_CURSOR));
        }
    }
    else
    {
        setDragCursor(getApp()->getDefaultCursor(DEF_DNDSTOP_CURSOR));
    }
    return(1);
}


// Toggle hidden files
long DirList::onCmdToggleHidden(FXObject*, FXSelector, void*)
{
    showHiddenFiles(!shownHiddenFiles());
    return(1);
}


// Update toggle hidden files widget
long DirList::onUpdToggleHidden(FXObject* sender, FXSelector, void*)
{
    if (shownHiddenFiles())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


// Show hidden files
long DirList::onCmdShowHidden(FXObject*, FXSelector, void*)
{
    showHiddenFiles(true);
    return(1);
}


// Update show hidden files widget
long DirList::onUpdShowHidden(FXObject* sender, FXSelector, void*)
{
    if (shownHiddenFiles())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


// Hide hidden files
long DirList::onCmdHideHidden(FXObject*, FXSelector, void*)
{
    showHiddenFiles(false);
    return(1);
}


// Update hide hidden files widget
long DirList::onUpdHideHidden(FXObject* sender, FXSelector, void*)
{
    if (!shownHiddenFiles())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


// Toggle files display
long DirList::onCmdToggleFiles(FXObject*, FXSelector, void*)
{
    showFiles(!showFiles());
    return(1);
}


// Update toggle files widget
long DirList::onUpdToggleFiles(FXObject* sender, FXSelector, void*)
{
    if (showFiles())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


// Show files
long DirList::onCmdShowFiles(FXObject*, FXSelector, void*)
{
    showFiles(true);
    return(1);
}


// Update show files widget
long DirList::onUpdShowFiles(FXObject* sender, FXSelector, void*)
{
    if (showFiles())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


// Hide files
long DirList::onCmdHideFiles(FXObject*, FXSelector, void*)
{
    showFiles(false);
    return(1);
}


// Update hide files widget
long DirList::onUpdHideFiles(FXObject* sender, FXSelector, void*)
{
    if (!showFiles())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


// Change pattern
long DirList::onCmdSetPattern(FXObject*, FXSelector, void* ptr)
{
    if (!ptr)
    {
        return(0);
    }
    setPattern((const char*)ptr);
    return(1);
}


// Update pattern
long DirList::onUpdSetPattern(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_SETVALUE), (void*)pattern.text());
    return(1);
}


// Reverse sort order
long DirList::onCmdSortReverse(FXObject*, FXSelector, void*)
{
    if (sortfunc == (FXTreeListSortFunc)ascending)
    {
        sortfunc = (FXTreeListSortFunc)descending;
    }
    else if (sortfunc == (FXTreeListSortFunc)descending)
    {
        sortfunc = (FXTreeListSortFunc)ascending;
    }
    else if (sortfunc == (FXTreeListSortFunc)ascendingCase)
    {
        sortfunc = (FXTreeListSortFunc)descendingCase;
    }
    else if (sortfunc == (FXTreeListSortFunc)descendingCase)
    {
        sortfunc = (FXTreeListSortFunc)ascendingCase;
    }
    scan(true);
    return(1);
}


// Update sender
long DirList::onUpdSortReverse(FXObject* sender, FXSelector, void* ptr)
{
    sender->handle(this, (sortfunc == (FXTreeListSortFunc)descending || sortfunc == (FXTreeListSortFunc)descendingCase) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), ptr);
    return(1);
}


// Toggle case sensitivity
long DirList::onCmdSortCase(FXObject*, FXSelector, void*)
{
    if (sortfunc == (FXTreeListSortFunc)ascending)
    {
        sortfunc = (FXTreeListSortFunc)ascendingCase;
    }
    else if (sortfunc == (FXTreeListSortFunc)descending)
    {
        sortfunc = (FXTreeListSortFunc)descendingCase;
    }
    else if (sortfunc == (FXTreeListSortFunc)ascendingCase)
    {
        sortfunc = (FXTreeListSortFunc)ascending;
    }
    else if (sortfunc == (FXTreeListSortFunc)descendingCase)
    {
        sortfunc = (FXTreeListSortFunc)descending;
    }
    scan(true);
    return(1);
}


// Check if case sensitive
long DirList::onUpdSortCase(FXObject* sender, FXSelector, void* ptr)
{
    sender->handle(this, (sortfunc == (FXTreeListSortFunc)ascendingCase || sortfunc == (FXTreeListSortFunc)descendingCase) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), ptr);
    return(1);
}


// Close directory
long DirList::onClosed(FXObject*, FXSelector, void* ptr)
{
    DirItem* item = (DirItem*)ptr;

    if (item->state&DirItem::FOLDER)
    {
        return(target && target->handle(this, FXSEL(SEL_CLOSED, message), ptr));
    }

    return(1);
}


// Open directory
long DirList::onOpened(FXObject*, FXSelector, void* ptr)
{
    DirItem* item = (DirItem*)ptr;

    if (item->state&DirItem::FOLDER)
    {
        return(target && target->handle(this, FXSEL(SEL_OPENED, message), ptr));
    }
    return(1);
}


// Item opened
long DirList::onExpanded(FXObject* sender, FXSelector sel, void* ptr)
{
    DirItem* item = (DirItem*)ptr;

    if (!(item->state&DirItem::FOLDER))
    {
        return(0);
    }

    // Expand tree item
    expandTree((TreeItem*)item, true);
    listChildItems(item);

    // Now we know for sure whether we really have subitems or not
    if (!item->first)
    {
        item->state &= ~DirItem::HASITEMS;
    }
    else
    {
        item->state |= DirItem::HASITEMS;
    }

    sortChildItems(item);
    return(1);
}


// Item closed
long DirList::onCollapsed(FXObject* sender, FXSelector sel, void* ptr)
{
    DirItem* item = (DirItem*)ptr;

    if (!(item->state&DirItem::FOLDER))
    {
        return(0);
    }

    // Collapse tree item
    collapseTree((TreeItem*)item, true);

    return(1);
}


// Expand tree
FXbool DirList::expandTree(TreeItem* tree, FXbool notify)
{
    if (FXTreeList::expandTree(tree, notify))
    {
        if (isItemDirectory(tree))
        {
            listChildItems((DirItem*)tree);
            sortChildItems(tree);
        }
        return(true);
    }
    return(false);
}


// Collapse tree
FXbool DirList::collapseTree(TreeItem* tree, FXbool notify)
{
    if (FXTreeList::collapseTree(tree, notify))
    {
        if (isItemDirectory(tree))
        {
            // As a memory saving feature, all knowledge below this item
            // is deleted; we'll just recreate it when its reexpanded!
            removeItems(tree->first, tree->last);
            recalc();
        }
        return(true);
    }
    return(false);
}


#if defined(linux)

// To periodically scan /proc/mounts and refresh the mtdevices list
long DirList::onMtdevicesRefresh(FXObject*, FXSelector, void*)
{
    // Don't refresh if window is minimized
    if (((FXTopWindow*)focuswindow)->isMinimized())
    {
        return(0);
    }

    struct mntent* mnt;
    FXStringDict*  tmpdict = new FXStringDict();
    FILE*          mtab = setmntent(MTAB_PATH, "r");
    if (mtab)
    {
        while ((mnt = getmntent(mtab)))
        {
            // To fix an issue with some Linux distributions
            FXString mntdir = mnt->mnt_dir;
            if ((mntdir != "/dev/.static/dev") && (mntdir.rfind("gvfs", 4, mntdir.length()) == -1))
            {
                tmpdict->insert(mnt->mnt_dir, "");
                if (mtdevices->find(mnt->mnt_dir))
                {
                    mtdevices->remove(mnt->mnt_dir);
                }
                mtdevices->insert(mnt->mnt_dir, mnt->mnt_type);
            }
        }
        endmntent(mtab);
    }

    // Remove mount points that don't exist anymore
    int s;
    for (s = mtdevices->first(); s < mtdevices->size(); s = mtdevices->next(s))
    {
        if (!tmpdict->find(mtdevices->key(s)))
        {
            mtdevices->remove(mtdevices->key(s));
        }
    }
    delete tmpdict;

    // Reset timer again
    getApp()->addTimeout(this, ID_MTDEVICES_REFRESH, MTDEVICES_INTERVAL*1000);
    return(0);
}


// To periodically scan /proc/mounts and detect up and down mounted devices
// NB : the refresh period is much longer than for onMtdevicesRefresh
long DirList::onUpdevicesRefresh(FXObject*, FXSelector, void*)
{
    // Don't refresh if window is minimized
    if (((FXTopWindow*)focuswindow)->isMinimized())
    {
        return(0);
    }

    struct mntent* mnt;
    struct stat    statbuf;
    FXString       mtstate;

    FXbool mount_warn = getApp()->reg().readUnsignedEntry("OPTIONS", "mount_warn", true);

    FXStringDict* tmpdict = new FXStringDict();
    FILE*         mtab = setmntent(MTAB_PATH, "r");
    if (mtab)
    {
        while ((mnt = getmntent(mtab)))
        {
            // To fix an issue with some Linux distributions
            FXString mntdir = mnt->mnt_dir;
            if ((mntdir != "/dev/.static/dev") && (mntdir.rfind("gvfs", 4, mntdir.length()) == -1))
            {
                tmpdict->insert(mnt->mnt_dir, "");

                if ((lstatmt(mnt->mnt_dir, &statbuf) == -1) && (errno != EACCES))
                {
                    mtstate = "down";
                    if (mount_warn)
                    {
                        MessageBox::warning(this, BOX_OK, _("Warning"), _("Mount point %s is not responding..."), mnt->mnt_dir);
                    }
                }
                else
                {
                    mtstate = "up";
                }

                if (updevices->find(mnt->mnt_dir))
                {
                    updevices->remove(mnt->mnt_dir);
                }
                updevices->insert(mnt->mnt_dir, mtstate.text());
            }
        }
        endmntent(mtab);
    }

    // Remove mount points that don't exist anymore
    int s;
    for (s = updevices->first(); s < updevices->size(); s = updevices->next(s))
    {
        if (!tmpdict->find(updevices->key(s)))
        {
            updevices->remove(updevices->key(s));
        }
    }
    delete tmpdict;

    // Reset timer again
    getApp()->addTimeout(this, ID_UPDEVICES_REFRESH, UPDEVICES_INTERVAL*1000);
    return(0);
}


#endif


// Refresh with timer
long DirList::onCmdRefreshTimer(FXObject*, FXSelector, void*)
{
    // Don't refresh if window is minimized
    if (((FXTopWindow*)focuswindow)->isMinimized())
    {
        return(0);
    }

    if (flags&FLAG_UPDATE)
    {
        scan(false);
        counter = (counter+1)%REFRESH_FREQUENCY;
    }

    // Reset timer again
    getApp()->addTimeout(this, ID_REFRESH_TIMER, REFRESH_INTERVAL);
    return(0);
}


// Force refresh
long DirList::onCmdRefresh(FXObject*, FXSelector, void*)
{
    scan(true);
    return(0);
}


// Scan items to see if listing is necessary
void DirList::scan(FXbool force)
{
    FXString    pathname;
    struct stat info;
    DirItem*    item;



    // Do root first time
    if (!firstitem || force)
    {
        listRootItems();
        sortRootItems();
    }

    // Check all items
    item = (DirItem*)firstitem;
    while (item)
    {
        // Is expanded directory?
        if (item->isDirectory() && item->isExpanded())
        {
            // Get the full path of the item
            pathname = getItemPathname((TreeItem*)item);

            // Stat this directory
            if (statrep(pathname.text(), &info) == 0)
            {
                // Get the mod date of the item
                FXTime newdate = (FXTime)FXMAX(info.st_mtime, info.st_ctime);

                // Forced, date was changed, or failed to get proper date and counter expired
                if (force || (item->date != newdate) || (counter == 0))
                {
                    // And do the refresh
#if defined(linux)
                    onMtdevicesRefresh(0, 0, 0); // Force mtdevices list refresh
#endif
                    listChildItems(item);
                    sortChildItems(item);

                    // Remember when we did this
                    item->date = newdate;
                }

                // Go deeper
                if (item->first)
                {
                    item = (DirItem*)item->first;
                    continue;
                }
            }

            // Directory does not exist
            else
            {
                // Go to parent and rescan
                setDirectory(FXPath::directory(pathname), false);
                scan(true);
                break;
            }
        }

        // Go up
        while (!item->next && item->parent)
        {
            item = (DirItem*)item->parent;
        }

        // Go to next
        item = (DirItem*)item->next;
    }
}


// List root directories
void DirList::listRootItems()
{
    DirItem*   item = (DirItem*)firstitem;
    FXIcon*    openicon, *closedicon;
    FileAssoc* fileassoc;

    // First time, make root node
    if (!item)
    {
        item = list = (DirItem*)appendItem(NULL, PATHSEPSTRING, harddiskicon, harddiskicon, NULL, true);
    }

    // Root is a directory, has items under it, and is searchable
    item->state |= DirItem::FOLDER|DirItem::HASITEMS;
    item->state &= ~(DirItem::CHARDEV|DirItem::BLOCKDEV|DirItem::FIFO|DirItem::SOCK|DirItem::SYMLINK|DirItem::EXECUTABLE);

    // Determine associations, icons and type
    fileassoc = NULL;
    openicon = harddiskicon;
    closedicon = harddiskicon;
    if (associations)
    {
        fileassoc = associations->findDirBinding(PATHSEPSTRING);
    }

    // If association is found, use it
    if (fileassoc)
    {
        if (fileassoc->miniicon)
        {
            closedicon = fileassoc->miniicon;
        }
        if (fileassoc->miniiconopen)
        {
            openicon = fileassoc->miniiconopen;
        }
    }

    // Update item information
    item->openIcon = openicon;
    item->closedIcon = closedicon;
    item->size = 0L;
    item->assoc = fileassoc;
    item->date = 0;

    // Create item
    if (id())
    {
        item->create();
    }

    // Need to layout
    recalc();
}


// List child items
void DirList::listChildItems(DirItem* par)
{
    DirItem*       oldlist, *newlist, **po, **pp, **pn, *item, *link;
    FXIcon*        openicon, *closedicon;
    FileAssoc*     fileassoc;
    DIR*           dirp;
    struct dirent* dp;
    struct stat    info;
    FXString       pathname, directory, name;
    FXString       type, mod, usrid, grpid, atts, del;
    FXString       timeformat;
    int            islink;
    FXlong         deldate;

    // Path to parent node
    directory = getItemPathname((TreeItem*)par);

    // Read time format
    timeformat = getApp()->reg().readStringEntry("SETTINGS", "time_format", DEFAULT_TIME_FORMAT);

    // Build new insert-order list
    oldlist = par->list;
    newlist = NULL;

    // Assemble lists
    po = &oldlist;
    pn = &newlist;

    // Get directory stream pointer
    dirp = opendir(directory.text());

    // Managed to open directory
    if (dirp)
    {
        // Process directory entries
        while ((dp = readdir(dirp)) != NULL)
        {
            // Get name of entry
            name = dp->d_name;

            // A dot special file?
            if ((name[0] == '.') && ((name[1] == 0) || ((name[1] == '.') && (name[2] == 0))))
            {
                continue;
            }

            // Hidden file or directory normally not shown
            if ((name[0] == '.') && !(options&DIRLIST_SHOWHIDDEN))
            {
                continue;
            }

            // Build full pathname of entry
            pathname = directory;
            if (!ISPATHSEP(pathname[pathname.length()-1]))
            {
                pathname += PATHSEPSTRING;
            }
            pathname += name;

            // Get file/link info
            if (lstatrep(pathname.text(), &info) != 0)
            {
                continue;
            }

            // If its a link, get the info on file itself
            islink = S_ISLNK(info.st_mode);
            if (islink && (statrep(pathname.text(), &info) != 0))
            {
                continue;
            }

            // If it is not a directory, and not showing files and matching pattern skip it
            if (!S_ISDIR(info.st_mode) && !((options&DIRLIST_SHOWFILES) && FXPath::match(pattern, name, matchmode)))
            {
                continue;
            }

            // Find it, and take it out from the old list if found
            for (pp = po; (item = *pp) != NULL; pp = &item->link)
            {
                if (compare(item->label, name) == 0)
                {
                    *pp = item->link;
                    item->link = NULL;
                    po = pp;
                    goto fnd;
                }
            }

            // Not found; prepend before list
            item = (DirItem*)appendItem(par, name, minifolderopenicon, minifolderclosedicon, NULL, true);

            // Next gets hung after this one
fnd:
            *pn = item;
            pn = &item->link;

            // Item flags
            if (info.st_mode&(S_IXUSR|S_IXGRP|S_IXOTH))
            {
                item->state |= DirItem::EXECUTABLE;
            }
            else
            {
                item->state &= ~DirItem::EXECUTABLE;
            }

            if (S_ISDIR(info.st_mode))
            {
                item->state |= DirItem::FOLDER;
                item->state &= ~DirItem::EXECUTABLE;
            }
            else
            {
                item->state &= ~(DirItem::FOLDER|DirItem::HASITEMS);
            }

            if (S_ISCHR(info.st_mode))
            {
                item->state |= DirItem::CHARDEV;
                item->state &= ~DirItem::EXECUTABLE;
            }
            else
            {
                item->state &= ~DirItem::CHARDEV;
            }

            if (S_ISBLK(info.st_mode))
            {
                item->state |= DirItem::BLOCKDEV;
                item->state &= ~DirItem::EXECUTABLE;
            }
            else
            {
                item->state &= ~DirItem::BLOCKDEV;
            }

            if (S_ISFIFO(info.st_mode))
            {
                item->state |= DirItem::FIFO;
                item->state &= ~DirItem::EXECUTABLE;
            }
            else
            {
                item->state &= ~DirItem::FIFO;
            }

            if (S_ISSOCK(info.st_mode))
            {
                item->state |= DirItem::SOCK;
                item->state &= ~DirItem::EXECUTABLE;
            }
            else
            {
                item->state &= ~DirItem::SOCK;
            }

            if (islink)
            {
                item->state |= DirItem::SYMLINK;
            }
            else
            {
                item->state &= ~DirItem::SYMLINK;
            }

            // We can drag items
            item->state |= DirItem::DRAGGABLE;

            // Assume no associations
            fileassoc = NULL;

            // Determine icons and type
            if (item->state&DirItem::FOLDER)
            {
                if (!::isReadExecutable(pathname))
                {
                    openicon = minifolderlockedicon;
                    closedicon = minifolderlockedicon;
                }
                else
                {
                    openicon = minifolderopenicon;
                    closedicon = minifolderclosedicon;
                }
                if (associations)
                {
                    fileassoc = associations->findDirBinding(pathname.text());
                }
            }
            else if (item->state&DirItem::EXECUTABLE)
            {
                openicon = miniappicon;
                closedicon = miniappicon;
                if (associations)
                {
                    fileassoc = associations->findExecBinding(pathname.text());
                }
            }
            else
            {
                openicon = minidocicon;
                closedicon = minidocicon;
                if (associations)
                {
                    fileassoc = associations->findFileBinding(pathname.text());
                }
            }

            // If association is found, use it
            if (fileassoc)
            {
                if (fileassoc->miniicon)
                {
                    closedicon = fileassoc->miniicon;
                }
                if (fileassoc->miniiconopen)
                {
                    openicon = fileassoc->miniiconopen;
                }
            }

            // Update item information
            item->openIcon = openicon;
            item->closedIcon = closedicon;
            item->size = (FXulong)info.st_size;
            item->assoc = fileassoc;
            item->date = info.st_mtime;

            // Set the HASITEMS flag
            (hasSubDirs(pathname.text()) == 1 ? item->setHasItems(true) : item->setHasItems(false));

            // Default folder type
            type = _("Folder");

            // Obtain user name
            FXString usrid = FXSystem::userName(info.st_uid);

            // Obtain group name
            FXString grpid = FXSystem::groupName(info.st_gid);

            // Permissions (caution : we don't use the FXSystem::modeString() function because
            // it seems to be incompatible with the info.st_mode format)
            FXString atts = ::permissions(info.st_mode);

            // Modification time
            mod = FXSystem::time(timeformat.text(), item->date);

            // If we are in trash can, obtain the deletion time
            deldate = 0;
            del = "";
            if (FXPath::directory(pathname) == trashfileslocation)
            {
                char*    endptr;
                FXString str;
                str = pathname.rafter('_');
                str = str.rbefore('-');
                deldate = strtol(str.text(), &endptr, 10);
                if (deldate != 0)
                {
                    del = FXSystem::time(timeformat.text(), deldate);
                }
            }

#if defined(linux)
            // Mounted devices may have a specific icon
            if (mtdevices->find(pathname.text()))
            {
                type = _("Mount point");

                if (streq(mtdevices->find(pathname.text()), "cifs"))
                {
                    item->closedIcon = nfsdriveicon;
                    item->openIcon = nfsdriveicon;
                }
                else
                {
                    item->closedIcon = harddiskicon;
                    item->openIcon = harddiskicon;
                }
            }

            // Devices found in fstab may have a specific icon
            if (fsdevices->find(pathname.text()))
            {
                type = _("Mount point");

                if (streq(fsdevices->find(pathname.text()), "harddisk"))
                {
                    item->closedIcon = harddiskicon;
                    item->openIcon = harddiskicon;
                }
                else if (streq(fsdevices->find(pathname.text()), "nfsdisk"))
                {
                    item->closedIcon = nfsdriveicon;
                    item->openIcon = nfsdriveicon;
                }
                else if (streq(fsdevices->find(pathname.text()), "smbdisk"))
                {
                    item->closedIcon = nfsdriveicon;
                    item->openIcon = nfsdriveicon;
                }
                else if (streq(fsdevices->find(pathname.text()), "floppy"))
                {
                    item->closedIcon = floppyicon;
                    item->openIcon = floppyicon;
                }
                else if (streq(fsdevices->find(pathname.text()), "cdrom"))
                {
                    item->closedIcon = cdromicon;
                    item->openIcon = cdromicon;
                }
                else if (streq(fsdevices->find(pathname.text()), "zip"))
                {
                    item->closedIcon = zipicon;
                    item->openIcon = zipicon;
                }
            }
#endif

            // Symbolic links have a specific icon
            if (islink)
            {
                type = _("Link to Folder");
                item->closedIcon = minilinkicon;
                item->openIcon = minilinkicon;
            }

            // Data used to update the tooltip
            item->tdata = item->label+"\t"+type+"\t"+mod+"\t"+usrid+"\t"+grpid+"\t"+atts+"\t"+del+"\t"+pathname;
            item->setData(&item->tdata);

            // Create item
            if (id())
            {
                item->create();
            }
        }

        // Close it
        closedir(dirp);
    }

    // Wipe items remaining in list:- they have disappeared!!
    for (item = oldlist; item; item = link)
    {
        link = item->link;
        removeItem(item, true);
    }

    // Now we know for sure whether we really have subitems or not
    if (par->first)
    {
        par->state |= DirItem::HASITEMS;
    }
    else
    {
        par->state &= ~DirItem::HASITEMS;
    }

    // Remember new list
    par->list = newlist;

    // Need to layout
    recalc();
}


// Is directory
FXbool DirList::isItemDirectory(const TreeItem* item) const
{
    if (item == NULL)
    {
        fprintf(stderr, "%s::isItemDirectory: item is NULL.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return((item->state&DirItem::FOLDER) != 0);
}


// Is file
FXbool DirList::isItemFile(const TreeItem* item) const
{
    if (item == NULL)
    {
        fprintf(stderr, "%s::isItemFile: item is NULL.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return((item->state&(DirItem::FOLDER|DirItem::CHARDEV|DirItem::BLOCKDEV|DirItem::FIFO|DirItem::SOCK)) == 0);
}


// Is executable
FXbool DirList::isItemExecutable(const TreeItem* item) const
{
    if (item == NULL)
    {
        fprintf(stderr, "%s::isItemExecutable: item is NULL.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return((item->state&DirItem::EXECUTABLE) != 0);
}


// Return absolute pathname of item
FXString DirList::getItemPathname(const TreeItem* item) const
{
    FXString pathname;

    if (item)
    {
        while (1)
        {
            pathname.prepend(item->getText());
            item = (TreeItem*)item->parent;
            if (!item)
            {
                break;
            }
            if (item->parent)
            {
                pathname.prepend(PATHSEP);
            }
        }
    }
    return(pathname);
}


// Return the item from the absolute pathname
TreeItem* DirList::getPathnameItem(const FXString& path)
{
    register TreeItem* item, *it;
    register int       beg = 0, end = 0;
    FXString           name;

    if (!path.empty())
    {
        if (ISPATHSEP(path[0]))
        {
            end++;
        }
        if (beg < end)
        {
            name = path.mid(beg, end-beg);
            for (it = (TreeItem*)firstitem; it; it = (TreeItem*)it->next)
            {
                if (compare(name, it->getText()) == 0)
                {
                    goto x;
                }
            }
            listRootItems();
            sortRootItems();
            for (it = (TreeItem*)firstitem; it; it = (TreeItem*)it->next)
            {
                if (compare(name, it->getText()) == 0)
                {
                    goto x;
                }
            }
            return(NULL);

x:
            item = it;
            FXASSERT(item);
            while (end < path.length())
            {
                beg = end;
                while (end < path.length() && !ISPATHSEP(path[end]))
                {
                    end++;
                }
                name = path.mid(beg, end-beg);
                for (it = (TreeItem*)item->first; it; it = (TreeItem*)it->next)
                {
                    if (compare(name, it->getText()) == 0)
                    {
                        goto y;
                    }
                }
                listChildItems((DirItem*)item);
                sortChildItems(item);
                for (it = (TreeItem*)item->first; it; it = (TreeItem*)it->next)
                {
                    if (compare(name, it->getText()) == 0)
                    {
                        goto y;
                    }
                }
                return(item);

y:
                item = it;
                FXASSERT(item);
                if ((end < path.length()) && ISPATHSEP(path[end]))
                {
                    end++;
                }
            }
            FXASSERT(item);
            return(item);
        }
    }
    return(NULL);
}


// Obtain item's file name only
FXString DirList::getItemFilename(const TreeItem* item) const
{
    if (item == NULL)
    {
        fprintf(stderr, "%s::getItemFilename: item is NULL.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return(item->label);
}


// Open all intermediate directories down toward given one
void DirList::setDirectory(const FXString& pathname, FXbool notify)
{
    if (!pathname.empty())
    {
        FXString path = FXPath::absolute(getItemPathname((TreeItem*)currentitem), pathname);

        while (!FXPath::isTopDirectory(path) && !::isDirectory(path))
        {
            path = FXPath::upLevel(path);
        }

        TreeItem* item = getPathnameItem(path);
        if (id())
        {
            layout();
        }
        makeItemVisible(item);
        setCurrentItem(item, notify);
    }
}


// Return directory part of path to current item
FXString DirList::getDirectory() const
{
    const TreeItem* item = (TreeItem*)currentitem;

    while (item)
    {
        if (item->state&DirItem::FOLDER)
        {
            return(getItemPathname(item));
        }
        item = (TreeItem*)item->parent;
    }
    return("");
}


// Set current (dir/file) name path
void DirList::setCurrentFile(const FXString& pathname, FXbool notify)
{
    if (!pathname.empty())
    {
        FXString path = FXPath::absolute(getItemPathname((TreeItem*)currentitem), pathname);
        while (!FXPath::isTopDirectory(path) && !::exists(path))
        {
            path = FXPath::upLevel(path);
        }
        TreeItem* item = getPathnameItem(path);
        if (id())
        {
            layout();
        }
        makeItemVisible(item);
        setCurrentItem(item, notify);
    }
}


// Get current (dir/file) name path
FXString DirList::getCurrentFile() const
{
    return(getItemPathname((TreeItem*)currentitem));
}


// Get list style
FXbool DirList::showFiles() const
{
    return((options&DIRLIST_SHOWFILES) != 0);
}


// Change list style
void DirList::showFiles(FXbool showing)
{
    FXuint opts = options;

    if (showing)
    {
        opts |= DIRLIST_SHOWFILES;
    }
    else
    {
        opts &= ~DIRLIST_SHOWFILES;
    }
    if (options != opts)
    {
        options = opts;
        scan(true);
    }
    setFocus();
}


// Return true if showing hidden files
FXbool DirList::shownHiddenFiles() const
{
    return((options&DIRLIST_SHOWHIDDEN) != 0);
}


// Change show hidden files mode
void DirList::showHiddenFiles(FXbool showing)
{
    FXuint opts = options;

    if (showing)
    {
        opts |= DIRLIST_SHOWHIDDEN;
    }
    else
    {
        opts &= ~DIRLIST_SHOWHIDDEN;
    }
    if (opts != options)
    {
        options = opts;
        scan(true);
    }
    setFocus();
}


// Set associations
void DirList::setAssociations(FileDict* assoc)
{
    associations = assoc;
    scan(true);
}


// Set the pattern to filter
void DirList::setPattern(const FXString& ptrn)
{
    if (ptrn.empty())
    {
        return;
    }
    if (pattern != ptrn)
    {
        pattern = ptrn;
        scan(true);
    }
    setFocus();
}


// Change file match mode
void DirList::setMatchMode(FXuint mode)
{
    if (matchmode != mode)
    {
        matchmode = mode;
        scan(true);
    }
    setFocus();
}


// Cleanup
DirList::~DirList()
{
    clearItems();
    getApp()->removeTimeout(this, ID_REFRESH_TIMER);
    getApp()->removeTimeout(this, ID_EXPAND_TIMER);
#if defined(linux)
    getApp()->removeTimeout(this, ID_MTDEVICES_REFRESH);
    getApp()->removeTimeout(this, ID_UPDEVICES_REFRESH);
#endif
    if (!(options&DIRLIST_NO_OWN_ASSOC))
    {
        delete associations;
    }
    associations = (FileDict*)-1;
}


// Update refresh timers if the window gains focus
long DirList::onUpdRefreshTimers(FXObject*, FXSelector, void*)
{
    static FXbool prevMinimized = true;
    static FXbool minimized = true;

    prevMinimized = minimized;
    if (((FXTopWindow*)focuswindow)->isMinimized())
    {
        minimized = false;
    }
    else
    {
        minimized = true;
    }

    // Update refresh timers
    if ((prevMinimized == false) && (minimized == true))
    {
        onCmdRefreshTimer(0, 0, 0);
#if defined(linux)
        onMtdevicesRefresh(0, 0, 0);
        onUpdevicesRefresh(0, 0, 0);
#endif
    }

    return(1);
}
#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/time.h>

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "File.h"
#include "DirList.h"
#include "Properties.h"
#include "BrowseInputDialog.h"
#include "ArchInputDialog.h"
#include "XFileExplorer.h"
#include "MessageBox.h"
#include "DirPanel.h"



// Refresh interval for the directory size (ms)
#define DIRSIZE_REFRESH_INTERVAL    1000

// Duration (in ms) before we can stop refreshing the file list
// Used for file operations on a large list of files
#define STOP_LIST_REFRESH_INTERVAL    5000

// Number of files before stopping the file list refresh
#define STOP_LIST_REFRESH_NBMAX       100

// Clipboard
extern FXString clipboard;
extern FXuint   clipboard_type;

// Global variables
extern FXMainWindow* mainWindow;
extern FXbool        allowPopupScroll;
#if defined(linux)
extern FXStringDict* fsdevices;
extern FXStringDict* mtdevices;
#endif
extern FXuint   single_click;
extern FXString xdgdatahome;



// Dirty hack to change the KEY_up and KEY_down behaviour
// These keys are no more associated with the mouse click action
#define SELECT_MASK    (TREELIST_SINGLESELECT|TREELIST_BROWSESELECT)
FXbool fromKeyPress = false;
long FXTreeList::onKeyPress(FXObject*, FXSelector, void* ptr)
{
    FXEvent*    event = (FXEvent*)ptr;
    FXTreeItem* item = currentitem;
    FXTreeItem* succ;
    int         page;

    flags &= ~FLAG_TIP;
    if (!isEnabled())
    {
        return(0);
    }
    if (target && target->tryHandle(this, FXSEL(SEL_KEYPRESS, message), ptr))
    {
        return(1);
    }
    if (item == NULL)
    {
        item = firstitem;
    }
    switch (event->code)
    {
    case KEY_Control_L:
    case KEY_Control_R:
    case KEY_Shift_L:
    case KEY_Shift_R:
    case KEY_Alt_L:
    case KEY_Alt_R:
        if (flags&FLAG_DODRAG)
        {
            handle(this, FXSEL(SEL_DRAGGED, 0), ptr);
        }
        return(1);

    case KEY_Page_Up:
    case KEY_KP_Page_Up:
        for (succ = item, page = verticalScrollBar()->getPage(); succ && 0 < page; )
        {
            item = succ;
            page -= succ->getHeight(this);
            if (succ->prev)
            {
                succ = succ->prev;
                while (succ->last && ((options&TREELIST_AUTOSELECT) || succ->isExpanded()))
                {
                    succ = succ->last;
                }
            }
            else if (succ->parent)
            {
                succ = succ->parent;
            }
        }
        goto hop;

    case KEY_Page_Down:
    case KEY_KP_Page_Down:
        for (succ = item, page = verticalScrollBar()->getPage(); succ && 0 < page; )
        {
            item = succ;
            page -= succ->getHeight(this);
            if (succ->first && ((options&TREELIST_AUTOSELECT) || succ->isExpanded()))
            {
                succ = succ->first;
            }
            else
            {
                while (!succ->next && succ->parent)
                {
                    succ = succ->parent;
                }
                succ = succ->next;
            }
        }
        goto hop;

    case KEY_Up:                          // Move up
    case KEY_KP_Up:
        if (item)
        {
            if (item->prev)
            {
                item = item->prev;
                while (item->last && ((options&TREELIST_AUTOSELECT) || item->isExpanded()))
                {
                    item = item->last;
                }
            }
            else if (item->parent)
            {
                item = item->parent;
            }
        }
        goto hop;

    case KEY_Down:                        // Move down
    case KEY_KP_Down:
        if (item)
        {
            if (item->first && ((options&TREELIST_AUTOSELECT) || item->isExpanded()))
            {
                item = item->first;
            }
            else
            {
                while (!item->next && item->parent)
                {
                    item = item->parent;
                }
                item = item->next;
            }
        }
        goto hop;

    case KEY_Right:                       // Move right/down and open subtree
    case KEY_KP_Right:
        if (item)
        {
            if (!(options&TREELIST_AUTOSELECT) && !item->isExpanded() && (item->hasItems() || item->getFirst()))
            {
                expandTree(item, true);
            }
            else if (item->first)
            {
                item = item->first;
            }
            else
            {
                while (!item->next && item->parent)
                {
                    item = item->parent;
                }
                item = item->next;
            }
        }
        goto hop;

    case KEY_Left:                        // Move left/up and close subtree
    case KEY_KP_Left:
        if (item)
        {
            if (!(options&TREELIST_AUTOSELECT) && item->isExpanded() && (item->hasItems() || item->getFirst()))
            {
                collapseTree(item, true);
            }
            else if (item->parent)
            {
                item = item->parent;
            }
            else if (item->prev)
            {
                item = item->prev;
            }
        }
        goto hop;

    case KEY_Home:                        // Move to first
    case KEY_KP_Home:
        item = firstitem;
        goto hop;

    case KEY_End:                         // Move to last
    case KEY_KP_End:
        item = lastitem;
        while (item)
        {
            if (item->last && ((options&TREELIST_AUTOSELECT) || item->isExpanded()))
            {
                item = item->last;
            }
            else if (item->next)
            {
                item = item->next;
            }
            else
            {
                break;
            }
        }
hop:
        lookup = FXString::null;
        if (item)
        {
            setCurrentItem(item, true);
            makeItemVisible(item);
            if ((options&SELECT_MASK) == TREELIST_EXTENDEDSELECT)
            {
                if (item->isEnabled())
                {
                    if (event->state&SHIFTMASK)
                    {
                        if (anchoritem)
                        {
                            selectItem(anchoritem, true);
                            extendSelection(item, true);
                        }
                        else
                        {
                            selectItem(item, true);
                            setAnchorItem(item);
                        }
                    }
                    else if (!(event->state&CONTROLMASK))
                    {
                        killSelection(true);
                        selectItem(item, true);
                        setAnchorItem(item);
                    }
                }
            }
        }

        // !!!! Hack to change the KEY_up and KEY_down behaviour !!!
        fromKeyPress = true;
        // !!!! End of hack !!!
        handle(this, FXSEL(SEL_CLICKED, 0), (void*)currentitem);

        if (currentitem && currentitem->isEnabled())
        {
            handle(this, FXSEL(SEL_COMMAND, 0), (void*)currentitem);
        }
        return(1);

    case KEY_space:
    case KEY_KP_Space:
        lookup = FXString::null;
        if (item && item->isEnabled())
        {
            switch (options&SELECT_MASK)
            {
            case TREELIST_EXTENDEDSELECT:
                if (event->state&SHIFTMASK)
                {
                    if (anchoritem)
                    {
                        selectItem(anchoritem, true);
                        extendSelection(item, true);
                    }
                    else
                    {
                        selectItem(item, true);
                    }
                }
                else if (event->state&CONTROLMASK)
                {
                    toggleItem(item, true);
                }
                else
                {
                    killSelection(true);
                    selectItem(item, true);
                }
                break;

            case TREELIST_MULTIPLESELECT:
            case TREELIST_SINGLESELECT:
                toggleItem(item, true);
                break;
            }
            setAnchorItem(item);
        }
        handle(this, FXSEL(SEL_CLICKED, 0), (void*)currentitem);
        if (currentitem && currentitem->isEnabled())
        {
            handle(this, FXSEL(SEL_COMMAND, 0), (void*)currentitem);
        }
        return(1);

    case KEY_Return:
    case KEY_KP_Enter:
        lookup = FXString::null;
        handle(this, FXSEL(SEL_DOUBLECLICKED, 0), (void*)currentitem);
        if (currentitem && currentitem->isEnabled())
        {
            handle(this, FXSEL(SEL_COMMAND, 0), (void*)currentitem);
        }
        return(1);

    default:
        if ((FXuchar)event->text[0] < ' ')
        {
            return(0);
        }
        if (event->state&(CONTROLMASK|ALTMASK))
        {
            return(0);
        }
        if (!Ascii::isPrint(event->text[0]))
        {
            return(0);
        }
        lookup.append(event->text);
        getApp()->addTimeout(this, ID_LOOKUPTIMER, getApp()->getTypingSpeed());
        item = findItem(lookup, currentitem, SEARCH_FORWARD|SEARCH_WRAP|SEARCH_PREFIX);
        if (item)
        {
            setCurrentItem(item, true);
            makeItemVisible(item);
            if ((options&SELECT_MASK) == TREELIST_EXTENDEDSELECT)
            {
                if (item->isEnabled())
                {
                    killSelection(true);
                    selectItem(item, true);
                }
            }
            setAnchorItem(item);
        }
        handle(this, FXSEL(SEL_CLICKED, 0), (void*)currentitem);
        if (currentitem && currentitem->isEnabled())
        {
            handle(this, FXSEL(SEL_COMMAND, 0), (void*)currentitem);
        }
        return(1);
    }
    return(0);
}


// Map
FXDEFMAP(DirPanel) DirPanelMap[] =
{
    FXMAPFUNC(SEL_CLIPBOARD_LOST, 0, DirPanel::onClipboardLost),
    FXMAPFUNC(SEL_CLIPBOARD_GAINED, 0, DirPanel::onClipboardGained),
    FXMAPFUNC(SEL_CLIPBOARD_REQUEST, 0, DirPanel::onClipboardRequest),
    FXMAPFUNC(SEL_TIMEOUT, DirPanel::ID_STOP_LIST_REFRESH_TIMER, DirPanel::onCmdStopListRefreshTimer),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_EXPANDTREE, DirPanel::onExpandTree),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_COLLAPSETREE, DirPanel::onCollapseTree),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_PROPERTIES, DirPanel::onCmdProperties),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_ARCHIVE, DirPanel::onCmdAddToArch),
    FXMAPFUNC(SEL_RIGHTBUTTONRELEASE, DirPanel::ID_FILELIST, DirPanel::onCmdPopupMenu),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_POPUP_MENU, DirPanel::onCmdPopupMenu),
    FXMAPFUNC(SEL_CLICKED, DirPanel::ID_FILELIST, DirPanel::onCmdDirectory),
    FXMAPFUNC(SEL_EXPANDED, DirPanel::ID_FILELIST, DirPanel::onExpand),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_COPY_CLIPBOARD, DirPanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_CUT_CLIPBOARD, DirPanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_ADDCOPY_CLIPBOARD, DirPanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_ADDCUT_CLIPBOARD, DirPanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_PASTE_CLIPBOARD, DirPanel::onCmdPaste),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_DIR_COPY, DirPanel::onCmdDirMan),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_DIR_CUT, DirPanel::onCmdDirMan),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_DIR_COPYTO, DirPanel::onCmdDirMan),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_DIR_MOVETO, DirPanel::onCmdDirMan),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_DIR_RENAME, DirPanel::onCmdDirMan),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_DIR_SYMLINK, DirPanel::onCmdDirMan),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_DIR_DELETE, DirPanel::onCmdDirDelete),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_DIR_TRASH, DirPanel::onCmdDirTrash),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_DIR_RESTORE, DirPanel::onCmdDirRestore),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_NEW_DIR, DirPanel::onCmdNewDir),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_XTERM, DirPanel::onCmdXTerm),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_TOGGLE_HIDDEN, DirPanel::onCmdToggleHidden),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_TOGGLE_TREE, DirPanel::onCmdToggleTree),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_CLOSE_TREE, DirPanel::onCmdCloseTree),
    FXMAPFUNC(SEL_TIMEOUT, DirPanel::ID_DIRSIZE_REFRESH, DirPanel::onCmdDirsizeRefresh),
    FXMAPFUNC(SEL_FOCUSIN, DirPanel::ID_FILELIST, DirPanel::onCmdFocus),
#if defined(linux)
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_MOUNT, DirPanel::onCmdMount),
    FXMAPFUNC(SEL_COMMAND, DirPanel::ID_UMOUNT, DirPanel::onCmdMount),
    FXMAPFUNC(SEL_UPDATE, DirPanel::ID_MOUNT, DirPanel::onUpdMount),
    FXMAPFUNC(SEL_UPDATE, DirPanel::ID_UMOUNT, DirPanel::onUpdUnmount),
#endif
    FXMAPFUNC(SEL_UPDATE, DirPanel::ID_PASTE_CLIPBOARD, DirPanel::onUpdPaste),
    FXMAPFUNC(SEL_UPDATE, DirPanel::ID_TOGGLE_HIDDEN, DirPanel::onUpdToggleHidden),
    FXMAPFUNC(SEL_UPDATE, DirPanel::ID_TOGGLE_TREE, DirPanel::onUpdToggleTree),
    FXMAPFUNC(SEL_UPDATE, DirPanel::ID_CUT_CLIPBOARD, DirPanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, DirPanel::ID_ARCHIVE, DirPanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, DirPanel::ID_DIR_MOVETO, DirPanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, DirPanel::ID_DIR_RENAME, DirPanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, DirPanel::ID_DIR_TRASH, DirPanel::onUpdDirTrash),
    FXMAPFUNC(SEL_UPDATE, DirPanel::ID_DIR_RESTORE, DirPanel::onUpdDirRestore),
    FXMAPFUNC(SEL_UPDATE, DirPanel::ID_DIR_DELETE, DirPanel::onUpdDirDelete),
    FXMAPFUNC(SEL_UPDATE, DirPanel::ID_NEW_DIR, DirPanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, DirPanel::ID_TITLE, DirPanel::onUpdTitle),
    FXMAPFUNC(SEL_UPDATE, 0, DirPanel::onUpdDirsizeRefresh),
};

// Object implementation
FXIMPLEMENT(DirPanel, FXVerticalFrame, DirPanelMap, ARRAYNUMBER(DirPanelMap))

// Construct Directory Panel
DirPanel::DirPanel(FXWindow* owner, FXComposite* p, FXColor listbackcolor, FXColor listforecolor, FXbool smoothscroll, FXuint opts, int x, int y, int w, int h) :
    FXVerticalFrame(p, opts, x, y, w, h, 0, 0, 0, 0)
{
    // Construct directory panel
    FXVerticalFrame* cont = new FXVerticalFrame(this, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    FXVerticalFrame* cont3 = new FXVerticalFrame(cont, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_SUNKEN, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    FXPacker*        packer = new FXHorizontalFrame(cont3, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|FRAME_RAISED, 0, 0, 0, 0, 0, 0, 0, 0);

    // Visually indicate if the panel is active
    // activeicon = new FXButton(packer, "", greenbuttonicon, this, DirPanel::ID_FILELIST, BUTTON_TOOLBAR|JUSTIFY_LEFT|LAYOUT_LEFT);

    // Panel title
    // paneltitle = new FXLabel(packer, _("Folders"), NULL, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X, 0, 0, 0, 0, 4);
    paneltitle = new TextLabel(packer, 0, this, ID_FILELIST, LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 6, 6, 3, 3);
    paneltitle->setText(_("Folders"));
    paneltitle->setBackColor(getApp()->getBaseColor());

    activeicon = new FXButton(packer, "", NULL, this, DirPanel::ID_FILELIST, BUTTON_TOOLBAR|JUSTIFY_LEFT|LAYOUT_LEFT);

    FXButton* dummyicon = new FXButton(packer, "", closeicon, this, ID_CLOSE_TREE, FRAME_RAISED|BUTTON_TOOLBAR|JUSTIFY_LEFT|LAYOUT_LEFT, 0, 0, 0, 0, 0, 0, 0, 0);
    dummyicon->setBackColor(getApp()->getBaseColor());


//    key = getApp()->reg().readStringEntry("KEYBINDINGS", "one_panel", "Ctrl-F1");
//    hotkey = _parseAccel(key);
//    btn->addHotKey(hotkey);

    FXuint options;
    if (smoothscroll)
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|TREELIST_BROWSESELECT|TREELIST_SHOWS_LINES|TREELIST_SHOWS_BOXES|FRAME_SUNKEN;
    }
    else
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|TREELIST_BROWSESELECT|TREELIST_SHOWS_LINES|TREELIST_SHOWS_BOXES|SCROLLERS_DONT_TRACK;
    }

    FXVerticalFrame* cont2 = new FXVerticalFrame(cont3, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_RAISED, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    list = new DirList(owner, cont2, this, ID_FILELIST, options);
    list->setTextColor(listforecolor);
    list->setBackColor(listbackcolor);

    statusbar = new FXHorizontalFrame(cont, JUSTIFY_LEFT|LAYOUT_FILL_X, 0, 0, 0, 0, 0, 0, 2, 0);

    FXString key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_dirs", "Ctrl-F5");

    status = new FXLabel(statusbar, _("0 bytes in root"), NULL, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X|FRAME_SUNKEN, 0, 0, 0, 0, 1, 0, 1, 1);
    status->setTarget(this);
    status->setSelector(FXSEL(SEL_UPDATE, DirPanel::ID_TITLE));

    // Home and trahscan locations
    trashlocation = xdgdatahome+PATHSEPSTRING TRASHPATH;
    trashfileslocation = xdgdatahome + PATHSEPSTRING TRASHFILESPATH;
    trashinfolocation = xdgdatahome + PATHSEPSTRING TRASHINFOPATH;

    // Start location (we return to the start location after each chdir)
    startlocation = FXSystem::getCurrentDirectory();

    // Single click navigation
    single_click = getApp()->reg().readUnsignedEntry("SETTINGS", "single_click", SINGLE_CLICK_NONE);
    if (single_click == SINGLE_CLICK_DIR_FILE)
    {
        list->setDefaultCursor(getApp()->getDefaultCursor(DEF_HAND_CURSOR));
    }

    // Dialogs
    newdirdialog = NULL;
    archdialog = NULL;
    operationdialog = NULL;
    operationdialogrename = NULL;

    // Initialize clipboard flag
    fromPaste = false;

    // Initialize control flag for right click popup menu
    ctrlflag = false;

    // Other initializations
    focuswindow = owner;
    isactive = false;
    curr_mtime = 0;
    curr_dirpath = "";
    allowDirsizeRefresh = true;
}


// Destructor
DirPanel::~DirPanel()
{
    getApp()->removeTimeout(this, ID_DIRSIZE_REFRESH);
    delete list;
    delete statusbar;
    delete status;
    delete newdirdialog;
    delete archdialog;
    delete operationdialog;
    delete operationdialogrename;
    delete paneltitle;
}


// Create X window
void DirPanel::create()
{
    // Register standard uri-list type
    urilistType = getApp()->registerDragType("text/uri-list");

    // Register special uri-list type used for Gnome, XFCE and Xfe
    xfelistType = getApp()->registerDragType("x-special/gnome-copied-files");

    // Register special uri-list type used for KDE
    kdelistType = getApp()->registerDragType("application/x-kde-cutselection");

    // Register standard UTF-8 text type used for file dialogs
    utf8Type = getApp()->registerDragType("UTF8_STRING");

    getApp()->addTimeout(this, ID_DIRSIZE_REFRESH, DIRSIZE_REFRESH_INTERVAL);
    FXVerticalFrame::create();
}


// Make DirPanel active
void DirPanel::setActive()
{
    // Set active icon
    // activeicon->setIcon(greenbuttonicon);
    activeicon->setIcon(NULL);
    activeicon->setTipText(_("Panel is active"));
    list->setFocus();
    isactive = true;

    // Current panel must get an inactive icon (but not get the inactive status!)
    FilePanel* currentpanel = ((XFileExplorer*)mainWindow)->getCurrentPanel();
    currentpanel->setInactive(false);
}


// Make DirPanel inactive
void DirPanel::setInactive()
{
    // Set active icon
    // activeicon->setIcon(graybuttonicon);
    activeicon->setIcon(NULL);
    activeicon->setTipText(_("Activate panel"));
    isactive = false;
}


// Focus on DirPanel when clicked (i.e. make panel active)
long DirPanel::onCmdFocus(FXObject* sender, FXSelector sel, void* ptr)
{
    setActive();
    return(1);
}


// To pass the expand message to DirList
long DirPanel::onExpand(FXObject*, FXSelector, void* ptr)
{
    list->handle(this, FXSEL(SEL_EXPANDED, 0), (void*)ptr);
    return(1);
}


// Change the directory when clicking on the tree list
long DirPanel::onCmdDirectory(FXObject*, FXSelector, void* ptr)
{
    TreeItem* item = (TreeItem*)ptr;

    if (item)
    {
        FXString directory = list->getItemPathname(item);
        if (!::isReadExecutable(directory))
        {
            MessageBox::error(this, BOX_OK_SU, _("Error"), _(" Permission to: %s denied."), directory.text());
            return(0);
        }
        FilePanel*  currentpanel = ((XFileExplorer*)mainWindow)->getCurrentPanel();
        FXComboBox* address = ((XFileExplorer*)mainWindow)->getAddressBox();
        currentpanel->setDirectory(directory, true);
        currentpanel->updatePath();

        // Remember latest directory in the location address
        FXString item;
        int      i = 0;
        int      count = address->getNumItems();
        FXString p = currentpanel->getDirectory();

        if (!count)
        {
            count++;
            address->insertItem(0, address->getText());
        }
        while (i < count)
        {
            item = address->getItem(i++);
            if (streq((const char*)&p[0], (const char*)&item[0]))
            {
                i--;
                break;
            }
        }
        if (i == count)
        {
            address->insertItem(0, currentpanel->getDirectory());
        }
    }

    // Manage single click navigation
    if (item && (single_click != SINGLE_CLICK_NONE) && !fromKeyPress)
    {
        list->handle(this, FXSEL(SEL_EXPANDED, 0), (void*)ptr);
    }
    fromKeyPress = false;

    return(1);
}


// Toggle hidden files
long DirPanel::onCmdToggleHidden(FXObject*, FXSelector, void*)
{
    list->showHiddenFiles(!list->shownHiddenFiles());
    return(1);
}


// Update toggle hidden files widget
long DirPanel::onUpdToggleHidden(FXObject* sender, FXSelector, void*)
{
    if (list->shownHiddenFiles())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


long DirPanel::onCmdToggleTree(FXObject* sender, FXSelector sel, void* ptr)
{
    return(this->handle(sender, FXSEL(SEL_COMMAND, FXWindow::ID_TOGGLESHOWN), ptr));
}


long DirPanel::onUpdToggleTree(FXObject* sender, FXSelector sel, void* ptr)
{
    if (this->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_CHECK), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_UNCHECK), ptr);
    }
    return(1);
}


// Directory list context menu
long DirPanel::onCmdPopupMenu(FXObject* o, FXSelector s, void* p)
{
    // Check if control key was pressed
    if (p != NULL)
    {
        FXEvent* event = (FXEvent*)p;
        if (event->state&CONTROLMASK)
        {
            ctrlflag = true;
        }
    }

    // Current item becomes item under cursor
    int    x, y, xitem, yitem;
    FXuint state;
    getRoot()->getCursorPosition(x, y, state);
    list->getCursorPosition(xitem, yitem, state);
    DirItem* item = (DirItem*)list->getItemAt(xitem, yitem);

    // If item, then set it current and set directory in DirList and FileList
    FXString dir;
    if (item)
    {
        list->setCurrentItem(item, true);
        dir = list->getItemPathname((TreeItem*)item);
        list->setDirectory(dir, true);
        ((XFileExplorer*)mainWindow)->getCurrentPanel()->setDirectory(dir, true);
        ((XFileExplorer*)mainWindow)->getCurrentPanel()->updatePath();
    }
    else
    {
        ctrlflag = true;
    }

    // Popup menu pane
    FXMenuPane* menu = new FXMenuPane(this);

    // Menu

    // Control flag set
    if (ctrlflag)
    {
        // Reset the control flag
        ctrlflag = false;

        // Panel menu items
        new FXMenuCommand(menu, _("New &folder..."), NULL, this, DirPanel::ID_NEW_DIR);

        new FXMenuSeparator(menu);
        new FXMenuCheck(menu, _("&Hidden folders"), this, DirPanel::ID_TOGGLE_HIDDEN);
        new FXMenuCheck(menu, _("Ignore c&ase"), list, DirList::ID_SORT_CASE);
        new FXMenuCheck(menu, _("&Reverse order"), list, DirList::ID_SORT_REVERSE);
        new FXMenuCommand(menu, _("E&xpand tree"), NULL, this, DirPanel::ID_EXPANDTREE);
        new FXMenuCommand(menu, _("Collap&se tree"), NULL, this, DirPanel::ID_COLLAPSETREE);
    }
    else
    {
        // Panel submenu items
        FXMenuPane* submenu = new FXMenuPane(this);

        new FXMenuCommand(submenu, _("New &folder..."), NULL, this, DirPanel::ID_NEW_DIR);

        new FXMenuSeparator(submenu);
        new FXMenuCheck(submenu, _("&Hidden folders"), this, DirPanel::ID_TOGGLE_HIDDEN);
        new FXMenuCheck(submenu, _("Ignore c&ase"), list, DirList::ID_SORT_CASE);
        new FXMenuCheck(submenu, _("&Reverse order"), list, DirList::ID_SORT_REVERSE);
        new FXMenuCommand(submenu, _("E&xpand tree"), NULL, this, DirPanel::ID_EXPANDTREE);
        new FXMenuCommand(submenu, _("Collap&se tree"), NULL, this, DirPanel::ID_COLLAPSETREE);

        new FXMenuCascade(menu, _("Pane&l"), NULL, submenu);
        new FXMenuSeparator(menu);

#if defined(linux)
        if (::isLink(dir))
        {
            dir = ::readLink(dir);
        }
        if (fsdevices->find(dir.text()) || mtdevices->find(dir.text()))
        {
            new FXMenuCommand(menu, _("M&ount"), NULL, this, ID_MOUNT);
            new FXMenuCommand(menu, _("Unmoun&t"), NULL, this, ID_UMOUNT);
            new FXMenuSeparator(menu);
        }
#endif
        new FXMenuCommand(menu, _("&Add to archive..."), NULL, this, DirPanel::ID_ARCHIVE);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("&Copy"), NULL, this, DirPanel::ID_COPY_CLIPBOARD);
        new FXMenuCommand(menu, _("C&ut"), NULL, this, DirPanel::ID_CUT_CLIPBOARD);
        new FXMenuCommand(menu, _("&Paste"), NULL, this, DirPanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("Re&name..."), NULL, this, DirPanel::ID_DIR_RENAME);
        new FXMenuCommand(menu, _("Cop&y to..."), NULL, this, DirPanel::ID_DIR_COPYTO);
        new FXMenuCommand(menu, _("&Move to..."), NULL, this, DirPanel::ID_DIR_MOVETO);
        new FXMenuCommand(menu, _("Symlin&k to..."), NULL, this, DirPanel::ID_DIR_SYMLINK);
        new FXMenuCommand(menu, _("Mo&ve to trash"), NULL, this, DirPanel::ID_DIR_TRASH);
        new FXMenuCommand(menu, _("R&estore from trash"), NULL, this, DirPanel::ID_DIR_RESTORE);
        new FXMenuCommand(menu, _("&Delete"), NULL, this, DirPanel::ID_DIR_DELETE);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("Prop&erties"), NULL, this, DirPanel::ID_PROPERTIES);
    }

    menu->create();
    allowPopupScroll = true;  // Allow keyboard scrolling
    menu->popup(NULL, x, y);
    getApp()->runModalWhileShown(menu);
    allowPopupScroll = false;
    return(1);
}


// Helper function used to explore the directory tree and expand or collapse it
long DirPanel::exploreUp(DirItem* item, const DirItem* rootitem, const int task)
{
    DirItem* parentitem = item;

    if (task == ID_EXPANDTREE)
    {
        list->expandTree((TreeItem*)item, true);
    }
    else
    {
        list->collapseTree((TreeItem*)item, true);
    }

    item = (DirItem*)item->getFirst();
    if (!item)
    {
        exploreDown(parentitem, rootitem, task);
    }
    else
    {
        exploreUp(item, rootitem, task);
    }
    return(1);
}


// Helper function used to explore the directory tree and expand or collapse it
long DirPanel::exploreDown(DirItem* item, const DirItem* rootitem, const int task)
{
    if (item == rootitem)
    {
        return(1);
    }

    DirItem* parentitem = (DirItem*)item->getParent();

    if (task == ID_EXPANDTREE)
    {
        list->expandTree((TreeItem*)item, true);
    }
    else
    {
        list->collapseTree((TreeItem*)item, true);
    }
    item = (DirItem*)item->getNext();

    if (!item)
    {
        exploreDown(parentitem, rootitem, task);
    }
    else
    {
        if (task == ID_EXPANDTREE)
        {
            list->expandTree((TreeItem*)item, true);
        }
        else
        {
            list->collapseTree((TreeItem*)item, true);
        }
        if (!list->isItemLeaf(item))
        {
            exploreUp(item, rootitem, task);
        }
        else
        {
            exploreDown(item, rootitem, task);
        }
    }
    return(1);
}


// Expand the directory tree under cursor
long DirPanel::onExpandTree(FXObject* sender, FXSelector sel, void*)
{
    DirItem* rootitem = (DirItem*)list->getCurrentItem();

    getApp()->beginWaitCursor();
    exploreUp(rootitem, rootitem, ID_EXPANDTREE);
    getApp()->endWaitCursor();

    return(1);
}


// Collapse the directory tree under cursor
long DirPanel::onCollapseTree(FXObject* sender, FXSelector sel, void*)
{
    DirItem* rootitem = (DirItem*)list->getCurrentItem();

    getApp()->beginWaitCursor();
    exploreUp(rootitem, rootitem, ID_COLLAPSETREE);
    getApp()->endWaitCursor();

    return(1);
}


// Directory properties
long DirPanel::onCmdProperties(FXObject* sender, FXSelector, void*)
{
    // Current item
    DirItem* item = (DirItem*)list->getCurrentItem();
    FXString pathname = list->getItemPathname((TreeItem*)item);

    PropertiesBox* attrdlg = new PropertiesBox(this, FXPath::name(pathname), FXPath::directory(pathname));

            attrdlg->create();

        attrdlg->show(PLACEMENT_OWNER);

    //~ if (attrdlg->execute(PLACEMENT_OWNER))
    //~ {
        list->setDirectory(pathname, true);
    //~ }
    //~ delete attrdlg;
    return(1);
}


// Add files or directory to an archive
long DirPanel::onCmdAddToArch(FXObject* o, FXSelector, void*)
{
    int      ret;
    FXString ext1, ext2, cmd, archive;
    File*    f;

    // Name and path of the current item
    DirItem* item = (DirItem*)list->getCurrentItem();
    FXString name = list->getItemText(item);
    FXString pathname = list->getItemPathname((TreeItem*)item);
    FXString parentdir = FXPath::directory(pathname);

    // Initial archive name with full path and default extension
    if (parentdir == PATHSEPSTRING)
    {
        if (name == PATHSEPSTRING) // Archive is root file system
        {
            archive = parentdir+"ROOT"+".tar.gz";
        }
        else
        {
            archive = parentdir+name+".tar.gz";
        }
    }
    else
    {
        archive = parentdir+PATHSEPSTRING+name+".tar.gz";
    }

    ret = chdir(parentdir.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), parentdir.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), parentdir.text());
        }

        return(0);
    }

    // Archive dialog
    if (archdialog == NULL)
    {
        archdialog = new ArchInputDialog(this, "");
    }
    archdialog->setText(archive);
    archdialog->CursorEnd();

    if (archdialog->execute())
    {
        if (archdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

        // Get string and preserve escape characters
        archive = ::quote(archdialog->getText());

        // Get extensions of the archive name
        ext1 = archdialog->getText().rafter('.', 1).lower();
        ext2 = archdialog->getText().rafter('.', 2).lower();

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zcvf "+archive+" ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jcvf "+archive+" ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jcvf "+archive+" ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zcvf "+archive+" ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -cvf "+archive+" ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zcvf "+archive+" ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zcvf "+archive+" ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "xz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jcvf "+archive+" ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jcvf "+archive+" ";
        }
        else if (ext1 == "z")
        {
            cmd = "compress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "zip -r "+archive+" ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z a "+archive+" ";
        }

        // Default archive format
        else
        {
            archive += ".tar.gz";
            cmd = "tar -zcvf "+archive+" ";
        }

        // Archive command name
        cmd = cmd+::quote(name);

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Create archive"), ARCHIVE);
        f->create();

        // Create archive
        f->archive(archive, cmd);
        ret = chdir(startlocation.text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
            }

            return(0);
        }

        getApp()->endWaitCursor();
        delete f;

        // Display parent directory in DirList and FileList
        list->setDirectory(parentdir, true);
        ((XFileExplorer*)mainWindow)->getCurrentPanel()->setDirectory(parentdir);
        ((XFileExplorer*)mainWindow)->getCurrentPanel()->updatePath();
    }
    return(1);
}


// We now really do have the clipboard, keep clipboard content
long DirPanel::onClipboardGained(FXObject* sender, FXSelector sel, void* ptr)
{
    FXVerticalFrame::onClipboardGained(sender, sel, ptr);
    return(1);
}


// We lost the clipboard, free clipboard content
long DirPanel::onClipboardLost(FXObject* sender, FXSelector sel, void* ptr)
{
    FXVerticalFrame::onClipboardLost(sender, sel, ptr);
    return(1);
}


// Somebody wants our clipboard content
long DirPanel::onClipboardRequest(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    FXuchar* data;
    FXuint   len;

    // Perhaps the target wants to supply its own data for the clipboard
    if (FXVerticalFrame::onClipboardRequest(sender, sel, ptr))
    {
        return(1);
    }

    // Clipboard target is xfelistType (Xfe, Gnome or XFCE)
    if (event->target == xfelistType)
    {
        // Don't modify the clipboard if we are called from updPaste()
        if (!clipboard_locked)
        {
            // Prepend "copy" or "cut" as in the Gnome way and avoid duplicating these strings
            if ((clipboard.find("copy\n") < 0) && (clipboard.find("cut\n") < 0))
            {
                if (clipboard_type == CUT_CLIPBOARD)
                {
                    clipboard = "cut\n" + clipboard;
                }
                else
                {
                    clipboard = "copy\n" + clipboard;
                }
            }
        }

        // Return clipboard content
        if (event->target == xfelistType)
        {
            if (!clipboard.empty())
            {
                len = clipboard.length();
                FXMEMDUP(&data, clipboard.text(), FXuchar, len);
                setDNDData(FROM_CLIPBOARD, event->target, data, len);

                // Return because xfelistType is not compatible with other types
                return(1);
            }
        }
    }

    // Clipboard target is kdelisType (KDE)
    if (event->target == kdelistType)
    {
        // The only data to be passed in this case is "0" for copy and "1" for cut
        // The uri data are passed using the standard uri-list type
        FXString flag;
        if (clipboard_type == CUT_CLIPBOARD)
        {
            flag = "1";
        }
        else
        {
            flag = "0";
        }

        // Return clipboard content
        if (event->target == kdelistType)
        {
            FXMEMDUP(&data, flag.text(), FXuchar, 1);
            setDNDData(FROM_CLIPBOARD, event->target, data, 1);
        }
    }

    // Clipboard target is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    if (event->target == urilistType)
    {
        if (!clipboard.empty())
        {
            len = clipboard.length();
            FXMEMDUP(&data, clipboard.text(), FXuchar, len);
            setDNDData(FROM_CLIPBOARD, event->target, data, len);

            return(1);
        }
    }

    // Clipboard target is utf8Type (to paste file pathes as text to other applications)
    if (event->target == utf8Type)
    {
        if (!clipboard.empty())
        {
            int      beg = 0, end = 0;
            FXString str = "";
            FXString pathname, url;

            // Clipboard don't contain 'copy\n' or 'cut\n' as first line
            if ((clipboard.find("copy\n") < 0) && (clipboard.find("cut\n") < 0))
            {
                // Remove the 'file:' prefix for each file path
                while (1)
                {
                    end = clipboard.find('\n', end);
                    if (end < 0) // Last line
                    {
                        end = clipboard.length();
                        url = clipboard.mid(beg, end-beg+1);
                        pathname = FXURL::decode(FXURL::fileFromURL(url));
                        str += pathname;
                        break;
                    }
                    url = clipboard.mid(beg, end-beg+1);
                    pathname = FXURL::decode(FXURL::fileFromURL(url));
                    str += pathname;
                    end++;
                    beg = end;
                }
                end = str.length();
                str = str.mid(0, end-2);  // Why is it end-2 here????
            }

            // Clipboard contains 'copy\n' or 'cut\n' as first line, thus skip it
            else
            {
                // Start after the 'copy\n' or 'cut\n' prefix
                end = clipboard.find('\n', 0);
                end++;
                beg = end;

                // Remove the 'file:' prefix for each file path
                while (1)
                {
                    end = clipboard.find('\n', end);
                    if (end < 0) // Last line
                    {
                        end = clipboard.length();
                        url = clipboard.mid(beg, end-beg+1);
                        pathname = FXURL::decode(FXURL::fileFromURL(url));
                        str += pathname;
                        break;
                    }
                    url = clipboard.mid(beg, end-beg+1);
                    pathname = FXURL::decode(FXURL::fileFromURL(url));
                    str += pathname;
                    end++;
                    beg = end;
                }
                end = str.length();
                //str=str.mid(0,end-1);
            }

            if (!str.empty())
            {
                len = str.length();
                FXMEMDUP(&data, str.text(), FXuchar, len);
                setDNDData(FROM_CLIPBOARD, event->target, data, len);

                return(1);
            }
        }
    }
    return(0);
}


// Copy or cut to clipboard (and add copy / add cut)
long DirPanel::onCmdCopyCut(FXObject*, FXSelector sel, void*)
{
    // Clear clipboard
    if ((FXSELID(sel) == ID_COPY_CLIPBOARD) || (FXSELID(sel) == ID_CUT_CLIPBOARD))
    {
        clipboard.clear();
    }

    // Add an '\n' at the end if addcopy or addcut
    else
    {
        clipboard += '\n';
    }

    // Clipboard type
    if ((FXSELID(sel) == ID_CUT_CLIPBOARD) || (FXSELID(sel) == ID_ADDCUT_CLIPBOARD))
    {
        clipboard_type = CUT_CLIPBOARD;
    }
    else
    {
        clipboard_type = COPY_CLIPBOARD;
    }

    // Current item
    DirItem* item = (DirItem*)list->getCurrentItem();
    FXString pathname = list->getItemPathname((TreeItem*)item);
    clipboard += FXURL::encode(::fileToURI(pathname));

    // Acquire the clipboard
    FXDragType types[4];
    types[0] = xfelistType;
    types[1] = kdelistType;
    types[2] = urilistType;
    types[3] = utf8Type;
    if (acquireClipboard(types, 4))
    {
        return(0);
    }

    return(1);
}


// Paste file(s) from clipboard
long DirPanel::onCmdPaste(FXObject*, FXSelector sel, void*)
{
    FXuchar* data;
    FXuint   len;
    int      beg, end, pos;
    FXString chaine, url, param;
    int      num = 0;
    FXbool   from_kde = false;

    // Target directory
    FXString targetdir = ((XFileExplorer*)mainWindow)->getCurrentPanel()->getDirectory();

    // If source is xfelistType (Gnome, XFCE, or Xfe app)
    if (getDNDData(FROM_CLIPBOARD, xfelistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';

        clipboard = (char*)data;

        // Loop over clipboard items
        for (beg = 0; beg < clipboard.length(); beg = end+1)
        {
            if ((end = clipboard.find("\n", beg)) < 0)
            {
                end = clipboard.length();
            }

            // Obtain item url
            url = clipboard.mid(beg, end-beg);

            // Eventually remove the trailing '\r' if any
            if ((pos = url.rfind('\r')) > 0)
            {
                url.erase(pos);
            }

            // Process first item
            if (num == 0)
            {
                // First item should be "copy" or "cut"
                if (url == "copy")
                {
                    clipboard_type = COPY_CLIPBOARD;
                    num++;
                }
                else if (url == "cut")
                {
                    clipboard_type = CUT_CLIPBOARD;
                    num++;
                }

                // If first item is not "copy" nor "cut", process it as a normal url
                // and use default clipboard type
                else
                {
                    // Update the param string
                    param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";

                    // Add one more because the first line "copy" or "cut" was not present
                    num += 2;
                }
            }

            // Process other items
            else
            {
                // Update the param string
                param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";
                num++;
            }
        }

        // Construct the final param string passed to the file management routine
        param = targetdir+"\n" + FXStringVal(num-1) + "\n" + param;

        // Copy or cut operation depending on the clipboard type
        switch (clipboard_type)
        {
        case COPY_CLIPBOARD:
            sel = FXSEL(SEL_COMMAND, DirPanel::ID_DIR_COPY);
            break;

        case CUT_CLIPBOARD:
            clipboard.clear();
            sel = FXSEL(SEL_COMMAND, DirPanel::ID_DIR_CUT);
            break;
        }
        fromPaste = true;
        this->handle(this, sel, (void*)param.text());

        // Free data pointer
        FXFREE(&data);

        // Return here because xfelistType is not compatible with other types
        return(1);
    }

    // If source type is kdelistType (KDE)
    if (getDNDData(FROM_CLIPBOARD, kdelistType, data, len))
    {
        from_kde = true;

        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        clipboard = (char*)data;

        // Obtain clipboard type (copy or cut)
        if (clipboard == "1")
        {
            clipboard_type = CUT_CLIPBOARD;
        }
        else
        {
            clipboard_type = COPY_CLIPBOARD;
        }

        FXFREE(&data);
    }


    // If source type is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    if (getDNDData(FROM_CLIPBOARD, urilistType, data, len))
    {
        // For non KDE apps, set action to copy
        if (!from_kde)
        {
            clipboard_type = COPY_CLIPBOARD;
        }

        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        clipboard = (char*)data;

        // Loop over clipboard items
        for (beg = 0; beg < clipboard.length(); beg = end+1)
        {
            if ((end = clipboard.find("\n", beg)) < 0)
            {
                end = clipboard.length();
            }

            // Obtain item url
            url = clipboard.mid(beg, end-beg);

            // Eventually remove the trailing '\r' if any
            if ((pos = url.rfind('\r')) > 0)
            {
                url.erase(pos);
            }

            // Update the param string
            param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";
            num++;
        }

        // Construct the final param string passed to the file management routine
        param = targetdir+"\n" + FXStringVal(num) + "\n" + param;

        // Copy or cut operation depending on the clipboard type
        switch (clipboard_type)
        {
        case COPY_CLIPBOARD:
            sel = FXSEL(SEL_COMMAND, DirPanel::ID_DIR_COPY);
            break;

        case CUT_CLIPBOARD:
            clipboard.clear();
            sel = FXSEL(SEL_COMMAND, DirPanel::ID_DIR_CUT);
            break;
        }
        fromPaste = true;
        handle(this, sel, (void*)param.text());

        FXFREE(&data);
        return(1);
    }
    return(0);
}


// Set the flag that allows to stop the file list refresh
long DirPanel::onCmdStopListRefreshTimer(FXObject*, FXSelector, void*)
{
    stopListRefresh = true;
    return(0);
}


// Copy/Move/Rename/Symlink directory
long DirPanel::onCmdDirMan(FXObject* sender, FXSelector sel, void* ptr)
{
    int      num;
    FXString src, targetdir, target, name, source;

    // Confirmation dialog?
    FXbool ask_before_copy = getApp()->reg().readUnsignedEntry("OPTIONS", "ask_before_copy", true);

    // If we are called from the paste command, get the parameters from the pointer
    // Multiple sources are allowed
    if (fromPaste)
    {
        // Reset the flag
        fromPaste = false;

        // Get the parameters
        FXString str = (char*)ptr;
        targetdir = str.section('\n', 0);
        num = FXUIntVal(str.section('\n', 1));
        src = str.after('\n', 2);
        source = src.section('\n', 0);

        // If no item, return
        if (num <= 0)
        {
            return(0);
        }
    }

    // Obtain the parameters from the dir panel (only one source)
    else
    {
        // Current item
        DirItem* item = (DirItem*)list->getCurrentItem();

        // Number of items
        if (item)
        {
            num = 1;
        }
        else
        {
            return(0);
        }

        // Source directory
        source = list->getItemPathname((TreeItem*)item);

        // Target directory
        targetdir = FXPath::directory(source);
    }

    // Go to target directory
    //chdir(targetdir.text());

    // Name and directory of the first source file
    name = FXPath::name(source);
    FXString dir = FXPath::directory(source);

    // Initialise target name
    if (targetdir != ROOTDIR)
    {
        target = targetdir+PATHSEPSTRING;
    }
    else
    {
        target = targetdir;
    }

    // Configure the command, title, message, etc.
    FXIcon*  icon = NULL;
    FXString command, title, message;
    if (FXSELID(sel) == ID_DIR_COPY)
    {
        command = "copy";
        title = _("Copy");
        icon = copy_bigicon;
        if (num == 1)
        {
            message = _("Copy ");
            message += source;
            if (::isFile(source))
            {
                target += name;
            }

            // Source and target are identical => add a suffix to the name
            FXString tgt = ::cleanPath(target); // Remove trailing / if any
            if ((::identical(source, tgt)) ||
                (::isDirectory(source) && (source == tgt+PATHSEPSTRING+FXPath::name(source))))
            {
                target = ::buildCopyName(source);
            }
        }
        else
        {
            message.format(_("Copy %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_DIR_RENAME)
    {
        command = "rename";
        title = _("Rename");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Rename ");
            message += name;
            target = name;
            title = _("Rename");
        }
        else
        {
            return(0);
        }
    }
    if (FXSELID(sel) == ID_DIR_COPYTO)
    {
        command = "copy";
        title = _("Copy to");
        icon = copy_bigicon;
        if (num == 1)
        {
            message = _("Copy ");
            message += source;
        }
        else
        {
            message.format(_("Copy %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_DIR_MOVETO)
    {
        command = "move";
        title = _("Move");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Move ");
            message += source;
            title = _("Move");
        }
        else
        {
            message.format(_("Move %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_DIR_CUT)
    {
        command = "move";
        title = _("Move");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Move ");
            message += source;
            if (::isFile(source))
            {
                target += name;
            }
            title = _("Move");
        }
        else
        {
            message.format(_("Move %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_DIR_SYMLINK)
    {
        command = "symlink";
        title = _("Symlink");
        icon = link_bigicon;
        if (num == 1)
        {
            message = _("Symlink ");
            message += source;
            target += name;
        }
        else
        {
            message.format(_("Symlink %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }

    // File operation dialog, if needed
    if (ask_before_copy || (source == target) || (FXSELID(sel) == ID_DIR_COPYTO) || (FXSELID(sel) == ID_DIR_MOVETO) || (FXSELID(sel) == ID_DIR_RENAME) || (FXSELID(sel) == ID_DIR_SYMLINK))
    {
		if (FXSELID(sel) == ID_DIR_RENAME)
		{
			if (operationdialogrename == NULL)
			{
				operationdialogrename = new InputDialog(this, "", "", title, _("To:"), icon);
			}
			operationdialogrename->setTitle(title);
			operationdialogrename->setIcon(icon);
			operationdialogrename->setMessage(message);
			operationdialogrename->setText(target);
            operationdialogrename->selectAll();
			operationdialogrename->CursorEnd();
			int rc = 1;
			rc = operationdialogrename->execute(PLACEMENT_CURSOR);
			target = operationdialogrename->getText();

			// Target name contains '/'
			if (target.contains(PATHSEPCHAR))
			{
				MessageBox::error(this, BOX_OK, _("Error"), _("The / character is not allowed in folder names, operation cancelled"));
				return(0);
			}

			if (!rc)
			{
				return(0);
			}
		}
		else
		{
			if (operationdialog == NULL)
			{
				operationdialog = new BrowseInputDialog(this, "", "", title, _("To:"), icon, BROWSE_INPUT_FOLDER);
			}
			operationdialog->setTitle(title);
			operationdialog->setIcon(icon);
			operationdialog->setMessage(message);
			operationdialog->setText(target);
			operationdialog->CursorEnd();
			operationdialog->setDirectory(targetdir);
			int rc = 1;
			rc = operationdialog->execute(PLACEMENT_CURSOR);
			target = operationdialog->getText();
			if (!rc)
			{
				return(0);
			}
		}
    }

    // Update target and target parent directory
    target = ::filePath(target, targetdir);
	if (::isDirectory(target))
	{
		targetdir = target;
	}
	else
	{
		targetdir = FXPath::directory(target);
	}

    // Target directory not writable
    if (!::isWritable(targetdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetdir.text());
        return(0);
    }

    // Multiple sources and non existent destination
    if ((num > 1) && !::exists(target))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), target.text());
        return(0);
    }

    // Multiple sources and target is a file
    if ((num > 1) && ::isFile(target))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("%s is not a folder"), target.text());
        return(0);
    }

    // Target is a directory and is not writable
    if (::isDirectory(target) & !::isWritable(target))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), target.text());
        return(0);
    }

    // Target is a file and its parent directory is not writable
    if (::isFile(target) && !::isWritable(targetdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetdir.text());
        return(0);
    }

    // Target parent directory doesn't exist
    if (!::exists(targetdir))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), targetdir.text());
        return(0);
    }

    // Target parent directory is not a directory
    if (!::isDirectory(targetdir))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("%s is not a folder"), targetdir.text());
        return(0);
    }

    // Current and next panel
    FilePanel* currentpanel = ((XFileExplorer*)mainWindow)->getCurrentPanel();
    FilePanel* nextpanel = ((XFileExplorer*)mainWindow)->getNextPanel();

    // One source
    File* f;
    int   ret;
    f = NULL;
    if (num == 1)
    {
        // An empty source file name corresponds to the ".." file
        // Don't perform any file operation on it!
        if (source == "")
        {
            return(0);
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        if (command == "copy")
        {
            f = new File(this, _("File copy"), COPY);
            f->create();

            // If target file is located at trash location, also create the corresponding trashinfo file
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && (target == trashfileslocation))
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(source, trashfileslocation);

                // Adjust target name to get the _N suffix if any
                FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                // Create trashinfo file
                createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                // Copy source to trash target
                ret = f->copy(source, trashtarget);
            }

            // Copy source to target
            else
            {
                ret = f->copy(source, target);
            }

            // An error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
            }
        }
        else if (command == "rename")
        {
            f = new File(this, _("File rename"), RENAME);
            f->create();
            ret = f->rename(source, target);

            // If file is located at trash location, try to also remove the corresponding trashinfo if it exists
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
            {
                FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                ::unlink(trashinfopathname.text());
            }
        }
        else if (command == "move")
        {
            f = new File(this, _("File move"), MOVE);
            f->create();

            // If target file is located at trash location, also create the corresponding trashinfo file
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && (target == trashfileslocation))
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(source, trashfileslocation);

                // Adjust target name to get the _N suffix if any
                FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                // Create trashinfo file
                createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                // Move source to trash target
                ret = f->move(source, trashtarget);
            }

            // Move source to target
            else
            {
                ret = f->move(source, target);
            }

            // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
            // Do it silently and don't report any error if it fails
            if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
            {
                FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                ::unlink(trashinfopathname.text());
            }

            // An error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
            }
        }
        else if (command == "symlink")
        {
            f = new File(this, _("Symlink"), SYMLINK);
            f->create();
            f->symlink(source, target);
        }
        
        // Shouldn't happen
        else
        {
            exit(EXIT_FAILURE);
        }

        getApp()->endWaitCursor();
        delete f;
    }

    // Multiple sources
    // Note : rename cannot be used in this case!
    else if (num > 1)
    {
        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        if (command == "copy")
        {
            f = new File(this, _("File copy"), COPY);
        }
        else if (command == "move")
        {
            f = new File(this, _("File move"), MOVE);
        }
        else if (command == "symlink")
        {
            f = new File(this, _("Symlink"), SYMLINK);
        }

        if (f == NULL)
        {
            fprintf(stderr, "%s::onCmdDirMan: NULL pointer specified.\n", getClassName());
            exit(EXIT_FAILURE);
        }
        else
        {
            f->create();
        }

        // Initialize file list stop refresh timer and flag
        stopListRefresh = false;
        getApp()->addTimeout(this, ID_STOP_LIST_REFRESH_TIMER, STOP_LIST_REFRESH_INTERVAL);

        // Loop on the multiple files
        for (int i = 0; i < num; i++)
        {
            // Stop refreshing the file list and directory size if file operation is long and has many files
            // This avoids flickering and speeds up things a bit
            if (stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
            {
                // Force a last refresh if current panel is destination
                if (currentpanel->getDirectory() == targetdir)
                {
                    currentpanel->getList()->onCmdRefresh(0, 0, 0);
                }

                // Force a last refresh if next panel is destination
                if (nextpanel->getDirectory() == targetdir)
                {
                    nextpanel->getList()->onCmdRefresh(0, 0, 0);
                }

                // Tell the file list to not refresh anymore
                currentpanel->setAllowRefresh(false);
                nextpanel->setAllowRefresh(false);

                // Avoid to refresh the dirsize
                setAllowDirsizeRefresh(false);

                // Don't need to stop again
                stopListRefresh = false;
            }

            // Individual source file
            source = src.section('\n', i);

            // An empty file name corresponds to the ".." file (why?)
            // Don't perform any file operation on it!
            if (source != "")
            {
                if (command == "copy")
                {
                    // If target file is located at trash location, also create the corresponding trashinfo file
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (target == trashfileslocation))
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(source, trashfileslocation);

                        // Adjust target name to get the _N suffix if any
                        FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                        // Create trashinfo file
                        createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                        // Copy source to trash target
                        ret = f->copy(source, trashtarget);
                    }

                    // Copy source to target
                    else
                    {
                        ret = f->copy(source, target);
                    }

                    // An error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
                        break;
                    }
                }
                else if (command == "move")
                {
                    // If target file is located at trash location, also create the corresponding trashinfo file
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (target == trashfileslocation))
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(source, trashfileslocation);

                        // Adjust target name to get the _N suffix if any
                        FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                        // Create trashinfo file
                        createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                        // Move source to trash target
                        ret = f->move(source, trashtarget);
                    }

                    // Move source to target
                    else
                    {
                        ret = f->move(source, target);
                    }

                    // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
                    // Do it silently and don't report any error if it fails
                    if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
                    {
                        FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                        ::unlink(trashinfopathname.text());
                    }

                    // An error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
                        break;
                    }
                }
                else if (command == "symlink")
                {
                    ret = f->symlink(source, target);

                    // An error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the symlink operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Symlink operation cancelled!"));
                        break;
                    }
                }
                // Shouldn't happen
                else
                {
                    exit(EXIT_FAILURE);
                }
            }
        }

        // Reinit timer and refresh flags
        getApp()->removeTimeout(this, ID_STOP_LIST_REFRESH_TIMER);
        currentpanel->setAllowRefresh(true);
        nextpanel->setAllowRefresh(true);
        setAllowDirsizeRefresh(true);

        getApp()->endWaitCursor();
        delete f;
    }

    // Refresh the path link and the directory list
    currentpanel->updatePath();
    list->handle(this, FXSEL(SEL_COMMAND, DirList::ID_REFRESH), NULL);
    return(1);
}


// Delete directory
long DirPanel::onCmdDirDelete(FXObject*, FXSelector, void*)
{
    // Current item
    DirItem* item = (DirItem*)list->getCurrentItem();
    FXString pathname = list->getItemPathname((TreeItem*)item);
    FXString parentdir = FXPath::directory(pathname);

    // If we don't have permission to write to the parent directory
    if (!::isWritable(parentdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), parentdir.text());
        return(0);
    }

    FXbool confirm_del = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete", true);
    FXbool confirm_del_emptydir = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete_emptydir", true);

    if (confirm_del)
    {
        FXString message;
        message.format(_("Definitively delete folder %s ?"), pathname.text());
        MessageBox box(this, _("Confirm Delete"), message, delete_big_permicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
        if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
        {
            return(0);
        }
    }

    // File object
    File* f = new File(this, _("File delete"), DELETE);
    f->create();

    // Confirm empty directory deletion
    if (confirm_del & confirm_del_emptydir)
    {
        if ((::isEmptyDir(pathname) == 0) && !::isLink(pathname))
        {
            // Dialog to confirm file deletion
            f->hideProgressDialog();
            FXString msg;
            msg.format(_("Folder %s is not empty, delete it anyway?"), pathname.text());
            MessageBox box(this, _("Confirm Delete"), msg, delete_big_permicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
            if (box.execute(PLACEMENT_CURSOR) == BOX_CLICKED_CANCEL)
            {
                goto end;
            }
            f->showProgressDialog();
        }
    }

    // If we don't have permission to write to the directory
    if (!::isWritable(pathname))
    {
        // Dialog to confirm directory deletion
        f->hideProgressDialog();
        FXString msg;
        msg.format(_("Folder %s is write-protected, definitively delete it anyway?"), pathname.text());
        MessageBox box(this, _("Confirm Delete"), msg, errorbigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
        FXuint     answer = box.execute(PLACEMENT_OWNER);
        if (answer == BOX_CLICKED_OK)
        {
            f->showProgressDialog();
            f->remove(pathname);

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Delete folder operation cancelled!"));
            }

            // Return to parent directory in DirList and FileList
            list->setDirectory(parentdir, true);
            ((XFileExplorer*)mainWindow)->getCurrentPanel()->setDirectory(parentdir);
            ((XFileExplorer*)mainWindow)->getCurrentPanel()->updatePath();
        }
    }

    // If we have permission to write
    else
    {
        f->remove(pathname);

        // If directory is located at trash location, try to also remove the trashinfo if it exists
        // Do it silently and don't report any error if it fails
        FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
        if (use_trash_can && (pathname.left(trashfileslocation.length()) == trashfileslocation))
        {
            FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(pathname)+".trashinfo";
            ::unlink(trashinfopathname.text());
        }

        // If action is cancelled in progress dialog
        if (f->isCancelled())
        {
            f->hideProgressDialog();
            MessageBox::error(this, BOX_OK, _("Warning"), _("Delete folder operation cancelled!"));
        }
        // Return to parent directory in DirList and FileList
        list->setDirectory(parentdir, true);
        ((XFileExplorer*)mainWindow)->getCurrentPanel()->setDirectory(parentdir);
        ((XFileExplorer*)mainWindow)->getCurrentPanel()->updatePath();
    }

end:
    delete f;

    // Force DirPanel and FilePanel refresh
    setAllowDirsizeRefresh(true);
    list->handle(this, FXSEL(SEL_COMMAND, DirList::ID_REFRESH), NULL);
    return(1);
}


// Move directory to trash can
long DirPanel::onCmdDirTrash(FXObject*, FXSelector, void*)
{
    // Current item
    DirItem* item = (DirItem*)list->getCurrentItem();
    FXString pathname = list->getItemPathname((TreeItem*)item);
    FXString parentdir = FXPath::directory(pathname);

    // If we don't have permission to write to the parent directory
    if (!::isWritable(parentdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), parentdir.text());
        return(0);
    }

    FXbool confirm_trash = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_trash", true);

    if (confirm_trash)
    {
        FXString message;
        message.format(_("Move folder %s to trash can?"), pathname.text());
        MessageBox box(this, _("Confirm Trash"), message, delete_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
        if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
        {
            return(0);
        }
    }

    // File object
    File* f = new File(this, _("Move to trash"), DELETE);
    f->create();

    // If we don't have permission to write to the directory
    if (!::isWritable(pathname))
    {
        // Dialog to confirm directory deletion
        f->hideProgressDialog();
        FXString str;
        str.format(_("Folder %s is write-protected, move it to trash can anyway?"), pathname.text());
        MessageBox box(this, _("Confirm Trash"), str, errorbigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
        FXuint     answer = box.execute(PLACEMENT_OWNER);
        if (answer == BOX_CLICKED_OK)
        {
            // Allow progress dialog
            f->showProgressDialog();

            // Trash files path name
            FXString trashpathname = createTrashpathname(pathname, trashfileslocation);

            // Create trashinfo file
            createTrashinfo(pathname, trashpathname, trashfileslocation, trashinfolocation);

            // Move file to trash files location
            int ret = f->move(pathname, trashpathname);

            // An error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move to trash operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Move to trash folder operation cancelled!"));
            }

            // Return to parent directory in DirList and FileList
            list->setDirectory(parentdir, true);
            ((XFileExplorer*)mainWindow)->getCurrentPanel()->setDirectory(parentdir);
            ((XFileExplorer*)mainWindow)->getCurrentPanel()->updatePath();
        }
    }

    // If we have permission to write
    else
    {
        // Trash files path name
        FXString trashpathname = createTrashpathname(pathname, trashfileslocation);

        // Create trashinfo file
        createTrashinfo(pathname, trashpathname, trashfileslocation, trashinfolocation);

        // Move file to trash files location
        int ret = f->move(pathname, trashpathname);

        // An error has occurred
        if ((ret == 0) && !f->isCancelled())
        {
            f->hideProgressDialog();
            MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move to trash operation!"));
        }

        // If action is cancelled in progress dialog
        if (f->isCancelled())
        {
            f->hideProgressDialog();
            MessageBox::error(this, BOX_OK, _("Warning"), _("Move to trash folder operation cancelled!"));
        }
        // Return to parent directory in DirList and FileList
        list->setDirectory(parentdir, true);
        ((XFileExplorer*)mainWindow)->getCurrentPanel()->setDirectory(parentdir);
        ((XFileExplorer*)mainWindow)->getCurrentPanel()->updatePath();
    }
    delete f;

    // Force DirPanel and FilePanel refresh
    setAllowDirsizeRefresh(true);
    list->handle(this, FXSEL(SEL_COMMAND, DirList::ID_REFRESH), NULL);
    return(1);
}


// Restore directory from trash can
long DirPanel::onCmdDirRestore(FXObject*, FXSelector, void*)
{
    // Current item
    DirItem* item = (DirItem*)list->getCurrentItem();
    FXString pathname = list->getItemPathname((TreeItem*)item);
    FXString parentdir = FXPath::directory(pathname);
    FXbool   confirm_trash = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_trash", true);

    // File object
    File* f = new File(this, _("Restore from trash"), DELETE);

    f->create();

    // Obtain trash base name and sub path
    FXString subpath = pathname;
    subpath.erase(0, trashfileslocation.length()+1);
    FXString trashbasename = subpath.before('/');
    if (trashbasename == "")
    {
        trashbasename = FXPath::name(pathname);
    }
    subpath.erase(0, trashbasename.length());

    // Read the .trashinfo file
    FILE*    fp;
    char     line[1024];
    FXbool   success = true;
    FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+trashbasename+".trashinfo";
    FXString origpathname = "";

    if ((fp = fopen(trashinfopathname.text(), "r")) != NULL)
    {
        // Read the first two lines and get the strings
        if (fgets(line, sizeof(line), fp) == NULL)
        {
            success = false;
        }
        if (fgets(line, sizeof(line), fp) == NULL)
        {
            success = false;
        }
        if (success)
        {
            origpathname = line;
            origpathname = origpathname.after('=');
            origpathname = origpathname.before('\n');
        }
        fclose(fp);
        origpathname = origpathname+subpath;
    }

    // Confirm restore dialog
    if (confirm_trash)
    {
        FXString message;
        message.format(_("Restore folder %s to its original location %s ?"), FXPath::name(pathname).text(), origpathname.text());
        f->hideProgressDialog();
        MessageBox box(this, _("Confirm Restore"), message, restore_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
        if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
        {
            getApp()->endWaitCursor();
            delete f;
            return(0);
        }
        f->showProgressDialog();
    }

    // Bracket used because of a compilation problem with gotos
    {
        if (origpathname == "")
        {
            f->hideProgressDialog();
            MessageBox::error(this, BOX_OK, _("Error"), _("Restore information not available for %s"), pathname.text());
            goto end;
        }

        // If parent dir of the original location does not exist
        FXString origparentdir = FXPath::directory(origpathname);
        if (!::exists(origparentdir))
        {
            // Ask the user if he wants to create it
            f->hideProgressDialog();
            FXString message;
            message.format(_("Parent folder %s does not exist, do you want to create it?"), origparentdir.text());
            MessageBox box(this, _("Confirm Restore"), message, restore_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
            if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
            {
                goto end;
            }
            else
            {
                f->showProgressDialog();
                errno = 0;
                int ret = mkpath(origparentdir.text(), 0755);
                int errcode = errno;
                if (ret == -1)
                {
                    f->hideProgressDialog();
                    if (errcode)
                    {
                        MessageBox::error(this, BOX_OK, _("Error"), _("Can't create folder %s : %s"), origparentdir.text(), strerror(errcode));
                    }
                    else
                    {
                        MessageBox::error(this, BOX_OK, _("Error"), _("Can't create folder %s"), origparentdir.text());
                    }
                    goto end;
                }
            }
        }

        // Move file to original location (with restore option)
        int ret = f->move(pathname, origpathname, true);

        // An error has occurred
        if ((ret == 0) && !f->isCancelled())
        {
            f->hideProgressDialog();
            MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the restore from trash operation!"));
            goto end;
        }

        // Silently remove trashinfo file
        FXString trashfilespathname = trashfileslocation+PATHSEPSTRING+trashbasename;
        if ((pathname == trashfilespathname) && !::exists(trashfilespathname))
        {
            ::unlink(trashinfopathname.text());
        }

        // If action is cancelled in progress dialog
        if (f->isCancelled())
        {
            f->hideProgressDialog();
            MessageBox::error(this, BOX_OK, _("Warning"), _("Restore from trash file operation cancelled!"));
            goto end;
        }

        // Return to parent directory in DirList and FileList
        list->setDirectory(parentdir, true);
        ((XFileExplorer*)mainWindow)->getCurrentPanel()->setDirectory(parentdir);
        ((XFileExplorer*)mainWindow)->getCurrentPanel()->updatePath();
    }

end:
    delete f;

    // Force DirPanel and FilePanel refresh
    setAllowDirsizeRefresh(true);
    list->handle(this, FXSEL(SEL_COMMAND, DirList::ID_REFRESH), NULL);
    return(1);
}


// Create new directory
long DirPanel::onCmdNewDir(FXObject*, FXSelector, void*)
{
    // Current item
    DirItem* item = (DirItem*)list->getCurrentItem();

    FXString dirpath = list->getItemPathname((TreeItem*)item);

    if (dirpath != ROOTDIR)
    {
        dirpath += PATHSEPSTRING;
    }

    if (newdirdialog == NULL)
    {
        newdirdialog = new InputDialog(this, "", _("Create new folder:"), _("New Folder"), "", bignewfoldericon);
    }
    newdirdialog->setText("");
    if (newdirdialog->execute(PLACEMENT_CURSOR))
    {
        if (newdirdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("Folder name is empty, operation cancelled"));
            return(0);
        }

		// Directory name contains '/'
		if (newdirdialog->getText().contains(PATHSEPCHAR))
		{
			MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in folder names, operation cancelled"));
			return(0);
		}

        FXString dirname = dirpath+newdirdialog->getText();
        if (dirname != dirpath)
        {
            // Create the new dir according to the current umask
            int mask;
            mask = umask(0);
            umask(mask);

            // Note that the umask value is in decimal (511 means octal 0777)
            errno = 0;
            int ret = ::mkdir(dirname.text(), 511 & ~mask);
            int errcode = errno;
            if (ret == -1)
            {
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s : %s"), dirname.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s"), dirname.text());
                }
                return(0);
            }
        }
    }

    // Force dirpanel refresh
    list->handle(this, FXSEL(SEL_COMMAND, DirList::ID_REFRESH), NULL);
    return(1);
}


// Run Terminal in the selected directory
long DirPanel::onCmdXTerm(FXObject*, FXSelector, void*)
{
    int ret;

    getApp()->beginWaitCursor();
    DirItem* item = (DirItem*)list->getCurrentItem();
    FXString buf = list->getItemPathname((TreeItem*)item);
    ret = chdir(buf.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), buf.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), buf.text());
        }

        return(0);
    }

    FXString cmd = getApp()->reg().readStringEntry("PROGS", "xterm", "xterm -sb");
    cmd += " &";

    ret = system(cmd.text());
    if (ret < 0)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Can't execute command %s"), cmd.text());
        return(0);
    }

    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }

        return(0);
    }

    getApp()->endWaitCursor();
    return(1);
}


#if defined(linux)
// Mount/Unmount directory
long DirPanel::onCmdMount(FXObject*, FXSelector sel, void*)
{
    int      ret;
    FXString cmd, msg, text;
    FXuint   op;
    File*    f;

    // Current item
    DirItem* item = (DirItem*)list->getCurrentItem();
    FXString dir = list->getItemPathname((TreeItem*)item);

    // If symbolic link
    if (::isLink(dir))
    {
        dir = FXFile::symlink(dir);
    }

    // Select the command and set the appropriate message
    if (FXSELID(sel) == ID_MOUNT)
    {
        op = MOUNT;
        msg = _("Mount");
	    cmd = getApp()->reg().readStringEntry("PROGS", "mount", DEFAULT_MOUNTCMD) + FXString(" ");
    }
    else
    {
        op = UNMOUNT;
        msg = _("Unmount");
		cmd = getApp()->reg().readStringEntry("PROGS", "unmount", DEFAULT_UMOUNTCMD) + FXString(" ");
    }
    cmd += ::quote(dir);
   	cmd += " 2>&1";

    ret = chdir(ROOTDIR);
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), ROOTDIR, strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), ROOTDIR);
        }

        return(0);
    }

    // Wait cursor
    getApp()->beginWaitCursor();

    // File object
    text = msg + _(" file system...");
    f = new File(this, text.text(), op);
    f->create();

    // Mount/unmount file system
    text = msg + _(" the folder:");
    f->mount(dir, text, cmd, op);
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }

        return(0);
    }

    // If action is cancelled in progress dialog
    if (f->isCancelled())
    {
        getApp()->endWaitCursor();
        f->hide();
        text = msg + _(" operation cancelled!");
        MessageBox::error(this, BOX_OK, _("Error"), "%s", text.text());
        delete f;
        return(0);
    }

    getApp()->endWaitCursor();
    delete f;

    // Force dirpanel refresh
    list->handle(this, FXSEL(SEL_COMMAND, DirList::ID_REFRESH), NULL);

    return(1);
}


// Update the Mount menu item
long DirPanel::onUpdMount(FXObject* o, FXSelector sel, void*)
{
    // Current item
    DirItem* item = (DirItem*)list->getCurrentItem();
    FXString dir = list->getItemPathname((TreeItem*)item);

    if (fsdevices->find(dir.text()) && !mtdevices->find(dir.text()))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update the Unmount menu item
long DirPanel::onUpdUnmount(FXObject* o, FXSelector sel, void*)
{
    // Current item
    DirItem* item = (DirItem*)list->getCurrentItem();
    FXString dir = list->getItemPathname((TreeItem*)item);

    if (fsdevices->find(dir.text()) || mtdevices->find(dir.text()))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


#endif


// Update the paste button
long DirPanel::onUpdPaste(FXObject* o, FXSelector, void*)
{
    FXuchar* data;
    FXuint   len;
    FXString buf;
    FXbool   clipboard_empty = true;

    // Lock clipboard to prevent changes in method onCmdRequestClipboard()
    clipboard_locked = true;

    // If source is xfelistType (Gnome, XFCE, or Xfe app)
    if (getDNDData(FROM_CLIPBOARD, xfelistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        buf = (char*)data;

        // Check if valid clipboard
        if (buf.find("file:/") >= 0)
        {
            clipboard_empty = false;
        }

        // Free data pointer
        FXFREE(&data);
    }

    // If source type is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    else if (getDNDData(FROM_CLIPBOARD, urilistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        buf = (char*)data;

        // Test if valid clipboard
        if (buf.find("file:/") >= 0)
        {
            clipboard_empty = false;
        }

        // Free data pointer
        FXFREE(&data);
    }

    // Gray out the paste button, if necessary
    if (clipboard_empty)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }

    // Unlock clipboard
    clipboard_locked = false;

    return(1);
}


// Update menu items and toolbar buttons that are related to file operations
long DirPanel::onUpdMenu(FXObject* o, FXSelector, void*)
{
    // Name of the current selected item
    TreeItem* item = (TreeItem*)list->getCurrentItem();

    // There is no selected item
    if (item == NULL)
    {
        return(0);
    }

    // Path name of the selected item
    FXString dir = list->getItemPathname(item);
    return(1);
}


// Update menu items and toolbar buttons that are related to file operations
long DirPanel::onUpdDirDelete(FXObject* o, FXSelector, void*)
{
    // Name of the current selected item
    TreeItem* item = (TreeItem*)list->getCurrentItem();

    // There is no selected item
    if (item == NULL)
    {
        return(0);
    }

    // Path name of the selected item
    FXString dir = list->getItemPathname(item);

    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    FXbool use_trash_bypass = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_bypass", false);
    if ( (!use_trash_can) | use_trash_bypass)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update menu items and toolbar buttons that are related to file operations
long DirPanel::onUpdDirTrash(FXObject* o, FXSelector, void*)
{
    // Name of the current selected item
    TreeItem* item = (TreeItem*)list->getCurrentItem();

    // There is no selected item
    if (item == NULL)
    {
        return(0);
    }

    // Path name of the selected item
    FXString dir = list->getItemPathname(item);

    // Disable move to trash menu if we are in trash can
    // or if the trash can directory is selected
    FXbool   trashenable = true;
    FXString trashparentdir = trashlocation.rbefore('/');

    if (dir.left(trashlocation.length()) == trashlocation)
    {
        trashenable = false;
    }

    if (dir == trashparentdir)
    {
        trashenable = false;
    }

    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    if (use_trash_can && trashenable)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


long DirPanel::onUpdDirRestore(FXObject* o, FXSelector, void*)
{
    // Name of the current selected item
    TreeItem* item = (TreeItem*)list->getCurrentItem();

    // There is no selected item
    if (item == NULL)
    {
        return(0);
    }

    // Path name of the selected item
    FXString dir = list->getItemPathname(item);

    // Enable restore from trash menu if we are in trash can
    FXbool restoreenable = false;
    if (dir.left(trashfileslocation.length()+1) == trashfileslocation+PATHSEPSTRING)
    {
        restoreenable = true;
    }

    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    if (use_trash_can && restoreenable)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Toggle dirsize refresh and force refresh if flag is true
void DirPanel::setAllowDirsizeRefresh(FXbool flag)
{
    allowDirsizeRefresh = flag;

    // Force refresh
    if (allowDirsizeRefresh)
    {
        curr_dirpath = "";
        onCmdDirsizeRefresh(0, 0, 0);
    }
}


// Refresh the directory size in the status bar
long DirPanel::onCmdDirsizeRefresh(FXObject* sender, FXSelector, void*)
{
    // Don't refresh if not allowed or window is minimized
    if (!allowDirsizeRefresh || ((FXTopWindow*)focuswindow)->isMinimized())
    {
        return(0);
    }

    FXulong  dnsize;
    char     dsize[64];
    FXString hsize;

    // Name of the current selected item
    TreeItem* item = (TreeItem*)list->getCurrentItem();

    // There is no selected item
    if (item == NULL)
    {
        status->setText(_("0 bytes in root"));
        return(0);
    }

    // Path name of the selected item (without trailing '/' except for the root path)
    FXString path = ::filePath(list->getItemPathname(item), "");

    // Compute directory size only if something has changed in directory
    struct stat statbuf;
    if (lstatrep(path.text(), &statbuf) == 0)
    {
        if (!((path == curr_dirpath) && (statbuf.st_mtime == curr_mtime)))
        {
            // Update curr directory mtime
            curr_mtime = statbuf.st_mtime;

            // Update curr directory path
            curr_dirpath = path;

            // Size of the files present in the directory
            //strlcpy(buf,path.text(),path.length()+1);
            dnsize = ::dirsize(path.text());

            // Size in human readable form
#if __WORDSIZE == 64
            snprintf(dsize, sizeof(dsize)-1, "%lu", dnsize);
#else
            snprintf(dsize, sizeof(dsize)-1, "%llu", dnsize);
#endif
            hsize = ::hSize(dsize);

            // Refresh the status label
            FXString string = hsize +  _(" in root");
            status->setText(string);
        }
    }

    // Reset timer again
    getApp()->addTimeout(this, ID_DIRSIZE_REFRESH, DIRSIZE_REFRESH_INTERVAL);

    // Important : returning 0 here avoids to continuously update the GUI!
    return(0);
}


// Update the path name in the Window title
long DirPanel::onUpdTitle(FXObject* sender, FXSelector, void*)
{
    // Name of the current selected item
    TreeItem* item = (TreeItem*)list->getCurrentItem();

    // There is no selected item
    if (item == NULL)
    {
        mainWindow->setTitle("Xfe - ");
        return(0);
    }

    // Path name of the selected item
    FXString path = list->getItemPathname(item);

    // Update the path in the window title
    if (getuid() == 0)
    {
        mainWindow->setTitle(path);
    }
    else
    {
        mainWindow->setTitle(path);
    }

    return(1);
}


// Update dirsize refresh timer if the window gains focus
long DirPanel::onUpdDirsizeRefresh(FXObject*, FXSelector, void*)
{
    static FXbool prevMinimized = true;
    static FXbool minimized = true;

    prevMinimized = minimized;
    if (((FXTopWindow*)focuswindow)->isMinimized())
    {
        minimized = false;
    }
    else
    {
        minimized = true;
    }

    // Update timer if window is unminimized
    if ((prevMinimized == false) && (minimized == true))
    {
        onCmdDirsizeRefresh(0, 0, 0);
    }

    return(1);
}

long DirPanel::onCmdCloseTree(FXObject* sender, FXSelector sel, void* ptr)
{
    this->handle(sender, FXSEL(SEL_COMMAND, FXWindow::ID_TOGGLESHOWN), ptr);
    //this->handle(sender, FXSEL(SEL_COMMAND, XFileExplorer::ID_SWITCH_TREE), ptr);
    return 1;
}
#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <fxdefs.h>
#include <FXPNGIcon.h>

#include "icons.h"
#include "ExecuteBox.h"

// Padding for message box buttons
#define HORZ_PAD    30
#define VERT_PAD    2


// Map
FXDEFMAP(ExecuteBox) ExecuteBoxMap[] =
{
    FXMAPFUNCS(SEL_COMMAND, ExecuteBox::ID_CLICKED_CANCEL, ExecuteBox::ID_CLICKED_EDIT, ExecuteBox::onCmdClicked),
};



// Object implementation
FXIMPLEMENT(ExecuteBox, DialogBox, ExecuteBoxMap, ARRAYNUMBER(ExecuteBoxMap))


// Create message box
ExecuteBox::ExecuteBox(FXWindow* win, const FXString& name, const FXString& text, FXuint opts, int x, int y) :
    DialogBox(win, name, opts|DECOR_TITLE|DECOR_BORDER|DECOR_RESIZE, x, y, 0, 0)
{
    FXVerticalFrame*   content = new FXVerticalFrame(this, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    FXHorizontalFrame* info = new FXHorizontalFrame(content, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 10, 10, 10, 10);

    new FXLabel(info, FXString::null, questionbigicon, ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(info, text, NULL, JUSTIFY_LEFT|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    FXHorizontalFrame* buttons = new FXHorizontalFrame(content, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|PACK_UNIFORM_WIDTH, 0, 0, 0, 0, 10, 10, 10, 10);
    FXButton*          cancel = new FXButton(buttons, _("&Cancel"), NULL, this, ID_CLICKED_CANCEL, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
    new FXButton(buttons, _("E&xecute"), NULL, this, ID_CLICKED_EXECUTE, FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
    new FXButton(buttons, _("Execute in Console &Mode"), NULL, this, ID_CLICKED_CONSOLE, FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
    new FXButton(buttons, _("&Edit"), NULL, this, ID_CLICKED_EDIT, FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
    cancel->setFocus();
}


// Close dialog
long ExecuteBox::onCmdClicked(FXObject*, FXSelector sel, void*)
{
    getApp()->stopModal(this, EXECBOX_CLICKED_CANCEL+(FXSELID(sel)-ID_CLICKED_CANCEL));
    hide();
    return(1);
}
// File management class with progress dialog

#include "config.h"
#include "i18n.h"

#include <fcntl.h>
#include <utime.h>
#if defined(linux)
#include <sys/statfs.h>
#endif

// For Sun compatibility
#ifdef __sun
#include <alloca.h>
#endif


#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>
#include <FXUTF8Codec.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "OverwriteBox.h"
#include "MessageBox.h"
#include "CommandWindow.h"
#include "File.h"


// Delay before the progress bar should be shown (ms)
#define SHOW_PROGRESSBAR_DELAY    1000

// Progress dialog width
#define PROGRESSDIALOG_WIDTH      200



// Message Map
FXDEFMAP(File) FileMap[] =
{
    FXMAPFUNC(SEL_COMMAND, File::ID_CANCEL_BUTTON, File::onCmdCancel),
    FXMAPFUNC(SEL_TIMEOUT, File::ID_TIMEOUT, File::onTimeout),
};

// Object implementation
FXIMPLEMENT(File, DialogBox, FileMap, ARRAYNUMBER(FileMap))

// Construct object
File::File(FXWindow* owner, FXString title, const FXuint operation, const FXuint num) : DialogBox(owner, title, DECOR_TITLE|DECOR_BORDER|DECOR_STRETCHABLE)
{
    // Progress window
    FXPacker* buttons = new FXPacker(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X, 0, 0, 10, 10, PROGRESSDIALOG_WIDTH, PROGRESSDIALOG_WIDTH, 5, 5);
    FXVerticalFrame* contents = new FXVerticalFrame(this, LAYOUT_SIDE_TOP|FRAME_NONE|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Cancel Button
    cancelButton = new FXButton(buttons, _("&Cancel"), NULL, this, File::ID_CANCEL_BUTTON, FRAME_RAISED|FRAME_THICK|LAYOUT_CENTER_X, 0, 0, 0, 0, 20, 20);
    cancelButton->setFocus();
    cancelButton->addHotKey(KEY_Escape);
    cancelled = false;

    // Progress bar
    progressbar = NULL;

    // Progress bar colors (foreground and background)
    FXuint  r, g, b, l;
    FXColor textcolor, textaltcolor;
    FXColor fgcolor = getApp()->reg().readColorEntry("SETTINGS", "pbarcolor", FXRGB(0, 0, 255));
    FXColor bgcolor = getApp()->reg().readColorEntry("SETTINGS", "backcolor", FXRGB(255, 255, 255));

    // Text color is white or black depending on the background luminance
    r = FXREDVAL(bgcolor);
    g = FXGREENVAL(bgcolor);
    b = FXBLUEVAL(bgcolor);
    l = (FXuint)(0.3*r+0.59*g+0.11*b);
    if (l < 150)
    {
        textcolor = FXRGB(255, 255, 255);
    }
    else
    {
        textcolor = FXRGB(0, 0, 0);
    }

    // Alternate text color is white or black depending on the foreground luminance
    r = FXREDVAL(fgcolor);
    g = FXGREENVAL(fgcolor);
    b = FXBLUEVAL(fgcolor);
    l = (FXuint)(0.3*r+0.59*g+0.11*b);
    if (l < 150)
    {
        textaltcolor = FXRGB(255, 255, 255);
    }
    else
    {
        textaltcolor = FXRGB(0, 0, 0);
    }

    // Progress dialog depends on the file operation
    switch (operation)
    {
    case COPY:
        // Labels and progress bar
        uplabel = new FXLabel(contents, _("Source:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);
        downlabel = new FXLabel(contents, _("Target:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);
        progressbar = new FXProgressBar(contents, NULL, 0, LAYOUT_FILL_X|FRAME_SUNKEN|FRAME_THICK|PROGRESSBAR_PERCENTAGE, 0, 0, 0, 0, PROGRESSDIALOG_WIDTH);
        progressbar->setBarColor(fgcolor);
        progressbar->setTextColor(textcolor);
        progressbar->setTextAltColor(textaltcolor);
        datatext = _("Copied data:");
        datalabel = new FXLabel(contents, datatext, NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);

        // Timer on
        getApp()->addTimeout(this, File::ID_TIMEOUT, SHOW_PROGRESSBAR_DELAY);
        break;

    case MOVE:
        // Labels and progress bar
        uplabel = new FXLabel(contents, _("Source:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);
        downlabel = new FXLabel(contents, _("Target:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);
        progressbar = new FXProgressBar(contents, NULL, 0, LAYOUT_FILL_X|FRAME_SUNKEN|FRAME_THICK|PROGRESSBAR_PERCENTAGE, 0, 0, 0, 0, PROGRESSDIALOG_WIDTH);
        progressbar->setBarColor(fgcolor);
        progressbar->setTextColor(textcolor);
        progressbar->setTextAltColor(textaltcolor);
        datatext = _("Moved data:");
        datalabel = new FXLabel(contents, datatext, NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);

        // Timer on
        getApp()->addTimeout(this, File::ID_TIMEOUT, SHOW_PROGRESSBAR_DELAY);
        break;

    case DELETE:
        // Labels
        uplabel = new FXLabel(contents, _("Delete:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);
        downlabel = new FXLabel(contents, _("From:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);
        datalabel = NULL;

        // Timer on
        getApp()->addTimeout(this, File::ID_TIMEOUT, SHOW_PROGRESSBAR_DELAY);
        break;

    case CHMOD:
        // Labels
        uplabel = new FXLabel(contents, _("Changing permissions..."), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);
        downlabel = new FXLabel(contents, _("File:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);
        datalabel = NULL;

        // Timer on
        getApp()->addTimeout(this, File::ID_TIMEOUT, SHOW_PROGRESSBAR_DELAY);
        break;

    case CHOWN:
        // Labels
        uplabel = new FXLabel(contents, _("Changing owner..."), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);
        downlabel = new FXLabel(contents, _("File:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);
        datalabel = NULL;

        // Timer on
        getApp()->addTimeout(this, File::ID_TIMEOUT, SHOW_PROGRESSBAR_DELAY);
        break;

#if defined(linux)
    case MOUNT:
        // Labels
        uplabel = new FXLabel(contents, _("Mount file system..."), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);
        downlabel = new FXLabel(contents, _("Mount the folder:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);
        datalabel = NULL;
        break;

    case UNMOUNT:
        // Labels
        uplabel = new FXLabel(contents, _("Unmount file system..."), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);
        downlabel = new FXLabel(contents, _("Unmount the folder:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);
        datalabel = NULL;
        break;
#endif

    default: // Other : RENAME, SYMLINK, ARCHIVE, EXTRACT, PKG_INSTALL, PKG_UNINSTALL
        // Progress dialog not used
        uplabel = NULL;
        downlabel = NULL;
        datalabel = NULL;
    }

    FXbool confirm_overwrite = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_overwrite", true);

    // Initialize the overwrite flags
    if (confirm_overwrite)
    {
        overwrite = false;
        overwrite_all = false;
        skip_all = false;
    }
    else
    {
        overwrite = true;
        overwrite_all = true;
        skip_all = false;
    }

    // Total data read
    totaldata = 0;

    // Owner window
    ownerwin = owner;

	// Number of selected items
	numsel = num;
	
    // Error message box
    mbox = new MessageBox(ownerwin, _("Error"), "", errorbigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
}


// Destructor
File::~File()
{
    getApp()->removeTimeout(this, File::ID_TIMEOUT);
    delete progressbar;
    delete mbox;
}


// Create and initialize
void File::create()
{
    DialogBox::create();
}


// Force timeout for progress dialog (used before opening confirmation or error dialogs)
void File::forceTimeout(void)
{
    getApp()->removeTimeout(this, File::ID_TIMEOUT);
    hide();
    getApp()->forceRefresh();
    getApp()->flush();
}


// Restart timeout for progress dialog  (used after closing confirmation or error dialogs)
void File::restartTimeout(void)
{
    getApp()->addTimeout(this, File::ID_TIMEOUT, SHOW_PROGRESSBAR_DELAY);
}


// Read bytes
FXlong File::fullread(int fd, FXuchar* ptr, FXlong len)
{
    FXlong nread;

#ifdef EINTR
    do
    {
        nread = read(fd, ptr, len);
    } while (nread < 0 && errno == EINTR);
#else
    nread = read(fd, ptr, len);
#endif
    return(nread);
}


// Write bytes
FXlong File::fullwrite(int fd, const FXuchar* ptr, FXlong len)
{
    FXlong nwritten, ntotalwritten = 0;

    while (len > 0)
    {
        nwritten = write(fd, ptr, len);
        if (nwritten < 0)
        {
#ifdef EINTR
            if (errno == EINTR)
            {
                continue;
            }
#endif
            return(-1);
        }
        ntotalwritten += nwritten;
        ptr += nwritten;
        len -= nwritten;
    }
    return(ntotalwritten);
}


// Construct overwrite dialog and get user answer
FXuint File::getOverwriteAnswer(FXString srcpath, FXString tgtpath)
{
    // Message string
    FXString msg;

    if (::isDirectory(tgtpath))
    {
        msg.format(_("Folder %s already exists.\nOverwrite?\n=> Caution, files within this folder could be overwritten!"), tgtpath.text());
    }
    else
    {
        msg.format(_("File %s already exists.\nOverwrite?"), tgtpath.text());
    }

    // Read time format
    FXString timeformat = getApp()->reg().readStringEntry("SETTINGS", "time_format", DEFAULT_TIME_FORMAT);

    // Get the size and mtime of the source and target
    struct stat linfo;
    FXString    srcsize, srcmtime, tgtsize, tgtmtime;
    FXbool      statsrc = false, stattgt = false;
    if (lstatrep(srcpath.text(), &linfo) == 0)
    {
        statsrc = true;
        srcmtime = FXSystem::time(timeformat.text(), linfo.st_mtime);
        char buf[MAXPATHLEN];
        if (S_ISDIR(linfo.st_mode)) // Folder
        {
            FXulong dirsize = 0;
            FXuint  nbfiles = 0, nbsubfolders = 0;
            FXulong totalsize=0;
            strlcpy(buf, srcpath.text(), srcpath.length()+1);
            dirsize = pathsize(buf, &nbfiles, &nbsubfolders,&totalsize);
#if __WORDSIZE == 64
            snprintf(buf, sizeof(buf), "%lu", dirsize);
#else
            snprintf(buf, sizeof(buf), "%llu", dirsize);
#endif
        }
        else // File
#if __WORDSIZE == 64
        {
            snprintf(buf, sizeof(buf), "%lu", (FXulong)linfo.st_size);
        }
#else
        {
            snprintf(buf, sizeof(buf), "%llu", (FXulong)linfo.st_size);
        }
#endif
        srcsize = ::hSize(buf);
    }
    if (lstatrep(tgtpath.text(), &linfo) == 0)
    {
        stattgt = true;
        tgtmtime = FXSystem::time(timeformat.text(), linfo.st_mtime);
        char buf[64];
        if (S_ISDIR(linfo.st_mode)) // Folder
        {
            FXulong dirsize = 0;
            FXuint  nbfiles = 0, nbsubfolders = 0;
            FXulong totalsize=0;

            strlcpy(buf, tgtpath.text(), tgtpath.length()+1);
            dirsize = pathsize(buf, &nbfiles, &nbsubfolders,&totalsize);
#if __WORDSIZE == 64
            snprintf(buf, sizeof(buf), "%lu", dirsize);
#else
            snprintf(buf, sizeof(buf), "%llu", dirsize);
#endif
        }
        else // File
#if __WORDSIZE == 64
        {
            snprintf(buf, sizeof(buf), "%lu", (FXulong)linfo.st_size);
        }
#else
        {
            snprintf(buf, sizeof(buf), "%llu", (FXulong)linfo.st_size);
        }
#endif
        tgtsize = ::hSize(buf);
    }

    // Overwrite dialog
    OverwriteBox* dlg;
    if (statsrc && stattgt)
    {
        if (numsel == 1)
        {
	        dlg = new OverwriteBox(ownerwin, _("Confirm Overwrite"), msg, srcsize, srcmtime, tgtsize, tgtmtime, OVWBOX_SINGLE_FILE);
		}
		else
		{
	        dlg = new OverwriteBox(ownerwin, _("Confirm Overwrite"), msg, srcsize, srcmtime, tgtsize, tgtmtime);
		}
    }
    else
    {
        if (numsel == 1)
        {
	        dlg = new OverwriteBox(ownerwin, _("Confirm Overwrite"), msg, OVWBOX_SINGLE_FILE);
		}
		else
		{
	        dlg = new OverwriteBox(ownerwin, _("Confirm Overwrite"), msg);
		}
    }

    FXuint answer = dlg->execute(PLACEMENT_OWNER);
    delete dlg;
    restartTimeout();

    return(answer);
}


// Copy ordinary file
// Return  0 to allow displaying an error message in the calling function
// Return -1 to prevent displaying an error message in the calling function
// Return -2 when an error has occurred during the copy
int File::copyfile(const FXString& source, const FXString& target, const FXbool preserve_date)
{
    FXString       destfile;
    FXuchar        buffer[32768];
    struct stat    info;
    struct utimbuf timbuf;
    FXlong         nread, nwritten;
    FXlong         size, dataread = 0;
    int            src, dst;
    int            ok = false;

    FXbool warn = getApp()->reg().readUnsignedEntry("OPTIONS", "preserve_date_warn", true);

    if ((src = ::open(source.text(), O_RDONLY)) >= 0)
    {
        if (statrep(source.text(), &info) == 0)
        {
            // If destination is a directory
            if (::isDirectory(target))
            {
                destfile = target+PATHSEPSTRING+FXPath::name(source);
            }
            else
            {
                destfile = target;
            }

            // Copy file block by block
            size = info.st_size;
            if ((dst = ::open(destfile.text(), O_WRONLY|O_CREAT|O_TRUNC, info.st_mode)) >= 0)
            {
 			   	int error = false;

                while (1)
                {
                    errno = 0;
                    nread = File::fullread(src, buffer, sizeof(buffer));
                    int errcode = errno;
                    if (nread < 0)
                    {
                        forceTimeout();

                        FXString str;
                        if (errcode)
                        {
                            str.format(_("Can't copy file %s: %s"), target.text(), strerror(errcode));
                        }
                        else
                        {
                            str.format(_("Can't copy file %s"), target.text());
                        }
                        mbox->setText(str);
                        FXuint answer = mbox->execute(PLACEMENT_OWNER);

                        restartTimeout();
                        if (answer == BOX_CLICKED_CANCEL)
                        {
                            ::close(dst);
                            ::close(src);
                            cancelled = true;
                            return(false);
                        }
                        else
                        {
							error = true; // An error has occurred
						}
                    }
                    if (nread == 0)
                    {
                        break;
                    }

                    // Force timeout checking for progress dialog
                    checkTimeout();

                    // Set percentage value for progress dialog
                    dataread += nread;
                    totaldata += nread;

                    if (progressbar)
                    {
                        // Percentage
                        int pct = (100.0*dataread)/size;
                        progressbar->setProgress(pct);

                        // Total data copied
                        FXString hsize;
                        char     size[64];

#if __WORDSIZE == 64
                        snprintf(size, sizeof(size)-1, "%ld", totaldata);
#else
                        snprintf(size, sizeof(size)-1, "%lld", totaldata);
#endif
                        hsize = ::hSize(size);
#if __WORDSIZE == 64
                        snprintf(size, sizeof(size)-1, "%s %s", datatext.text(), hsize.text());
#else
                        snprintf(size, sizeof(size)-1, "%s %s", datatext.text(), hsize.text());
#endif

                        datalabel->setText(size);
                    }

                    // Give cancel button an opportunity to be clicked
                    if (cancelButton)
                    {
                        getApp()->runModalWhileEvents(cancelButton);
                    }

                    // Set labels for progress dialog
                    FXString label = _("Source: ")+source;
                    if (uplabel)
                    {
                    	uplabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
					}
                    label = _("Target: ")+target;
                    if (downlabel)
                    {
                    	downlabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
					}
                    getApp()->repaint();

                    // If cancel button was clicked, close files and return
                    if (cancelled)
                    {
                        ::close(dst);
                        ::close(src);
                        return(false);
                    }
                    errno = 0;
                    nwritten = File::fullwrite(dst, buffer, nread);
                    errcode = errno;
                    if (nwritten < 0)
                    {
                        forceTimeout();

                        FXString str;
                        if (errcode)
                        {
                            str.format(_("Can't copy file %s: %s"), target.text(), strerror(errcode));
                        }
                        else
                        {
                            str.format(_("Can't copy file %s"), target.text());
                        }
                        mbox->setText(str);
                        FXuint answer = mbox->execute(PLACEMENT_OWNER);

                        restartTimeout();
                        if (answer == BOX_CLICKED_CANCEL)
                        {
                            ::close(dst);
                            ::close(src);
                            cancelled = true;
                            return(false);
                        }
                        else
                        {
							error = true; // An error has occurred
						}
                    }
                }

				// An error has occurred during the copy 
                if (error)
                {
                	ok = -2;
				}
                else
                {
                	ok = true;
				}

                ::close(dst);

                // Keep original date if asked
                if (preserve_date)
                {
                    timbuf.actime = info.st_atime;
                    timbuf.modtime = info.st_mtime;
                    errno = 0;
                    int rc = utime(destfile.text(), &timbuf);
                    int errcode = errno;
                    if (warn && rc)
                    {
                        forceTimeout();

                        FXString str;
                        if (errcode)
                        {
                            str.format(_("Can't preserve date when copying file %s : %s"), target.text(), strerror(errcode));
                        }
                        else
                        {
                            str.format(_("Can't preserve date when copying file %s"), target.text());
                        }
                        mbox->setText(str);
                        FXuint answer = mbox->execute(PLACEMENT_OWNER);

                        restartTimeout();
                        if (answer == BOX_CLICKED_CANCEL)
                        {
                            ::close(src);
                            cancelled = true;
                            return(false);
                        }
                    }
                }
            }

#if defined(linux)
            // If source file is on a ISO9660 file system (CD or DVD, thus read-only)
            // then add to the target the write permission for the user
            if (ok)
            {
                struct statfs fs;
                if ((statfs(source.text(), &fs) == 0) && (fs.f_type == 0x9660))
                {
                    ::chmod(target.text(), info.st_mode|S_IWUSR);
                }
            }
#endif
        }
        ::close(src);
    }

    // File cannot be opened
    else
    {
        forceTimeout();
        int errcode = errno;

        FXString str;
        if (errcode)
        {
            str.format(_("Can't copy file %s: %s"), target.text(), strerror(errcode));
        }
        else
        {
            str.format(_("Can't copy file %s"), target.text());
        }
        mbox->setText(str);
        FXuint answer = mbox->execute(PLACEMENT_OWNER);

        restartTimeout();
        if (answer == BOX_CLICKED_CANCEL)
        {
            cancelled = true;
            return(false);
        }
        ok = -1; // Prevent displaying an error message
                 // in the calling function
    }
    return(ok);
}


// Copy directory
int File::copydir(const FXString& source, const FXString& target, struct stat& parentinfo, inodelist* inodes, const FXbool preserve_date)
{
    DIR*           dirp;
    struct dirent* dp;
    struct stat    linfo;
    struct utimbuf timbuf;
    inodelist*     in, inode;
    FXString       destfile, oldchild, newchild;

    FXbool warn = getApp()->reg().readUnsignedEntry("OPTIONS", "preserve_date_warn", true);

    // Destination file
    destfile = target;

    // See if visited this inode already
    for (in = inodes; in; in = in->next)
    {
        if (in->st_ino == parentinfo.st_ino)
        {
            return(true);
        }
    }

    // Try make directory, if none exists yet
    if ((mkdir(destfile.text(), parentinfo.st_mode|S_IWUSR) != 0) && (errno != EEXIST))
    {
        return(false);
    }

    // Can we stat it
    if ((lstatrep(destfile.text(), &linfo) != 0) || !S_ISDIR(linfo.st_mode))
    {
        return(false);
    }

    // Try open directory to copy
    dirp = opendir(source.text());
    if (!dirp)
    {
        return(false);
    }

    // Add this to the list
    inode.st_ino = linfo.st_ino;
    inode.next = inodes;

    // Copy stuff
    while ((dp = readdir(dirp)) != NULL)
    {
        if ((dp->d_name[0] != '.') || ((dp->d_name[1] != '\0') && ((dp->d_name[1] != '.') || (dp->d_name[2] != '\0'))))
        {
            oldchild = source;
            if (!ISPATHSEP(oldchild[oldchild.length()-1]))
            {
                oldchild.append(PATHSEP);
            }
            oldchild.append(dp->d_name);
            newchild = destfile;
            if (!ISPATHSEP(newchild[newchild.length()-1]))
            {
                newchild.append(PATHSEP);
            }
            newchild.append(dp->d_name);
            if (!copyrec(oldchild, newchild, &inode, preserve_date))
            {
                // If the cancel button was pressed
                if (cancelled)
                {
                    closedir(dirp);
                    return(false);
                }

                // Or a permission problem occured
                else
                {
                    FXString str;
                    if (::isDirectory(oldchild))
                    {
                        str.format(_("Can't copy folder %s : Permission denied"), oldchild.text());
                    }
                    else
                    {
                        str.format(_("Can't copy file %s : Permission denied"), oldchild.text());
                    }
                    forceTimeout();
                    mbox->setText(str);
                    FXuint answer = mbox->execute(PLACEMENT_OWNER);

                    restartTimeout();
                    if (answer == BOX_CLICKED_CANCEL)
                    {
                        closedir(dirp);
                        cancelled = true;
                        return(false);
                    }
                }
            }
        }
    }

    // Close directory
    closedir(dirp);

    // Keep original date if asked
    if (preserve_date)
    {
        if (lstatrep(source.text(), &linfo) == 0)
        {
            timbuf.actime = linfo.st_atime;
            timbuf.modtime = linfo.st_mtime;
            errno = 0;
            int rc = utime(destfile.text(), &timbuf);
            int errcode = errno;
            if (warn && rc)
            {
                forceTimeout();
                FXString str;
                if (errcode)
                {
                    str.format(_("Can't preserve date when copying folder %s: %s"), target.text(), strerror(errcode));
                }
                else
                {
                    str.format(_("Can't preserve date when copying folder %s"), target.text());
                }
                mbox->setText(str);
                FXuint answer = mbox->execute(PLACEMENT_OWNER);

                restartTimeout();
                if (answer == BOX_CLICKED_CANCEL)
                {
                    cancelled = true;
                    return(false);
                }
            }
        }
    }

    // Success
    return(true);
}


// Recursive copy
int File::copyrec(const FXString& source, const FXString& target, inodelist* inodes, const FXbool preserve_date)
{
    struct stat linfo1, linfo2;

    // Source file or directory does not exist
    if (lstatrep(source.text(), &linfo1) != 0)
    {
        return(false);
    }

    // If target is not a directory, remove it if allowed
    if (lstatrep(target.text(), &linfo2) == 0)
    {
        if (!S_ISDIR(linfo2.st_mode))
        {
            if (!(overwrite|overwrite_all))
            {
                return(false);
            }
            if (::unlink(target.text()) != 0)
            {
                return(false);
            }
        }
    }

    // Source is directory: copy recursively
    if (S_ISDIR(linfo1.st_mode))
    {
        return(File::copydir(source, target, linfo1, inodes, preserve_date));
    }

    // Source is regular file: copy block by block
    if (S_ISREG(linfo1.st_mode))
    {
        return(File::copyfile(source, target, preserve_date));
    }

    // Remove target if it already exists
    if (::exists(target))
    {
        int ret = File::remove(target);
        if (!ret)
        {
            return(false);
        }
    }

    // Source is fifo: make a new one
    if (S_ISFIFO(linfo1.st_mode))
    {
        return(mkfifo(target.text(), linfo1.st_mode));
    }

    // Source is device: make a new one
    if (S_ISBLK(linfo1.st_mode) || S_ISCHR(linfo1.st_mode) || S_ISSOCK(linfo1.st_mode))
    {
        return(mknod(target.text(), linfo1.st_mode, linfo1.st_rdev) == 0);
    }

    // Source is symbolic link: make a new one
    if (S_ISLNK(linfo1.st_mode))
    {
        FXString lnkfile = ::readLink(source);
        return(::symlink(lnkfile.text(), target.text()) == 0);
    }

    // This shouldn't happen
    return(false);
}


// Copy file (with progress dialog)
// Return  0 to allow displaying an error message in the calling function
// Return -1 to prevent displaying an error message in the calling function
int File::copy(const FXString& source, const FXString& target, const FXbool confirm_dialog, const FXbool preserve_date)
{
    FXString targetfile;

    // Source doesn't exist
    if (!::exists(source))
    {
        forceTimeout();
        MessageBox::error(this, BOX_OK, _("Error"), _("Source %s doesn't exist"), source.text());
        return(-1);
    }

    // Source and target are identical
    if (::identical(target, source))
    {
        forceTimeout();
        MessageBox::error(this, BOX_OK, _("Error"), _("Destination %s is identical to source"), target.text());
        return(-1);
    }

    // Source path is included into target path
    FXString str = source + PATHSEPSTRING;
    if (target.left(str.length()) == str)
    {
        forceTimeout();
        MessageBox::error(this, BOX_OK, _("Error"), _("Target %s is a sub-folder of source"), target.text());
        return(-1);
    }

    // Target is an existing directory
    if (::isDirectory(target))
    {
        targetfile = target+PATHSEPSTRING+FXPath::name(source);
    }
    else
    {
        targetfile = target;
    }

    // Source and target are identical => add a suffix to the name
    if (::identical(source, targetfile))
    {
        targetfile = ::buildCopyName(::cleanPath(targetfile)); // Remove trailing / if any
    }
    // Source and target file are identical
    if (::identical(targetfile, source))
    {
        forceTimeout();
        MessageBox::error(this, BOX_OK, _("Error"), _("Destination %s is identical to source"), targetfile.text());
        return(-1);
    }

    // Target already exists
    if (::exists(targetfile))
    {
        // Overwrite dialog if necessary
        if ( (!(overwrite_all | skip_all)) & confirm_dialog )
        {
            FXString label = _("Source: ")+source;
            if (uplabel)
            {
				uplabel->setText(::multiLines(label, MAX_MESSAGE_LENGTH));
			}
            label = _("Target: ")+targetfile;
            if (downlabel)
            {
				downlabel->setText(::multiLines(label, MAX_MESSAGE_LENGTH));
			}
            getApp()->repaint();
            forceTimeout();
            FXuint answer = getOverwriteAnswer(source, targetfile);
            switch (answer)
            {
            // Cancel
            case 0:
                forceTimeout();
                cancelled = true;
                return(false);

                break;

            // Overwrite
            case 1:
                overwrite = true;
                break;

            // Overwrite all
            case 2:
                overwrite_all = true;
                break;

            // Skip
            case 3:
                overwrite = false;
                break;

            // Skip all
            case 4:
                skip_all = true;
                break;
            }
        }
        if ( (!(overwrite | overwrite_all)) | skip_all )
        {
            return(true);
        }

        // Remove targetfile if source is not a directory
        if (!::isDirectory(source))
        {
            if (File::remove(targetfile) == false)
            {
                forceTimeout();
                return(false);
            }
        }
    }

    // Copy file or directory
    return(File::copyrec(source, targetfile, NULL, preserve_date));
}


// Remove file or directory (with progress dialog)
// Return  0 to allow displaying an error message in the calling function
// Return -1 to prevent displaying an error message in the calling function
int File::remove(const FXString& file)
{
    FXString      dirname;
    struct stat   linfo;
    static FXbool ISDIR = false;  // Caution! ISDIR is common to all File instances, is that we want?

    if (lstatrep(file.text(), &linfo) == 0)
    {
        // It is a directory
        if (S_ISDIR(linfo.st_mode))
        {
            DIR* dirp = opendir(file.text());
            if (dirp)
            {
                struct dirent* dp;
                FXString       child;

                // Used to display only one progress dialog when deleting a directory
                ISDIR = true;

                // Force timeout checking for progress dialog
                checkTimeout();

                // Give cancel button an opportunity to be clicked
                if (cancelButton)
                {
                    getApp()->runModalWhileEvents(cancelButton);
                }

                // Set labels for progress dialog
                FXString label = _("Delete folder: ")+file;
                if (uplabel)
                {
                    uplabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
                }
                dirname = FXPath::directory(FXPath::absolute(file));
                label = _("From: ")+dirname;
                if (downlabel)
                {
                    downlabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
                }
                getApp()->repaint();

                // If cancel button was clicked, return
                if (cancelled)
                {
                    closedir(dirp);
                    return(false);
                }

                while ((dp = readdir(dirp)) != NULL)
                {
                    if ((dp->d_name[0] != '.') || ((dp->d_name[1] != '\0') && ((dp->d_name[1] != '.') || (dp->d_name[2] != '\0'))))
                    {
                        child = file;
                        if (!ISPATHSEP(child[child.length()-1]))
                        {
                            child.append(PATHSEP);
                        }
                        child.append(dp->d_name);
                        if (!File::remove(child))
                        {
                            closedir(dirp);
                            return(false);
                        }
                    }
                }
                closedir(dirp);
            }
            if (rmdir(file.text()) == -1)
            {
                int errcode = errno;
                forceTimeout();

                FXString str;
                if (errcode)
                {
                    str.format(_("Can't delete folder %s: %s"), file.text(), strerror(errcode));
                }
                else
                {
                    str.format(_("Can't delete folder %s"), file.text());
                }
                mbox->setText(str);
                FXuint answer = mbox->execute(PLACEMENT_OWNER);

                restartTimeout();
                if (answer == BOX_CLICKED_CANCEL)
                {
                    cancelled = true;
                    return(false);
                }
                return(-1); // To prevent displaying an error message
                // in the calling function
            }
            else
            {
                return(true);
            }
        }
        else
        {
            // If it was not a directory
            if (!ISDIR)
            {
                // Force timeout checking for progress dialog
                checkTimeout();

                // Give cancel button an opportunity to be clicked
                if (cancelButton)
                {
                    getApp()->runModalWhileEvents(cancelButton);
                }

                // Set labels for progress dialog
                FXString label = _("Delete:")+file;
                if (uplabel)
                {
                    uplabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
                }
                dirname = FXPath::directory(FXPath::absolute(file));
                label = _("From: ")+dirname;
                if (downlabel)
                {
                    downlabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
                }
                getApp()->repaint();

                // If cancel button was clicked, return
                if (cancelled)
                {
                    return(false);
                }
            }
            if (::unlink(file.text()) == -1)
            {
                int errcode = errno;
                forceTimeout();

                FXString str;
                if (errcode)
                {
                    str.format(_("Can't delete file %s: %s"), file.text(), strerror(errcode));
                }
                else
                {
                    str.format(_("Can't delete file %s"), file.text());
                }
                mbox->setText(str);
                FXuint answer = mbox->execute(PLACEMENT_OWNER);

                restartTimeout();
                if (answer == BOX_CLICKED_CANCEL)
                {
                    cancelled = true;
                    return(false);
                }
                return(-1); // To prevent displaying an error message
                            // in the calling function
            }
            else
            {
                return(true);
            }
        }
    }
    return(-1);
}


// Rename a file or a directory (no progress dialog)
// Return  0 to allow displaying an error message in the calling function
// Return -1 to prevent displaying an error message in the calling function
int File::rename(const FXString& source, const FXString& target)
{
    // Source doesn't exist
    if (!::exists(source))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Source %s doesn't exist"), source.text());
        return(-1);
    }

    // Source and target are identical
    if (::identical(target, source))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Destination %s is identical to source"), target.text());
        return(-1);
    }

    // Target already exists => only allow overwriting destination if both source and target are files
    if (::exists(target))
    {
		// Source or target are a directory
		if (::isDirectory(source) || ::isDirectory(target))
		{
	        MessageBox::error(this, BOX_OK, _("Error"), _("Destination %s already exists"), target.text());
			return(-1);
		}

		// Source and target are files
		else
		{
			FXuint answer = getOverwriteAnswer(source, target);
			if (answer == 0)
			{
				return(-1);
			}
		}
    }

    // Rename file using the standard C function
    // This should only work for files that are on the same file system
    if (::rename(source.text(), target.text()) == 0)
    {
        return(true);
    }

    int errcode = errno;
    if ((errcode != EXDEV) && (errcode != ENOTEMPTY))
    {
        forceTimeout();
        MessageBox::error(this, BOX_OK, _("Error"), _("Can't rename to target %s: %s"), target.text(), strerror(errcode));
        return(-1);
    }

    // If files are on different file systems, use the copy/delete scheme and preserve the original date
    int ret = this->copy(source, target, false, true);
    if (ret == true)
    {
        return(remove(source.text()) == true);
    }
    else
    {
        return(false);
    }
}


// Move files
// Return  0 to allow displaying an error message in the calling function
// Return -1 to prevent displaying an error message in the calling function
int File::move(const FXString& source, const FXString& target, const FXbool restore)
{
    // Source doesn't exist
    if (!::exists(source))
    {
        forceTimeout();
        MessageBox::error(this, BOX_OK, _("Error"), _("Source %s doesn't exist"), source.text());
        return(-1);
    }

    // Source and target are identical
    if (identical(target, source))
    {
        forceTimeout();
        MessageBox::error(this, BOX_OK, _("Error"), _("Destination %s is identical to source"), target.text());
        return(-1);
    }

    // Source path is included into target path
    FXString str = source + PATHSEPSTRING;
    if (target.left(str.length()) == str)
    {
        forceTimeout();
        MessageBox::error(this, BOX_OK, _("Error"), _("Target %s is a sub-folder of source"), target.text());
        return(-1);
    }

    // Target is an existing directory (don't do this in the restore case)
    FXString targetfile;
    if (!restore && ::isDirectory(target))
    {
        targetfile = target+PATHSEPSTRING+FXPath::name(source);
    }
    else
    {
        targetfile = target;
    }

    // Source and target file are identical
    if (::identical(targetfile, source))
    {
        forceTimeout();
        MessageBox::error(this, BOX_OK, _("Error"), _("Destination %s is identical to source"), targetfile.text());
        return(-1);
    }

    // Force timeout checking for progress dialog
    checkTimeout();

    // Give cancel button an opportunity to be clicked
    if (cancelButton)
    {
        getApp()->runModalWhileEvents(cancelButton);
    }

    // Set labels for progress dialog
    FXString label = _("Source: ")+source;
    if (uplabel)
    {
    	uplabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
	}
    label = _("Target: ")+target;
    if (downlabel)
    {
		downlabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
	}
    getApp()->repaint();

    // Target file already exists
    if (::exists(targetfile))
    {
        // Overwrite dialog if necessary
        if (!overwrite_all & !skip_all)
        {
            forceTimeout();
            FXuint answer = getOverwriteAnswer(source, targetfile);
            restartTimeout();
            switch (answer)
            {
            // Cancel
            case 0:
                forceTimeout();
                cancelled = true;
                return(false);

                break;

            // Overwrite
            case 1:
                overwrite = true;
                break;

            // Overwrite all
            case 2:
                overwrite_all = true;
                break;

            // Skip
            case 3:
                overwrite = false;
                break;

            // Skip all
            case 4:
                skip_all = true;
                break;
            }
        }
        if ( (!(overwrite | overwrite_all)) | skip_all )
        {
            // Hide progress dialog and restart timer
            forceTimeout();
            restartTimeout();

            return(true);
        }
    }

    // Get the size of the source
    FXulong srcsize = 0;
    struct stat linfo;
    if (lstatrep(source.text(), &linfo) == 0)
    {
        char buf[MAXPATHLEN];
        if (S_ISDIR(linfo.st_mode)) // Folder
        {
            FXuint nbfiles = 0, nbsubfolders = 0;
            FXulong totalsize=0;
            strlcpy(buf, source.text(), source.length()+1);
            srcsize = pathsize(buf, &nbfiles, &nbsubfolders,&totalsize);
            totaldata += srcsize;
        }
        else // File
        {
            srcsize = (FXulong)linfo.st_size;
            totaldata += srcsize;
        }
    }

    if (progressbar)
    {
        // Trick to display a percentage
        int pct = (100.0*rand())/RAND_MAX+50;
        progressbar->setProgress((int)pct);

        //Total data moved
        FXString hsize;
        char     size[64];

#if __WORDSIZE == 64
        snprintf(size, sizeof(size)-1, "%ld", totaldata);
#else
        snprintf(size, sizeof(size)-1, "%lld", totaldata);
#endif
        hsize = ::hSize(size);
#if __WORDSIZE == 64
        snprintf(size, sizeof(size)-1, "%s %s", datatext.text(), hsize.text());
#else
        snprintf(size, sizeof(size)-1, "%s %s", datatext.text(), hsize.text());
#endif

        datalabel->setText(size);
    }

    // Rename file using the standard C function
    // This should only work for files that are on the same file system
    if (::rename(source.text(), targetfile.text()) == 0)
    {
        return(true);
    }

    int errcode = errno;
    if ((errcode != EXDEV) && (errcode != ENOTEMPTY))
    {
        forceTimeout();
        MessageBox::error(this, BOX_OK, _("Error"), _("Can't rename to target %s: %s"), targetfile.text(), strerror(errcode));
        return(-1);
    }

    // If files are on different file systems, use the copy/delete scheme and preserve the original date
    totaldata -= srcsize; // Avoid counting data twice

    int ret = this->copy(source, target, false, true);

    // Success
    if (ret == true)
    {
        return(remove(source.text()) == true);
    }
    
    // Error during copy
    else if (ret == -2)
    {
		return true;
	}   
    
    // Operation cancelled
    else
    {
        return(false);
    }
}


// Symbolic Link file (no progress dialog)
// Return  0 to allow displaying an error message in the calling function
// Return -1 to prevent displaying an error message in the calling function
int File::symlink(const FXString& source, const FXString& target)
{
    // Source doesn't exist
    if (!::exists(source))
    {
        forceTimeout();
        MessageBox::error(this, BOX_OK, _("Error"), _("Source %s doesn't exist"), source.text());
        return(-1);
    }

    // Source and target are identical
    if (::identical(target, source))
    {
        forceTimeout();
        MessageBox::error(this, BOX_OK, _("Error"), _("Destination %s is identical to source"), target.text());
        return(-1);
    }

    // Target is an existing directory
    FXString targetfile;
    if (::isDirectory(target))
    {
        targetfile = target+PATHSEPSTRING+FXPath::name(source);
    }
    else
    {
        targetfile = target;
    }

    // Source and target are identical
    if (::identical(targetfile, source))
    {
        forceTimeout();
        MessageBox::error(this, BOX_OK, _("Error"), _("Destination %s is identical to source"), targetfile.text());
        return(-1);
    }

    // Target already exists
    if (::exists(targetfile))
    {
        // Overwrite dialog if necessary
        if (!(overwrite_all | skip_all))
        {
            FXuint answer = getOverwriteAnswer(source, targetfile);
            switch (answer)
            {
            // Cancel
            case 0:
                forceTimeout();
                return(false);

                break;

            // Overwrite
            case 1:
                overwrite = true;
                break;

            // Overwrite all
            case 2:
                overwrite_all = true;
                break;

            // Skip
            case 3:
                overwrite = false;
                break;

            // Skip all
            case 4:
                skip_all = true;
                break;
            }
        }
        if ( (!(overwrite | overwrite_all)) | skip_all )
        {
            return(true);
        }
    }

    // Create symbolic link using the standard C function
    errno = 0;

    // Use the relative path for the symbolic link
    FXString relativepath;
    if (::exists(target) && ::isDirectory(target))
    {
        relativepath = FXPath::relative(target, source);
    }
    else
    {
        relativepath = FXPath::relative(FXPath::directory(target), source);
    }

    int ret = ::symlink(relativepath.text(), targetfile.text());

    int errcode = errno;
    if (ret == 0)
    {
        return(true);
    }
    else
    {
        forceTimeout();
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't symlink %s: %s"), target.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't symlink %s"), target.text());
        }
        return(-1);
    }
}


// Chmod a file or directory, recursively or not
// We don't process symbolic links (since their permissions cannot be changed)
//
// Note : the variable file returns the last processed file
// It can be different from the initial path, if recursive chmod is used
// (Used to fill an error message, if needed)
int File::chmod(char* path, char* file, mode_t mode, FXbool rec, const FXbool dironly, const FXbool fileonly)
{
    struct stat linfo;

    // Initialise the file variable with the initial path
    strlcpy(file, path, strlen(path)+1);

    // If it doesn't exist
    if (lstatrep(path, &linfo))
    {
        return(-1);
    }

    // If it's a symbolic link
    if (S_ISLNK(linfo.st_mode))
    {
        return(0);
    }

    if (!S_ISDIR(linfo.st_mode)) // File
    {
        if (dironly)
        {
            return(0);
        }

        // Force timeout checking for progress dialog
        checkTimeout();

        // Give cancel button an opportunity to be clicked
        if (cancelButton)
        {
            getApp()->runModalWhileEvents(cancelButton);
        }

        // Set labels for progress dialog
        FXString label = _("Changing permissions...");
        uplabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
        label = _("File:")+FXString(path);
        downlabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
        getApp()->repaint();

        // If cancel button was clicked, return
        if (cancelled)
        {
            return(-1);
        }

        return(::chmod(path, mode));
    }
    else // Directory
    {
        if ((rec == false) && !fileonly)
        {
            // Force timeout checking for progress dialog
            checkTimeout();

            // Give cancel button an opportunity to be clicked
            if (cancelButton)
            {
                getApp()->runModalWhileEvents(cancelButton);
            }

            // Set labels for progress dialog
            FXString label = _("Changing permissions...");
            uplabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
            label = _("Folder: ")+FXString(path);
            downlabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
            getApp()->repaint();

            // If cancel button was clicked, return
            if (cancelled)
            {
                return(-1);
            }

            if (::chmod(path, mode)) // Do not change recursively
            {
                return(-1);
            }
        }
        else
        {
            return(rchmod(path, file, mode, dironly, fileonly)); // Recursive change
        }
    }
    return(0);
}


// Recursive chmod for a directory
// We don't process symbolic links (since their permissions cannot be changed)
int File::rchmod(char* path, char* file, mode_t mode, const FXbool dironly, const FXbool fileonly)
{
    struct stat linfo;

    // Initialize the file variable with the initial path
    strlcpy(file, path, strlen(path)+1);

    // If it doesn't exist
    if (lstatrep(path, &linfo))
    {
        return(-1);
    }

    // If it's a symbolic link
    if (S_ISLNK(linfo.st_mode))
    {
        return(0);
    }

    if (!S_ISDIR(linfo.st_mode)) // File
    {
        if (dironly)
        {
            return(0);
        }

        // Force timeout checking for progress dialog
        checkTimeout();

        // Give cancel button an opportunity to be clicked
        if (cancelButton)
        {
            getApp()->runModalWhileEvents(cancelButton);
        }

        // Set labels for progress dialog
        FXString label = _("Changing permissions...");
        uplabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
        label = _("File:")+FXString(path);
        downlabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
        getApp()->repaint();

        // If cancel button was clicked, return
        if (cancelled)
        {
            return(-1);
        }

        return(::chmod(path, mode));
    }

    DIR*           dir;
    struct dirent* entry;
    int            i, pl = strlen(path);

    if (!(dir = opendir(path)))
    {
        return(-1);
    }

    for (i = 0; (entry = readdir(dir)); i++)
    {
        if ((entry->d_name[0] != '.') || ((entry->d_name[1] != '\0') &&
                                          ((entry->d_name[1] != '.') ||
                                           (entry->d_name[2] != '\0'))))
        {
            int   pl1 = pl, l = strlen(entry->d_name);
            char* path1 = (char*)alloca(pl1+l+2);

            strlcpy(path1, path, strlen(path)+1);
            if (path1[pl1-1] != '/')
            {
                path1[pl1++] = '/';
            }
            strlcpy(path1+pl1, entry->d_name, strlen(entry->d_name)+1);

            // Modify the file variable with the new path
            strlcpy(file, path1, strlen(path1)+1);
            if (rchmod(path1, file, mode, dironly, fileonly))
            {
                closedir(dir);
                return(-1);
            }
        }
    }

    if (closedir(dir))
    {
        return(-1);
    }

    if (fileonly)
    {
        return(0);
    }
    else
    {
        return(::chmod(path, mode));
    }
}


// Chown a file or directory, recursively or not
// We don't follow symbolic links
//
// Note : the variable file returns the last processed file
// It can be different from the initial path, if recursive chmod is used
// (Used to fill an error message, if needed)
int File::chown(char* path, char* file, uid_t uid, gid_t gid, const FXbool rec, const FXbool dironly, const FXbool fileonly)
{
    struct stat linfo;

    // Initialise the file variable with the initial path
    strlcpy(file, path, strlen(path)+1);

    // If it doesn't exist
    if (lstatrep(path, &linfo))
    {
        return(-1);
    }

    if (!S_ISDIR(linfo.st_mode)) // File
    {
        if (dironly)
        {
            return(0);
        }

        // Force timeout checking for progress dialog
        checkTimeout();

        // Give cancel button an opportunity to be clicked
        if (cancelButton)
        {
            getApp()->runModalWhileEvents(cancelButton);
        }

        // Set labels for progress dialog
        FXString label = _("Changing owner...");
        uplabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
        label = _("File:")+FXString(path);
        downlabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
        getApp()->repaint();

        // If cancel button was clicked, return
        if (cancelled)
        {
            return(-1);
        }

        if (::lchown(path, uid, gid))
        {
            return(-1);
        }
    }
    else // Directory
    {
        if ((rec == false) && !fileonly)
        {
            // Force timeout checking for progress dialog
            checkTimeout();

            // Give cancel button an opportunity to be clicked
            if (cancelButton)
            {
                getApp()->runModalWhileEvents(cancelButton);
            }

            // Set labels for progress dialog
            FXString label = _("Changing owner...");
            uplabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
            label = _("Folder: ")+FXString(path);
            downlabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
            getApp()->repaint();

            // If cancel button was clicked, return
            if (cancelled)
            {
                return(-1);
            }

            if (::lchown(path, uid, gid)) // Do not change recursively
            {
                return(-1);
            }
        }
        else if (rchown(path, file, uid, gid, dironly, fileonly)) // Recursive change
        {
            return(-1);
        }
    }
    return(0);
}


// Recursive chown for a directory
// We don't follow symbolic links
int File::rchown(char* path, char* file, uid_t uid, gid_t gid, const FXbool dironly, const FXbool fileonly)
{
    struct stat linfo;

    // Initialise the file variable with the initial path
    strlcpy(file, path, strlen(path)+1);

    // If it doesn't exist
    if (lstatrep(path, &linfo))
    {
        return(-1);
    }

    if (!S_ISDIR(linfo.st_mode)) // file
    {
        if (dironly)
        {
            return(0);
        }

        // Force timeout checking for progress dialog
        checkTimeout();

        // Give cancel button an opportunity to be clicked
        if (cancelButton)
        {
            getApp()->runModalWhileEvents(cancelButton);
        }

        // Set labels for progress dialog
        FXString label = _("Changing owner...");
        uplabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
        label = _("File:")+FXString(path);
        downlabel->setText(::truncLine(label, MAX_MESSAGE_LENGTH));
        getApp()->repaint();

        // If cancel button was clicked, return
        if (cancelled)
        {
            return(-1);
        }

        return(::lchown(path, uid, gid));
    }

    DIR*           dir;
    struct dirent* entry;
    int            i, pl = strlen(path);

    if (!(dir = opendir(path)))
    {
        return(-1);
    }

    for (i = 0; (entry = readdir(dir)); i++)
    {
        if ((entry->d_name[0] != '.') || ((entry->d_name[1] != '\0') &&
                                          ((entry->d_name[1] != '.') ||
                                           (entry->d_name[2] != '\0'))))
        {
            int   pl1 = pl, l = strlen(entry->d_name);
            char* path1 = (char*)alloca(pl1+l+2);

            strlcpy(path1, path, strlen(path)+1);
            if (path1[pl1-1] != '/')
            {
                path1[pl1++] = '/';
            }
            strlcpy(path1+pl1, entry->d_name, strlen(entry->d_name)+1);
            strlcpy(file, path1, strlen(path1)+1);
            if (rchown(path1, file, uid, gid, dironly, fileonly))
            {
                closedir(dir);
                return(-1);
            }
        }
    }

    if (closedir(dir))
    {
        return(-1);
    }

    if (fileonly)
    {
        return(0);
    }
    else
    {
        return(::lchown(path, uid, gid));
    }
}


// Extract an archive in a specified directory
int File::extract(const FXString name, const FXString dir, const FXString cmd)
{
    int ret;

    // Change to the specified directory
    FXString currentdir = FXSystem::getCurrentDirectory();

    ret = chdir(dir.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), dir.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), dir.text());
        }

        return(0);
    }

    // Make and show command window
    CommandWindow* cmdwin = new CommandWindow(getApp(), _("Extract archive"), cmd, 30, 80);
    cmdwin->create();
    cmdwin->setIcon(archexticon);

    // The command window object deletes itself after closing the window!

    // Return to initial directory
    ret = chdir(currentdir.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), currentdir.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), currentdir.text());
        }

        return(0);
    }

    return(1);
}


// Create an archive
int File::archive(const FXString name, const FXString cmd)
{
    // Target file already exists
    if (::exists(FXPath::dequote(name)))
    {
		FXString msg;
		msg.format(_("File %s already exists.\nOverwrite?"), name.text());
		OverwriteBox* dlg = new OverwriteBox(ownerwin, _("Confirm Overwrite"), msg, OVWBOX_SINGLE_FILE);
		FXuint answer = dlg->execute(PLACEMENT_OWNER);
		delete dlg;
		if (answer == 0)
		{
			return(false);				
		}
    }

    // Make and show command window
    CommandWindow* cmdwin = new CommandWindow(getApp(), _("Add to archive"), cmd, 30, 80);
    cmdwin->create();
    cmdwin->setIcon(archaddicon);

    // The command window object deletes itself after closing the window!

    return(1);
}


#if defined(linux)
int File::mount(const FXString dir, const FXString msg, const FXString cmd, const FXuint op)
{
    FXbool mount_messages = getApp()->reg().readUnsignedEntry("OPTIONS", "mount_messages", true);

    // Show progress dialog (no timer here)
    show(PLACEMENT_OWNER);
    getApp()->forceRefresh();
    getApp()->flush();

    // Set labels for progress dialog
    uplabel->setText(msg);
    downlabel->setText(dir.text());
    getApp()->repaint();

    // Give cancel button an opportunity to be clicked
    if (cancelButton)
    {
        getApp()->runModalWhileEvents(cancelButton);
    }

    // If cancel button was clicked, return
    if (cancelled)
    {
        return(-1);
    }

    // Perform the mount/unmount command
    FILE* pcmd = popen(cmd.text(), "r");
    if (!pcmd)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Failed command: %s"), cmd.text());
        return(-1);
    }

    // Get error message if any
    char text[10000] = { 0 };
    FXString buf;
    while (fgets(text, sizeof(text), pcmd))
    {
        buf += text;
    }
    snprintf(text, sizeof(text)-1, "%s", buf.text());

    // Close the stream
    if ((pclose(pcmd) == -1) && (strcmp(text, "") != 0))
    {
        MessageBox::error(this, BOX_OK, _("Error"), "%s", text);
        return(-1);
    }

    // Hide progress dialog
    hide();

    // Success message, eventually
    if (mount_messages)
    {
        if (op == MOUNT)
        {
            MessageBox::information(this, BOX_OK, _("Success"), _("Folder %s was successfully mounted."), dir.text());
        }
        else
        {
            MessageBox::information(this, BOX_OK, _("Success"), _("Folder %s was successfully unmounted."), dir.text());
        }
    }
    return(1);
}


// Install / Upgrade package
int File::pkgInstall(const FXString name, const FXString cmd)
{
    // Make and show command window
    CommandWindow* cmdwin = new CommandWindow(getApp(), _("Install/Upgrade package"), cmd, 10, 80);

    cmdwin->create();

    FXString msg;
    msg.format(_("Installing package: %s \n"), name.text());
    cmdwin->appendText(msg.text());

    // The command window object deletes itself after closing the window!

    return(1);
}


// Uninstall package
int File::pkgUninstall(const FXString name, const FXString cmd)
{
    // Make and show command window
    CommandWindow* cmdwin = new CommandWindow(getApp(), _("Uninstall package"), cmd, 10, 80);

    cmdwin->create();

    FXString msg;
    msg.format(_("Uninstalling package: %s \n"), name.text());
    cmdwin->appendText(msg.text());

    // The command window object deletes itself after closing the window!

    return(1);
}


#endif


// Handle cancel button in progress bar dialog
long File::onCmdCancel(FXObject*, FXSelector, void*)
{
    cancelled = true;
    return(1);
}


// Handle timeout for progress bar
long File::onTimeout(FXObject*, FXSelector, void*)
{
    show(PLACEMENT_OWNER);
    getApp()->forceRefresh();
    getApp()->flush();
    return(1);
}
// File dialog. Taken from the FOX library and slightly modified.

#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "FileList.h"
#include "InputDialog.h"
#include "DirHistBox.h"
#include "MessageBox.h"
#include "FileDialog.h"

#define FILELISTMASK     (_ICONLIST_EXTENDEDSELECT|_ICONLIST_SINGLESELECT|_ICONLIST_BROWSESELECT|_ICONLIST_MULTIPLESELECT)
#define FILESTYLEMASK    (_ICONLIST_DETAILED|_ICONLIST_MINI_ICONS|_ICONLIST_BIG_ICONS|_ICONLIST_ROWS|_ICONLIST_COLUMNS|_ICONLIST_AUTOSIZE)

// Single click navigation
extern FXuint single_click;

// To allow keyboard scrolling in popup dialogs
extern FXbool allowPopupScroll;


// Map
FXDEFMAP(FileSelector) FileSelectorMap[] =
{
    FXMAPFUNC(SEL_COMMAND, FileSelector::ID_ACCEPT, FileSelector::onCmdAccept),
    FXMAPFUNC(SEL_COMMAND, FileSelector::ID_DIRTREE, FileSelector::onCmdDirTree),
    FXMAPFUNC(SEL_COMMAND, FileSelector::ID_FILEFILTER, FileSelector::onCmdFilter),
    FXMAPFUNC(SEL_DOUBLECLICKED, FileSelector::ID_FILELIST, FileSelector::onCmdItemDoubleClicked),
    FXMAPFUNC(SEL_CLICKED, FileSelector::ID_FILELIST, FileSelector::onCmdItemClicked),
    FXMAPFUNC(SEL_SELECTED, FileSelector::ID_FILELIST, FileSelector::onCmdItemSelected),
    FXMAPFUNC(SEL_DESELECTED, FileSelector::ID_FILELIST, FileSelector::onCmdItemDeselected),
    FXMAPFUNC(SEL_COMMAND, FileSelector::ID_DIR_UP, FileSelector::onCmdDirUp),
    FXMAPFUNC(SEL_UPDATE, FileSelector::ID_DIR_UP, FileSelector::onUpdDirUp),
    FXMAPFUNC(SEL_COMMAND, FileSelector::ID_DIR_BACK, FileSelector::onCmdDirBack),
    FXMAPFUNC(SEL_UPDATE, FileSelector::ID_DIR_BACK, FileSelector::onUpdDirBack),
    FXMAPFUNC(SEL_COMMAND, FileSelector::ID_DIR_FORWARD, FileSelector::onCmdDirForward),
    FXMAPFUNC(SEL_UPDATE, FileSelector::ID_DIR_FORWARD, FileSelector::onUpdDirForward),
    FXMAPFUNC(SEL_COMMAND, FileSelector::ID_DIR_BACK_HIST, FileSelector::onCmdDirBackHist),
    FXMAPFUNC(SEL_UPDATE, FileSelector::ID_DIR_BACK_HIST, FileSelector::onUpdDirBackHist),
    FXMAPFUNC(SEL_COMMAND, FileSelector::ID_DIR_FORWARD_HIST, FileSelector::onCmdDirForwardHist),
    FXMAPFUNC(SEL_UPDATE, FileSelector::ID_DIR_FORWARD_HIST, FileSelector::onUpdDirForwardHist),
    FXMAPFUNC(SEL_COMMAND, FileSelector::ID_HOME, FileSelector::onCmdHome),
    FXMAPFUNC(SEL_COMMAND, FileSelector::ID_NEWDIR, FileSelector::onCmdNewDir),
    FXMAPFUNC(SEL_COMMAND, FileSelector::ID_NEWFILE, FileSelector::onCmdNewFile),
    FXMAPFUNC(SEL_COMMAND, FileSelector::ID_WORK, FileSelector::onCmdWork),
    FXMAPFUNC(SEL_RIGHTBUTTONRELEASE, FileSelector::ID_FILELIST, FileSelector::onCmdPopupMenu),
    FXMAPFUNC(SEL_COMMAND, FileSelector::ID_POPUP_MENU, FileSelector::onCmdPopupMenu),
    FXMAPFUNC(SEL_KEYPRESS, 0, FileSelector::onCmdKeyPress),
    FXMAPFUNC(SEL_KEYRELEASE, 0, FileSelector::onCmdKeyRelease),
};


// Implementation
FXIMPLEMENT(FileSelector, FXPacker, FileSelectorMap, ARRAYNUMBER(FileSelectorMap))


// Default pattern
static const char allfiles[] = "All Files (*)";

// File selector object
FileSelector::FileSelector(FXComposite* p, FXObject* tgt, FXSelector sel, FXuint opts, int x, int y, int w, int h) :
    FXPacker(p, opts, x, y, w, h, 0, 0, 0, 0, 0, 0)
{
    FXAccelTable* table = getShell()->getAccelTable();

    target = tgt;
    message = sel;

    // Global container
    FXVerticalFrame* cont = new FXVerticalFrame(this, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // Container for the action buttons
    // FXHorizontalFrame* buttons = new FXHorizontalFrame(cont, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_THICK, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0);
    FXHorizontalFrame* buttons = new FXHorizontalFrame(cont, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_THICK, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // Container for the path linker
    FXHorizontalFrame* pathframe = new FXHorizontalFrame(cont, LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // File list
    FXuint options;
    FXbool smoothscroll = getApp()->reg().readUnsignedEntry("SETTINGS", "smooth_scroll", true);
    if (smoothscroll)
    {
        options = _ICONLIST_MINI_ICONS|_ICONLIST_BROWSESELECT|LAYOUT_FILL_X|LAYOUT_FILL_Y;
    }
    else
    {
        options = _ICONLIST_MINI_ICONS|_ICONLIST_BROWSESELECT|FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_X|LAYOUT_FILL_Y|SCROLLERS_DONT_TRACK;
    }
    FXbool showthumbnails = getApp()->reg().readUnsignedEntry("FILEDIALOG", "showthumbnails", false);

    // FXHorizontalFrame* listcont = new FXHorizontalFrame(this, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_THICK|FRAME_SUNKEN, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    FXVerticalFrame* cont2 = new FXVerticalFrame(cont, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_SUNKEN|FRAME_THICK, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    list = new FileList(this, cont2, this, ID_FILELIST, showthumbnails, options);

    // Set list colors and columns size for detailed mode
    list->setTextColor(getApp()->reg().readColorEntry("SETTINGS", "listforecolor", FXRGB(0, 0, 0)));
    list->setBackColor(getApp()->reg().readColorEntry("SETTINGS", "listbackcolor", FXRGB(255, 255, 255)));
    list->setHeaderSize(0, getApp()->reg().readUnsignedEntry("FILEDIALOG", "name_size", 200));
    list->setHeaderSize(1, getApp()->reg().readUnsignedEntry("FILEDIALOG", "size_size", 60));
    list->setHeaderSize(2, getApp()->reg().readUnsignedEntry("FILEDIALOG", "type_size", 100));
    list->setHeaderSize(3, getApp()->reg().readUnsignedEntry("FILEDIALOG", "ext_size", 100));
    list->setHeaderSize(4, getApp()->reg().readUnsignedEntry("FILEDIALOG", "modd_size", 150));
    list->setHeaderSize(5, getApp()->reg().readUnsignedEntry("FILEDIALOG", "user_size", 50));
    list->setHeaderSize(6, getApp()->reg().readUnsignedEntry("FILEDIALOG", "grou_size", 50));
    list->setHeaderSize(7, getApp()->reg().readUnsignedEntry("FILEDIALOG", "attr_size", 100));

    // Set file selector options
    FXuint liststyle = getApp()->reg().readUnsignedEntry("FILEDIALOG", "liststyle", _ICONLIST_MINI_ICONS);
    FXbool hiddenfiles = getApp()->reg().readUnsignedEntry("FILEDIALOG", "hiddenfiles", false);
    showHiddenFiles(hiddenfiles);
    setFileBoxStyle(liststyle);

    // Entry buttons
    FXMatrix* fields = new FXMatrix(cont, 3, MATRIX_BY_COLUMNS|LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X);
    new FXLabel(fields, _("&File Name:"), NULL, JUSTIFY_LEFT|LAYOUT_CENTER_Y);
    filename = new FXTextField(fields, 25, this, ID_ACCEPT, TEXTFIELD_ENTER_ONLY|LAYOUT_FILL_COLUMN|LAYOUT_FILL_X|FRAME_SUNKEN|FRAME_THICK);
    new FXButton(fields, _("&OK"), NULL, this, ID_ACCEPT, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_FILL_X, 0, 0, 0, 0, 20, 20);
    accept = new FXButton(buttons, FXString::null, NULL, NULL, 0, LAYOUT_FIX_X|LAYOUT_FIX_Y|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, 0, 0, 0, 0, 0, 0);
    new FXLabel(fields, _("File F&ilter:"), NULL, JUSTIFY_LEFT|LAYOUT_CENTER_Y);
    FXHorizontalFrame* filterframe = new FXHorizontalFrame(fields, LAYOUT_FILL_COLUMN|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    filefilter = new FXComboBox(filterframe, 10, this, ID_FILEFILTER, COMBOBOX_STATIC|LAYOUT_FILL_X);
    filefilter->setNumVisible(4);

    readonly = new FXCheckButton(filterframe, _("Read Only"), NULL, 0, ICON_BEFORE_TEXT|JUSTIFY_LEFT|LAYOUT_CENTER_Y);
    cancel = new FXButton(fields, _("&Cancel"), NULL, NULL, 0, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_FILL_X, 0, 0, 0, 0, 20, 20);

    // Action buttons
    FXString        key;
    FXHotKey        hotkey;
    FXButton*       btn;
    FXToggleButton* tglbtn;

    new FXFrame(buttons, LAYOUT_FIX_WIDTH, 0, 0, 4, 1);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_back", "Ctrl-Backspace");
    btn = new FXButton(buttons, TAB+_("Go to previous folder")+PARS(key), dirbackicon, this, ID_DIR_BACK, BUTTON_TOOLBAR|FRAME_RAISED, 0, 0, 0, 0, 3, 3, 3, 3);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    btnbackhist = new FXArrowButton(buttons, this, ID_DIR_BACK_HIST, LAYOUT_FILL_Y|FRAME_RAISED|FRAME_THICK|ARROW_DOWN|ARROW_TOOLBAR);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_forward", "Shift-Backspace");
    btn = new FXButton(buttons, TAB+_("Go to next folder")+PARS(key), dirforwardicon, this, ID_DIR_FORWARD, BUTTON_TOOLBAR|FRAME_RAISED, 0, 0, 0, 0, 3, 3, 3, 3);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    btnforwardhist = new FXArrowButton(buttons, this, ID_DIR_FORWARD_HIST, LAYOUT_FILL_Y|FRAME_RAISED|FRAME_THICK|ARROW_DOWN|ARROW_TOOLBAR);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_up", "Backspace");
    btn = new FXButton(buttons, TAB+_("Go to parent folder")+PARS(key), dirupicon, this, ID_DIR_UP, BUTTON_TOOLBAR|FRAME_RAISED, 0, 0, 0, 0, 3, 3, 3, 3);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_home", "Ctrl-H");
    btn = new FXButton(buttons, TAB+_("Go to home folder")+PARS(key), homeicon, this, ID_HOME, BUTTON_TOOLBAR|FRAME_RAISED, 0, 0, 0, 0, 3, 3, 3, 3);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_work", "Shift-F2");
    btn = new FXButton(buttons, TAB+_("Go to working folder")+PARS(key), workicon, this, ID_WORK, BUTTON_TOOLBAR|FRAME_RAISED, 0, 0, 0, 0, 3, 3, 3, 3);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_folder", "F7");
    btn = new FXButton(buttons, TAB+_("New folder")+PARS(key), newfoldericon, this, ID_NEWDIR, BUTTON_TOOLBAR|FRAME_RAISED, 0, 0, 0, 0, 3, 3, 3, 3);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "big_icons", "F10");
    btn = new FXButton(buttons, TAB+_("Big icon list")+PARS(key), bigiconsicon, list, FileList::ID_SHOW_BIG_ICONS, BUTTON_TOOLBAR|FRAME_RAISED, 0, 0, 0, 0, 3, 3, 3, 3);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "small_icons", "F11");
    btn = new FXButton(buttons, TAB+_("Small icon list")+PARS(key), smalliconsicon, list, FileList::ID_SHOW_MINI_ICONS, BUTTON_TOOLBAR|FRAME_RAISED, 0, 0, 0, 0, 3, 3, 3, 3);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "detailed_file_list", "F12");
    btn = new FXButton(buttons, TAB+_("Detailed file list")+PARS(key), detailsicon, list, FileList::ID_SHOW_DETAILS, BUTTON_TOOLBAR|FRAME_RAISED, 0, 0, 0, 0, 3, 3, 3, 3);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");
    tglbtn = new FXToggleButton(buttons, TAB+_("Show hidden files")+PARS(key), TAB+_("Hide hidden files")+PARS(key), showhiddenicon, hidehiddenicon, list, FileList::ID_TOGGLE_HIDDEN, TOGGLEBUTTON_TOOLBAR|FRAME_RAISED, 0, 0, 0, 0, 3, 3, 3, 3);
    hotkey = _parseAccel(key);
    tglbtn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");
    tglbtn = new FXToggleButton(buttons, TAB+_("Show thumbnails")+PARS(key), TAB+_("Hide thumbnails")+PARS(key), showthumbicon, hidethumbicon, list, FileList::ID_TOGGLE_THUMBNAILS, TOGGLEBUTTON_TOOLBAR|FRAME_RAISED, 0, 0, 0, 0, 3, 3, 3, 3);
    hotkey = _parseAccel(key);
    tglbtn->addHotKey(hotkey);

    // Path text
    pathtext = new TextLabel(pathframe, 0, this, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    pathtext->setBackColor(getApp()->getBaseColor());

    // Path linker
    pathlink = new PathLinker(pathframe, list, NULL, LAYOUT_FILL_X);

//    dirbox=new FXDirBox(buttons,this,ID_DIRTREE,DIRBOX_NO_OWN_ASSOC|FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_X|LAYOUT_CENTER_Y,0,0,0,0,1,1,1,1);
    //dirbox=new FXDirBox(buttons,this,ID_DIRTREE,FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_X|LAYOUT_CENTER_Y,0,0,0,0,1,1,1,1);
    //dirbox->setNumVisible(5);
    //dirbox->setAssociations(list->getAssociations());

    readonly->hide();
    if (table)
    {
        FXString key;
        FXHotKey hotkey;

        key = getApp()->reg().readStringEntry("KEYBINDINGS", "select_all", "Ctrl-A");
        hotkey = _parseAccel(key);
        table->addAccel(hotkey, list, FXSEL(SEL_COMMAND, FileList::ID_SELECT_ALL));

        key = getApp()->reg().readStringEntry("KEYBINDINGS", "deselect_all", "Ctrl-Z");
        hotkey = _parseAccel(key);
        table->addAccel(hotkey, list, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL));

        key = getApp()->reg().readStringEntry("KEYBINDINGS", "invert_selection", "Ctrl-I");
        hotkey = _parseAccel(key);
        table->addAccel(hotkey, list, FXSEL(SEL_COMMAND, FileList::ID_SELECT_INVERSE));

        key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_file", "Ctrl-N");
        hotkey = _parseAccel(key);
        table->addAccel(hotkey, this, FXSEL(SEL_COMMAND, ID_NEWFILE));
    }

    setSelectMode(SELECT_FILE_ANY);                          // For backward compatibility, this HAS to be the default!
    setPatternList(allfiles);
    setDirectory(FXSystem::getCurrentDirectory());           // Update file list
    pathlink->setPath(FXSystem::getCurrentDirectory());      // Update path linker
    pathtext->setText(FXSystem::getCurrentDirectory());      // Update path text

    list->setFocus();
    accept->hide();

    // Change default cursor if single click navigation
    if (single_click == SINGLE_CLICK_DIR_FILE)
    {
        list->setDefaultCursor(getApp()->getDefaultCursor(DEF_HAND_CURSOR));
    }
}


// Create X window
void FileSelector::create()
{
    // Display or hide path linker
    FXbool show_pathlink = getApp()->reg().readUnsignedEntry("SETTINGS", "show_pathlinker", true);

    if (show_pathlink)
    {
        pathtext->hide();
        pathlink->show();
    }
    else
    {
        pathlink->hide();
        pathtext->show();
    }
    FXPacker::create();
}


// Double-clicked item in file list
long FileSelector::onCmdItemDoubleClicked(FXObject*, FXSelector, void* ptr)
{
    FXlong index = (FXlong)ptr;

    if (index < 0)
    {
        return(1);
    }

    // If directory, open the directory
    if (list->isItemDirectory(index))
    {
        FXString pathname = list->getItemPathname(index);

        // Does not have access
        if (!::isReadExecutable(pathname))
        {
            MessageBox::error(this, BOX_OK, _("Error"), _(" Permission to: %s denied."), pathname.text());
            return(0);
        }

        setDirectory(pathname);
        pathlink->setPath(pathname);
        pathtext->setText(pathname);
        return(1);
    }

    // Only return if we wanted a file
    if ((selectmode != SELECT_FILE_DIRECTORY) && (selectmode != SELECT_FILE_MIXED))
    {
        if (list->isItemFile(index))
        {
            FXObject*  tgt = accept->getTarget();
            FXSelector sel = accept->getSelector();
            if (tgt)
            {
                tgt->handle(accept, FXSEL(SEL_COMMAND, sel), (void*)1);
            }
        }
    }
    return(1);
}


// Single clicked item in file list
long FileSelector::onCmdItemClicked(FXObject*, FXSelector, void* ptr)
{
    if (single_click != SINGLE_CLICK_NONE)
    {
        FXlong index = (FXlong)ptr;
        if (index < 0)
        {
            return(1);
        }

        // In detailed mode, avoid single click when mouse cursor is not over the first column
        int    x, y;
        FXuint state;
        getCursorPosition(x, y, state);
        FXbool allow = true;
        if (!(list->getListStyle()&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS)) && ((x-list->getXPosition()) > list->getHeaderSize(0)))
        {
            allow = false;
        }

        // Single click with control or shift
        if (state&(CONTROLMASK|SHIFTMASK))
        {
            return(1);
        }

        // Single click without control or shift
        else
        {
            // If directory, open the directory
            if ((single_click != SINGLE_CLICK_NONE) && list->isItemDirectory(index) && allow)
            {
                FXString pathname = list->getItemPathname(index);

                // Does not have access
                if (!::isReadExecutable(pathname))
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _(" Permission to: %s denied."), pathname.text());
                    return(0);
                }
                setDirectory(pathname);
                pathlink->setPath(pathname);
                pathtext->setText(pathname);
                return(1);
            }
            else if ((single_click == SINGLE_CLICK_DIR_FILE) && list->isItemFile(index) && allow)
            {
                FXObject*  tgt = accept->getTarget();
                FXSelector sel = accept->getSelector();
                if (tgt)
                {
                    tgt->handle(accept, FXSEL(SEL_COMMAND, sel), (void*)1);
                }
            }
        }
    }
    return(1);
}


// Change in items which are selected
long FileSelector::onCmdItemSelected(FXObject*, FXSelector, void* ptr)
{
    FXlong   index = (FXlong)ptr;
    FXString text, file;

    if (selectmode == SELECT_FILE_MULTIPLE)
    {
        for (int i = 0; i < list->getNumItems(); i++)
        {
            if (list->isItemFile(i) && list->isItemSelected(i))
            {
                if (!text.empty())
                {
                    text += ' ';
                }
                text += ::quote(list->getItemFilename(i));
            }
        }
        filename->setText(text);
    }
    else if (selectmode == SELECT_FILE_MULTIPLE_ALL)
    {
        for (int i = 0; i < list->getNumItems(); i++)
        {
            if (list->isItemSelected(i) && (list->getItemFilename(i) != ".."))
            {
                if (!text.empty())
                {
                    text += ' ';
                }
                text += ::quote(list->getItemFilename(i));
            }
        }
        filename->setText(text);
    }
    else if (selectmode == SELECT_FILE_DIRECTORY)
    {
        if (list->isItemDirectory(index))
        {
            if (list->getItemFilename(index) != "..")
            {
                text = list->getItemFilename(index);
                filename->setText(text);
            }
        }
    }
    // Mode added to select both directories and files
    else if (selectmode == SELECT_FILE_MIXED)
    {
        if (list->getItemFilename(index) != "..")
        {
            text = list->getItemFilename(index);
            filename->setText(text);
        }
    }
    else
    {
        if (list->isItemFile(index))
        {
            text = list->getItemFilename(index);
            filename->setText(text);
        }
    }
    return(1);
}


// Change in items which are deselected
long FileSelector::onCmdItemDeselected(FXObject*, FXSelector, void*)
{
    FXString text, file;

    if (selectmode == SELECT_FILE_MULTIPLE)
    {
        for (int i = 0; i < list->getNumItems(); i++)
        {
            if (list->isItemFile(i) && list->isItemSelected(i))
            {
                if (!text.empty())
                {
                    text += ' ';
                }
                text += ::quote(list->getItemFilename(i));
            }
        }
        filename->setText(text);
    }
    else if (selectmode == SELECT_FILE_MULTIPLE_ALL)
    {
        for (int i = 0; i < list->getNumItems(); i++)
        {
            if (list->isItemSelected(i) && (list->getItemFilename(i) != ".."))
            {
                if (!text.empty())
                {
                    text += ' ';
                }
                text += ::quote(list->getItemFilename(i));
            }
        }
        filename->setText(text);
    }
    return(1);
}


// Hit the accept button or enter in text field
long FileSelector::onCmdAccept(FXObject*, FXSelector, void*)
{
    FXSelector sel = accept->getSelector();
    FXObject*  tgt = accept->getTarget();

    // Get (first) filename
    FXString path = getFilename();

    // If filename is empty, we get the current directory
    if (path.empty())
    {
        path = list->getDirectory();
        filename->setText(path);
    }

    // Only do something if a selection was made
    if (!path.empty())
    {
        // Is directory?
        if (::isDirectory(path))
        {
            // In directory mode:- we got our answer!
            if ((selectmode == SELECT_FILE_DIRECTORY) || (selectmode == SELECT_FILE_MULTIPLE_ALL) || (selectmode == SELECT_FILE_MIXED))
            {
                if (tgt)
                {
                    tgt->handle(accept, FXSEL(SEL_COMMAND, sel), (void*)1);
                }
                return(1);
            }

            // Hop over to that directory
            list->setDirectory(path);
            pathlink->setPath(list->getDirectory());
            pathtext->setText(list->getDirectory());
            filename->setText(FXString::null);
            return(1);
        }

        // Get directory part of path
        FXString dir = FXPath::directory(path);

        // In file mode, directory part of path should exist
        if (::isDirectory(dir))
        {
            // In any mode, existing directory part is good enough
            if (selectmode == SELECT_FILE_ANY)
            {
                if (tgt)
                {
                    tgt->handle(accept, FXSEL(SEL_COMMAND, sel), (void*)1);
                }
                return(1);
            }

            // In existing mode, the whole filename must exist and be a file
            else if (selectmode == SELECT_FILE_EXISTING)
            {
                if (::isFile(path))
                {
                    if (tgt)
                    {
                        tgt->handle(accept, FXSEL(SEL_COMMAND, sel), (void*)1);
                    }
                    return(1);
                }
            }

            // In multiple mode, return if all selected files exist
            else if (selectmode == SELECT_FILE_MULTIPLE)
            {
                for (int i = 0; i < list->getNumItems(); i++)
                {
                    if (list->isItemSelected(i) && list->isItemFile(i))
                    {
                        if (tgt)
                        {
                            tgt->handle(accept, FXSEL(SEL_COMMAND, sel), (void*)1);
                        }
                        return(1);
                    }
                }
            }

            // Multiple files and/or directories
            else
            {
                for (int i = 0; i < list->getNumItems(); i++)
                {
                    if (list->isItemSelected(i) && (list->getItemFilename(i) != ".."))
                    {
                        if (tgt)
                        {
                            tgt->handle(accept, FXSEL(SEL_COMMAND, sel), (void*)1);
                        }
                        return(1);
                    }
                }
            }
        }

        // Go up to the lowest directory which still exists
        while (!FXPath::isTopDirectory(dir) && !::isDirectory(dir))
        {
            dir = FXPath::upLevel(dir);
        }

        // Switch as far as we could go
        list->setDirectory(dir);
        pathlink->setPath(list->getDirectory());
        pathtext->setText(list->getDirectory());

        // Put the tail end back for further editing
        if (ISPATHSEP(path[dir.length()]))
        {
            path.erase(0, dir.length()+1);
        }
        else
        {
            path.erase(0, dir.length());
        }

        // Replace text box with new stuff
        filename->setText(path);
        filename->selectAll();
    }

    return(1);
}


// User clicked up directory button
long FileSelector::onCmdDirUp(FXObject*, FXSelector, void*)
{
    setDirectory(FXPath::upLevel(list->getDirectory()));
    pathlink->setPath(list->getDirectory());
    pathtext->setText(list->getDirectory());
    return(1);
}


// Can we still go up
long FileSelector::onUpdDirUp(FXObject* sender, FXSelector, void*)
{
    if (FXPath::isTopDirectory(list->getDirectory()))
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), NULL);
    }
    return(1);
}


// Directory back
long FileSelector::onCmdDirBack(FXObject*, FXSelector s, void* p)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = list->backhist;
    forwardhist = list->forwardhist;

    // Get the previous directory
    item = backhist->getFirst();
    if (item)
    {
        pathname = backhist->getString(item);
    }

    // Update the history
    backhist->removeFirstItem();
    forwardhist->insertFirstItem(list->getDirectory());

    // Go to to the previous directory
    list->setDirectory(pathname, false);
    pathlink->setPath(list->getDirectory());
    pathtext->setText(list->getDirectory());

    return(1);
}


// Update directory back
long FileSelector::onUpdDirBack(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist;
    FXString    pathname;

    // Get the filelist history
    backhist = list->backhist;

    // Gray out the button if no item in history
    if (backhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory forward
long FileSelector::onCmdDirForward(FXObject*, FXSelector s, void* p)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = list->backhist;
    forwardhist = list->forwardhist;

    // Get the next directory
    item = forwardhist->getFirst();
    if (item)
    {
        pathname = forwardhist->getString(item);
    }

    // Update the history
    forwardhist->removeFirstItem();
    backhist->insertFirstItem(list->getDirectory());

    // Go to to the previous directory
    list->setDirectory(pathname, false);
    pathlink->setPath(list->getDirectory());
    pathtext->setText(list->getDirectory());

    return(1);
}


// Update directory forward
long FileSelector::onUpdDirForward(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* forwardhist;
    FXString    pathname;

    // Get the filelist history
    forwardhist = list->forwardhist;

    // Gray out the button if no item in history
    if (forwardhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory back history
long FileSelector::onCmdDirBackHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = list->backhist;
    forwardhist = list->forwardhist;

    // Get all string items and display them in a list box
    int num = backhist->getNumItems();
    if (num > 0)
    {
        FXString* dirs = new FXString[num];
        FXString  strlist = "";

        // Get string items
        item = backhist->getFirst();
        for (int i = 0; i <= num-1; i++)
        {
            if (item)
            {
                FXString str = backhist->getString(item);
                dirs[i] = str;
                strlist = strlist+str+"\n";
                item = backhist->getNext(item);
            }
        }

        // Display list box
        FXWindow* owner = this->getOwner();
        int       pos = DirHistBox::box(btnbackhist, DECOR_NONE, strlist, owner->getX()+245, owner->getY()+37);

        // If an item was selected
        if (pos != -1)
        {
            // Update back history
            if (pos == num-1)
            {
                backhist->removeAllItems();
            }
            else
            {
                item = backhist->getItemAtPos(pos+1);
                backhist->removeAllItemsBefore(item);
            }

            // Update forward history
            forwardhist->insertFirstItem(list->getDirectory());
            if (pos > 0)
            {
                for (int i = 0; i <= pos-1; i++)
                {
                    forwardhist->insertFirstItem(dirs[i]);
                }
            }

            // Go to to the selected directory
            pathname = dirs[pos];
            list->setDirectory(pathname, false);
            pathlink->setPath(list->getDirectory());
            pathtext->setText(list->getDirectory());
        }
        delete[]dirs;
    }

    return(1);
}


// Update directory back
long FileSelector::onUpdDirBackHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist;
    FXString    pathname;

    // Get the filelist history
    backhist = list->backhist;

    // Gray out the button if no item in history
    if (backhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory forward history
long FileSelector::onCmdDirForwardHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = list->backhist;
    forwardhist = list->forwardhist;

    // Get all string items and display them in a list box
    int num = forwardhist->getNumItems();
    if (num > 0)
    {
        FXString* dirs = new FXString[num];
        FXString  strlist = "";

        // Get string items
        item = forwardhist->getFirst();
        for (int i = 0; i <= num-1; i++)
        {
            if (item)
            {
                FXString str = forwardhist->getString(item);
                dirs[i] = str;
                strlist = strlist+str+"\n";
                item = forwardhist->getNext(item);
            }
        }

        // Display list box
        FXWindow* owner = this->getOwner();
        int       pos = DirHistBox::box(btnforwardhist, DECOR_NONE, strlist, owner->getX()+285, owner->getY()+37);

        // If an item was selected
        if (pos != -1)
        {
            // Update forward history
            if (pos == num-1)
            {
                forwardhist->removeAllItems();
            }
            else
            {
                item = forwardhist->getItemAtPos(pos+1);
                forwardhist->removeAllItemsBefore(item);
            }

            // Update back history
            backhist->insertFirstItem(list->getDirectory());
            if (pos > 0)
            {
                for (int i = 0; i <= pos-1; i++)
                {
                    backhist->insertFirstItem(dirs[i]);
                }
            }

            // Go to to the selected directory
            pathname = dirs[pos];
            list->setDirectory(pathname, false);
            pathlink->setPath(list->getDirectory());
            pathtext->setText(list->getDirectory());
        }
        delete[]dirs;
    }

    return(1);
}


// Update directory forward
long FileSelector::onUpdDirForwardHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* forwardhist;
    FXString    pathname;

    // Get the filelist history
    forwardhist = list->forwardhist;

    // Gray out the button if no item in history
    if (forwardhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Back to home directory
long FileSelector::onCmdHome(FXObject*, FXSelector, void*)
{
    setDirectory(FXSystem::getHomeDirectory());
    pathlink->setPath(list->getDirectory());
    pathtext->setText(list->getDirectory());
    return(1);
}


// Create new directory
long FileSelector::onCmdNewDir(FXObject*, FXSelector, void*)
{
    // Focus on current list
    list->setFocus();

    FXString dirname = "";
    FXString dirpath = list->getDirectory();
    if (dirpath != ROOTDIR)
    {
        dirpath += PATHSEPSTRING;
    }

    InputDialog* dialog = new InputDialog(this, dirname, _("Create new folder..."), _("New Folder"), "", bignewfoldericon);
    dialog->CursorEnd();
    if (dialog->execute(PLACEMENT_CURSOR))
    {
        if (dialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("Folder name is empty, operation cancelled"));
            return(0);
        }

		// Directory name contains '/'
		if (dialog->getText().contains(PATHSEPCHAR))
		{
			MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in folder names, operation cancelled"));
			return(0);
		}

        dirname = dirpath+dialog->getText();
        if (dirname != dirpath)
        {
            // Create the new dir according to the current umask
            int mask;
            mask = umask(0);
            umask(mask);

            // Note that the umask value is in decimal (511 means octal 0777)
            errno = 0;
            int ret = ::mkdir(dirname.text(), 511 & ~mask);
            int errcode = errno;
            if (ret == -1)
            {
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), "Can't create folder %s: %s", dirname.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), "Can't create folder %s", dirname.text());
                }
                return(0);
            }
        }
    }
    delete dialog;

    return(1);
}


// Create new file
long FileSelector::onCmdNewFile(FXObject*, FXSelector, void*)
{
    FXString filename = "";

    // Focus on current list
    list->setFocus();

    FXString pathname = list->getDirectory();
    if (pathname != ROOTDIR)
    {
        pathname += PATHSEPSTRING;
    }

    InputDialog* dialog = new InputDialog(this, filename, _("Create new file..."), _("New File"), "", bignewfileicon);
    dialog->CursorEnd();

    // Accept was pressed
    if (dialog->execute(PLACEMENT_CURSOR))
    {
        if (dialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

		// File name contains '/'
		if (dialog->getText().contains(PATHSEPCHAR))
		{
			MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in file names, operation cancelled"));
			return(0);
		}

        filename = pathname+dialog->getText();
        FILE* file;
        if (filename != pathname)
        {
            // Test some error conditions
            if (::exists(filename))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("File or folder %s already exists"), filename.text());
                return(0);
            }
            // Create the new file
            errno = 0;
            if (!(file = fopen(filename.text(), "w+")) || fclose(file))
            {
                if (errno)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), "Can't create file %s: %s", filename.text(), strerror(errno));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), "Can't create file %s", filename.text());
                }
                return(0);
            }
            // Change the file permissions according to the current umask
            int mask;
            mask = umask(0);
            umask(mask);
            errno = 0;
            if (chmod(filename.text(), 438 & ~mask) != 0)
            {
                if (errno)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), "Can't set permissions in %s: %s", filename.text(), strerror(errno));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), "Can't set permissions in %s", filename.text());
                }
                return(0);
            }
        }
    }
    delete dialog;


    return(1);
}


// Back to current working directory
long FileSelector::onCmdWork(FXObject*, FXSelector, void*)
{
    setDirectory(FXSystem::getCurrentDirectory());
    pathlink->setPath(list->getDirectory());
    pathtext->setText(list->getDirectory());
    return(1);
}


// Strip pattern from text if present
FXString FileSelector::patternFromText(const FXString& pattern)
{
    int beg, end;

    end = pattern.rfind(')');         // Search from the end so we can allow ( ) in the pattern name itself
    beg = pattern.rfind('(', end-1);
    if ((0 <= beg) && (beg < end))
    {
        return(pattern.mid(beg+1, end-beg-1));
    }
    return(pattern);
}


// Return the first extension "ext1" found in the pattern if the
// pattern is of the form "*.ext1,*.ext2,..." or the empty string
// if the pattern contains other wildcard combinations.
FXString FileSelector::extensionFromPattern(const FXString& pattern)
{
    int beg, end, c;

    beg = 0;
    if (pattern[beg] == '*')
    {
        beg++;
        if (pattern[beg] == '.')
        {
            beg++;
            end = beg;
            while ((c = pattern[end]) != '\0' && c != ',' && c != '|')
            {
                if ((c == '*') || (c == '?') || (c == '[') || (c == ']') || (c == '^') || (c == '!'))
                {
                    return(FXString::null);
                }
                end++;
            }
            return(pattern.mid(beg, end-beg));
        }
    }
    return(FXString::null);
}


// Change the pattern; change the filename to the suggested extension
long FileSelector::onCmdFilter(FXObject*, FXSelector, void* ptr)
{
    FXString pat = patternFromText((char*)ptr);

    list->setPattern(pat);
    if (selectmode == SELECT_FILE_ANY)
    {
        FXString ext = extensionFromPattern(pat);
        if (!ext.empty())
        {
            FXString name = FXPath::stripExtension(filename->getText());
            if (!name.empty())
            {
                filename->setText(name+"."+ext);
            }
        }
    }
    return(1);
}


// Set directory
void FileSelector::setDirectory(const FXString& path)
{
    FXString abspath = FXPath::absolute(path);

    list->setDirectory(abspath);
    pathlink->setPath(list->getDirectory());
    pathtext->setText(list->getDirectory());

    if (selectmode != SELECT_FILE_ANY)
    {
        filename->setText(FXString::null);
    }
}


// Get directory
FXString FileSelector::getDirectory() const
{
    return(list->getDirectory());
}


// Set file name
void FileSelector::setFilename(const FXString& path)
{
    FXString abspath = FXPath::absolute(path);

    list->setCurrentFile(abspath);
    pathlink->setPath(FXPath::directory(abspath));
    pathtext->setText(FXPath::directory(abspath));
    filename->setText(FXPath::name(abspath));
}


// Get complete path + filename
FXString FileSelector::getFilename() const
{
    register int i;

    if (selectmode == SELECT_FILE_MULTIPLE_ALL)
    {
        for (i = 0; i < list->getNumItems(); i++)
        {
            if (list->isItemSelected(i) && (list->getItemFilename(i) != ".."))
            {
                return(FXPath::absolute(list->getDirectory(), list->getItemFilename(i)));
            }
        }
    }
    else if (selectmode == SELECT_FILE_MULTIPLE)
    {
        for (i = 0; i < list->getNumItems(); i++)
        {
            if (list->isItemSelected(i) && list->isItemFile(i))
            {
                return(FXPath::absolute(list->getDirectory(), list->getItemFilename(i)));
            }
        }
    }
    else
    {
        if (!filename->getText().empty())
        {
            return(FXPath::absolute(list->getDirectory(), filename->getText()));
        }
    }
    return(FXString::null);
}


// Return empty-string terminated list of selected file names, or NULL
FXString* FileSelector::getFilenames() const
{
    register FXString* files = NULL;
    register int       i, n;

    if (list->getNumItems())
    {
        if (selectmode == SELECT_FILE_MULTIPLE_ALL)
        {
            for (i = n = 0; i < list->getNumItems(); i++)
            {
                if (list->isItemSelected(i) && (list->getItemFilename(i) != ".."))
                {
                    n++;
                }
            }
            if (n)
            {
                files = new FXString [n+1];
                for (i = n = 0; i < list->getNumItems(); i++)
                {
                    if (list->isItemSelected(i) && (list->getItemFilename(i) != ".."))
                    {
                        files[n++] = list->getItemPathname(i);
                    }
                }
                files[n] = FXString::null;
            }
        }
        else
        {
            for (i = n = 0; i < list->getNumItems(); i++)
            {
                if (list->isItemSelected(i) && list->isItemFile(i))
                {
                    n++;
                }
            }
            if (n)
            {
                files = new FXString [n+1];
                for (i = n = 0; i < list->getNumItems(); i++)
                {
                    if (list->isItemSelected(i) && list->isItemFile(i))
                    {
                        files[n++] = list->getItemPathname(i);
                    }
                }
                files[n] = FXString::null;
            }
        }
    }
    return(files);
}


// Set bunch of patterns
void FileSelector::setPatternList(const char** ptrns)
{
    filefilter->clearItems();
    if (ptrns)
    {
        while (ptrns[0] && ptrns[1])
        {
            filefilter->appendItem(FXStringFormat("%s (%s)", ptrns[0], ptrns[1]));
            ptrns += 2;
        }
    }
    if (!filefilter->getNumItems())
    {
        filefilter->appendItem(allfiles);
    }
    setCurrentPattern(0);
}


// Change patterns, each pattern separated by newline
void FileSelector::setPatternList(const FXString& patterns)
{
    FXString pat;
    int      i;

    filefilter->clearItems();
    for (i = 0; !(pat = patterns.section('\n', i)).empty(); i++)
    {
        filefilter->appendItem(pat);
    }
    if (!filefilter->getNumItems())
    {
        filefilter->appendItem(allfiles);
    }
    setCurrentPattern(0);
}


// Return list of patterns
FXString FileSelector::getPatternList() const
{
    FXString pat;
    int      i;

    for (i = 0; i < filefilter->getNumItems(); i++)
    {
        if (!pat.empty())
        {
            pat += '\n';
        }
        pat += filefilter->getItemText(i);
    }
    return(pat);
}


// Set current filter pattern
void FileSelector::setPattern(const FXString& ptrn)
{
    filefilter->setText(ptrn);
    list->setPattern(ptrn);
}


// Get current filter pattern
FXString FileSelector::getPattern() const
{
    return(list->getPattern());
}


// Set current file pattern from the list
void FileSelector::setCurrentPattern(int patno)
{
    if ((FXuint)patno >= (FXuint)filefilter->getNumItems())
    {
        fprintf(stderr, "%s::setCurrentPattern: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    filefilter->setCurrentItem(patno);
    list->setPattern(patternFromText(filefilter->getItemText(patno)));
}


// Return current pattern
int FileSelector::getCurrentPattern() const
{
    return(filefilter->getCurrentItem());
}


// Change pattern for pattern number patno
void FileSelector::setPatternText(int patno, const FXString& text)
{
    if ((FXuint)patno >= (FXuint)filefilter->getNumItems())
    {
        fprintf(stderr, "%s::setPatternText: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    filefilter->setItemText(patno, text);
    if (patno == filefilter->getCurrentItem())
    {
        setPattern(patternFromText(text));
    }
}


// Return pattern text of pattern patno
FXString FileSelector::getPatternText(int patno) const
{
    if ((FXuint)patno >= (FXuint)filefilter->getNumItems())
    {
        fprintf(stderr, "%s::getPatternText: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return(filefilter->getItemText(patno));
}


// Change space for item
void FileSelector::setItemSpace(int s)
{
    list->setItemSpace(s);
}


// Get space for item
int FileSelector::getItemSpace() const
{
    return(list->getItemSpace());
}


// Change File List style
void FileSelector::setFileBoxStyle(FXuint style)
{
    list->setListStyle((list->getListStyle()&~FILESTYLEMASK) | (style&FILESTYLEMASK));
}


// Return File List style
FXuint FileSelector::getFileBoxStyle() const
{
    return(list->getListStyle()&FILESTYLEMASK);
}


// Change file selection mode
void FileSelector::setSelectMode(FXuint mode)
{
    switch (mode)
    {
    case SELECT_FILE_EXISTING:
        list->showOnlyDirectories(false);
        list->setListStyle((list->getListStyle()&~FILELISTMASK)|_ICONLIST_BROWSESELECT);
        break;

    case SELECT_FILE_MULTIPLE:
    case SELECT_FILE_MULTIPLE_ALL:
        list->showOnlyDirectories(false);
        list->setListStyle((list->getListStyle()&~FILELISTMASK)|_ICONLIST_EXTENDEDSELECT);
        break;

    case SELECT_FILE_DIRECTORY:
        list->showOnlyDirectories(true);
        list->setListStyle((list->getListStyle()&~FILELISTMASK)|_ICONLIST_BROWSESELECT);
        break;

    case SELECT_FILE_MIXED:
        list->setListStyle((list->getListStyle()&~FILELISTMASK)|_ICONLIST_BROWSESELECT);
        break;

    default:
        list->showOnlyDirectories(false);
        list->setListStyle((list->getListStyle()&~FILELISTMASK)|_ICONLIST_BROWSESELECT);
        break;
    }
    selectmode = mode;
}


// Show readonly button
void FileSelector::showReadOnly(FXbool show)
{
    show ? readonly->show() : readonly->hide();
}


// Return true if readonly is shown
FXbool FileSelector::shownReadOnly() const
{
    return(readonly->shown());
}


// Set initial state of readonly button
void FileSelector::setReadOnly(FXbool state)
{
    readonly->setCheck(state);
}


// Get readonly state
FXbool FileSelector::getReadOnly() const
{
    return(readonly->getCheck());
}


// Return true if hidden files are displayed
FXbool FileSelector::shownHiddenFiles() const
{
    return(list->shownHiddenFiles());
}


// Return true if thumbnails are displayed
FXbool FileSelector::shownThumbnails() const
{
    return(list->shownThumbnails());
}


// Change show hidden files mode
void FileSelector::showHiddenFiles(FXbool shown)
{
    list->showHiddenFiles(shown);
}


// Change show thumbnails files mode
void FileSelector::showThumbnails(FXbool shown)
{
    list->showThumbnails(shown);
}


// Cleanup; icons must be explicitly deleted
FileSelector::~FileSelector()
{
    // Write options to the registry
    getApp()->reg().writeUnsignedEntry("FILEDIALOG", "name_size", list->getHeaderSize(0));
    getApp()->reg().writeUnsignedEntry("FILEDIALOG", "size_size", list->getHeaderSize(1));
    getApp()->reg().writeUnsignedEntry("FILEDIALOG", "type_size", list->getHeaderSize(2));
    getApp()->reg().writeUnsignedEntry("FILEDIALOG", "ext_size", list->getHeaderSize(3));
    getApp()->reg().writeUnsignedEntry("FILEDIALOG", "modd_size", list->getHeaderSize(4));
    getApp()->reg().writeUnsignedEntry("FILEDIALOG", "user_size", list->getHeaderSize(5));
    getApp()->reg().writeUnsignedEntry("FILEDIALOG", "grou_size", list->getHeaderSize(6));
    getApp()->reg().writeUnsignedEntry("FILEDIALOG", "attr_size", list->getHeaderSize(7));
    getApp()->reg().writeUnsignedEntry("FILEDIALOG", "liststyle", getFileBoxStyle());
    getApp()->reg().writeUnsignedEntry("FILEDIALOG", "hiddenfiles", shownHiddenFiles());
    getApp()->reg().writeUnsignedEntry("FILEDIALOG", "showthumbnails", shownThumbnails());
    getApp()->reg().write();

    FXAccelTable* table = getShell()->getAccelTable();
    if (table)
    {
        table->removeAccel(MKUINT(KEY_BackSpace, 0));
        table->removeAccel(MKUINT(KEY_h, CONTROLMASK));
        table->removeAccel(MKUINT(KEY_w, CONTROLMASK));
        table->removeAccel(MKUINT(KEY_a, CONTROLMASK));
        table->removeAccel(MKUINT(KEY_i, CONTROLMASK));
    }
    delete list;
    delete pathlink;
    delete pathtext;
    delete filename;
    delete filefilter;
    delete readonly;
    delete accept;
    delete cancel;
    delete btnbackhist;
    delete btnforwardhist;
}


// File selector context menu
long FileSelector::onCmdPopupMenu(FXObject* o, FXSelector s, void* p)
{
    // Popup menu pane
    FXMenuPane menu(this);
    int        x, y;
    FXuint     state;

    getRoot()->getCursorPosition(x, y, state);

    new FXMenuCommand(&menu, _("Go ho&me"), homeicon, this, ID_HOME);
    new FXMenuCommand(&menu, _("Go &work"), workicon, this, ID_WORK);
    new FXMenuCommand(&menu, _("New &file..."), newfileicon, this, ID_NEWFILE);
    new FXMenuCommand(&menu, _("New f&older..."), newfoldericon, this, ID_NEWDIR);
    new FXMenuSeparator(&menu);
    new FXMenuCheck(&menu, _("&Hidden files"), list, FileList::ID_TOGGLE_HIDDEN);
    new FXMenuCheck(&menu, _("Thum&bnails"), list, FileList::ID_TOGGLE_THUMBNAILS);
    new FXMenuSeparator(&menu);
    new FXMenuRadio(&menu, _("B&ig icons"), list, IconList::ID_SHOW_BIG_ICONS);
    new FXMenuRadio(&menu, _("&Small icons"), list, IconList::ID_SHOW_MINI_ICONS);
    new FXMenuRadio(&menu, _("Fu&ll file list"), list, IconList::ID_SHOW_DETAILS);
    new FXMenuSeparator(&menu);
    new FXMenuRadio(&menu, _("&Rows"), list, FileList::ID_ARRANGE_BY_ROWS);
    new FXMenuRadio(&menu, _("&Columns"), list, FileList::ID_ARRANGE_BY_COLUMNS);
    new FXMenuCheck(&menu, _("Autosize"), list, FileList::ID_AUTOSIZE);
    new FXMenuSeparator(&menu);
    new FXMenuRadio(&menu, _("&Name"), list, FileList::ID_SORT_BY_NAME);
    new FXMenuRadio(&menu, _("Si&ze"), list, FileList::ID_SORT_BY_SIZE);
    new FXMenuRadio(&menu, _("&Type"), list, FileList::ID_SORT_BY_TYPE);
    new FXMenuRadio(&menu, _("E&xtension"), list, FileList::ID_SORT_BY_EXT);
    new FXMenuRadio(&menu, _("&Date"), list, FileList::ID_SORT_BY_TIME);
    new FXMenuRadio(&menu, _("&User"), list, FileList::ID_SORT_BY_USER);
    new FXMenuRadio(&menu, _("&Group"), list, FileList::ID_SORT_BY_GROUP);
    new FXMenuRadio(&menu, _("&Permissions"), list, FileList::ID_SORT_BY_PERM);
    new FXMenuSeparator(&menu);
    new FXMenuCheck(&menu, _("Ignore c&ase"), list, FileList::ID_SORT_CASE);
    new FXMenuCheck(&menu, _("Fold&ers first"), list, FileList::ID_DIRS_FIRST);
    new FXMenuCheck(&menu, _("Re&verse order"), list, FileList::ID_SORT_REVERSE);

    menu.create();
    allowPopupScroll = true;  // Allow keyboard scrolling
    menu.popup(NULL, x, y);
    getApp()->runModalWhileShown(&menu);
    allowPopupScroll = false;
    return(1);
}

// If Shift-F10 or Menu is pressed, opens the popup menu
long FileSelector::onCmdKeyPress(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    // Shift-F10 or Menu was pressed : open popup menu
   	if ((event->state&SHIFTMASK && event->code == KEY_F10) || event->code == KEY_Menu)
    {
        this->handle(sender, FXSEL(SEL_COMMAND, FileSelector::ID_POPUP_MENU), ptr);
        return(1);
    }

    // Any other key was pressed : handle the pressed key in the usual way
    else
    {
        if (this->onKeyPress(sender, sel, ptr))
        {
            return(1);
        }
    }

    return(0);
}

long FileSelector::onCmdKeyRelease(FXObject* sender, FXSelector sel, void* ptr)
{
    if (this->onKeyRelease(sender, sel, ptr))
    {
        return(1);
    }

    return(0);
}


// Object implementation
FXIMPLEMENT(FileDialog, DialogBox, NULL, 0)


// File Dialog object
FileDialog::FileDialog(FXWindow* owner, const FXString& name, FXuint opts, int x, int y, int w, int h) :
    DialogBox(owner, name, opts|DECOR_TITLE|DECOR_BORDER|DECOR_RESIZE|DECOR_MAXIMIZE|DECOR_CLOSE, x, y, w, h, 0, 0, 0, 0, 4, 4)
{
    list = new FileSelector(this, NULL, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    list->acceptButton()->setTarget(this);
    list->acceptButton()->setSelector(DialogBox::ID_ACCEPT);
    list->cancelButton()->setTarget(this);
    list->cancelButton()->setSelector(DialogBox::ID_CANCEL);

    // Set file dialog options
    FXuint width = getApp()->reg().readUnsignedEntry("FILEDIALOG", "width", 640);
    FXuint height = getApp()->reg().readUnsignedEntry("FILEDIALOG", "height", 480);
    setWidth(width);
    setHeight(height);
}


// Set file name
void FileDialog::setFilename(const FXString& path)
{
    list->setFilename(path);
}


// Get filename, if any
FXString FileDialog::getFilename() const
{
    return(list->getFilename());
}


// Return empty-string terminated list of selected file names,
FXString* FileDialog::getFilenames() const
{
    return(list->getFilenames());
}


// Set pattern
void FileDialog::setPattern(const FXString& ptrn)
{
    list->setPattern(ptrn);
}


// Get pattern
FXString FileDialog::getPattern() const
{
    return(list->getPattern());
}


// Change patterns, each pattern separated by newline
void FileDialog::setPatternList(const FXString& patterns)
{
    list->setPatternList(patterns);
}


// Return list of patterns
FXString FileDialog::getPatternList() const
{
    return(list->getPatternList());
}


// Set directory
void FileDialog::setDirectory(const FXString& path)
{
    list->setDirectory(path);
}


// Get directory
FXString FileDialog::getDirectory() const
{
    return(list->getDirectory());
}


// Set current file pattern from the list
void FileDialog::setCurrentPattern(int n)
{
    list->setCurrentPattern(n);
}


// Return current pattern
int FileDialog::getCurrentPattern() const
{
    return(list->getCurrentPattern());
}


FXString FileDialog::getPatternText(int patno) const
{
    return(list->getPatternText(patno));
}


void FileDialog::setPatternText(int patno, const FXString& text)
{
    list->setPatternText(patno, text);
}


// Set list of patterns (DEPRECATED)
void FileDialog::setPatternList(const char** ptrns)
{
    list->setPatternList(ptrns);
}


// Change space for item
void FileDialog::setItemSpace(int s)
{
    list->setItemSpace(s);
}


// Get space for item
int FileDialog::getItemSpace() const
{
    return(list->getItemSpace());
}


// Change File List style
void FileDialog::setFileBoxStyle(FXuint style)
{
    list->setFileBoxStyle(style);
}


// Return File List style
FXuint FileDialog::getFileBoxStyle() const
{
    return(list->getFileBoxStyle());
}


// Change file selection mode
void FileDialog::setSelectMode(FXuint mode)
{
    list->setSelectMode(mode);
}


// Return file selection mode
FXuint FileDialog::getSelectMode() const
{
    return(list->getSelectMode());
}


// Show readonly button
void FileDialog::showReadOnly(FXbool show)
{
    list->showReadOnly(show);
}


// Return true if readonly is shown
FXbool FileDialog::shownReadOnly() const
{
    return(list->shownReadOnly());
}


// Set initial state of readonly button
void FileDialog::setReadOnly(FXbool state)
{
    list->setReadOnly(state);
}


// Get readonly state
FXbool FileDialog::getReadOnly() const
{
    return(list->getReadOnly());
}


// Return true if thumbnails are displayed
FXbool FileDialog::shownThumbnails() const
{
    return(list->shownThumbnails());
}


// Return true if hidden files are displayed
FXbool FileDialog::shownHiddenFiles() const
{
    return(list->shownHiddenFiles());
}


// Change show hidden files mode
void FileDialog::showHiddenFiles(FXbool shown)
{
    list->showHiddenFiles(shown);
}


// Change show thumbnails files mode
void FileDialog::showThumbnails(FXbool shown)
{
    list->showThumbnails(shown);
}


// Cleanup
FileDialog::~FileDialog()
{
    // Write options to the registry
    getApp()->reg().writeUnsignedEntry("FILEDIALOG", "width", getWidth());
    getApp()->reg().writeUnsignedEntry("FILEDIALOG", "height", getHeight());
    getApp()->reg().write();

    delete list;
}


// Open existing filename
FXString FileDialog::getOpenFilename(FXWindow* owner, const FXString& caption, const FXString& path, const FXString& patterns, int initial)
{
    FileDialog opendialog(owner, caption);
    FXString   filename;

    opendialog.setSelectMode(SELECT_FILE_EXISTING);
    opendialog.setPatternList(patterns);
    opendialog.setCurrentPattern(initial);
    opendialog.setFilename(path);
    if (opendialog.execute())
    {
        filename = opendialog.getFilename();
        if (::isFile(filename))
        {
            return(filename);
        }
    }
    return(FXString::null);
}


// Save to filename
FXString FileDialog::getSaveFilename(FXWindow* owner, const FXString& caption, const FXString& path, const FXString& patterns, int initial)
{
    FileDialog savedialog(owner, caption);

    savedialog.setSelectMode(SELECT_FILE_ANY);
    savedialog.setPatternList(patterns);
    savedialog.setCurrentPattern(initial);
    savedialog.setFilename(path);
    if (savedialog.execute())
    {
        return(savedialog.getFilename());
    }
    return(FXString::null);
}


// Open multiple existing files
FXString* FileDialog::getOpenFilenames(FXWindow* owner, const FXString& caption, const FXString& path, const FXString& patterns, int initial)
{
    FileDialog opendialog(owner, caption);

    opendialog.setSelectMode(SELECT_FILE_MULTIPLE);
    opendialog.setPatternList(patterns);
    opendialog.setCurrentPattern(initial);
    opendialog.setFilename(path);
    if (opendialog.execute())
    {
        return(opendialog.getFilenames());
    }
    return(NULL);
}


// Open existing directory name
FXString FileDialog::getOpenDirectory(FXWindow* owner, const FXString& caption, const FXString& path)
{
    FileDialog dirdialog(owner, caption);
    FXString   dirname;

    dirdialog.setSelectMode(SELECT_FILE_DIRECTORY);
    dirdialog.setFilename(path);
    if (dirdialog.execute())
    {
        dirname = dirdialog.getFilename();
        if (::isDirectory(dirname))
        {
            return(dirname);
        }
    }
    return(FXString::null);
}


// Switched directories using directory tree
 long FileSelector::onCmdDirTree(FXObject*,FXSelector,void* ptr){
//   if(allowNavigation()){
    list->setDirectory((FXchar*)ptr);
     if(selectmode==SELECTFILE_DIRECTORY) filename->setText(FXString::null);
//     }
//   else{
//     dirbox->setDirectory(getDirectory());
//     }
   return 1;
   }



/* void FXFileDict::setAssociations(FileDict* assocs)
{
    if (associations != assocs)
    {
        associations = assocs;
        scan(true);
    }
    setFocus();
}
*/
// File association tables. Taken from the FOX library and slightly modified.

#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "FileDict.h"

#define COMMANDLEN      256
#define EXTENSIONLEN    128
#define MIMETYPELEN     64
#define ICONNAMELEN     256


// Object implementation
FXIMPLEMENT(IconDict, FXDict, NULL, 0)


// Default icon path
const char IconDict::defaultIconPath[] = DEFAULTICONPATH;


// Build icon table
IconDict::IconDict(FXApp* a, const FXString& p) : path(p)
{
    app = a;
    source = new FXIconSource(a);
}


// Search for the icon name along the search path, and try to load it
void* IconDict::createData(const void* ptr)
{
    //FXIcon* loadedicon = source->loadIconFile(FXPath::search(path, (const char*)ptr));
    FXIcon* loadedicon = loadiconfile(getApp(), path, (const char*)ptr, getApp()->getBackColor());
    //loadedicon->blend(getApp()->getBackColor());
    //return(source->loadIconFile(FXPath::search(path, (const char*)ptr)));
    return (loadedicon);
}


// Delete the icon
void IconDict::deleteData(void* ptr)
{
    delete ((FXIcon*)ptr);
}


// Save data
void IconDict::save(FXStream& store) const
{
    FXDict::save(store);
    store << source;
    store << path;
}


// Load data
void IconDict::load(FXStream& store)
{
    FXDict::load(store);
    store >> source;
    store >> path;
}


// Destructor
IconDict::~IconDict()
{
    delete source;
    source = (FXIconSource*)-1L;
    clear();
}


// These registry keys are used for default bindings.
const char FileDict::defaultExecBinding[] = "defaultexecbinding";
const char FileDict::defaultDirBinding[] = "defaultdirbinding";
const char FileDict::defaultFileBinding[] = "defaultfilebinding";


// Object implementation
FXIMPLEMENT(FileDict, FXDict, NULL, 0)


// Construct an file-extension association table
FileDict::FileDict(FXApp* a) : app(a), settings(&a->reg())
{
    icons = new IconDict(a, settings->readStringEntry("SETTINGS", "iconpath", DEFAULTICONPATH));
}


// Construct an file-extension association table, and alternative settings database
FileDict::FileDict(FXApp* a, FXSettings* db) : app(a), settings(db)
{
    icons = new IconDict(a, settings->readStringEntry("SETTINGS", "iconpath", DEFAULTICONPATH));
}


// Create new association from extension
void* FileDict::createData(const void* ptr)
{
    register const char* p = (const char*)ptr;
    register char*       q;
    char                 command[COMMANDLEN];
    char                 extension[EXTENSIONLEN];
    char                 mimetype[MIMETYPELEN];
    char                 bigname[ICONNAMELEN];
    char                 bignameopen[ICONNAMELEN];
    char                 mininame[ICONNAMELEN];
    char                 mininameopen[ICONNAMELEN];
    FileAssoc*           fileassoc;

    // Make association record
    fileassoc = new FileAssoc;

    // Parse command
    for (q = command; *p && *p != ';' && q < command+COMMANDLEN-1; *q++ = *p++)
    {
    }
    *q = '\0';

    // Skip section separator
    if (*p == ';')
    {
        p++;
    }

    // Parse extension type
    for (q = extension; *p && *p != ';' && q < extension+EXTENSIONLEN-1; *q++ = *p++)
    {
    }
    *q = '\0';

    // Skip section separator
    if (*p == ';')
    {
        p++;
    }

    // Parse big icon name
    for (q = bigname; *p && *p != ';' && *p != ':' && q < bigname+ICONNAMELEN-1; *q++ = *p++)
    {
    }
    *q = '\0';

    // Skip icon separator
    if (*p == ':')
    {
        p++;
    }

    // Parse big open icon name
    for (q = bignameopen; *p && *p != ';' && q < bignameopen+ICONNAMELEN-1; *q++ = *p++)
    {
    }
    *q = '\0';

    // Skip section separator
    if (*p == ';')
    {
        p++;
    }

    // Parse mini icon name
    for (q = mininame; *p && *p != ';' && *p != ':' && q < mininame+ICONNAMELEN-1; *q++ = *p++)
    {
    }
    *q = '\0';

    // Skip icon separator
    if (*p == ':')
    {
        p++;
    }

    // Parse mini open icon name
    for (q = mininameopen; *p && *p != ';' && q < mininameopen+ICONNAMELEN-1; *q++ = *p++)
    {
    }
    *q = '\0';

    // Skip section separator
    if (*p == ';')
    {
        p++;
    }

    // Parse mime type
    for (q = mimetype; *p && *p != ';' && q < mimetype+MIMETYPELEN-1; *q++ = *p++)
    {
    }
    *q = '\0';

    // Initialize association data
    fileassoc->command = command;
    fileassoc->extension = extension;
    fileassoc->bigicon = NULL;
    fileassoc->miniicon = NULL;
    fileassoc->bigiconopen = NULL;
    fileassoc->miniiconopen = NULL;
    fileassoc->mimetype = mimetype;
    fileassoc->dragtype = 0;
    fileassoc->flags = 0;

    // Insert icons into icon dictionary
    if (bigname[0])
    {
        fileassoc->bigicon = fileassoc->bigiconopen = icons->insert(bigname);
        //fileassoc->bigicon->blend(getApp()->getBackColor());
    }
    if (mininame[0])
    {
        fileassoc->miniicon = fileassoc->miniiconopen = icons->insert(mininame);
        //fileassoc->miniicon->blend(getApp()->getBackColor());
    }

    // Add open icons also; we will fall back on the regular icons in needed
    if (bignameopen[0])
    {
        fileassoc->bigiconopen = icons->insert(bignameopen);
    }
    if (mininameopen[0])
    {
        fileassoc->miniiconopen = icons->insert(mininameopen);
    }

    // Return the binding
    return(fileassoc);
}


// Delete association
void FileDict::deleteData(void* ptr)
{
    delete ((FileAssoc*)ptr);
}


// Set icon search path
void FileDict::setIconPath(const FXString& path)
{
    // Replace iconpath setting in registry
    settings->writeStringEntry("SETTINGS", "iconpath", path.text());

    // Change it in icon dictionary
    icons->setIconPath(path);
}


// Return current icon search path
FXString FileDict::getIconPath() const
{
    return(icons->getIconPath());
}


// Replace or add file association
FileAssoc* FileDict::replace(const char* ext, const char* str)
{
    // Replace entry in registry
    settings->writeStringEntry("FILETYPES", ext, str);

    // Replace record
    return((FileAssoc*)FXDict::replace(ext, str));
}


// Remove file association
FileAssoc* FileDict::remove(const char* ext)
{
    // Delete registry entry for this type
    settings->deleteEntry("FILETYPES", ext);

    // Remove record
    FXDict::remove(ext);

    return(NULL);
}


// Find file association using the lower case file extension
FileAssoc* FileDict::associate(const char* key)
{
    register const char* association;
    register FileAssoc*  record;
    register char        lowkey[MAXPATHLEN];

    // Convert the association key to lower case
    // Uses these functions because they seem to be faster than FXString
    strlcpy(lowkey, key, strlen(key)+1);
    strlow(lowkey);

    // See if we have an existing record already and stores the key extension
    if ((record = find(lowkey)) != NULL)
    {
        record->key = lowkey;
        return(record);
    }

    // See if this entry is known in FILETYPES
    association = settings->readStringEntry("FILETYPES", lowkey, "");

    // If not an empty string, make a record for it now and stores the key extension
    if (association[0])
    {
        record = (FileAssoc*)FXDict::insert(lowkey, association);
        record->key = lowkey;
        return(record);
    }

    // Not a known file type
    return(NULL);
}


// Find file association from registry
FileAssoc* FileDict::findFileBinding(const char* pathname)
{
    register const char* filename = pathname;
    register const char* p = pathname;
    register FileAssoc*  record;

    while (*p)
    {
        if (ISPATHSEP(*p))
        {
            filename = p+1;
        }
        p++;
    }

    if (strlen(filename) == 0)
    {
        return(associate(defaultFileBinding));
    }

    record = associate(filename);

    if (record)
    {
        return(record);
    }

    filename = strchr(filename, '.');

    while (filename)
    {
        if (strlen(filename) > 1)
        {
            record = associate(filename+1);
        }
        if (record)
        {
            return(record);
        }
        filename = strchr(filename+1, '.');
    }
    return(associate(defaultFileBinding));
}


// Find directory association from registry
FileAssoc* FileDict::findDirBinding(const char* pathname)
{
    register const char* path = pathname;
    register FileAssoc*  record;

    while (*path)
    {
        record = associate(path);
        if (record)
        {
            return(record);
        }
        path++;
        while (*path && !ISPATHSEP(*path))
        {
            path++;
        }
    }
    return(associate(defaultDirBinding));
}


// Find executable association from registry
FileAssoc* FileDict::findExecBinding(const char* pathname)
{
    return(associate(defaultExecBinding));
}


// Destructor
FileDict::~FileDict()
{
    delete icons;
    clear();
    app = (FXApp*)-1;
    icons = (IconDict*)-1;
}
// File list. Taken from the FOX library and slightly modified.
// The compare(), compare_nolocale() and compare_locale() functions are adapted from a patch
// submitted by Vladimir Tmara Patio


#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>
#include <FXJPGIcon.h>
#include <FXTIFIcon.h>
#if defined(linux)
#include <mntent.h>
#endif

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "File.h"
#include "FileDict.h"
#include "IconList.h"
#include "MessageBox.h"
#include "InputDialog.h"
#include "StringList.h"
#include "FileList.h"
#include "FilePanel.h"
#include "XFileExplorer.h"

//extern FXMainWindow* mainWindow;


// Number of columns in detailed view, in the general case
#define NB_HEADERS    8

// Minimum file name size in detailed view
#ifndef MIN_NAME_SIZE
#define MIN_NAME_SIZE    75
#endif

// Time interval before refreshing the view
#define REFRESH_INTERVAL     1000
#define REFRESH_FREQUENCY    30

// Time interval before opening a folder
#define OPEN_INTERVAL        1000

// Counter limit for image refreshing
#define REFRESH_COUNT        100

#define HASH1(x, n)    (((FXuint)(x)*13)%(n))         // Probe Position [0..n-1]
#define HASH2(x, n)    (1|(((FXuint)(x)*17)%((n)-1))) // Probe Distance [1..n-1]


#if defined(linux)
FXStringDict* fsdevices = NULL; // Devices from fstab
FXStringDict* mtdevices = NULL; // Mounted devices
FXStringDict* updevices = NULL; // Responding devices
#endif

extern FXbool   allowPopupScroll;
extern FXString xdgdatahome;



// Object implementation
FXIMPLEMENT(FileItem, IconItem, NULL, 0)


// Map
FXDEFMAP(FileList) FileListMap[] =
{
    FXMAPFUNC(SEL_DRAGGED, 0, FileList::onDragged),
    FXMAPFUNC(SEL_TIMEOUT, FileList::ID_REFRESH_TIMER, FileList::onCmdRefreshTimer),
    FXMAPFUNC(SEL_TIMEOUT, FileList::ID_OPEN_TIMER, FileList::onOpenTimer),
    FXMAPFUNC(SEL_DND_ENTER, 0, FileList::onDNDEnter),
    FXMAPFUNC(SEL_DND_LEAVE, 0, FileList::onDNDLeave),
    FXMAPFUNC(SEL_DND_DROP, 0, FileList::onDNDDrop),
    FXMAPFUNC(SEL_DND_MOTION, 0, FileList::onDNDMotion),
    FXMAPFUNC(SEL_DND_REQUEST, 0, FileList::onDNDRequest),
    FXMAPFUNC(SEL_BEGINDRAG, 0, FileList::onBeginDrag),
    FXMAPFUNC(SEL_ENDDRAG, 0, FileList::onEndDrag),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_DRAG_COPY, FileList::onCmdDragCopy),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_DRAG_MOVE, FileList::onCmdDragMove),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_DRAG_LINK, FileList::onCmdDragLink),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_DRAG_REJECT, FileList::onCmdDragReject),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_DIRECTORY_UP, FileList::onCmdDirectoryUp),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_SORT_BY_NAME, FileList::onCmdSortByName),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_SORT_BY_DIRNAME, FileList::onCmdSortByDirName),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_SORT_BY_TYPE, FileList::onCmdSortByType),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_SORT_BY_SIZE, FileList::onCmdSortBySize),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_SORT_BY_EXT, FileList::onCmdSortByExt),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_SORT_BY_TIME, FileList::onCmdSortByTime),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_SORT_BY_USER, FileList::onCmdSortByUser),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_SORT_BY_GROUP, FileList::onCmdSortByGroup),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_SORT_BY_PERM, FileList::onCmdSortByPerm),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_SORT_BY_DELTIME, FileList::onCmdSortByDeltime),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_SORT_BY_ORIGPATH, FileList::onCmdSortByOrigpath),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_SORT_REVERSE, FileList::onCmdSortReverse),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_SORT_CASE, FileList::onCmdSortCase),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_DIRS_FIRST, FileList::onCmdDirsFirst),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_SET_PATTERN, FileList::onCmdSetPattern),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_SHOW_HIDDEN, FileList::onCmdShowHidden),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_HIDE_HIDDEN, FileList::onCmdHideHidden),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_TOGGLE_HIDDEN, FileList::onCmdToggleHidden),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_TOGGLE_THUMBNAILS, FileList::onCmdToggleThumbnails),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_HEADER_CHANGE, FileList::onCmdHeader),
    FXMAPFUNC(SEL_COMMAND, FileList::ID_REFRESH, FileList::onCmdRefresh),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_HEADER_CHANGE, FileList::onUpdHeader),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_DIRECTORY_UP, FileList::onUpdDirectoryUp),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_SORT_BY_NAME, FileList::onUpdSortByName),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_SORT_BY_DIRNAME, FileList::onUpdSortByDirName),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_SORT_BY_TYPE, FileList::onUpdSortByType),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_SORT_BY_SIZE, FileList::onUpdSortBySize),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_SORT_BY_EXT, FileList::onUpdSortByExt),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_SORT_BY_TIME, FileList::onUpdSortByTime),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_SORT_BY_USER, FileList::onUpdSortByUser),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_SORT_BY_GROUP, FileList::onUpdSortByGroup),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_SORT_BY_PERM, FileList::onUpdSortByPerm),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_SORT_BY_DELTIME, FileList::onUpdSortByDeltime),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_SORT_BY_ORIGPATH, FileList::onUpdSortByOrigpath),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_SORT_REVERSE, FileList::onUpdSortReverse),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_SORT_CASE, FileList::onUpdSortCase),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_DIRS_FIRST, FileList::onUpdDirsFirst),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_SET_PATTERN, FileList::onUpdSetPattern),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_SHOW_HIDDEN, FileList::onUpdShowHidden),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_HIDE_HIDDEN, FileList::onUpdHideHidden),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_TOGGLE_HIDDEN, FileList::onUpdToggleHidden),
    FXMAPFUNC(SEL_UPDATE, FileList::ID_TOGGLE_THUMBNAILS, FileList::onUpdToggleThumbnails),
    FXMAPFUNC(SEL_UPDATE, 0, FileList::onUpdRefreshTimer),
};


// Object implementation
FXIMPLEMENT(FileList, IconList, FileListMap, ARRAYNUMBER(FileListMap))



// File List
// Note : the attribute _ICONLIST_FILELIST indicates that the icon list is a file list
FileList::FileList(FXWindow* focuswin, FXComposite* p, FXObject* tgt, FXSelector sel, FXbool showthumbs, FXuint opts, int x, int y, int w, int h) :
    IconList(p, tgt, sel, opts, x, y, w, h), directory(ROOTDIR), orgdirectory(ROOTDIR), pattern("*")
{ 
    flags |= FLAG_ENABLED|FLAG_DROPTARGET;
    associations = NULL;
    appendHeader(_("Name"), NULL, 200);
    if (options&_FILELIST_SEARCH)
    {
        appendHeader(_("Folder"), NULL, 150);
    }
    appendHeader(_("Size"), NULL, 60);
    appendHeader(_("Type"), NULL, 100);
    appendHeader(_("Extension"), NULL, 100);
    appendHeader(_("Modified date"), NULL, 150);
    appendHeader(_("User"), NULL, 50);
    appendHeader(_("Group"), NULL, 50);
    appendHeader(_("Permissions"), NULL, 100);

    // Initializations
    matchmode = FILEMATCH_FILE_NAME|FILEMATCH_NOESCAPE;
    associations = new FileDict(getApp());
    dropaction = DRAG_MOVE;
    sortfunc = ascendingCase;
    dirsfirst = true;
    allowrefresh = true;
    timestamp = 0;
    counter = 1;
    prevIndex = -1;
    list = NULL;
    displaythumbnails = showthumbs;
    backhist = NULL;
    forwardhist = NULL;
    focuswindow = focuswin;
    deldatesize = 0;
    origpathsize = 0;

#if defined(linux)
    // Initialize the fsdevices, mtdevices and updevices lists
    // if it was not done in DirList (useful for XFileWrite, XFilePackage and XFileImage)
    struct mntent* mnt;
    if (fsdevices == NULL)
    {
        // To list file system devices
        fsdevices = new FXStringDict();
        FILE* fstab = setmntent(FSTAB_PATH, "r");
        if (fstab)
        {
            while ((mnt = getmntent(fstab)))
            {
                if (!streq(mnt->mnt_type, MNTTYPE_IGNORE) && !streq(mnt->mnt_type, MNTTYPE_SWAP) &&
                    !streq(mnt->mnt_dir, "/"))
                {
                    if (!strncmp(mnt->mnt_fsname, "/dev/fd", 7))
                    {
                        fsdevices->insert(mnt->mnt_dir, "floppy");
                    }
                    else if (!strncmp(mnt->mnt_type, "iso", 3))
                    {
                        fsdevices->insert(mnt->mnt_dir, "cdrom");
                    }
                    else if (!strncmp(mnt->mnt_fsname, "/dev/zip", 8))
                    {
                        fsdevices->insert(mnt->mnt_dir, "zip");
                    }
                    else if (streq(mnt->mnt_type, "nfs"))
                    {
                        fsdevices->insert(mnt->mnt_dir, "nfsdisk");
                    }
                    else if (streq(mnt->mnt_type, "smbfs"))
                    {
                        fsdevices->insert(mnt->mnt_dir, "smbdisk");
                    }
                    else if (streq(mnt->mnt_type, "cifs"))
                    {
                        fsdevices->insert(mnt->mnt_dir, "smbdisk");
                    }
                    else
                    {
                        fsdevices->insert(mnt->mnt_dir, "harddisk");
                    }
                }
            }
            endmntent(fstab);
        }
    }
    if (mtdevices == NULL)
    {
        // To list mounted devices
        mtdevices = new FXStringDict();
        FILE* mtab = setmntent(MTAB_PATH, "r");
        if (mtab)
        {
            while ((mnt = getmntent(mtab)))
            {
                // To fix an issue with some Linux distributions
                FXString mntdir = mnt->mnt_dir;
                if ((mntdir != "/dev/.static/dev") && (mntdir.rfind("gvfs", 4, mntdir.length()) == -1))
                {
                    mtdevices->insert(mnt->mnt_dir, mnt->mnt_type);
                }
            }
            endmntent(mtab);
        }
    }
    if (updevices == NULL)
    {
        // To mark mount points that are up or down
        updevices = new FXStringDict();
        struct stat statbuf;
        FXString    mtstate;
        FILE*       mtab = setmntent(MTAB_PATH, "r");
        if (mtab)
        {
            while ((mnt = getmntent(mtab)))
            {
                // To fix an issue with some Linux distributions
                FXString mntdir = mnt->mnt_dir;
                if ((mntdir != "/dev/.static/dev") && (mntdir.rfind("gvfs", 4, mntdir.length()) == -1))
                {
                    if (lstatmt(mnt->mnt_dir, &statbuf) == -1)
                    {
                        mtstate = "down";
                    }
                    else
                    {
                        mtstate = "up";
                    }
                    updevices->insert(mnt->mnt_dir, mtstate.text());
                }
            }
            endmntent(mtab);
        }
    }
#endif

    // Trahscan location
    trashfileslocation = xdgdatahome + PATHSEPSTRING TRASHFILESPATH;
    trashinfolocation = xdgdatahome + PATHSEPSTRING TRASHINFOPATH;
}


#if defined(linux)


// Force mtdevices list refresh
void FileList::refreshMtdevices(void)
{
    struct mntent* mnt;
    FXStringDict*  tmpdict = new FXStringDict();
    FILE*          mtab = setmntent(MTAB_PATH, "r");

    if (mtab)
    {
        while ((mnt = getmntent(mtab)))
        {
            // To fix an issue with some Linux distributions
            FXString mntdir = mnt->mnt_dir;
            if ((mntdir != "/dev/.static/dev") && (mntdir.rfind("gvfs", 4, mntdir.length()) == -1))
            {
                tmpdict->insert(mnt->mnt_dir, "");
                if (mtdevices->find(mnt->mnt_dir))
                {
                    mtdevices->remove(mnt->mnt_dir);
                }
                mtdevices->insert(mnt->mnt_dir, mnt->mnt_type);
            }
        }
        endmntent(mtab);
    }

    // Remove mount points that don't exist anymore
    int s;
    for (s = mtdevices->first(); s < mtdevices->size(); s = mtdevices->next(s))
    {
        if (!tmpdict->find(mtdevices->key(s)))
        {
            mtdevices->remove(mtdevices->key(s));
        }
    }

    delete tmpdict;
}


#endif


// Create the file list
void FileList::create()
{
    IconList::create();
    if (!deleteType)
    {
        deleteType = getApp()->registerDragType(deleteTypeName);
    }
    if (!urilistType)
    {
        urilistType = getApp()->registerDragType(urilistTypeName);
    }
    getApp()->addTimeout(this, ID_REFRESH_TIMER, REFRESH_INTERVAL);
}


// Cleanup
FileList::~FileList()
{
    getApp()->removeTimeout(this, ID_REFRESH_TIMER);
    getApp()->removeTimeout(this, ID_OPEN_TIMER);
    delete associations;
    delete forwardhist;
    delete backhist;

    associations = (FileDict*)-1;
    list = (FileItem*)-1L;
}


// Open up folder when hovering long over a folder
long FileList::onOpenTimer(FXObject*, FXSelector, void*)
{
    int    xx, yy, index;
    FXuint state;

    getCursorPosition(xx, yy, state);
    index = getItemAt(xx, yy);
    if ((0 <= index) && isItemDirectory(index))
    {
        dropdirectory = getItemPathname(index);
        setDirectory(dropdirectory);
        getApp()->addTimeout(this, ID_OPEN_TIMER, OPEN_INTERVAL);
        prevIndex = -1;
    }
    return(1);
}


// Handle drag-and-drop enter
long FileList::onDNDEnter(FXObject* sender, FXSelector sel, void* ptr)
{
    IconList::onDNDEnter(sender, sel, ptr);

    // Keep original directory
    orgdirectory = getDirectory();

    return(1);
}


// Handle drag-and-drop leave
long FileList::onDNDLeave(FXObject* sender, FXSelector sel, void* ptr)
{
    IconList::onDNDLeave(sender, sel, ptr);

    if (prevIndex != -1)
    {
        setItemMiniIcon(prevIndex, minifoldericon);
        setItemBigIcon(prevIndex, bigfoldericon);
        prevIndex = -1;
    }

    // Cancel open up timer
    getApp()->removeTimeout(this, ID_OPEN_TIMER);

    // Stop scrolling
    stopAutoScroll();

    // Restore original directory
    setDirectory(orgdirectory);
    return(1);
}


// Handle drag-and-drop motion
long FileList::onDNDMotion(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    int      index = -1;

    // Cancel open up timer
    getApp()->removeTimeout(this, ID_OPEN_TIMER);

    // Start autoscrolling
    if (startAutoScroll(event, false))
    {
        return(1);
    }

    // Give base class a shot
    if (IconList::onDNDMotion(sender, sel, ptr))
    {
        return(1);
    }

    // Dropping list of filenames
    if (offeredDNDType(FROM_DRAGNDROP, urilistType))
    {
        index = getItemAt(event->win_x, event->win_y);
        if ((prevIndex != -1) && (prevIndex != index))
        {
            // Symlink folders have a different icon
            if (isItemLink(prevIndex))
            {
                setItemMiniIcon(prevIndex, minilinkicon);
                setItemBigIcon(prevIndex, biglinkicon);
                deselectItem(prevIndex);
            }
            else
            {
                setItemMiniIcon(prevIndex, minifoldericon);
                setItemBigIcon(prevIndex, bigfoldericon);
                deselectItem(prevIndex);
            }
            prevIndex = -1;
        }

        // Drop in the background
        dropdirectory = getDirectory();

        // What is being done (move,copy,link)
        dropaction = inquireDNDAction();

        // We will open up a folder if we can hover over it for a while
        if ((0 <= index) && isItemDirectory(index))
        {
            // Set open up timer
            getApp()->addTimeout(this, ID_OPEN_TIMER, OPEN_INTERVAL);
            prevIndex = index;
            setItemMiniIcon(index, minifolderopenicon);
            setItemBigIcon(index, bigfolderopenicon);
            selectItem(index);

            // Directory where to drop, or directory to open up
            dropdirectory = getItemPathname(index);
        }

        // See if dropdirectory is writable
        if (::isWritable(dropdirectory))
        {
            acceptDrop(DRAG_ACCEPT);
        }
        return(1);
    }
    return(0);
}


// Set drag type to copy
long FileList::onCmdDragCopy(FXObject* sender, FXSelector sel, void* ptr)
{
    dropaction = DRAG_COPY;
    return(1);
}


// Set drag type to move
long FileList::onCmdDragMove(FXObject* sender, FXSelector sel, void* ptr)
{
    dropaction = DRAG_MOVE;
    return(1);
}


// Set drag type to symlink
long FileList::onCmdDragLink(FXObject* sender, FXSelector sel, void* ptr)
{
    dropaction = DRAG_LINK;
    return(1);
}


// Cancel drag action
long FileList::onCmdDragReject(FXObject* sender, FXSelector sel, void* ptr)
{
    dropaction = DRAG_REJECT;
    return(1);
}


// Handle drag-and-drop drop
long FileList::onDNDDrop(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuchar* data;
    FXuint   len;
    FXbool   showdialog = true;
    File*    f = NULL;
    int      ret;

    FXbool ask_before_copy = getApp()->reg().readUnsignedEntry("OPTIONS", "ask_before_copy", true);
    FXbool confirm_dnd = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_drag_and_drop", true);


    // Cancel open up timer
    getApp()->removeTimeout(this, ID_OPEN_TIMER);

    // Stop scrolling
    stopAutoScroll();

    // Perhaps target wants to deal with it
    if (IconList::onDNDDrop(sender, sel, ptr))
    {
        return(1);
    }

    // Check if control key or shift key were pressed
    FXbool ctrlshiftkey = false;

    if (ptr != NULL)
    {
        FXEvent* event = (FXEvent*)ptr;
        if (event->state&CONTROLMASK)
        {
            ctrlshiftkey = true;
        }
        if (event->state&SHIFTMASK)
        {
            ctrlshiftkey = true;
        }
    }

    // Get DND data
    // This is done before displaying the popup menu to fix a drag and drop problem with konqueror and dolphin file managers
    FXbool dnd = getDNDData(FROM_DRAGNDROP, urilistType, data, len);

    int    xx, yy, index=-1;

    // Display the dnd dialog if the control or shift key were not pressed
    if (confirm_dnd & !ctrlshiftkey)
    {
		// Get item index
		FXuint state;
		getCursorPosition(xx, yy, state);
		index = getItemAt(xx, yy);

        // Display a popup to select the drag type
        dropaction = DRAG_REJECT;
        FXMenuPane menu(this);
        int        x, y;
        getRoot()->getCursorPosition(x, y, state);
        new FXMenuCommand(&menu, _("Copy here"), copy_clpicon, this, FileList::ID_DRAG_COPY);
        new FXMenuCommand(&menu, _("Move here"), moveiticon, this, FileList::ID_DRAG_MOVE);
        new FXMenuCommand(&menu, _("Link here"), minilinkicon, this, FileList::ID_DRAG_LINK);
        new FXMenuSeparator(&menu);
        new FXMenuCommand(&menu, _("Cancel"), NULL, this, FileList::ID_DRAG_REJECT);
        menu.create();
        allowPopupScroll = true;  // Allow keyboard scrolling
        menu.popup(NULL, x, y);
        getApp()->runModalWhileShown(&menu);
        allowPopupScroll = false;
    }

    if (prevIndex != -1)
    {
        setItemMiniIcon(prevIndex, minifoldericon);
        setItemBigIcon(prevIndex, bigfoldericon);
        prevIndex = -1;
    }
    // Restore original directory
    setDirectory(orgdirectory);

    // Get uri-list of files being dropped
    if (dnd)  // See comment upper
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        char* p, *q;
        p = q = (char*)data;

        // Number of selected items
        FXString buf = p;
        int      num = buf.contains('\n')+1;

        // Eventually correct the number of selected items
        // because sometimes there is another '\n' at the end of the string
        int pos = buf.rfind('\n');
        if (pos == buf.length()-1)
        {
            num = num-1;
        }

        // File object
        if (dropaction == DRAG_COPY)
        {
            f = new File(this, _("File copy"), COPY, num);
        }
        else if (dropaction == DRAG_MOVE)
        {
            f = new File(this, _("File move"), MOVE, num);
        }
        else if (dropaction == DRAG_LINK)
        {
            f = new File(this, _("File symlink"), SYMLINK, num);
        }
        else
        {
			// Deselect item
			if (index >= 0)
			{
				deselectItem(index);
			}
            FXFREE(&data);
            return(0);
        }

        // Target directory
        FXString targetdir = dropdirectory;

        while (*p)
        {
            while (*q && *q != '\r')
            {
                q++;
            }
            FXString url(p, q-p);
            FXString source(FXURL::decode(FXURL::fileFromURL(url)));
            FXString target(targetdir);
            FXString sourcedir = FXPath::directory(source);

            // File operation dialog, if needed
            if (((!confirm_dnd) | ctrlshiftkey) & ask_before_copy & showdialog)
            {
                FXIcon*  icon = NULL;
                FXString title, message;
                if (dropaction == DRAG_COPY)
                {
                    title = _("Copy");
                    icon = copy_bigicon;
                    if (num == 1)
                    {
                        message = title+source;
                    }
                    else
                    {
                        message.format(_("Copy %s files/folders.\nFrom: %s"), FXStringVal(num).text(), sourcedir.text());
                    }
                }
                else if (dropaction == DRAG_MOVE)
                {
                    title = _("Move");
                    icon = move_bigicon;
                    if (num == 1)
                    {
                        message = title+source;
                    }
                    else
                    {
                        message.format(_("Move %s files/folders.\nFrom: %s"), FXStringVal(num).text(), sourcedir.text());
                    }
                }
                else if ((dropaction == DRAG_LINK) && (num == 1))
                {
                    title = _("Symlink");
                    icon = link_bigicon;
                    message = title+source;
                }

                InputDialog* dialog = new InputDialog(this, targetdir, message, title, _("To:"), icon);
                dialog->CursorEnd();
                int rc = 1;
                rc = dialog->execute();
                target = dialog->getText();
                target = ::filePath(target);

                if (num > 1)
                {
                    showdialog = false;
                }
                delete dialog;
                if (!rc)
                {
                    return(0);
                }
            }
            // Move the source file
            if (dropaction == DRAG_MOVE)
            {
                // Move file
                f->create();

                // If target file is located at trash location, also create the corresponding trashinfo file
                // Do it silently and don't report any error if it fails
                FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                if (use_trash_can && (FXPath::directory(target) == trashfileslocation))
                {
                    // Trash files path name
                    FXString trashpathname = createTrashpathname(source, trashfileslocation);

                    // Adjust target name to get the _N suffix if any
                    FXString trashtarget = FXPath::directory(target)+PATHSEPSTRING+FXPath::name(trashpathname);

                    // Create trashinfo file
                    createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                    // Move source to trash target
                    ret = f->move(source, trashtarget);
                }

                // Move source to target
                else
                {
                    //target=FXPath::directory(target);
                    ret = f->move(source, target);
                }

                // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
                // Do it silently and don't report any error if it fails
                if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
                {
                    FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                    ::unlink(trashinfopathname.text());
                }

                // An error has occurred
                if ((ret == 0) && !f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
                    break;
                }

                // If action is cancelled in progress dialog
                if (f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
                    break;
                }
            }
            // Copy the source file
            else if (dropaction == DRAG_COPY)
            {
                // Copy file
                f->create();

                // If target file is located at trash location, also create the corresponding trashinfo file
                // Do it silently and don't report any error if it fails
                FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                if (use_trash_can && (FXPath::directory(target) == trashfileslocation))
                {
                    // Trash files path name
                    FXString trashpathname = createTrashpathname(source, trashfileslocation);

                    // Adjust target name to get the _N suffix if any
                    FXString trashtarget = FXPath::directory(target)+PATHSEPSTRING+FXPath::name(trashpathname);

                    // Create trashinfo file
                    createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                    // Copy source to trash target
                    ret = f->copy(source, trashtarget);
                }

                // Copy source to target
                else
                {
                    //target=FXPath::directory(target);
                    ret = f->copy(source, target);
                }

                // An error has occurred
                if ((ret == 0) && !f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
                    break;
                }

                // If action is cancelled in progress dialog
                if (f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
                    break;
                }
            }
            // Link the source file (no progress dialog in this case)
            else if (dropaction == DRAG_LINK)
            {
                // Link file
                f->create();
                f->symlink(source, target);
            }
            if (*q == '\r')
            {
                q += 2;
            }
            p = q;
        }
        delete f;
        FXFREE(&data);
        return(1);
    }

    return(0);
}


// Somebody wants our dragged data
long FileList::onDNDRequest(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    FXuchar* data;
    FXuint   len;

    // Perhaps the target wants to supply its own data
    if (IconList::onDNDRequest(sender, sel, ptr))
    {
        return(1);
    }

    // Return list of filenames as a uri-list
    if (event->target == urilistType)
    {
        if (!dragfiles.empty())
        {
            len = dragfiles.length();
            FXMEMDUP(&data, dragfiles.text(), FXuchar, len);
            setDNDData(FROM_DRAGNDROP, event->target, data, len);
        }
        return(1);
    }

    // Delete selected files
    if (event->target == deleteType)
    {
        return(1);
    }

    return(0);
}


// Start a drag operation
long FileList::onBeginDrag(FXObject* sender, FXSelector sel, void* ptr)
{
    register int i;

    if (IconList::onBeginDrag(sender, sel, ptr))
    {
        return(1);
    }
    if (beginDrag(&urilistType, 1))
    {
        dragfiles = FXString::null;
        for (i = 0; i < getNumItems(); i++)
        {
            if (isItemSelected(i))
            {
                if (getItemFilename(i) == "..")
                {
                    deselectItem(i);
                }
                else
                {
                    dragfiles += FXURL::encode(::fileToURI(getItemFullPathname(i)));
                    dragfiles += "\r\n";
                }
            }
        }
        return(1);
    }
    return(0);
}


// End drag operation
long FileList::onEndDrag(FXObject* sender, FXSelector sel, void* ptr)
{
    if (IconList::onEndDrag(sender, sel, ptr))
    {
        return(1);
    }
    endDrag((didAccept() != DRAG_REJECT));
    setDragCursor(getDefaultCursor());
    dragfiles = FXString::null;
    return(1);
}


// Dragged stuff around
long FileList::onDragged(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent*     event = (FXEvent*)ptr;
    FXDragAction action;

    if (IconList::onDragged(sender, sel, ptr))
    {
        return(1);
    }
    action = DRAG_MOVE;

    if (event->state&CONTROLMASK)
    {
        action = DRAG_COPY;
    }
    if (event->state&SHIFTMASK)
    {
        action = DRAG_MOVE;
    }
    if ((event->state&CONTROLMASK) && (event->state&SHIFTMASK))
    {
        action = DRAG_LINK;
    }

    // If source directory is read-only, convert move action to copy
    if (!::isWritable(orgdirectory) && (action == DRAG_MOVE))
    {
        action = DRAG_COPY;
    }

    handleDrag(event->root_x, event->root_y, action);
    if (didAccept() != DRAG_REJECT)
    {
        if (action == DRAG_MOVE)
        {
            setDragCursor(getApp()->getDefaultCursor(DEF_DNDMOVE_CURSOR));
        }
        else if (action == DRAG_LINK)
        {
            setDragCursor(getApp()->getDefaultCursor(DEF_DNDLINK_CURSOR));
        }
        else
        {
            setDragCursor(getApp()->getDefaultCursor(DEF_DNDCOPY_CURSOR));
        }
    }
    else
    {
        setDragCursor(getApp()->getDefaultCursor(DEF_DNDSTOP_CURSOR));
    }
    return(1);
}


// Toggle hidden files display
long FileList::onCmdToggleHidden(FXObject*, FXSelector, void*)
{
    showHiddenFiles(!shownHiddenFiles());
    return(1);
}


// Toggle thumbnails display
long FileList::onCmdToggleThumbnails(FXObject*, FXSelector, void*)
{
    showThumbnails(!displaythumbnails);
    return(1);
}


// Update toggle thumbnails button
long FileList::onUpdToggleThumbnails(FXObject* sender, FXSelector, void*)
{
    if (shownThumbnails())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


// Update toggle hidden files button
long FileList::onUpdToggleHidden(FXObject* sender, FXSelector, void*)
{
    if (shownHiddenFiles())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


// Show hidden files
long FileList::onCmdShowHidden(FXObject*, FXSelector, void*)
{
    showHiddenFiles(true);
    return(1);
}


// Update show hidden files widget
long FileList::onUpdShowHidden(FXObject* sender, FXSelector, void*)
{
    if (shownHiddenFiles())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


// Hide hidden files
long FileList::onCmdHideHidden(FXObject*, FXSelector, void*)
{
    showHiddenFiles(false);
    return(1);
}


// Update hide hidden files widget
long FileList::onUpdHideHidden(FXObject* sender, FXSelector, void*)
{
    if (!shownHiddenFiles())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


// Move up one level
long FileList::onCmdDirectoryUp(FXObject*, FXSelector, void*)
{
    setFocus();
    setDirectory(FXPath::upLevel(directory), true, directory);
    return(1);
}


// Determine if we can still go up more
long FileList::onUpdDirectoryUp(FXObject* sender, FXSelector, void* ptr)
{
    FXuint msg = FXPath::isTopDirectory(directory) ? ID_DISABLE : ID_ENABLE;

    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);
    return(1);
}


// Change pattern
long FileList::onCmdSetPattern(FXObject*, FXSelector, void* ptr)
{
    if (!ptr)
    {
        return(0);
    }
    setPattern((const char*)ptr);
    return(1);
}


// Update pattern
long FileList::onUpdSetPattern(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_SETVALUE), (void*)pattern.text());
    return(1);
}


// Sort by name
long FileList::onCmdSortByName(FXObject*, FXSelector, void*)
{
    if (dirsfirst == false)
    {
        if (getIgnoreCase() == true)
        {
            sortfunc = (sortfunc == ascendingCaseMix) ? descendingCaseMix : ascendingCaseMix;
        }
        else
        {
            sortfunc = (sortfunc == ascendingMix) ? descendingMix : ascendingMix;
        }
    }
    else
    {
        if (getIgnoreCase() == true)
        {
            sortfunc = (sortfunc == ascendingCase) ? descendingCase : ascendingCase;
        }
        else
        {
            sortfunc = (sortfunc == ascending) ? descending : ascending;
        }
    }
    setSortHeader(0);
    scan(true);
    return(1);
}


// Update sender
long FileList::onUpdSortByName(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (sortfunc == ascending || sortfunc == descending || sortfunc == ascendingCase || sortfunc == descendingCase ||
                          sortfunc == ascendingMix || sortfunc == descendingMix || sortfunc == ascendingCaseMix || sortfunc == descendingCaseMix) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    return(1);
}


// Sort by directory name (for search list)
long FileList::onCmdSortByDirName(FXObject*, FXSelector, void*)
{
    if (dirsfirst == false)
    {
        if (getIgnoreCase() == true)
        {
            sortfunc = (sortfunc == ascendingDirCaseMix) ? descendingDirCaseMix : ascendingDirCaseMix;
        }
        else
        {
            sortfunc = (sortfunc == ascendingDirMix) ? descendingDirMix : ascendingDirMix;
        }
    }
    else
    {
        if (getIgnoreCase() == true)
        {
            sortfunc = (sortfunc == ascendingDirCase) ? descendingDirCase : ascendingDirCase;
        }
        else
        {
            sortfunc = (sortfunc == ascendingDir) ? descendingDir : ascendingDir;
        }
    }
    scan(true);
    return(1);
}


// Update sender
long FileList::onUpdSortByDirName(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (sortfunc == ascendingDir || sortfunc == descendingDir || sortfunc == ascendingDirCase || sortfunc == descendingDirCase ||
                          sortfunc == ascendingDirMix || sortfunc == descendingDirMix || sortfunc == ascendingDirCaseMix || sortfunc == descendingDirCaseMix) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    return(1);
}


// Sort by type
long FileList::onCmdSortByType(FXObject*, FXSelector, void*)
{
    if (dirsfirst == false)
    {
        sortfunc = (sortfunc == ascendingTypeMix) ? descendingTypeMix : ascendingTypeMix;
    }
    else
    {
        sortfunc = (sortfunc == ascendingType) ? descendingType : ascendingType;
    }

    if (options&_FILELIST_SEARCH)
    {
        setSortHeader(3);
    }
    else
    {
        setSortHeader(2);
    }

    scan(true);
    return(1);
}


// Update sender
long FileList::onUpdSortByType(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (sortfunc == ascendingType || sortfunc == descendingType || sortfunc == ascendingTypeMix || sortfunc == descendingTypeMix) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    return(1);
}


// Sort by size
long FileList::onCmdSortBySize(FXObject*, FXSelector, void*)
{
    if (dirsfirst == false)
    {
        sortfunc = (sortfunc == ascendingSizeMix) ? descendingSizeMix : ascendingSizeMix;
    }
    else
    {
        sortfunc = (sortfunc == ascendingSize) ? descendingSize : ascendingSize;
    }

    if (options&_FILELIST_SEARCH)
    {
        setSortHeader(2);
    }
    else
    {
        setSortHeader(1);
    }

    scan(true);
    return(1);
}


// Update sender
long FileList::onUpdSortBySize(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (sortfunc == ascendingSize || sortfunc == descendingSize || sortfunc == ascendingSizeMix || sortfunc == descendingSizeMix) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    return(1);
}


// Sort by ext
long FileList::onCmdSortByExt(FXObject*, FXSelector, void*)
{
    if (dirsfirst == false)
    {
        sortfunc = (sortfunc == ascendingExtMix) ? descendingExtMix : ascendingExtMix;
    }
    else
    {
        sortfunc = (sortfunc == ascendingExt) ? descendingExt : ascendingExt;
    }

    if (options&_FILELIST_SEARCH)
    {
        setSortHeader(4);
    }
    else
    {
        setSortHeader(3);
    }

    scan(true);
    return(1);
}


// Sort by original path
long FileList::onCmdSortByOrigpath(FXObject*, FXSelector, void*)
{
    if (dirsfirst == false)
    {
        sortfunc = (sortfunc == ascendingOrigpathMix) ? descendingOrigpathMix : ascendingOrigpathMix;
    }
    else
    {
        sortfunc = (sortfunc == ascendingOrigpath) ? descendingOrigpath : ascendingOrigpath;
    }

    setSortHeader(8);

    scan(true);
    return(1);
}


// Sort by deletion time
long FileList::onCmdSortByDeltime(FXObject*, FXSelector, void*)
{
    if (dirsfirst == false)
    {
        sortfunc = (sortfunc == ascendingDeltimeMix) ? descendingDeltimeMix : ascendingDeltimeMix;
    }
    else
    {
        sortfunc = (sortfunc == ascendingDeltime) ? descendingDeltime : ascendingDeltime;
    }

    setSortHeader(9);

    scan(true);
    return(1);
}


// Update sender
long FileList::onUpdSortByExt(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (sortfunc == ascendingExt || sortfunc == descendingExt || sortfunc == ascendingExtMix || sortfunc == descendingExtMix) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    return(1);
}


// Sort by time
long FileList::onCmdSortByTime(FXObject*, FXSelector, void*)
{
    if (dirsfirst == false)
    {
        sortfunc = (sortfunc == ascendingTimeMix) ? descendingTimeMix : ascendingTimeMix;
    }
    else
    {
        sortfunc = (sortfunc == ascendingTime) ? descendingTime : ascendingTime;
    }

    if (options&_FILELIST_SEARCH)
    {
        setSortHeader(5);
    }
    else
    {
        setSortHeader(4);
    }

    scan(true);
    return(1);
}


// Update sender
long FileList::onUpdSortByTime(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (sortfunc == ascendingTime || sortfunc == descendingTime || sortfunc == ascendingTimeMix || sortfunc == descendingTimeMix) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    return(1);
}


// Sort by user
long FileList::onCmdSortByUser(FXObject*, FXSelector, void*)
{
    if (dirsfirst == false)
    {
        sortfunc = (sortfunc == ascendingUserMix) ? descendingUserMix : ascendingUserMix;
    }
    else
    {
        sortfunc = (sortfunc == ascendingUser) ? descendingUser : ascendingUser;
    }

    if (options&_FILELIST_SEARCH)
    {
        setSortHeader(6);
    }
    else
    {
        setSortHeader(5);
    }

    scan(true);
    return(1);
}


// Update sender
long FileList::onUpdSortByUser(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (sortfunc == ascendingUser || sortfunc == descendingUser || sortfunc == ascendingUserMix || sortfunc == descendingUserMix) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    return(1);
}


// Sort by group
long FileList::onCmdSortByGroup(FXObject*, FXSelector, void*)
{
    if (dirsfirst == false)
    {
        sortfunc = (sortfunc == ascendingGroupMix) ? descendingGroupMix : ascendingGroupMix;
    }
    else
    {
        sortfunc = (sortfunc == ascendingGroup) ? descendingGroup : ascendingGroup;
    }

    if (options&_FILELIST_SEARCH)
    {
        setSortHeader(7);
    }
    else
    {
        setSortHeader(6);
    }

    scan(true);
    return(1);
}


// Update sender
long FileList::onUpdSortByGroup(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (sortfunc == ascendingGroup || sortfunc == descendingGroup || sortfunc == ascendingGroupMix || sortfunc == descendingGroupMix) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    return(1);
}


// Sort by permissions
long FileList::onCmdSortByPerm(FXObject*, FXSelector, void*)
{
    if (dirsfirst == false)
    {
        sortfunc = (sortfunc == ascendingPermMix) ? descendingPermMix : ascendingPermMix;
    }
    else
    {
        sortfunc = (sortfunc == ascendingPerm) ? descendingPerm : ascendingPerm;
    }

    if (options&_FILELIST_SEARCH)
    {
        setSortHeader(8);
    }
    else
    {
        setSortHeader(7);
    }

    scan(true);
    return(1);
}


// Update sender
long FileList::onUpdSortByPerm(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (sortfunc == ascendingPerm || sortfunc == descendingPerm || sortfunc == ascendingPermMix || sortfunc == descendingPermMix) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    return(1);
}


// Update sender
long FileList::onUpdSortByDeltime(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (sortfunc == ascendingDeltime || sortfunc == descendingDeltime || sortfunc == ascendingDeltimeMix || sortfunc == descendingDeltimeMix) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);

    if (!(options&_FILELIST_SEARCH) && (getNumHeaders() == NB_HEADERS+2))
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update sender
long FileList::onUpdSortByOrigpath(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (sortfunc == ascendingOrigpath || sortfunc == descendingOrigpath || sortfunc == ascendingOrigpathMix || sortfunc == descendingOrigpathMix) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);

    if (!(options&_FILELIST_SEARCH) && (getNumHeaders() == NB_HEADERS+2))
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Reverse sort order
long FileList::onCmdSortReverse(FXObject*, FXSelector, void*)
{
    if (sortfunc == ascending)
    {
        sortfunc = descending;
    }

    else if (sortfunc == ascendingMix)
    {
        sortfunc = descendingMix;
    }

    else if (sortfunc == descending)
    {
        sortfunc = ascending;
    }

    else if (sortfunc == descendingMix)
    {
        sortfunc = ascendingMix;
    }

    else if (sortfunc == ascendingCase)
    {
        sortfunc = descendingCase;
    }

    else if (sortfunc == ascendingCaseMix)
    {
        sortfunc = descendingCaseMix;
    }

    else if (sortfunc == descendingCase)
    {
        sortfunc = ascendingCase;
    }

    else if (sortfunc == descendingCaseMix)
    {
        sortfunc = ascendingCaseMix;
    }

    else if (sortfunc == ascendingType)
    {
        sortfunc = descendingType;
    }

    else if (sortfunc == ascendingTypeMix)
    {
        sortfunc = descendingTypeMix;
    }

    else if (sortfunc == descendingType)
    {
        sortfunc = ascendingType;
    }

    else if (sortfunc == descendingTypeMix)
    {
        sortfunc = ascendingTypeMix;
    }

    else if (sortfunc == ascendingExt)
    {
        sortfunc = descendingExt;
    }

    else if (sortfunc == ascendingExtMix)
    {
        sortfunc = descendingExtMix;
    }

    else if (sortfunc == descendingExt)
    {
        sortfunc = ascendingExt;
    }

    else if (sortfunc == descendingExtMix)
    {
        sortfunc = ascendingExtMix;
    }

    else if (sortfunc == ascendingSize)
    {
        sortfunc = descendingSize;
    }

    else if (sortfunc == ascendingSizeMix)
    {
        sortfunc = descendingSizeMix;
    }

    else if (sortfunc == descendingSize)
    {
        sortfunc = ascendingSize;
    }

    else if (sortfunc == descendingSizeMix)
    {
        sortfunc = ascendingSizeMix;
    }

    else if (sortfunc == ascendingTime)
    {
        sortfunc = descendingTime;
    }

    else if (sortfunc == ascendingTimeMix)
    {
        sortfunc = descendingTimeMix;
    }

    else if (sortfunc == descendingTime)
    {
        sortfunc = ascendingTime;
    }

    else if (sortfunc == descendingTimeMix)
    {
        sortfunc = ascendingTimeMix;
    }

    else if (sortfunc == ascendingUserMix)
    {
        sortfunc = descendingUser;
    }

    else if (sortfunc == ascendingUserMix)
    {
        sortfunc = descendingUser;
    }

    else if (sortfunc == descendingUser)
    {
        sortfunc = ascendingUser;
    }

    else if (sortfunc == descendingUserMix)
    {
        sortfunc = ascendingUserMix;
    }

    else if (sortfunc == ascendingGroup)
    {
        sortfunc = descendingGroup;
    }

    else if (sortfunc == ascendingGroupMix)
    {
        sortfunc = descendingGroupMix;
    }

    else if (sortfunc == descendingGroup)
    {
        sortfunc = ascendingGroup;
    }

    else if (sortfunc == descendingGroupMix)
    {
        sortfunc = ascendingGroupMix;
    }

    else if (sortfunc == ascendingPerm)
    {
        sortfunc = descendingPerm;
    }

    else if (sortfunc == ascendingPermMix)
    {
        sortfunc = descendingPermMix;
    }

    else if (sortfunc == descendingPerm)
    {
        sortfunc = ascendingPerm;
    }

    else if (sortfunc == descendingPermMix)
    {
        sortfunc = ascendingPermMix;
    }

    else if (sortfunc == ascendingDir)
    {
        sortfunc = descendingDir;
    }

    else if (sortfunc == ascendingDirMix)
    {
        sortfunc = descendingDirMix;
    }

    else if (sortfunc == descendingDir)
    {
        sortfunc = ascendingDir;
    }

    else if (sortfunc == descendingDirMix)
    {
        sortfunc = ascendingDirMix;
    }

    else if (sortfunc == ascendingDirCase)
    {
        sortfunc = descendingDirCase;
    }

    else if (sortfunc == ascendingDirCaseMix)
    {
        sortfunc = descendingDirCaseMix;
    }

    else if (sortfunc == descendingDirCase)
    {
        sortfunc = ascendingDirCase;
    }

    else if (sortfunc == descendingDirCaseMix)
    {
        sortfunc = ascendingDirCaseMix;
    }

    else if (sortfunc == ascendingOrigpath)
    {
        sortfunc = descendingOrigpath;
    }

    else if (sortfunc == ascendingOrigpathMix)
    {
        sortfunc = descendingOrigpathMix;
    }

    else if (sortfunc == descendingOrigpath)
    {
        sortfunc = ascendingOrigpath;
    }

    else if (sortfunc == descendingOrigpathMix)
    {
        sortfunc = ascendingOrigpathMix;
    }

    else if (sortfunc == ascendingDeltime)
    {
        sortfunc = descendingDeltime;
    }

    else if (sortfunc == ascendingDeltimeMix)
    {
        sortfunc = descendingDeltimeMix;
    }

    else if (sortfunc == descendingDeltime)
    {
        sortfunc = ascendingDeltime;
    }

    else if (sortfunc == descendingDeltimeMix)
    {
        sortfunc = ascendingDeltimeMix;
    }

    scan(true);
    return(1);
}


// Update sender
long FileList::onUpdSortReverse(FXObject* sender, FXSelector, void*)
{
    FXSelector selector = FXSEL(SEL_COMMAND, ID_UNCHECK);

    if (sortfunc == descending)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingMix)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingCase)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingCaseMix)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingType)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingTypeMix)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingExt)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingExtMix)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingSize)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingSizeMix)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingTime)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingTimeMix)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingUser)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingUserMix)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingGroup)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingGroupMix)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingPerm)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingPermMix)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingDir)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingDirMix)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingDirCase)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingDirCaseMix)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingOrigpath)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingOrigpathMix)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingDeltime)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    else if (sortfunc == descendingDeltimeMix)
    {
        selector = FXSEL(SEL_COMMAND, ID_CHECK);
    }

    sender->handle(this, selector, NULL);

    return(1);
}


// Toggle case sensitivity
long FileList::onCmdSortCase(FXObject*, FXSelector, void*)
{
    setIgnoreCase(!getIgnoreCase());
    if (dirsfirst == false)
    {
        if (getIgnoreCase() == true)
        {
            if ((sortfunc == ascending) || (sortfunc == ascendingMix) || (sortfunc == ascendingCase))
            {
                sortfunc = ascendingCaseMix;
            }

            else if ((sortfunc == descending) || (sortfunc == descendingMix) || (sortfunc == descendingCase))
            {
                sortfunc = descendingCaseMix;
            }

            else if ((sortfunc == ascendingDir) || (sortfunc == ascendingDirMix) || (sortfunc == ascendingDirCase))
            {
                sortfunc = ascendingDirCaseMix;
            }

            else if ((sortfunc == descendingDir) || (sortfunc == descendingDirMix) || (sortfunc == descendingDirCase))
            {
                sortfunc = descendingDirCaseMix;
            }
        }
        else
        {
            if ((sortfunc == ascending) || (sortfunc == ascendingCase) || (sortfunc == ascendingCaseMix))
            {
                sortfunc = ascendingMix;
            }

            else if ((sortfunc == descending) || (sortfunc == descendingCase) || (sortfunc == descendingCaseMix))
            {
                sortfunc = descendingMix;
            }

            else if ((sortfunc == ascendingDir) || (sortfunc == ascendingDirCase) || (sortfunc == ascendingDirCaseMix))
            {
                sortfunc = ascendingDirMix;
            }

            else if ((sortfunc == descendingDir) || (sortfunc == descendingDirCase) || (sortfunc == descendingDirCaseMix))
            {
                sortfunc = descendingDirMix;
            }
        }
    }
    else
    {
        if (getIgnoreCase() == true)
        {
            if ((sortfunc == ascending) || (sortfunc == ascendingMix) || (sortfunc == ascendingCaseMix))
            {
                sortfunc = ascendingCase;
            }

            else if ((sortfunc == descending) || (sortfunc == descendingMix) || (sortfunc == descendingCaseMix))
            {
                sortfunc = descendingCase;
            }

            else if ((sortfunc == ascendingDir) || (sortfunc == ascendingDirMix) || (sortfunc == ascendingDirCaseMix))
            {
                sortfunc = ascendingDirCase;
            }

            else if ((sortfunc == descendingDir) || (sortfunc == descendingDirMix) || (sortfunc == descendingDirCaseMix))
            {
                sortfunc = descendingDirCase;
            }
        }
        else
        {
            if ((sortfunc == ascendingMix) || (sortfunc == ascendingCase) || (sortfunc == ascendingCaseMix))
            {
                sortfunc = ascending;
            }

            else if ((sortfunc == descendingMix) || (sortfunc == descendingCase) || (sortfunc == descendingCaseMix))
            {
                sortfunc = descending;
            }

            else if ((sortfunc == ascendingDirMix) || (sortfunc == ascendingDirCase) || (sortfunc == ascendingDirCaseMix))
            {
                sortfunc = ascendingDir;
            }

            else if ((sortfunc == descendingDirMix) || (sortfunc == descendingDirCase) || (sortfunc == descendingDirCaseMix))
            {
                sortfunc = descendingDir;
            }
        }
    }
    scan(true);
    return(1);
}


// Update case sensitivity
long FileList::onUpdSortCase(FXObject* sender, FXSelector, void* ptr)
{
    if ((sortfunc == ascending) || (sortfunc == descending) || (sortfunc == ascendingMix) || (sortfunc == descendingMix) ||
        (sortfunc == ascendingCase) || (sortfunc == descendingCase) || (sortfunc == ascendingCaseMix) || (sortfunc == descendingCaseMix))
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), ptr);

        if (getIgnoreCase() == true)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), ptr);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), ptr);
        }
    }
    else if ((sortfunc == ascendingDir) || (sortfunc == descendingDir) || (sortfunc == ascendingDirMix) || (sortfunc == descendingDirMix) ||
             (sortfunc == ascendingDirCase) || (sortfunc == descendingDirCase) || (sortfunc == ascendingDirCaseMix) || (sortfunc == descendingDirCaseMix))
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), ptr);

        if (getIgnoreCase() == true)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), ptr);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), ptr);
        }
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), ptr);
    }

    return(1);
}


// Toggle directories first
long FileList::onCmdDirsFirst(FXObject*, FXSelector, void*)
{
    dirsfirst = !dirsfirst;
    if (dirsfirst == false)
    {
        if (sortfunc == ascending)
        {
            sortfunc = ascendingMix;
        }

        else if (sortfunc == descending)
        {
            sortfunc = descendingMix;
        }

        else if (sortfunc == ascendingCase)
        {
            sortfunc = ascendingCaseMix;
        }

        else if (sortfunc == descendingCase)
        {
            sortfunc = descendingCaseMix;
        }

        else if (sortfunc == ascendingType)
        {
            sortfunc = ascendingTypeMix;
        }

        else if (sortfunc == descendingType)
        {
            sortfunc = descendingTypeMix;
        }

        else if (sortfunc == ascendingExt)
        {
            sortfunc = ascendingExtMix;
        }

        else if (sortfunc == descendingExt)
        {
            sortfunc = descendingExtMix;
        }

        else if (sortfunc == ascendingSize)
        {
            sortfunc = ascendingSizeMix;
        }

        else if (sortfunc == descendingSize)
        {
            sortfunc = descendingSizeMix;
        }

        else if (sortfunc == ascendingTime)
        {
            sortfunc = ascendingTimeMix;
        }

        else if (sortfunc == descendingTime)
        {
            sortfunc = descendingTimeMix;
        }

        else if (sortfunc == ascendingUser)
        {
            sortfunc = ascendingUserMix;
        }

        else if (sortfunc == descendingUser)
        {
            sortfunc = descendingUserMix;
        }

        else if (sortfunc == ascendingGroup)
        {
            sortfunc = ascendingGroupMix;
        }

        else if (sortfunc == descendingGroup)
        {
            sortfunc = descendingGroupMix;
        }

        else if (sortfunc == ascendingPerm)
        {
            sortfunc = ascendingPermMix;
        }

        else if (sortfunc == descendingPerm)
        {
            sortfunc = descendingPermMix;
        }

        else if (sortfunc == ascendingDir)
        {
            sortfunc = ascendingDirMix;
        }

        else if (sortfunc == descendingDir)
        {
            sortfunc = descendingDirMix;
        }

        else if (sortfunc == ascendingDirCase)
        {
            sortfunc = ascendingDirCaseMix;
        }

        else if (sortfunc == descendingDirCase)
        {
            sortfunc = descendingDirCaseMix;
        }

        else if (sortfunc == ascendingOrigpath)
        {
            sortfunc = ascendingOrigpathMix;
        }

        else if (sortfunc == descendingOrigpath)
        {
            sortfunc = descendingOrigpathMix;
        }

        else if (sortfunc == ascendingDeltime)
        {
            sortfunc = ascendingDeltimeMix;
        }

        else if (sortfunc == descendingDeltime)
        {
            sortfunc = descendingDeltimeMix;
        }
    }
    else
    {
        if (sortfunc == ascendingMix)
        {
            sortfunc = ascending;
        }

        else if (sortfunc == descendingMix)
        {
            sortfunc = descending;
        }

        else if (sortfunc == ascendingCaseMix)
        {
            sortfunc = ascendingCase;
        }

        else if (sortfunc == descendingCaseMix)
        {
            sortfunc = descendingCase;
        }

        else if (sortfunc == ascendingTypeMix)
        {
            sortfunc = ascendingType;
        }

        else if (sortfunc == descendingTypeMix)
        {
            sortfunc = descendingType;
        }

        else if (sortfunc == ascendingExtMix)
        {
            sortfunc = ascendingExt;
        }

        else if (sortfunc == descendingExtMix)
        {
            sortfunc = descendingExt;
        }

        else if (sortfunc == ascendingSizeMix)
        {
            sortfunc = ascendingSize;
        }

        else if (sortfunc == descendingSizeMix)
        {
            sortfunc = descendingSize;
        }

        else if (sortfunc == ascendingTimeMix)
        {
            sortfunc = ascendingTime;
        }

        else if (sortfunc == descendingTimeMix)
        {
            sortfunc = descendingTime;
        }

        else if (sortfunc == ascendingUserMix)
        {
            sortfunc = ascendingUser;
        }

        else if (sortfunc == descendingUserMix)
        {
            sortfunc = descendingUser;
        }

        else if (sortfunc == ascendingGroupMix)
        {
            sortfunc = ascendingGroup;
        }

        else if (sortfunc == descendingGroupMix)
        {
            sortfunc = descendingGroup;
        }

        else if (sortfunc == ascendingPermMix)
        {
            sortfunc = ascendingPerm;
        }

        else if (sortfunc == descendingPermMix)
        {
            sortfunc = descendingPerm;
        }

        else if (sortfunc == ascendingDirMix)
        {
            sortfunc = ascendingDir;
        }

        else if (sortfunc == descendingDirMix)
        {
            sortfunc = descendingDir;
        }

        else if (sortfunc == ascendingDirCaseMix)
        {
            sortfunc = ascendingDirCase;
        }

        else if (sortfunc == descendingDirCaseMix)
        {
            sortfunc = descendingDirCase;
        }

        else if (sortfunc == ascendingOrigpathMix)
        {
            sortfunc = ascendingOrigpath;
        }

        else if (sortfunc == descendingOrigpathMix)
        {
            sortfunc = descendingOrigpath;
        }

        else if (sortfunc == ascendingDeltimeMix)
        {
            sortfunc = ascendingDeltime;
        }

        else if (sortfunc == descendingDeltimeMix)
        {
            sortfunc = descendingDeltime;
        }
    }
    scan(true);
    return(1);
}


// Update directories first
long FileList::onUpdDirsFirst(FXObject* sender, FXSelector, void* ptr)
{
    if (dirsfirst == true)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), ptr);
    }

    return(1);
}


// Clicked header button
long FileList::onCmdHeader(FXObject*, FXSelector, void* ptr)
{
    // List is a search list (a directory name column is inserted between name and file size)
    if (options&_FILELIST_SEARCH)
    {
        FXuint num = (FXuint)(FXuval)ptr;
        if (num < NB_HEADERS+1)
        {
            if (num == 0)
            {
                handle(this, FXSEL(SEL_COMMAND, ID_SORT_BY_NAME), NULL);
            }
            else if (num == 1)
            {
                handle(this, FXSEL(SEL_COMMAND, ID_SORT_BY_DIRNAME), NULL);
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, (ID_SORT_BY_NAME+num-1)), NULL);
            }

            setSortHeader(num);
        }
        if (getHeaderSize(0) < MIN_NAME_SIZE)
        {
            setHeaderSize(0, MIN_NAME_SIZE);
        }
    }

    // List is a file list
    else
    {
        FXuint num = (FXuint)(FXuval)ptr;

        // Deletion date and original path columns are displayed
        if (getNumHeaders() == NB_HEADERS+2)
        {
            if (num < NB_HEADERS+2)
            {
                handle(this, FXSEL(SEL_COMMAND, (ID_SORT_BY_NAME+num)), NULL);
                setSortHeader(num);
            }
        }

        // Standard case
        else
        {
            if (num < NB_HEADERS)
            {
                handle(this, FXSEL(SEL_COMMAND, (ID_SORT_BY_NAME+num)), NULL);
                setSortHeader(num);
            }
        }
        if (getHeaderSize(0) < MIN_NAME_SIZE)
        {
            setHeaderSize(0, MIN_NAME_SIZE);
        }
    }
    return(1);
}


// Update header button
long FileList::onUpdHeader(FXObject*, FXSelector, void*)
{
    // List is a search list (a directory name column is inserted between name and file size)
    if (options&_FILELIST_SEARCH)
    {
        header->setArrowDir(0, (sortfunc == ascending || sortfunc == ascendingCase ||
                                sortfunc == ascendingMix || sortfunc == ascendingCaseMix)  ? false : (sortfunc == descending || sortfunc == descendingCase ||
                                                                                                      sortfunc == descendingMix || sortfunc == descendingCaseMix) ? true : MAYBE);         // Name

        header->setArrowDir(1, (sortfunc == ascendingDir || sortfunc == ascendingDirCase ||
                                sortfunc == ascendingDirMix || sortfunc == ascendingDirCaseMix)  ? false : (sortfunc == descendingDir || sortfunc == descendingDirCase ||
                                                                                                            sortfunc == descendingDirMix || sortfunc == descendingDirCaseMix) ? true : MAYBE); // Name

        header->setArrowDir(2, (sortfunc == ascendingSize || sortfunc == ascendingSizeMix)  ? false : (sortfunc == descendingSize || sortfunc == descendingSizeMix) ? true : MAYBE);           // Size
        header->setArrowDir(3, (sortfunc == ascendingType || sortfunc == ascendingTypeMix)  ? false : (sortfunc == descendingType || sortfunc == descendingTypeMix) ? true : MAYBE);           // Type
        header->setArrowDir(4, (sortfunc == ascendingExt || sortfunc == ascendingExtMix)   ? false : (sortfunc == descendingExt || sortfunc == descendingExtMix)  ? true : MAYBE);             // Extension
        header->setArrowDir(5, (sortfunc == ascendingTime || sortfunc == ascendingTimeMix)  ? false : (sortfunc == descendingTime || sortfunc == descendingTimeMix) ? true : MAYBE);           // Date
        header->setArrowDir(6, (sortfunc == ascendingUser || sortfunc == ascendingUserMix)  ? false : (sortfunc == descendingUser || sortfunc == descendingUserMix) ? true : MAYBE);           // User
        header->setArrowDir(7, (sortfunc == ascendingGroup || sortfunc == ascendingGroupMix) ? false : (sortfunc == descendingGroup || sortfunc == descendingGroupMix) ? true : MAYBE);        // Group
        header->setArrowDir(8, (sortfunc == ascendingPerm || sortfunc == ascendingPermMix)  ? false : (sortfunc == descendingPerm || sortfunc == descendingPermMix) ? true : MAYBE);           // Permissions
        if (getHeaderSize(0) < MIN_NAME_SIZE)
        {
            setHeaderSize(0, MIN_NAME_SIZE);
        }

        if ((sortfunc == ascending) || (sortfunc == ascendingCase) || (sortfunc == ascendingMix) || (sortfunc == ascendingCaseMix) || (sortfunc == descending) || (sortfunc == descendingCase) || (sortfunc == descendingMix) || (sortfunc == descendingCaseMix))
        {
            setSortHeader(0);
        }
        else if ((sortfunc == ascendingDir) || (sortfunc == ascendingDirCase) || (sortfunc == ascendingDirMix) || (sortfunc == ascendingDirCaseMix) || (sortfunc == descendingDir) || (sortfunc == descendingDirCase) || (sortfunc == descendingDirMix) || (sortfunc == descendingDirCaseMix))
        {
            setSortHeader(1);
        }
        else if ((sortfunc == ascendingSize) || (sortfunc == ascendingSizeMix) || (sortfunc == descendingSize) || (sortfunc == descendingSizeMix))
        {
            setSortHeader(2);
        }
        else if ((sortfunc == ascendingType) || (sortfunc == ascendingTypeMix) || (sortfunc == descendingType) || (sortfunc == descendingTypeMix))
        {
            setSortHeader(3);
        }
        else if ((sortfunc == ascendingExt) || (sortfunc == ascendingExtMix) || (sortfunc == descendingExt) || (sortfunc == descendingExtMix))
        {
            setSortHeader(4);
        }
        else if ((sortfunc == ascendingTime) || (sortfunc == ascendingTimeMix) || (sortfunc == descendingTime) || (sortfunc == descendingTimeMix))
        {
            setSortHeader(5);
        }
        else if ((sortfunc == ascendingUser) || (sortfunc == ascendingUserMix) || (sortfunc == descendingUser) || (sortfunc == descendingUserMix))
        {
            setSortHeader(6);
        }
        else if ((sortfunc == ascendingGroup) || (sortfunc == ascendingGroupMix) || (sortfunc == descendingGroup) || (sortfunc == descendingGroupMix))
        {
            setSortHeader(7);
        }
        else if ((sortfunc == ascendingPerm) || (sortfunc == ascendingPermMix) || (sortfunc == descendingPerm) || (sortfunc == descendingPermMix))
        {
            setSortHeader(8);
        }
    }

    // List is a file list
    else
    {
        header->setArrowDir(0, (sortfunc == ascending || sortfunc == ascendingCase ||
                                sortfunc == ascendingMix || sortfunc == ascendingCaseMix)  ? false : (sortfunc == descending || sortfunc == descendingCase ||
                                                                                                      sortfunc == descendingMix || sortfunc == descendingCaseMix) ? true : MAYBE);      // Name
        header->setArrowDir(1, (sortfunc == ascendingSize || sortfunc == ascendingSizeMix)  ? false : (sortfunc == descendingSize || sortfunc == descendingSizeMix) ? true : MAYBE);    // Size
        header->setArrowDir(2, (sortfunc == ascendingType || sortfunc == ascendingTypeMix)  ? false : (sortfunc == descendingType || sortfunc == descendingTypeMix) ? true : MAYBE);    // Type
        header->setArrowDir(3, (sortfunc == ascendingExt || sortfunc == ascendingExtMix)   ? false : (sortfunc == descendingExt || sortfunc == descendingExtMix)  ? true : MAYBE);      // Extension
        header->setArrowDir(4, (sortfunc == ascendingTime || sortfunc == ascendingTimeMix)  ? false : (sortfunc == descendingTime || sortfunc == descendingTimeMix) ? true : MAYBE);    // Date
        header->setArrowDir(5, (sortfunc == ascendingUser || sortfunc == ascendingUserMix)  ? false : (sortfunc == descendingUser || sortfunc == descendingUserMix) ? true : MAYBE);    // User
        header->setArrowDir(6, (sortfunc == ascendingGroup || sortfunc == ascendingGroupMix) ? false : (sortfunc == descendingGroup || sortfunc == descendingGroupMix) ? true : MAYBE); // Group
        header->setArrowDir(7, (sortfunc == ascendingPerm || sortfunc == ascendingPermMix)  ? false : (sortfunc == descendingPerm || sortfunc == descendingPermMix) ? true : MAYBE);    // Permissions
        if (getNumHeaders() == NB_HEADERS+2)
        {
            header->setArrowDir(8, (sortfunc == ascendingOrigpath || sortfunc == ascendingOrigpathMix) ? false : (sortfunc == descendingOrigpath || sortfunc == descendingOrigpathMix) ? true : MAYBE);   // Original path
            origpathsize = header->getItemSize(NB_HEADERS);

            header->setArrowDir(9, (sortfunc == ascendingDeltime || sortfunc == ascendingDeltimeMix) ? false : (sortfunc == descendingDeltime || sortfunc == descendingDeltimeMix) ? true : MAYBE);   // Deletion date
            deldatesize = header->getItemSize(NB_HEADERS+1);
        }
        if (getHeaderSize(0) < MIN_NAME_SIZE)
        {
            setHeaderSize(0, MIN_NAME_SIZE);
        }

        if ((sortfunc == ascending) || (sortfunc == ascendingCase) || (sortfunc == ascendingMix) || (sortfunc == ascendingCaseMix) || (sortfunc == descending) || (sortfunc == descendingCase) || (sortfunc == descendingMix) || (sortfunc == descendingCaseMix))
        {
            setSortHeader(0);
        }
        else if ((sortfunc == ascendingSize) || (sortfunc == ascendingSizeMix) || (sortfunc == descendingSize) || (sortfunc == descendingSizeMix))
        {
            setSortHeader(1);
        }
        else if ((sortfunc == ascendingType) || (sortfunc == ascendingTypeMix) || (sortfunc == descendingType) || (sortfunc == descendingTypeMix))
        {
            setSortHeader(2);
        }
        else if ((sortfunc == ascendingExt) || (sortfunc == ascendingExtMix) || (sortfunc == descendingExt) || (sortfunc == descendingExtMix))
        {
            setSortHeader(3);
        }
        else if ((sortfunc == ascendingTime) || (sortfunc == ascendingTimeMix) || (sortfunc == descendingTime) || (sortfunc == descendingTimeMix))
        {
            setSortHeader(4);
        }
        else if ((sortfunc == ascendingUser) || (sortfunc == ascendingUserMix) || (sortfunc == descendingUser) || (sortfunc == descendingUserMix))
        {
            setSortHeader(5);
        }
        else if ((sortfunc == ascendingGroup) || (sortfunc == ascendingGroupMix) || (sortfunc == descendingGroup) || (sortfunc == descendingGroupMix))
        {
            setSortHeader(6);
        }
        else if ((sortfunc == ascendingPerm) || (sortfunc == ascendingPermMix) || (sortfunc == descendingPerm) || (sortfunc == descendingPermMix))
        {
            setSortHeader(7);
        }
        else if ((sortfunc == ascendingOrigpath) || (sortfunc == ascendingOrigpathMix) || (sortfunc == descendingOrigpath) || (sortfunc == descendingOrigpathMix))
        {
            setSortHeader(8);
        }
        else if ((sortfunc == ascendingDeltime) || (sortfunc == ascendingDeltimeMix) || (sortfunc == descendingDeltime) || (sortfunc == descendingDeltimeMix))
        {
            setSortHeader(9);
        }
    }
    return(1);
}


/**
 * Compares fields of p and q, supposing they are single byte strings
 * without using the current locale.
 * @param  igncase	Ignore upper/lower-case?
 * @param  asc		Ascending?  If false is descending order
 * @param  jmp		Field to compare (separated with \t)
 *
 * @return 0 if equal, negative if p<q, positive if p>q
 * If jmp has an invalid value returns 0 and errno will be EINVAL
 */
static inline int compare_nolocale(char* p, char* q, FXbool igncase, FXbool asc, FXuint jmp)
{
    int retnames, ret = 0, i;

    // Compare names

    register char* pp = p;
    register char* qq = q;

    // Go to next '\t' or '\0'
    while (*pp != '\0' && *pp > '\t')
    {
        pp++;
    }

    while (*qq != '\0' && *qq > '\t')
    {
        qq++;
    }

    // Save characters at current position
    register char pw = *pp;
    register char qw = *qq;

    // Set characters to null, to stop comparison
    *pp = '\0';
    *qq = '\0';

    // Compare strings
    retnames = comparenat(p, q, igncase);

    // Restore saved characters
    *pp = pw;
    *qq = qw;

    if (jmp == 0)
    {
        ret = retnames;
        goto end;
    }

    // Compare other fields
    // Find where to start comparison
    if (jmp == 1)
    {
        for (i = 1; *pp && i; i -= (*pp++ == '\t'))
        {
        }
        for (i = 1; *qq && i; i -= (*qq++ == '\t'))
        {
        }
    }

    else if ((jmp > 1) && (jmp < 8))
    {
        // 2->type, 3->ext, 5->user, 6->group, 7->perm,
        // Adjust the header index depending on the list type
        if (pp[1] == '/')
        {
            for (i = jmp + 1; *pp && i; i -= (*pp++ == '\t'))
            {
            }
            for (i = jmp + 1; *qq && i; i -= (*qq++ == '\t'))
            {
            }
        }
        else
        {
            for (i = jmp; *pp && i; i -= (*pp++ == '\t'))
            {
            }
            for (i = jmp; *qq && i; i -= (*qq++ == '\t'))
            {
            }
        }
    }
    else if (jmp == 8)
    {
        for (i = 8; *pp && i; i -= (*pp++ == '\t'))
        {
        }
        for (i = 8; *qq && i; i -= (*qq++ == '\t'))
        {
        }
    }
    else
    {
        errno = EINVAL;
        return(0);
    }

    // This part between brackets to make the compiler happy!
    {
        register char* sp = pp;
        register char* sq = qq;

        // Find where to stop comparison
        while (*pp != '\0' && *pp > '\t')
        {
            pp++;
        }

        while (*qq != '\0' && *qq > '\t')
        {
            qq++;
        }

        // Save characters at current position
        pw = *pp;
        qw = *qq;

        // Set characters to null, to stop comparison
        *pp = '\0';
        *qq = '\0';

        // Compare wide strings
        ret = comparenat(sp, sq, igncase);

        // Restore saved characters
        *pp = pw;
        *qq = qw;

        if (ret == 0)
        {
            ret = retnames;
        }
    }

end:

    // If descending flip
    if (!asc)
    {
        ret = ret * -1;
    }

    return(ret);
}


/**
 * Compares fields of p and q, supposing they are wide strings
 * and using the current locale.
 * @param  igncase	Ignore upper/lower-case?
 * @param  asc		Ascending?  If false is descending order
 * @param  jmp		Field to compare (separated with \t)
 *
 * @return 0 if equal, negative if p<q, positive if p>q
 * If jmp has an invalid value returns 0 and errno will be EINVAL
 */
static inline int compare_locale(wchar_t* p, wchar_t* q, FXbool igncase, FXbool asc, int jmp)
{
    int retnames, ret = 0, i;

    // Compare names

    register wchar_t* pp = p;
    register wchar_t* qq = q;

    // Go to next '\t' or '\0'
    while (*pp != '\0' && *pp > '\t')
    {
        pp++;
    }

    while (*qq != '\0' && *qq > '\t')
    {
        qq++;
    }

    // Save characters at current position
    register wchar_t pw = *pp;
    register wchar_t qw = *qq;

    // Set characters to null, to stop comparison
    *pp = '\0';
    *qq = '\0';

    // Compare wide strings
    retnames = comparewnat(p, q, igncase);

    // Restore saved characters
    *pp = pw;
    *qq = qw;

    if (jmp == 0)
    {
        ret = retnames;
        goto end;
    }

    // Compare other fields
    // Find where to start comparison
    if (jmp == 1)
    {
/*        for (i = 1; *pp && i; i -= (*pp++ == '\t'))
        {
        }
        for (i = 1; *qq && i; i -= (*qq++ == '\t'))
        {
        }*/
    }

/*    else if ((jmp > 1) && (jmp < 8))
    {
        // 2->type, 3->ext, 5->user, 6->group, 7->perm,
        // Adjust the header index depending on the list type
        if (pp[1] == '/')
        {
            for (i = jmp + 1; *pp && i; i -= (*pp++ == '\t'))
            {
            }
            for (i = jmp + 1; *qq && i; i -= (*qq++ == '\t'))
            {
            }
        }
        else
        {
            for (i = jmp; *pp && i; i -= (*pp++ == '\t'))
            {
            }
            for (i = jmp; *qq && i; i -= (*qq++ == '\t'))
            {
            }
        }
    }

    else if (jmp == 8)
    {
        for (i = 8; *pp && i; i -= (*pp++ == '\t'))
        {
        }
        for (i = 8; *qq && i; i -= (*qq++ == '\t'))
        {
        }
    } */
    else
    {
        errno = EINVAL;
        return(0);
    }

    // This part between brackets to make the compiler happy!
    {
        register wchar_t* sp = pp;
        register wchar_t* sq = qq;

        // Find where to stop comparison
        while (*pp != '\0' && *pp > '\t')
        {
            pp++;
        }

        while (*qq != '\0' && *qq > '\t')
        {
            qq++;
        }

        // Save characters at current position
        pw = *pp;
        qw = *qq;

        // Set characters to null, to stop comparison
        *pp = '\0';
        *qq = '\0';

        // Compare wide strings
        ret = comparewnat(sp, sq, igncase);

        // Restore saved characters
        *pp = pw;
        *qq = qw;

        if (ret == 0)
        {
            ret = retnames;
        }
    }

end:

    // If descending flip
    if (!asc)
    {
        ret = ret * -1;
    }

    return(ret);
}


/**
 * Compares a field of pa with the same field of pb, if the fields are
 * equal compare by name
 * @param  igncase	Ignore upper/lower-case?
 * @param  asc		Ascending?  If false is descending order
 * @param  mixdir	Mix directories with files?
 * @param  jmp		Field to compare (separated with \t)
 *
 * @return 0 if equal, negative if pa<pb, positive if pa>pb
 * Requires to allocate some space, if there is no memory this
 * function returns 0 and errno will be ENOMEM
 * If jmp has an invalid value returns 0 and errno will be EINVAL
 */
int FileList::compare(const IconItem* pa, const IconItem* pb,
                      FXbool igncase, FXbool asc, FXbool mixdir, FXuint jmp)
{
    register const FileItem* a = (FileItem*)pa;
    register const FileItem* b = (FileItem*)pb;
    register char*           p = (char*)a->label.text();
    register char*           q = (char*)b->label.text();

    // Common cases
    // Directory '..' should always be on top
    if ((p[0] == '.') && (p[1] == '.') && (p[2] == '\t'))
    {
        return(-1);
    }

    if ((q[0] == '.') && (q[1] == '.') && (q[2] == '\t'))
    {
        return(1);
    }

    if (!mixdir)
    {
        int diff = (int)b->isDirectory() - (int)a->isDirectory();
        if (diff)
        {
            return(diff);
        }
    }

    // Prepare wide char strings
    wchar_t* wa = NULL;
    wchar_t* wb = NULL;
    size_t   an, bn;
    an = mbstowcs(NULL, (const char*)p, 0);
    if (an == (size_t)-1)
    {
        return(compare_nolocale(p, q, igncase, asc, jmp)); // If error, fall back to no locale comparison
    }
    wa = (wchar_t*)calloc(an + 1, sizeof(wchar_t));
    if (wa == NULL)
    {
        errno = ENOMEM;
        return(0);
    }
    mbstowcs(wa, p, an + 1);
    bn = mbstowcs(NULL, (const char*)q, 0);
    if (bn == (size_t)-1)
    {
        free(wa);
        return(compare_nolocale(p, q, igncase, asc, jmp)); // If error, fall back to no locale comparison
    }
    wb = (wchar_t*)calloc(bn + 1, sizeof(wchar_t));
    if (wb == NULL)
    {
        errno = ENOMEM;
        free(wa);
        free(wb);
        return(0);
    }
    mbstowcs(wb, q, bn + 1);

    // Perform comparison based on the current locale
    int ret = compare_locale(wa, wb, igncase, asc, jmp);

    // Free memory
    if (wa != NULL)
    {
        free(wa);
    }
    if (wb != NULL)
    {
        free(wb);
    }

    return(ret);
}


// Compare file names
int FileList::ascending(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, true, false, 0));
}


// Compare file names, mixing files and directories
int FileList::ascendingMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, true, true, 0));
}


// Compare file names, case insensitive
int FileList::ascendingCase(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, true, true, false, 0));
}


// Compare file names, case insensitive, mixing files and directories
int FileList::ascendingCaseMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, true, true, true, 0));
}


// Compare directory names
int FileList::ascendingDir(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, true, false, 1));
}


// Compare directory names, mixing files and directories
int FileList::ascendingDirMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, true, true, 1));
}


// Compare directory names, case insensitive
int FileList::ascendingDirCase(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, true, true, false, 1));
}


// Compare directory names, case insensitive, mixing files and directories
int FileList::ascendingDirCaseMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, true, true, true, 1));
}


// Compare file types
int FileList::ascendingType(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, true, false, 2));
}


// Compare file types, mixing files and directories
int FileList::ascendingTypeMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, true, true, 2));
}


// Compare file extension
int FileList::ascendingExt(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, true, false, 3));
}


// Compare file extension, mixing files and directories
int FileList::ascendingExtMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, true, true, 3));
}


// Compare file size - Warning: only returns the sign of the comparison!!!
int FileList::ascendingSize(const IconItem* pa, const IconItem* pb)
{
    register const FileItem* a = (FileItem*)pa;
    register const FileItem* b = (FileItem*)pb;

    register const FXuchar* p = (const FXuchar*)a->label.text();
    register const FXuchar* q = (const FXuchar*)b->label.text();

    // Directory '..' should always be on top
    if ((p[0] == '.') && (p[1] == '.') && (p[2] == '\t'))
    {
        return(-1);
    }
    if ((q[0] == '.') && (q[1] == '.') && (q[2] == '\t'))
    {
        return(1);
    }

    register int diff = (int)b->isDirectory() - (int)a->isDirectory();
    register int sum = (int)b->isDirectory() + (int)a->isDirectory();

    if (diff)
    {
        return(diff);
    }
    if (sum == 2)
    {
        return(ascendingCase(pa, pb));
    }

    register FXlong l = a->size - b->size;
    if (l)
    {
        if (l >= 0)
        {
            return(1);
        }
        else
        {
            return(-1);
        }
    }
    return(ascendingCase(pa, pb));
}


// Compare file size - Warning : only returns the sign of the comparison!!!
// Mixing files and directories
int FileList::ascendingSizeMix(const IconItem* pa, const IconItem* pb)
{
    register const FileItem* a = (FileItem*)pa;
    register const FileItem* b = (FileItem*)pb;

    register const FXuchar* p = (const FXuchar*)a->label.text();
    register const FXuchar* q = (const FXuchar*)b->label.text();
    register int            adir = (int)a->isDirectory();
    register int            bdir = (int)b->isDirectory();

    // Directory '..' should always be on top
    if ((p[0] == '.') && (p[1] == '.') && (p[2] == '\t'))
    {
        return(-1);
    }
    if ((q[0] == '.') && (q[1] == '.') && (q[2] == '\t'))
    {
        return(1);
    }

    if (adir && bdir)
    {
        return(ascendingCaseMix(pa, pb));
    }
    if (adir && !bdir)
    {
        return(-1);
    }
    if (!adir && bdir)
    {
        return(1);
    }

    register FXlong l = a->size - b->size;
    if (l)
    {
        if (l >= 0)
        {
            return(1);
        }
        else
        {
            return(-1);
        }
    }
    return(ascendingCaseMix(pa, pb));
}


// Compare file time
int FileList::ascendingTime(const IconItem* pa, const IconItem* pb)
{
    register const FileItem* a = (FileItem*)pa;
    register const FileItem* b = (FileItem*)pb;

    register const FXuchar* p = (const FXuchar*)a->label.text();
    register const FXuchar* q = (const FXuchar*)b->label.text();

    // Directory '..' should always be on top
    if ((p[0] == '.') && (p[1] == '.') && (p[2] == '\t'))
    {
        return(-1);
    }
    if ((q[0] == '.') && (q[1] == '.') && (q[2] == '\t'))
    {
        return(1);
    }

    register int diff = (int)b->isDirectory() - (int)a->isDirectory();
    if (diff)
    {
        return(diff);
    }

    register FXlong l = (FXlong)a->date - (FXlong)b->date;
    if (l)
    {
        return(l);
    }
    return(ascendingCase(pa, pb));
}


// Compare file time, mixing files and directories
int FileList::ascendingTimeMix(const IconItem* pa, const IconItem* pb)
{
    register const FileItem* a = (FileItem*)pa;
    register const FileItem* b = (FileItem*)pb;

    register const FXuchar* p = (const FXuchar*)a->label.text();
    register const FXuchar* q = (const FXuchar*)b->label.text();

    // Directory '..' should always be on top
    if ((p[0] == '.') && (p[1] == '.') && (p[2] == '\t'))
    {
        return(-1);
    }
    if ((q[0] == '.') && (q[1] == '.') && (q[2] == '\t'))
    {
        return(1);
    }

    register FXlong l = (FXlong)a->date - (FXlong)b->date;
    if (l)
    {
        return(l);
    }
    return(ascendingCaseMix(pa, pb));
}


// Compare file user
int FileList::ascendingUser(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, true, false, 5));
}


// Compare file user, mixing files and directories
int FileList::ascendingUserMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, true, true, 5));
}


// Compare file group
int FileList::ascendingGroup(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, true, false, 6));
}


// Compare file group, mixing files and directories
int FileList::ascendingGroupMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, true, true, 6));
}


// Compare file permissions
int FileList::ascendingPerm(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, true, false, 7));
}


// Compare file permissions, mixing files and directories
int FileList::ascendingPermMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, true, true, 7));
}


// Compare file deletion time
int FileList::ascendingDeltime(const IconItem* pa, const IconItem* pb)
{
    register const FileItem* a = (FileItem*)pa;
    register const FileItem* b = (FileItem*)pb;

    register const FXuchar* p = (const FXuchar*)a->label.text();
    register const FXuchar* q = (const FXuchar*)b->label.text();

    // Directory '..' should always be on top
    if ((p[0] == '.') && (p[1] == '.') && (p[2] == '\t'))
    {
        return(-1);
    }
    if ((q[0] == '.') && (q[1] == '.') && (q[2] == '\t'))
    {
        return(1);
    }

    register int diff = (int)b->isDirectory() - (int)a->isDirectory();
    if (diff)
    {
        return(diff);
    }
    register FXlong l = (FXlong)a->deldate - (FXlong)b->deldate;
    if (l)
    {
        return(l);
    }
    return(ascendingCase(pa, pb));
}


// Compare file deletion time, mixing files and directories
int FileList::ascendingDeltimeMix(const IconItem* pa, const IconItem* pb)
{
    register const FileItem* a = (FileItem*)pa;
    register const FileItem* b = (FileItem*)pb;

    register const FXuchar* p = (const FXuchar*)a->label.text();
    register const FXuchar* q = (const FXuchar*)b->label.text();

    // Directory '..' should always be on top
    if ((p[0] == '.') && (p[1] == '.') && (p[2] == '\t'))
    {
        return(-1);
    }
    if ((q[0] == '.') && (q[1] == '.') && (q[2] == '\t'))
    {
        return(1);
    }

    register FXlong l = (FXlong)a->deldate - (FXlong)b->deldate;
    if (l)
    {
        return(l);
    }
    return(ascendingCaseMix(pa, pb));
}


// Compare original path
int FileList::ascendingOrigpath(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, true, false, 8));
}


// Compare original path, mixing files and directories
int FileList::ascendingOrigpathMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, true, true, 8));
}


// Reversed compare file name, case insensitive
int FileList::descendingCase(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, true, false, false, 0));
}


// Reversed compare file name, case insensitive, mixing files and directories
int FileList::descendingCaseMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, true, false, true, 0));
}


// Reversed compare file name
int FileList::descending(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, false, false, 0));
}


// Reversed compare file name, mixing files and directories
int FileList::descendingMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, false, true, 0));
}


// Reversed compare directory names, case insensitive
int FileList::descendingDirCase(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, true, false, false, 1));
}


// Reversed compare directory names, case insensitive, mixing files and directories
int FileList::descendingDirCaseMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, true, false, true, 1));
}


// Reversed compare directory names
int FileList::descendingDir(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, false, false, 1));
}


// Reversed compare directory names, mixing files and directories
int FileList::descendingDirMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, false, true, 1));
}


// Reversed compare file type
int FileList::descendingType(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, false, false, 2));
}


// Reversed compare file type, mixing files and directories
int FileList::descendingTypeMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, false, true, 2));
}


// Reversed compare file extension
int FileList::descendingExt(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, false, false, 3));
}


// Reversed compare file extension, mixing files and directories
int FileList::descendingExtMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, false, true, 3));
}


// Reversed compare file size
int FileList::descendingSize(const IconItem* pa, const IconItem* pb)
{
    register const FileItem* a = (FileItem*)pa;
    register const FileItem* b = (FileItem*)pb;

    register const FXuchar* p = (const FXuchar*)a->label.text();
    register const FXuchar* q = (const FXuchar*)b->label.text();

    // Directory '..' should always be on top
    if ((p[0] == '.') && (p[1] == '.') && (p[2] == '\t'))
    {
        return(-1);
    }
    if ((q[0] == '.') && (q[1] == '.') && (q[2] == '\t'))
    {
        return(1);
    }

    register int diff = (int)b->isDirectory() - (int)a->isDirectory();
    register int sum = (int)b->isDirectory() + (int)a->isDirectory();
    if (diff)
    {
        return(diff);
    }
    if (sum == 2)
    {
        return(-ascendingCase(pa, pb));
    }
    register FXlong l = a->size - b->size;
    if (l)
    {
        if (l >= 0)
        {
            return(-1);
        }
        else
        {
            return(1);
        }
    }
    return(-ascendingCase(pa, pb));
}


// Reversed compare file size, mixing files and directories
int FileList::descendingSizeMix(const IconItem* pa, const IconItem* pb)
{
    register const FileItem* a = (FileItem*)pa;
    register const FileItem* b = (FileItem*)pb;

    register const FXuchar* p = (const FXuchar*)a->label.text();
    register const FXuchar* q = (const FXuchar*)b->label.text();
    register int            adir = (int)a->isDirectory();
    register int            bdir = (int)b->isDirectory();

    // Directory '..' should always be on top
    if ((p[0] == '.') && (p[1] == '.') && (p[2] == '\t'))
    {
        return(-1);
    }
    if ((q[0] == '.') && (q[1] == '.') && (q[2] == '\t'))
    {
        return(1);
    }

    if (adir && bdir)
    {
        return(-ascendingCaseMix(pa, pb));
    }
    if (adir && !bdir)
    {
        return(1);
    }
    if (!adir && bdir)
    {
        return(-1);
    }

    register FXlong l = a->size - b->size;
    if (l)
    {
        if (l >= 0)
        {
            return(-1);
        }
        else
        {
            return(1);
        }
    }
    return(-ascendingCaseMix(pa, pb));
}


// Reversed compare file time
int FileList::descendingTime(const IconItem* pa, const IconItem* pb)
{
    register const FileItem* a = (FileItem*)pa;
    register const FileItem* b = (FileItem*)pb;

    register const FXuchar* p = (const FXuchar*)a->label.text();
    register const FXuchar* q = (const FXuchar*)b->label.text();

    // Directory '..' should always be on top
    if ((p[0] == '.') && (p[1] == '.') && (p[2] == '\t'))
    {
        return(-1);
    }
    if ((q[0] == '.') && (q[1] == '.') && (q[2] == '\t'))
    {
        return(1);
    }

    register int diff = (int)b->isDirectory() - (int)a->isDirectory();
    if (diff)
    {
        return(diff);
    }
    register FXlong l = (FXlong)a->date - (FXlong)b->date;
    if (l)
    {
        return(-l);
    }
    return(-ascendingCase(pa, pb));
}


// Reversed compare file time, mixing files and directories
int FileList::descendingTimeMix(const IconItem* pa, const IconItem* pb)
{
    register const FileItem* a = (FileItem*)pa;
    register const FileItem* b = (FileItem*)pb;

    register const FXuchar* p = (const FXuchar*)a->label.text();
    register const FXuchar* q = (const FXuchar*)b->label.text();

    // Directory '..' should always be on top
    if ((p[0] == '.') && (p[1] == '.') && (p[2] == '\t'))
    {
        return(-1);
    }
    if ((q[0] == '.') && (q[1] == '.') && (q[2] == '\t'))
    {
        return(1);
    }

    register FXlong l = (FXlong)a->date - (FXlong)b->date;
    if (l)
    {
        return(-l);
    }
    return(-ascendingCaseMix(pa, pb));
}


// Reversed compare file user
int FileList::descendingUser(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, false, false, 5));
}


// Reversed compare file user, mixing files and directories
int FileList::descendingUserMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, false, true, 5));
}


// Reversed compare file group
int FileList::descendingGroup(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, false, false, 6));
}


// Reversed compare file group, mixing files and directories
int FileList::descendingGroupMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, false, true, 6));
}


// Reversed compare file permission
int FileList::descendingPerm(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, false, false, 7));
}


// Reversed compare file permission, mixing files and directories
int FileList::descendingPermMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, false, true, 7));
}


// Reversed compare file deletion time
int FileList::descendingDeltime(const IconItem* pa, const IconItem* pb)
{
    register const FileItem* a = (FileItem*)pa;
    register const FileItem* b = (FileItem*)pb;

    register const FXuchar* p = (const FXuchar*)a->label.text();
    register const FXuchar* q = (const FXuchar*)b->label.text();

    // Directory '..' should always be on top
    if ((p[0] == '.') && (p[1] == '.') && (p[2] == '\t'))
    {
        return(-1);
    }
    if ((q[0] == '.') && (q[1] == '.') && (q[2] == '\t'))
    {
        return(1);
    }

    register int diff = (int)b->isDirectory() - (int)a->isDirectory();
    if (diff)
    {
        return(diff);
    }
    register FXlong l = (FXlong)a->deldate - (FXlong)b->deldate;
    if (l)
    {
        return(-l);
    }
    return(-ascendingCase(pa, pb));
}


// Reversed compare file deletion time, mixing files and directories
int FileList::descendingDeltimeMix(const IconItem* pa, const IconItem* pb)
{
    register const FileItem* a = (FileItem*)pa;
    register const FileItem* b = (FileItem*)pb;

    register const FXuchar* p = (const FXuchar*)a->label.text();
    register const FXuchar* q = (const FXuchar*)b->label.text();

    // Directory '..' should always be on top
    if ((p[0] == '.') && (p[1] == '.') && (p[2] == '\t'))
    {
        return(-1);
    }
    if ((q[0] == '.') && (q[1] == '.') && (q[2] == '\t'))
    {
        return(1);
    }

    register FXlong l = (FXlong)a->deldate - (FXlong)b->deldate;
    if (l)
    {
        return(-l);
    }
    return(-ascendingCaseMix(pa, pb));
}


// Reversed compare original path
int FileList::descendingOrigpath(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, false, false, 8));
}


// Reversed original path, mixing files and directories
int FileList::descendingOrigpathMix(const IconItem* pa, const IconItem* pb)
{
    return(compare(pa, pb, false, false, true, 8));
}


// Force an immediate update of the list
long FileList::onCmdRefresh(FXObject*, FXSelector, void*)
{
    // Force a refresh of the file association table
    if (associations)
    {
        delete associations;
        associations = new FileDict(getApp());
    }
    allowrefresh = true;
    scan(true);
    return(1);
}


// Allow or forbid file list refresh
void FileList::setAllowRefresh(const FXbool allow)
{
    if (allow == false)
    {
        allowrefresh = false;
    }
    else
    {
        allowrefresh = true;
    }
}


// Refresh; don't update if user is interacting with the list
long FileList::onCmdRefreshTimer(FXObject*, FXSelector, void*)
{
    // Don't refresh if window is minimized
    if (((FXTopWindow*)focuswindow)->isMinimized())
    {
        return(0);
    }

    // Don't refresh if not allowed
    if (flags&FLAG_UPDATE && allowrefresh)
    {
        scan(false);
        counter = (counter+1)%REFRESH_FREQUENCY;
    }

    // Reset timer again
    getApp()->addTimeout(this, ID_REFRESH_TIMER, REFRESH_INTERVAL);
    return(0);
}


// Set current filename
void FileList::setCurrentFile(const FXString& pathname)
{
    // FIXME notify argument?
    if (!pathname.empty())
    {
        setDirectory(FXPath::directory(pathname));
        setCurrentItem(findItem(FXPath::name(pathname)));
    }
}


// Get pathname to current file, if any
FXString FileList::getCurrentFile() const
{
    if (current < 0)
    {
        return(FXString::null);
    }
    return(getItemPathname(current));
}


// Set directory being displayed and update the history if necessary
void FileList::setDirectory(const FXString& pathname, const FXbool histupdate, FXString prevpath)
{
    //FXLabel* addressicon = ((XFileExplorer*)mainWindow)->getAddressIcon();

    // Only update the history if it was requested
    if (histupdate)
    {
        // At first call, allocate the history
        if (forwardhist == NULL)
        {
            forwardhist = new StringList();
        }
        if (backhist == NULL)
        {
            backhist = new StringList();
        }

        // Update the history
        else
        {
            backhist->insertFirstItem(getDirectory());
            forwardhist->removeAllItems();
        }
    }

    FXString path("");

    // FIXME notify argument?
    if (!pathname.empty())
    {
        path = FXPath::absolute(directory, pathname);

        while (!FXPath::isTopDirectory(path) && !::isDirectory(path))
        {
            path = FXPath::upLevel(path);
        }
        if (directory != path)
        {
            directory = ::cleanPath(path);
            clearItems();
            list = NULL;
            scan(true);
        }
    }
    // If possible, select directory we came from, otherwise select first item
    if (hasFocus())
    {
        int sel_index = 0;

        if (!prevpath.empty())
        {
            if (path == FXPath::upLevel(prevpath)) // Did we come from subdirectory?
            {
                // Find dir in list
                sel_index = findItem(FXPath::name(prevpath));
                if ((sel_index == -1) && getNumItems())
                {
                    // Not found, select first item
                    sel_index = 0;
                }
            }
        }

        if ((sel_index != -1) && getNumItems())
        {
            enableItem(sel_index);
            setCurrentItem(sel_index);
        }

    //addressicon->setIcon(minifolderopenicon);
    }
}


// Set the pattern to filter
void FileList::setPattern(const FXString& ptrn)
{
    if (ptrn.empty())
    {
        return;
    }
    if (pattern != ptrn)
    {
        pattern = ptrn;
        scan(true);
    }
    setFocus();
}


// Change file match mode
void FileList::setMatchMode(FXuint mode)
{
    if (matchmode != mode)
    {
        matchmode = mode;
        scan(true);
    }
    setFocus();
}


// Return true if showing hidden files
FXbool FileList::shownHiddenFiles() const
{
    return((options&_FILELIST_SHOWHIDDEN) != 0);
}


// Change show hidden files mode
void FileList::showHiddenFiles(FXbool shown)
{
    FXuint opts = shown ? (options|_FILELIST_SHOWHIDDEN) : (options&~_FILELIST_SHOWHIDDEN);

    if (opts != options)
    {
        options = opts;
        scan(true);
    }
    setFocus();
}


// Return true if showing thumbnails
FXbool FileList::shownThumbnails() const
{
    return(displaythumbnails);
}


// Change show thumbnails mode
void FileList::showThumbnails(FXbool display)
{
    displaythumbnails = display;

    // Refresh to display or hide thumbnails
    scan(true);
    setFocus();
}


// Return true if showing directories only
FXbool FileList::showOnlyDirectories() const
{
    return((options&_FILELIST_SHOWDIRS) != 0);
}


// Change show directories only mode
void FileList::showOnlyDirectories(FXbool shown)
{
    FXuint opts = shown ? (options|_FILELIST_SHOWDIRS) : (options&~_FILELIST_SHOWDIRS);

    if (opts != options)
    {
        options = opts;
        scan(true);
    }
    setFocus();
}


// Compare till '\t' or '\0'
static FXbool fileequal(const FXString& a, const FXString& b)
{
    register const FXuchar* p1 = (const FXuchar*)a.text();
    register const FXuchar* p2 = (const FXuchar*)b.text();
    register int            c1, c2;

    do
    {
        c1 = *p1++;
        c2 = *p2++;
    } while (c1 != '\0' && c1 != '\t' && c1 == c2);
    return((c1 == '\0' || c1 == '\t') && (c2 == '\0' || c2 == '\t'));
}


// Create custom item
IconItem* FileList::createItem(const FXString& text, FXIcon* big, FXIcon* mini, void* ptr)
{
    return(new FileItem(text, big, mini, ptr));
}


// Is directory
FXbool FileList::isItemDirectory(int index) const
{
    if ((FXuint)index >= (FXuint)items.no())
    {
        fprintf(stderr, "%s::isItemDirectory: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return((((FileItem*)items[index])->state&FileItem::FOLDER) != 0);
}


// Is file
FXbool FileList::isItemFile(int index) const
{
    if ((FXuint)index >= (FXuint)items.no())
    {
        fprintf(stderr, "%s::isItemFile: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return((((FileItem*)items[index])->state&(FileItem::FOLDER|FileItem::CHARDEV|FileItem::BLOCKDEV|FileItem::FIFO|FileItem::SOCK)) == 0);
}


// Is executable
FXbool FileList::isItemExecutable(int index) const
{
    if ((FXuint)index >= (FXuint)items.no())
    {
        fprintf(stderr, "%s::isItemExecutable: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return((((FileItem*)items[index])->state&FileItem::EXECUTABLE) != 0);
}


// Is link
FXbool FileList::isItemLink(int index) const
{
    if ((FXuint)index >= (FXuint)items.no())
    {
        fprintf(stderr, "%s::isItemLink: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return((((FileItem*)items[index])->state&FileItem::SYMLINK) != 0);
}


// Get file name from item at index
FXString FileList::getItemFilename(int index) const
{
    if ((FXuint)index >= (FXuint)items.no())
    {
        fprintf(stderr, "%s::getItemFilename: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    FXString label = items[index]->getText();
    return(label.section('\t', 0));
}


// Get pathname from item at index, relatively to the current directory
FXString FileList::getItemPathname(int index) const
{
    if ((FXuint)index >= (FXuint)items.no())
    {
        fprintf(stderr, "%s::getItemPathname: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    FXString label = items[index]->getText();
    return(FXPath::absolute(directory, label.section('\t', 0)));
}


// Get full pathname from item at index, as obtained from the label string
FXString FileList::getItemFullPathname(int index) const
{
    if ((FXuint)index >= (FXuint)items.no())
    {
        fprintf(stderr, "%s::getItemFullPathname: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    FXString label = items[index]->getText();
    return(label.rafter('\t'));
}


// Get associations (if any) from the file
FileAssoc* FileList::getItemAssoc(int index) const
{
    if ((FXuint)index >= (FXuint)items.no())
    {
        fprintf(stderr, "%s::getItemAssoc: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return(((FileItem*)items[index])->assoc);
}


// Return file size of the item
FXulong FileList::getItemFileSize(int index) const
{
    if ((FXuint)index >= (FXuint)items.no())
    {
        fprintf(stderr, "%s::getItemFileSize: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return(((FileItem*)items[index])->size);
}


// Change associations table; force a rescan so as to
// update the bindings in each item to the new associations
void FileList::setAssociations(FileDict* assocs)
{
    if (associations != assocs)
    {
        associations = assocs;
        scan(true);
    }
    setFocus();
}


// Change header size
void FileList::setHeaderSize(int index, int size)
{
    if (index == NB_HEADERS)
    {
        origpathsize = size;
    }
    else if (index == NB_HEADERS+1)
    {
        deldatesize = size;
    }
    else
    {
        if ((FXuint)index >= (FXuint)header->getNumItems())
        {
            fprintf(stderr, "%s::setHeaderSize: index out of range.\n", getClassName());
            exit(EXIT_FAILURE);
        }
        header->setItemSize(index, size);
    }
}


// Get header size
int FileList::getHeaderSize(int index) const
{
    if (index == NB_HEADERS)
    {
        return(origpathsize);
    }

    if (index == NB_HEADERS+1)
    {
        return(deldatesize);
    }

    if ((FXuint)index >= (FXuint)header->getNumItems())
    {
        fprintf(stderr, "%s::getHeaderSize: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }

    return(header->getItemSize(index));
}


// Update refresh timer if the window is unminimized
long FileList::onUpdRefreshTimer(FXObject*, FXSelector, void*)
{
    static FXbool prevMinimized = true;
    static FXbool minimized = true;

    prevMinimized = minimized;
    if (((FXTopWindow*)focuswindow)->isMinimized())
    {
        minimized = false;
    }
    else
    {
        minimized = true;
    }

    // Update refresh timer
    if ((prevMinimized == false) && (minimized == true))
    {
        onCmdRefreshTimer(0, 0, 0);
    }

    return(1);
}


// Scan items to see if listing is necessary
void FileList::scan(FXbool force)
{
    // Start wait cursor if refresh forced (use custom function)
    if (force)
    {
        ::setWaitCursor(getApp(), BEGIN_CURSOR);
    }



    // Special case where the file list is a search list
    if (options&_FILELIST_SEARCH)
    {
        FXbool updated = updateItems(force);
        if (updated)
        {
            sortItems(); // Only sort if search list was updated
        }
    }

    // Normal case
    else
    {
        struct stat info;

        // Stat the current directory
        if (::info(directory, info))
        {
            // New date of directory
            FXTime newdate = (FXTime)FXMAX(info.st_mtime, info.st_ctime);

            // Forced, directory date was changed, or failed to get proper date or counter expired
            if (force || (timestamp != newdate) || (counter == 0))
            {
                // And do the refresh
#if defined(linux)
                refreshMtdevices();
#endif
                listItems(force);
                sortItems();

                // Remember when we did this
                timestamp = newdate;
            }
        }

        // Move to higher directory
        else
        {
            setDirectory(FXPath::upLevel(directory));
        }
    }

    // Stop wait cursor if refresh forced (use custom function)
    if (force)
    {
        ::setWaitCursor(getApp(), END_CURSOR);
    }
}


// Update the list (used in a search list)
FXbool FileList::updateItems(FXbool force)
{
    FXString      grpid, usrid, atts, mod, ext, del;
    FXString      filename, dirname, pathname;
    FileItem*     item;
    FileAssoc*    fileassoc;
    FXString      filetype, lowext;
    FXIcon*       big, *mini;
    FXIcon*       bigthumb = NULL, *minithumb = NULL;
    FXIconSource* source;
    time_t        filemtime, filectime;
    struct stat   info, linfo;
    FXbool        isLink, isBrokenLink;
    FXbool        updated = false;

    // Loop over the item list
    for (int u = 0; u < getNumItems(); u++)
    {
        // Current item
        item = (FileItem*)getItem(u);
        pathname = getItemFullPathname(u);
        dirname = FXPath::directory(pathname);
        filename = FXPath::name(pathname);

        // Get file/link info and indicate if it is a link
        if (lstatrep(pathname.text(), &linfo) != 0)
        {
            removeItem(u, true);
            u--;
            continue;
        }
        isLink = S_ISLNK(linfo.st_mode);
        isBrokenLink = false;

        // Find if it is a broken link
        if (isLink && (statrep(pathname.text(), &info) != 0))
        {
            isBrokenLink = true;
        }

        // File times
        filemtime = linfo.st_mtime;
        filectime = linfo.st_ctime;

        // Update only if the item has changed (mtime or ctime)
        if (force || (item->date != filemtime) || (item->cdate != filectime))
        {
            // Indicate that the list was updated
            updated = true;

            // Obtain user name
            usrid = FXSystem::userName(linfo.st_uid);

            // Obtain group name
            grpid = FXSystem::groupName(linfo.st_gid);

            // Permissions (caution : we don't use the FXSystem::modeString() function because
            // it seems to be incompatible with the info.st_mode format)
            atts = ::permissions(linfo.st_mode);

            // Mod time
            mod = FXSystem::time("%x %X", filemtime);

            del = "";
            ext = "";
            // Obtain the extension for files only
            if (!S_ISDIR(linfo.st_mode))
            {
                ext = FXPath::name(pathname).rafter('.', 2).lower();
                if ((ext == "tar.gz") || (ext == "tar.bz2") || (ext == "tar.xz") || (ext == "tar.z")) // Special cases
                {
					// Do nothing
                }
                else
                {
                    ext = FXPath::extension(pathname).lower();
                }
            }

            // Obtain the stat info on the file itself
            if (statrep(pathname.text(), &info) != 0)
            {
                // Except in the case of a broken link
                if (isBrokenLink)
                {
                    lstatrep(pathname.text(), &info);
                }
                else
                {
                    removeItem(u, true);
                    u--;
                    continue;
                }
            }

            // Set item flags from the obtained info
            if (S_ISDIR(info.st_mode))
            {
                item->state |= FileItem::FOLDER;
            }
            else
            {
                item->state &= ~FileItem::FOLDER;
            }
            if (S_ISLNK(info.st_mode))
            {
                item->state |= FileItem::SYMLINK;
            }
            else
            {
                item->state &= ~FileItem::SYMLINK;
            }
            if (S_ISCHR(info.st_mode))
            {
                item->state |= FileItem::CHARDEV;
            }
            else
            {
                item->state &= ~FileItem::CHARDEV;
            }
            if (S_ISBLK(info.st_mode))
            {
                item->state |= FileItem::BLOCKDEV;
            }
            else
            {
                item->state &= ~FileItem::BLOCKDEV;
            }
            if (S_ISFIFO(info.st_mode))
            {
                item->state |= FileItem::FIFO;
            }
            else
            {
                item->state &= ~FileItem::FIFO;
            }
            if (S_ISSOCK(info.st_mode))
            {
                item->state |= FileItem::SOCK;
            }
            else
            {
                item->state &= ~FileItem::SOCK;
            }
            if ((info.st_mode&(S_IXUSR|S_IXGRP|S_IXOTH)) && !(S_ISDIR(info.st_mode) || S_ISCHR(info.st_mode) || S_ISBLK(info.st_mode) || S_ISFIFO(info.st_mode) || S_ISSOCK(info.st_mode)))
            {
                item->state |= FileItem::EXECUTABLE;
            }
            else
            {
                item->state &= ~FileItem::EXECUTABLE;
            }

            // We can drag items
            item->state |= FileItem::DRAGGABLE;

            // Assume no associations
            fileassoc = NULL;

            // Determine icons and type
            if (item->state&FileItem::FOLDER)
            {
                if (!::isReadExecutable(pathname))
                {
                    big = bigfolderlockedicon;
                    mini = minifolderlockedicon;
                    filetype = _("Folder");
                }
                else
                {
                    big = bigfoldericon;
                    mini = minifoldericon;
                    filetype = _("Folder");
                }
            }
            else if (item->state&FileItem::CHARDEV)
            {
                big = bigchardevicon;
                mini = minichardevicon;
                filetype = _("Character Device");
            }
            else if (item->state&FileItem::BLOCKDEV)
            {
                big = bigblockdevicon;
                mini = miniblockdevicon;
                filetype = _("Block Device");
            }
            else if (item->state&FileItem::FIFO)
            {
                big = bigpipeicon;
                mini = minipipeicon;
                filetype = _("Named Pipe");
            }
            else if (item->state&FileItem::SOCK)
            {
                big = bigsocketicon;
                mini = minisocketicon;
                filetype = _("Socket");
            }
            else if (item->state&FileItem::EXECUTABLE)
            {
                big = bigexecicon;
                mini = miniexecicon;
                filetype = _("Executable");
                if (associations)
                {
                    fileassoc = associations->findFileBinding(pathname.text());
                }
            }
            else
            {
                big = bigdocicon;
                mini = minidocicon;
                filetype = _("Document");
                if (associations)
                {
                    fileassoc = associations->findFileBinding(pathname.text());
                }
            }

            // If association is found, use it
            if (fileassoc)
            {
				// Don't use associations when the file name is also an extension name (ex: zip, rar, tar, etc.)
				if (fileassoc->key != FXPath::name(pathname))
				{
					filetype = fileassoc->extension.text();

					if (fileassoc->bigicon)
					{
						big = fileassoc->bigicon;
					}
					if (fileassoc->miniicon)
					{
						mini = fileassoc->miniicon;
					}
				}
            }

            // Symbolic links have a specific type
            if (isBrokenLink)
            {
                filetype = _("Broken link");
            }

            else if (isLink)
            {
                if (associations)
                {
                    // Don't forget to remove trailing '/' here!
                    fileassoc = associations->findFileBinding(::cleanPath(::readLink(pathname)).text());
                    if (fileassoc)
                    {
                        filetype = _("Link to ")+fileassoc->extension;
                    }
                    else
                    {
                        filetype = _("Link to ")+filetype;
                    }
                }
            }

            // Don't display the file size for directories
            FXString hsize;
            if (S_ISDIR(linfo.st_mode))
            {
                hsize = "";
            }
            else
            {
                char size[64];
#if __WORDSIZE == 64
                snprintf(size, sizeof(size)-1, "%lu", (FXulong)linfo.st_size);
#else
                snprintf(size, sizeof(size)-1, "%llu", (FXulong)linfo.st_size);
#endif
                hsize = ::hSize(size);
            }

            big->blend(getApp()->getBackColor());
            mini->blend(getApp()->getBackColor());

            big->create();
            mini->create();

            // Set item icons
            item->setBigIcon(big);
            item->setMiniIcon(mini);

            // Attempt to load thumbnails for image files
            if (displaythumbnails)
            {
                // Load big icon from file
                bigthumb = NULL;
                minithumb = NULL;
                if (associations)
                {
                    source = associations->getIconDict()->getIconSource();
                    if (!(item->state&FileItem::FIFO)) // Avoid pipes
                    {
                        bigthumb = source->loadIconFile(pathname);
                    }
                }

                if (bigthumb)
                {
                    register FXuint w = bigthumb->getWidth();
                    register FXuint h = bigthumb->getHeight();

                    // Eventually scale the big icon (best quality)
                    if ((w > MAX_BIGTHUMB_SIZE) || (h > MAX_BIGTHUMB_SIZE))
                    {
                        if (w > h)
                        {
                            bigthumb->scale(MAX_BIGTHUMB_SIZE, (MAX_BIGTHUMB_SIZE*h)/w, 1);
                        }
                        else
                        {
                            bigthumb->scale((MAX_BIGTHUMB_SIZE*w)/h, MAX_BIGTHUMB_SIZE, 1);
                        }

                        // Size has changed
                        w = bigthumb->getWidth();
                        h = bigthumb->getHeight();
                    }

                    // Copy the big icon to the mini icon (faster than direct rescaling)
                    minithumb = new FXIcon(getApp());
                    FXColor* tmpdata;
                    if (!FXMEMDUP(&tmpdata, bigthumb->getData(), FXColor, w*h))
                    {
                        throw FXMemoryException(_("Unable to load image"));
                    }
                    minithumb->setData(tmpdata, IMAGE_OWNED, w, h);

                    // Eventually scale the mini icon (best quality)
                    w = minithumb->getWidth();
                    h = minithumb->getHeight();
                    if ((w > MAX_MINITHUMB_SIZE) || (h > MAX_MINITHUMB_SIZE))
                    {
                        if (w > h)
                        {
                            minithumb->scale(MAX_MINITHUMB_SIZE, (MAX_MINITHUMB_SIZE*h)/w, 1);
                        }
                        else
                        {
                            minithumb->scale((MAX_MINITHUMB_SIZE*w)/h, MAX_MINITHUMB_SIZE, 1);
                        }
                    }

                    // Set thumbnail icons as owned
                    if (!isLink && !isBrokenLink)
                    {
                        item->setBigIcon(bigthumb, true);
                        item->setMiniIcon(minithumb, true);
                    }
                }
            }

            // Set other item attributes
            item->size = (FXulong)linfo.st_size;
            item->assoc = fileassoc;
            item->date = filemtime;
            item->cdate = filectime;

#if defined(linux)
            // Devices have a specific icon
            if (fsdevices->find(pathname.text()))
            {
                filetype = _("Mount point");

                if (streq(fsdevices->find(pathname.text()), "harddisk"))
                {
                    item->setBigIcon(bigharddiskicon);
                    item->setMiniIcon(harddiskicon);
                }
                else if (streq(fsdevices->find(pathname.text()), "nfsdisk"))
                {
                    item->setBigIcon(bignfsdriveicon);
                    item->setMiniIcon(nfsdriveicon);
                }
                else if (streq(fsdevices->find(pathname.text()), "smbdisk"))
                {
                    item->setBigIcon(bignfsdriveicon);
                    item->setMiniIcon(nfsdriveicon);
                }
                else if (streq(fsdevices->find(pathname.text()), "floppy"))
                {
                    item->setBigIcon(bigfloppyicon);
                    item->setMiniIcon(floppyicon);
                }
                else if (streq(fsdevices->find(pathname.text()), "cdrom"))
                {
                    item->setBigIcon(bigcdromicon);
                    item->setMiniIcon(cdromicon);
                }
                else if (streq(fsdevices->find(pathname.text()), "zip"))
                {
                    item->setBigIcon(bigzipicon);
                    item->setMiniIcon(zipicon);
                }
            }
#endif

            // Update item label
            // NB : Item del is empty if we are not in trash can
            //      Item pathname is not displayed but is used in the tooltip

            if (dirname.length() > 256)
            {
                dirname = dirname.trunc(256) + "[...]";   // Truncate directory path name to 25 characters to prevent overflow
            }
            item->label.format("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s",
                               filename.text(), dirname.text(), hsize.text(), filetype.text(), ext.text(),
                               mod.text(), usrid.text(), grpid.text(), atts.text(),
                               del.text(), pathname.text());

            // Symbolic links have a specific icon
            if (isLink)
            {
                // Broken link
                if (isBrokenLink)
                {
                    item->setBigIcon(bigbrokenlinkicon);
                    item->setMiniIcon(minibrokenlinkicon);
                }
                else
                {
                    item->setBigIcon(biglinkicon);
                    item->setMiniIcon(minilinkicon);
                }
            }
        }

        // Finally don't forget to create the item!
        item->create();

/*
        // Refresh the GUI if an image has to be drawn and recompute the icon height
        if (displaythumbnails)
        {
            if (updated && bigthumb && minithumb && (u < REFRESH_COUNT))
            {
                update();
                recompute();
                makeItemVisible(0); // Fix some refresh problems
                repaint();
            }
        }
*/
    }

    // Gotta recalc size of content
    if (updated)
    {
        recalc();
    }

    return(updated);
}


// List directory (used in a standard file list)
void FileList::listItems(FXbool force)
{
    FileItem       *oldlist, *newlist;
    FileItem       **po, **pn, **pp;
    FXString       grpid, usrid, atts, mod, ext, del, origpath;
    FXString       name, dirname, pathname;
    FileItem       *curitem = NULL;
    FileItem       *item, *link;
    FileAssoc      *fileassoc;
    FXString       filetype, lowext, timeformat;
    FXIconSource   *source;
    FXIcon         *big, *mini;
    FXIcon         *bigthumb = NULL, *minithumb = NULL;
    time_t         filemtime, filectime;
    struct stat    info, linfo;
    struct dirent  *dp;
    DIR*           dirp;
    FXbool         isInTrash, isLink, isBrokenLink, isLinkToDir;
    FXlong         deldate;

    // Read time format
    timeformat = getApp()->reg().readStringEntry("SETTINGS", "time_format", DEFAULT_TIME_FORMAT);

    // Build old and new insert-order lists
    oldlist = list;
    newlist = NULL;

    // Head of old and new lists
    po = &oldlist;
    pn = &newlist;

    // Remember current item
    if (0 <= current)
    {
        curitem = (FileItem*)items[current];
    }

    // Start inserting
    items.clear();

    // Get info about directory
    if (statrep(directory.text(), &info) == 0)
    {
        // Need latest change no matter what actually changed!
        timestamp = FXMAX(info.st_mtime, info.st_ctime);

        // Set path to stat with
        dirname = directory.text();

        if (dirname != ROOTDIR)
        {
            dirname += PATHSEPSTRING;
        }

        // Add the deletion time and original path headers if we are in trash can
        if (dirname.left(trashfileslocation.length()) == trashfileslocation)
        {
            if (getNumHeaders() == NB_HEADERS)
            {
                appendHeader(_("Original path"), NULL, origpathsize);
                appendHeader(_("Deletion date"), NULL, deldatesize);
            }
            isInTrash = true;
        }
        // Eventually remove the deletion and original path headers if we are not in trash can
        else
        {
            if (getNumHeaders() == NB_HEADERS+2)
            {
                deldatesize = header->getItemSize(NB_HEADERS+1);
                removeHeader(NB_HEADERS);
                origpathsize = header->getItemSize(NB_HEADERS);
                removeHeader(NB_HEADERS);

                // Change back the sort function to default if necessary
                if ((sortfunc == ascendingOrigpath) || (sortfunc == ascendingOrigpathMix) ||
                    (sortfunc == descendingOrigpath) || (sortfunc == descendingOrigpathMix))
                {
                    sortfunc = ascendingCase;
                    setSortHeader(0);
                }
                if ((sortfunc == ascendingDeltime) || (sortfunc == ascendingDeltimeMix) ||
                    (sortfunc == descendingDeltime) || (sortfunc == descendingDeltimeMix))
                {
                    sortfunc = ascendingCase;
                    setSortHeader(0);
                }
            }
            isInTrash = false;
        }

        // Get directory stream pointer
        dirp = opendir(directory.text());

        // Managed to open directory
        if (dirp)
        {
            // Loop over directory entries
            while ((dp = readdir(dirp)) != NULL)
            {
                // Directory entry name
                name = dp->d_name;

                // Hidden file (.xxx) or directory (. or .yyy) normally not shown,
                // but directory .. is always shown so we can navigate up or down
                // Hidden files in the trash can base directory are always shown
                if ((name[0] == '.') && ((name[1] == 0) || (!((name[1] == '.') && (name[2] == 0)) && !(options&_FILELIST_SHOWHIDDEN) &&
                                                            (dirname != trashfileslocation+PATHSEPSTRING))))
                {
                    continue;
                }

                /* if ((name[0] == '.') && ((name[1] == 0) || ((name[0] == '.') && ((name[1] == '.') || (!((name[1] == '.') && (name[2] == 0)) && !(options&_FILELIST_SHOWHIDDEN) &&
                                                            (dirname != trashfileslocation+PATHSEPSTRING))))))
                {
                    continue;
                } */

                // Build full pathname
                pathname = dirname+name;

                // Get file/link info and indicate if it is a link
                if (lstatrep(pathname.text(), &linfo) != 0)
                {
                    continue;
                }
                isLink = S_ISLNK(linfo.st_mode);
                isBrokenLink = false;
                isLinkToDir = false;

                // Find if it is a broken link or a link to a directory
                if (isLink)
                {
                    if (statrep(pathname.text(), &info) != 0)
                    {
                        isBrokenLink = true;
                    }
                    else if (S_ISDIR(info.st_mode))
                    {
                        isLinkToDir = true;
                    }
                }

                // If not a directory, nor a link to a directory and we want only directories, skip it
                if (!isLinkToDir && !S_ISDIR(linfo.st_mode) && (options&_FILELIST_SHOWDIRS))
                {
                    continue;
                }

                // Is it a directory or does it match the pattern?
                if (!S_ISDIR(linfo.st_mode) && !FXPath::match(pattern, name, matchmode))
                {
                    continue;
                }

                // File times
                filemtime = linfo.st_mtime;
                filectime = linfo.st_ctime;

                // Find it, and take it out from the old list if found
                for (pp = po; (item = *pp) != NULL; pp = &item->link)
                {
                    if (fileequal(item->label, name))
                    {
                        *pp = item->link;
                        item->link = NULL;
                        po = pp;
                        goto fnd;
                    }
                }

                // Make new item if we have to
                item = (FileItem*)createItem(FXString::null, NULL, NULL, NULL);
                // Append item in list
fnd:
                *pn = item;
                pn = &item->link;

                // Append
                if (item == curitem)
                {
                    current = items.no();
                }
                items.append(item);

                // Update only if forced, or if the item has changed (mtime or ctime)
                if (force || (item->date != filemtime) || (item->cdate != filectime))
                {
                    // Obtain user name
                    usrid = FXSystem::userName(linfo.st_uid);

                    // Obtain group name
                    grpid = FXSystem::groupName(linfo.st_gid);

                    // Permissions (caution : we don't use the FXSystem::modeString() function because
                    // it seems to be incompatible with the info.st_mode format)
                    atts = ::permissions(linfo.st_mode);

                    // Mod time
                    mod = FXSystem::time(timeformat.text(), filemtime);

                    // If we are in trash can, obtain the deletion time and the original path
                    deldate = 0;
                    del = "";
                    ext = "";
                    origpath = "";
                    FXString delstr = "";
                    if (isInTrash)
                    {
                        // Obtain trash base name and sub path
                        FXString subpath = dirname;
                        subpath.erase(0, trashfileslocation.length()+1);
                        FXString trashbasename = subpath.before('/');
                        if (trashbasename == "")
                        {
                            trashbasename = name;
                        }
                        subpath.erase(0, trashbasename.length());

                        // Read the .trashinfo file
                        FILE*    fp;
                        char     line[1024];
                        FXbool   success = true;
                        FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+trashbasename+".trashinfo";
                        if ((fp = fopen(trashinfopathname.text(), "r")) != NULL)
                        {
                            // Read the first three lines and get the strings
                            if (fgets(line, sizeof(line), fp) == NULL)
                            {
                                success = false;
                            }
                            if (fgets(line, sizeof(line), fp) == NULL)
                            {
                                success = false;
                            }
                            if (success)
                            {
                                origpath = line;
                                origpath = origpath.after('=');
                                origpath = origpath.before('\n');
                            }
                            if (fgets(line, sizeof(line), fp) == NULL)
                            {
                                success = false;
                            }
                            if (success)
                            {
                                delstr = line;
                                delstr = delstr.after('=');
                                delstr = delstr.before('\n');
                            }
                            fclose(fp);
                        }

                        // Eventually include sub path in the original path
                        if (subpath == "")
                        {
                            origpath = origpath+subpath;
                        }
                        else
                        {
                            origpath = origpath+subpath+name;
                        }
                        if (delstr == "")
                        {
                            origpath = "";
                        }

                        // Special case
                        if (name == "..")
                        {
                            origpath = "";
                            delstr = "";
                        }

                        // Convert date
                        deldate = deltime(delstr);
                        if (deldate != 0)
                        {
                            del = FXSystem::time(timeformat.text(), deldate);
                        }

                        // Obtain the extension for files only
                        if (!S_ISDIR(linfo.st_mode))
                        {
                            ext = "";
                            if (dirname == trashfileslocation)
                            {
                                ext = FXPath::extension(pathname.rbefore('_'));
                            }
                            if (ext == "")
                            {
                                ext = FXPath::name(pathname).rafter('.', 2).lower();
                                if ((ext == "tar.gz") || (ext == "tar.bz2") || (ext == "tar.xz") || (ext == "tar.z")) // Special cases
                                {
									// Do nothing
                                }
                                else
                                {
                                    ext = FXPath::extension(pathname).lower();
                                }
                            }
                        }
                    }
                    else
                    {
                        // Obtain the extension for files only
                        if (!S_ISDIR(linfo.st_mode))
                        {
                            ext = FXPath::name(pathname).rafter('.', 2).lower();
                            if ((ext == "tar.gz") || (ext == "tar.bz2") || (ext == "tar.xz") || (ext == "tar.z")) // Special cases
                            {
								// Do nothing
                            }
                            else
                            {
                                ext = FXPath::extension(pathname).lower();
                            }
                        }
                    }

                    // Obtain the stat info on the file or the referred file if it is a link
                    if (statrep(pathname.text(), &info) != 0)
                    {
                        // Except in the case of a broken link
                        if (isBrokenLink)
                        {
                            lstatrep(pathname.text(), &info);
                        }
                        else
                        {
                            continue;
                        }
                    }

                    // Set item flags from the obtained info or linfo
                    if (S_ISDIR(info.st_mode))
                    {
                        item->state |= FileItem::FOLDER;
                    }
                    else
                    {
                        item->state &= ~FileItem::FOLDER;
                    }
                    if (S_ISLNK(linfo.st_mode))
                    {
                        item->state |= FileItem::SYMLINK;
                    }
                    else
                    {
                        item->state &= ~FileItem::SYMLINK;
                    }
                    if (S_ISCHR(info.st_mode))
                    {
                        item->state |= FileItem::CHARDEV;
                    }
                    else
                    {
                        item->state &= ~FileItem::CHARDEV;
                    }
                    if (S_ISBLK(info.st_mode))
                    {
                        item->state |= FileItem::BLOCKDEV;
                    }
                    else
                    {
                        item->state &= ~FileItem::BLOCKDEV;
                    }
                    if (S_ISFIFO(info.st_mode))
                    {
                        item->state |= FileItem::FIFO;
                    }
                    else
                    {
                        item->state &= ~FileItem::FIFO;
                    }
                    if (S_ISSOCK(info.st_mode))
                    {
                        item->state |= FileItem::SOCK;
                    }
                    else
                    {
                        item->state &= ~FileItem::SOCK;
                    }
                    if ((info.st_mode&(S_IXUSR|S_IXGRP|S_IXOTH)) && !(S_ISDIR(info.st_mode) || S_ISCHR(info.st_mode) || S_ISBLK(info.st_mode) || S_ISFIFO(info.st_mode) || S_ISSOCK(info.st_mode)))
                    {
                        item->state |= FileItem::EXECUTABLE;
                    }
                    else
                    {
                        item->state &= ~FileItem::EXECUTABLE;
                    }

                    // We can drag items
                    item->state |= FileItem::DRAGGABLE;

                    // Assume no associations
                    fileassoc = NULL;

                    // Determine icons and type
                    if (item->state&FileItem::FOLDER)
                    {
                        if (!::isReadExecutable(pathname))
                        {
                            big = bigfolderlockedicon;
                            mini = minifolderlockedicon;
                            filetype = _("Folder");
                        }
                        else
                        {
                            big = bigfoldericon;
                            mini = minifoldericon;
                            filetype = _("Folder");
                        }
                    }
                    else if (item->state&FileItem::CHARDEV)
                    {
                        big = bigchardevicon;
                        mini = minichardevicon;
                        filetype = _("Character Device");
                    }
                    else if (item->state&FileItem::BLOCKDEV)
                    {
                        big = bigblockdevicon;
                        mini = miniblockdevicon;
                        filetype = _("Block Device");
                    }
                    else if (item->state&FileItem::FIFO)
                    {
                        big = bigpipeicon;
                        mini = minipipeicon;
                        filetype = _("Named Pipe");
                    }
                    else if (item->state&FileItem::SOCK)
                    {
                        big = bigsocketicon;
                        mini = minisocketicon;
                        filetype = _("Socket");
                    }
                    else if (item->state&FileItem::EXECUTABLE)
                    {
                        big = bigexecicon;
                        mini = miniexecicon;
                        filetype = _("Executable");
                        if (associations)
                        {
                            fileassoc = associations->findFileBinding(pathname.text());
                        }
                    }
                    else
                    {
                        big = bigdocicon;
                        mini = minidocicon;
                        filetype = _("Document");
                        if (associations)
                        {
                            // Eventually strip the '_' suffix when we are in trash root
                            if (dirname == trashfileslocation)
                            {
                                FXString stripname = pathname.rbefore('_');
                                if (stripname == "")
                                {
                                    fileassoc = associations->findFileBinding(pathname.text());
                                }
                                else
                                {
                                    fileassoc = associations->findFileBinding(stripname.text());
                                }
                            }
                            else
                            {
                                fileassoc = associations->findFileBinding(pathname.text());
                            }
                        }
                    }

                    // If association is found, use it
                    if (fileassoc)
                    {
						// Don't use associations when the file name is also an extension name (ex: zip, rar, tar, etc.)
						if (fileassoc->key != FXPath::name(pathname))
						{
							if ((fileassoc->extension != "") || !(item->state&FileItem::EXECUTABLE))
							{
								filetype = fileassoc->extension.text();
							}
							if (fileassoc->bigicon)
							{
								big = fileassoc->bigicon;
							}
							if (fileassoc->miniicon)
							{
								mini = fileassoc->miniicon;
							}
						}
                    }

                    // Symbolic links have a specific type
                    if (isBrokenLink)
                    {
                        filetype = _("Broken link");
                    }

                    else if (isLink)
                    {
                        if (associations)
                        {
                            // Don't forget to remove trailing '/' here!
                            fileassoc = associations->findFileBinding(::cleanPath(::readLink(pathname)).text());
                            if (fileassoc && (fileassoc->extension != ""))
                            {
                                filetype = _("Link to ")+fileassoc->extension;
                            }

                            // If no association found, get the link file type from the referred file type
                            else
                            {
                                if (item->state&FileItem::FOLDER)
                                {
                                    filetype = _("Folder");
                                }
                                else if (item->state&FileItem::CHARDEV)
                                {
                                    filetype = _("Character Device");
                                }
                                else if (item->state&FileItem::BLOCKDEV)
                                {
                                    filetype = _("Block Device");
                                }
                                else if (item->state&FileItem::FIFO)
                                {
                                    filetype = _("Named Pipe");
                                }
                                else if (item->state&FileItem::SOCK)
                                {
                                    filetype = _("Socket");
                                }
                                else if (item->state&FileItem::EXECUTABLE)
                                {
                                    filetype = _("Executable");
                                }
                                else
                                {
                                    filetype = _("Document");
                                }

                                filetype = _("Link to ")+filetype;
                            }
                        }
                    }

                    // Don't display the file size for directories
                    FXString hsize;
                    if (S_ISDIR(linfo.st_mode))
                    {
                        hsize = "";
                    }
                    else
                    {
                        char size[64];
#if __WORDSIZE == 64
                        snprintf(size, sizeof(size)-1, "%lu", (FXulong)linfo.st_size);
#else
                        snprintf(size, sizeof(size)-1, "%llu", (FXulong)linfo.st_size);
#endif
                        hsize = ::hSize(size);
                    }

                    // Set item icons
                    item->setBigIcon(big);
                    item->setMiniIcon(mini);

                    // Attempt to load thumbnails for image files
                    if (displaythumbnails)
                    {
                        // Load big icon from file
                        bigthumb = NULL;
                        minithumb = NULL;
                        if (associations)
                        {
                            source = associations->getIconDict()->getIconSource();
                            if (!(item->state&FileItem::FIFO)) // Avoid pipes
                            {
                                bigthumb = source->loadIconFile(pathname);
                            }
                        }

                        if (bigthumb)
                        {
                            register FXuint w = bigthumb->getWidth();
                            register FXuint h = bigthumb->getHeight();

                            // Eventually scale the big icon (best quality)
                            if ((w > MAX_BIGTHUMB_SIZE) || (h > MAX_BIGTHUMB_SIZE))
                            {
                                if (w > h)
                                {
                                    bigthumb->scale(MAX_BIGTHUMB_SIZE, (MAX_BIGTHUMB_SIZE*h)/w, 1);
                                }
                                else
                                {
                                    bigthumb->scale((MAX_BIGTHUMB_SIZE*w)/h, MAX_BIGTHUMB_SIZE, 1);
                                }

                                // Size has changed
                                w = bigthumb->getWidth();
                                h = bigthumb->getHeight();
                            }

                            // Copy the big icon to the mini icon (faster than direct rescaling)
                            minithumb = new FXIcon(getApp());
                            FXColor* tmpdata;
                            if (!FXMEMDUP(&tmpdata, bigthumb->getData(), FXColor, w*h))
                            {
                                throw FXMemoryException(_("Unable to load image"));
                            }
                            minithumb->setData(tmpdata, IMAGE_OWNED, w, h);

                            // Eventually scale the mini icon (best quality)
                            w = minithumb->getWidth();
                            h = minithumb->getHeight();
                            if ((w > MAX_MINITHUMB_SIZE) || (h > MAX_MINITHUMB_SIZE))
                            {
                                if (w > h)
                                {
                                    minithumb->scale(MAX_MINITHUMB_SIZE, (MAX_MINITHUMB_SIZE*h)/w, 1);
                                }
                                else
                                {
                                    minithumb->scale((MAX_MINITHUMB_SIZE*w)/h, MAX_MINITHUMB_SIZE, 1);
                                }
                            }

                            // Set thumbnail icons as owned
                            if (!isLink && !isBrokenLink)
                            {
                                item->setBigIcon(bigthumb, true);
                                item->setMiniIcon(minithumb, true);
                            }
                        }
                    }

                    // Set other item attributes
                    item->size = (FXulong)linfo.st_size;
                    item->assoc = fileassoc;
                    item->date = filemtime;
                    item->cdate = filectime;
                    item->deldate = deldate;

#if defined(linux)
                    // Mounted devices may have a specific icon
                    if (mtdevices->find(pathname.text()))
                    {
                        filetype = _("Mount point");

                        if (streq(mtdevices->find(pathname.text()), "cifs"))
                        {
                            item->setBigIcon(bignfsdriveicon);
                            item->setMiniIcon(nfsdriveicon);
                        }
                        else
                        {
                            item->setBigIcon(bigharddiskicon);
                            item->setMiniIcon(harddiskicon);
                        }
                    }

                    // Devices found in fstab may have a specific icon
                    if (fsdevices->find(pathname.text()))
                    {
                        filetype = _("Mount point");

                        if (streq(fsdevices->find(pathname.text()), "harddisk"))
                        {
                            item->setBigIcon(bigharddiskicon);
                            item->setMiniIcon(harddiskicon);
                        }
                        else if (streq(fsdevices->find(pathname.text()), "nfsdisk"))
                        {
                            item->setBigIcon(bignfsdriveicon);
                            item->setMiniIcon(nfsdriveicon);
                        }
                        else if (streq(fsdevices->find(pathname.text()), "smbdisk"))
                        {
                            item->setBigIcon(bignfsdriveicon);
                            item->setMiniIcon(nfsdriveicon);
                        }
                        else if (streq(fsdevices->find(pathname.text()), "floppy"))
                        {
                            item->setBigIcon(bigfloppyicon);
                            item->setMiniIcon(floppyicon);
                        }
                        else if (streq(fsdevices->find(pathname.text()), "cdrom"))
                        {
                            item->setBigIcon(bigcdromicon);
                            item->setMiniIcon(cdromicon);
                        }
                        else if (streq(fsdevices->find(pathname.text()), "zip"))
                        {
                            item->setBigIcon(bigzipicon);
                            item->setMiniIcon(zipicon);
                        }
                    }
#endif

                    // Update item label
                    // NB : Item del is empty if we are not in trash can
                    //      Item pathname is not displayed but is used in the tooltip
                    item->label.format("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s",
                                       name.text(), hsize.text(), filetype.text(), ext.text(),
                                       mod.text(), usrid.text(), grpid.text(), atts.text(),
                                       origpath.text(), del.text(), pathname.text());

                    // Dotdot folders have a specific icon
                    if ((name[0] == '.') && (name[1] == '.') && (name[2] == 0))
                    {
                        //item->hide();
                        item->setBigIcon(bigfolderupicon);
                        item->setMiniIcon(minifolderupicon);
                    }

                    // Symbolic links have a specific icon
                    if (isLink)
                    {
                        // Broken link
                        if (isBrokenLink)
                        {
                            item->setBigIcon(bigbrokenlinkicon);
                            item->setMiniIcon(minibrokenlinkicon);
                        }
                        else
                        {
                            item->setBigIcon(biglinkicon);
                            item->setMiniIcon(minilinkicon);
                        }
                    }
                }

                // Create item
                if (id())
                {
                    item->create();
                }

                // Refresh the GUI if an image has to be drawn and recompute the icon height
                // Don't redraw if there are too many images
                if (displaythumbnails)
                {
                    if (bigthumb && minithumb && (items.no() < REFRESH_COUNT))
                    {
                        update();
                        recompute();
                        makeItemVisible(0); // Fix some refresh problems
                        repaint();
                    }
                }
            }
            closedir(dirp);
        }
    }

    // Wipe items remaining in list:- they have disappeared!!
    for (item = oldlist; item; item = link)
    {
        link = item->link;
        delete item;
    }

    // Validate
    if (current >= items.no())
    {
        current = -1;
    }
    if (anchor >= items.no())
    {
        anchor = -1;
    }
    if (extent >= items.no())
    {
        extent = -1;
    }

    // Remember new list
    list = newlist;

    // Gotta recalc size of content
    recalc();
}
#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/time.h>

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "startupnotification.h"
#include "FileDialog.h"
#include "FileList.h"
#include "Properties.h"
#include "XFileExplorer.h"
#include "InputDialog.h"
#include "BrowseInputDialog.h"
#include "ArchInputDialog.h"
#include "HistInputDialog.h"
#include "File.h"
#include "MessageBox.h"
#include "OverwriteBox.h"
#include "CommandWindow.h"
#include "ExecuteBox.h"
#include "PathLinker.h"
#include "FilePanel.h"
#include <string>
#include <iostream>

// Duration (in ms) before we can stop refreshing the file list
// Used for file operations on a large list of files
#define STOP_LIST_REFRESH_INTERVAL    5000

// Number of files before stopping the file list refresh
#define STOP_LIST_REFRESH_NBMAX       100


// Clipboard notes :
// The uri-list type used for Xfe is the same as the Gnome uri-list type
// The standard uri-list type is used for KDE and non Gnome / XFCE file managers
// A special uri-list type that containd only "0" (for copy) or "1" (for cut) is used for KDE compatibility


// Global Variables
extern FXMainWindow* mainWindow;
extern FXString      homedir;
extern FXString      xdgdatahome;

// Clipboard
extern FXString clipboard;
FXuint          clipboard_type = 0;


extern char OpenHistory[OPEN_HIST_SIZE][MAX_COMMAND_SIZE];
extern int  OpenNum;
extern char FilterHistory[FILTER_HIST_SIZE][MAX_PATTERN_SIZE];
extern int  FilterNum;
#if defined(linux)
extern FXStringDict* fsdevices;
extern FXStringDict* mtdevices;
extern FXbool        pkg_format;
#endif

extern FXbool allowPopupScroll;
extern FXuint single_click;


// Map
FXDEFMAP(FilePanel) FilePanelMap[] =
{
    FXMAPFUNC(SEL_CLIPBOARD_LOST, 0, FilePanel::onClipboardLost),
    FXMAPFUNC(SEL_CLIPBOARD_GAINED, 0, FilePanel::onClipboardGained),
    FXMAPFUNC(SEL_CLIPBOARD_REQUEST, 0, FilePanel::onClipboardRequest),
    FXMAPFUNC(SEL_TIMEOUT, FilePanel::ID_STOP_LIST_REFRESH_TIMER, FilePanel::onCmdStopListRefreshTimer),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DIRECTORY_UP, FilePanel::onCmdDirectoryUp),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILTER, FilePanel::onCmdItemFilter),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILTER_CURRENT, FilePanel::onCmdItemFilter),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_HOME, FilePanel::onCmdGoHome),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_TRASH, FilePanel::onCmdGoTrash),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_VIEW, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_MIDDLEBUTTONPRESS, FilePanel::ID_FILELIST, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EDIT, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_COMPARE, FilePanel::onCmdCompare),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PROPERTIES, FilePanel::onCmdProperties),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_XTERM, FilePanel::onCmdXTerm),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_DIR, FilePanel::onCmdNewDir),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_FILE, FilePanel::onCmdNewFile),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_SYMLINK, FilePanel::onCmdNewSymlink),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_COPY, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_CUT, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_COPYTO, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_MOVETO, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_RENAME, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_SYMLINK, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_COPY_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_CUT_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADDCOPY_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADDCUT_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PASTE_CLIPBOARD, FilePanel::onCmdPaste),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_TRASH, FilePanel::onCmdFileTrash),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_RESTORE, FilePanel::onCmdFileRestore),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_DELETE, FilePanel::onCmdFileDelete),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_OPEN_WITH, FilePanel::onCmdOpenWith),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_OPEN, FilePanel::onCmdOpen),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_REFRESH, FilePanel::onCmdRefresh),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_BIG_ICONS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_MINI_ICONS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_DETAILS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_TOGGLE_HIDDEN, FilePanel::onCmdToggleHidden),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_TOGGLE_THUMBNAILS, FilePanel::onCmdToggleThumbnails),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SELECT_ALL, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DESELECT_ALL, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SELECT_INVERSE, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADD_TO_ARCH, FilePanel::onCmdAddToArch),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT, FilePanel::onCmdExtract),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT_TO_FOLDER, FilePanel::onCmdExtractToFolder),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT_HERE, FilePanel::onCmdExtractHere),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_RUN_SCRIPT, FilePanel::onCmdRunScript),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_RUN_SCRIPT, FilePanel::onUpdRunScript),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_SCRIPTDIR, FilePanel::onCmdGoScriptDir),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DIR_USAGE, FilePanel::onCmdDirUsage),
    FXMAPFUNC(SEL_RIGHTBUTTONRELEASE, FilePanel::ID_FILELIST, FilePanel::onCmdPopupMenu),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_POPUP_MENU, FilePanel::onCmdPopupMenu),
    FXMAPFUNC(SEL_DOUBLECLICKED, FilePanel::ID_FILELIST, FilePanel::onCmdItemDoubleClicked),
    FXMAPFUNC(SEL_CLICKED, FilePanel::ID_FILELIST, FilePanel::onCmdItemClicked),
    FXMAPFUNC(SEL_FOCUSIN, FilePanel::ID_FILELIST, FilePanel::onCmdFocus),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_STATUS, FilePanel::onUpdStatus),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_DIRECTORY_UP, FilePanel::onUpdUp),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_COPY_CLIPBOARD, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_CUT_CLIPBOARD, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PASTE_CLIPBOARD, FilePanel::onUpdPaste),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PROPERTIES, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_TRASH, FilePanel::onUpdFileTrash),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_RESTORE, FilePanel::onUpdFileRestore),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_GO_TRASH, FilePanel::onUpdGoTrash),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_DELETE, FilePanel::onUpdFileDelete),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_MOVETO, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_COPYTO, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_RENAME, FilePanel::onUpdSelMult),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_COMPARE, FilePanel::onUpdCompare),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_EDIT, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_VIEW, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_OPEN, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_ADD_TO_ARCH, FilePanel::onUpdAddToArch),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_BIG_ICONS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_MINI_ICONS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_DETAILS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_TOGGLE_HIDDEN, FilePanel::onUpdToggleHidden),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_TOGGLE_THUMBNAILS, FilePanel::onUpdToggleThumbnails),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_DIR_USAGE, FilePanel::onUpdDirUsage),
#if defined(linux)
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_MOUNT, FilePanel::onCmdMount),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_UMOUNT, FilePanel::onCmdMount),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_MOUNT, FilePanel::onUpdMount),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_UMOUNT, FilePanel::onUpdUnmount),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_QUERY, FilePanel::onCmdPkgQuery),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_INSTALL, FilePanel::onCmdPkgInstall),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_UNINSTALL, FilePanel::onCmdPkgUninstall),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PKG_QUERY, FilePanel::onUpdPkgQuery),
#endif
};

// Object implementation
FXIMPLEMENT(FilePanel, FXVerticalFrame, FilePanelMap, ARRAYNUMBER(FilePanelMap))

// Construct File Panel
FilePanel::FilePanel(FXWindow* owner, const char* nm, FXComposite* p, DirPanel* dp, FXuint name_size, FXuint size_size, FXuint type_size, FXuint ext_size,
                     FXuint modd_size, FXuint user_size, FXuint grou_size, FXuint attr_size, FXuint deldate_size, FXuint origpath_size, FXbool showthumbs, FXColor listbackcolor, FXColor listforecolor,
                     FXColor attentioncolor, FXbool smoothscroll, FXuint opts, int x, int y, int w, int h) :
    FXVerticalFrame(p, opts, x, y, w, h, 0, 0, 0, 0)
{
    name = nm;
    dirpanel = dp;
    attenclr = attentioncolor;

    // Global container
    FXVerticalFrame* cont = new FXVerticalFrame(this, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // Container for the path linker
    FXHorizontalFrame* pathframe = new FXHorizontalFrame(cont, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0);

    // File list

    // Smooth scrolling
    FXuint options;
    if (smoothscroll)
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS;
    }
    else
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS|SCROLLERS_DONT_TRACK;
    }

    FXHorizontalFrame* cont2 = new FXHorizontalFrame(cont, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_SUNKEN|FRAME_THICK, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    /*FXVerticalFrame* webview = new FXVerticalFrame(cont2, LAYOUT_FIX_WIDTH|LAYOUT_FILL_Y, 0, 0, 200, 0, 0, 0, 0, 0);
    webview->setBackColor(getApp()->getBackColor());

    FXLabel* webviewbg = new FXLabel(webview, "", webviewbgicon, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    webviewbg->setBackColor(getApp()->getBackColor());

    webviewtext = new FXLabel(webview, "Folder", 0, 0, 10, 100, 0, 0, 10, 10, 0, 0);
    webviewtext->setBackColor(getApp()->getBackColor());

    std::cout << webviewtext;
    std::cout << "\n";


    FXHorizontalFrame* webviewsep = new FXHorizontalFrame(webview, LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, 184, 2);
    webviewsep->setBackColor(FXRGB(102,153,204));

    //std::string iconbg = "test";
    //std::string* ptr = &iconbg;

    //FXEvent *ev=(FXEvent*)ptr;
    //FXDCWindow dc(webviewbg,ev);
    //dc.drawIcon(webviewbgicon,10,10);

    FXLabel* webviewicon = new FXLabel(webview, "", bigfoldericon, LAYOUT_FIX_X|LAYOUT_FIX_Y, 16, 16, 0, 0, 0, 0, 0, 0);
    webviewicon->setBackColor(FXRGBA(255,255,255,0));*/

    list = new FileList(owner, cont2, this, ID_FILELIST, showthumbs, options);
    list->setHeaderSize(0, name_size);
    list->setHeaderSize(1, size_size);
    list->setHeaderSize(2, type_size);
    list->setHeaderSize(3, ext_size);
    list->setHeaderSize(4, modd_size);
    list->setHeaderSize(5, user_size);
    list->setHeaderSize(6, grou_size);
    list->setHeaderSize(7, attr_size);
    list->setHeaderSize(8, deldate_size);
    list->setHeaderSize(9, origpath_size);
    list->setTextColor(listforecolor);
    list->setBackColor(listbackcolor);

    // Path text
    pathtext = new TextLabel(pathframe, 0, this, ID_FILELIST, LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0);
    pathtext->setBackColor(getApp()->getBaseColor());

    // Hide path frame if path link/breadcrums are disabled
    show_pathlink = getApp()->reg().readUnsignedEntry("SETTINGS", "show_pathlinker", true);

    if (show_pathlink == false)
    {
         pathframe->hide();
    }



    // Path linker
    pathlink = new PathLinker(pathframe, list, dirpanel->getList(), JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X);
    //FXButton* dummyicon = new FXButton(pathframe, "", minifoldericon, this, 2, BUTTON_TOOLBAR|JUSTIFY_LEFT|LAYOUT_LEFT);


    // Visually indicate if the panel is active
    activeicon = new FXButton(pathframe, "", minifoldericon, this, FilePanel::ID_FILELIST, BUTTON_TOOLBAR|JUSTIFY_LEFT|LAYOUT_LEFT);



    // Status bar
    statusbar = new FXHorizontalFrame(cont, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|LAYOUT_BOTTOM, 0, 0, 0, 0, 0, 0, 0, 0);

    statusbar->setTarget(this);
    statusbar->setSelector(FXSEL(SEL_UPDATE, FilePanel::ID_STATUS));

    FXString key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "filter", "Ctrl-D");

    FXHorizontalFrame* hframe = new FXHorizontalFrame(statusbar, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0);
    statuslabel = new FXLabel(hframe, _("Status"), NULL, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X|FRAME_SUNKEN);
    filterlabel = new FXLabel(hframe, "", NULL, JUSTIFY_LEFT|LAYOUT_LEFT);

    corner = new FXDragCorner(statusbar);

    // Panel separator
    panelsep = new FXHorizontalSeparator(cont, SEPARATOR_GROOVE|LAYOUT_FILL_X);

    // Initializations
    selmult = false;
    current = NULL;

    // Single click navigation
    single_click = getApp()->reg().readUnsignedEntry("SETTINGS", "single_click", SINGLE_CLICK_NONE);
    if (single_click == SINGLE_CLICK_DIR_FILE)
    {
        list->setDefaultCursor(getApp()->getDefaultCursor(DEF_HAND_CURSOR));
    }

    // Dialogs
    operationdialogsingle = NULL;
    operationdialogrename = NULL;
    operationdialogmultiple = NULL;
    newdirdialog = NULL;
    newfiledialog = NULL;
    newlinkdialog = NULL;
    opendialog = NULL;
    archdialog = NULL;
    filterdialog = NULL;
    comparedialog = NULL;

    // Home and trahscan locations
    trashlocation = xdgdatahome+PATHSEPSTRING TRASHPATH;
    trashfileslocation = xdgdatahome + PATHSEPSTRING TRASHFILESPATH;
    trashinfolocation = xdgdatahome + PATHSEPSTRING TRASHINFOPATH;

    // Start location (we return to the start location after each chdir)
    startlocation = FXSystem::getCurrentDirectory();

    // Initialize clipboard flags
    clipboard_locked = false;
    fromPaste = false;

    // Initialize control flag for right click popup menu
    ctrl = false;

    // Initialize the Shift-F10 flag
    shiftf10 = false;

    // Initialize the active panel flag
    isactive = false;

    // Default programs identifiers
    progs["<txtviewer>"] = TXTVIEWER;
    progs["<txteditor>"] = TXTEDITOR;
    progs["<imgviewer>"] = IMGVIEWER;
    progs["<imgeditor>"] = IMGEDITOR;
    progs["<pdfviewer>"] = PDFVIEWER;
    progs["<audioplayer>"] = AUDIOPLAYER;
    progs["<videoplayer>"] = VIDEOPLAYER;
    progs["<archiver>"] = ARCHIVER;
}


// Create X window
void FilePanel::create()
{
    // Register standard uri-list type
    urilistType = getApp()->registerDragType("text/uri-list");

    // Register special uri-list type used for Gnome, XFCE and Xfe
    xfelistType = getApp()->registerDragType("x-special/gnome-copied-files");

    // Register special uri-list type used for KDE
    kdelistType = getApp()->registerDragType("application/x-kde-cutselection");

    // Register standard UTF-8 text type used for file dialogs
    utf8Type = getApp()->registerDragType("UTF8_STRING");

    // Display or hide path linker
    FXbool show_pathlink = getApp()->reg().readUnsignedEntry("SETTINGS", "show_pathlinker", true);
    if (show_pathlink)
    {
        pathtext->hide();
        pathlink->show();
    }
    else
    {
        pathtext->show();
        pathlink->hide();
    }

    FXVerticalFrame::create();
}


// Destructor
FilePanel::~FilePanel()
{
    delete list;
    delete current;
    delete next;
    delete statuslabel;
    delete filterlabel;
    delete statusbar;
    delete panelsep;
    delete pathlink;
    delete newfiledialog;
    delete newlinkdialog;
    delete newdirdialog;
    delete opendialog;
    delete archdialog;
    delete filterdialog;
    delete comparedialog;
    delete operationdialogsingle;
    delete operationdialogrename;
    delete operationdialogmultiple;
    delete pathtext;
}


// Make panel active
void FilePanel::setActive()
{
    // Set active icon
    // activeicon->setIcon(greenbuttonicon);
    activeicon->setIcon(NULL);
    activeicon->setTipText(_("Panel is active"));

    pathlink->focus();
    current = this;

    // Make dirpanel point on the current directory,
    // but only if Filepanel and Dirpanel directories are different
    if (dirpanel->getDirectory() != current->list->getDirectory())
    {
        dirpanel->setDirectory(current->list->getDirectory(), true);
    }

    // Make dirpanel inactive
    dirpanel->setInactive();

    next->setInactive();
    list->setFocus();

    isactive = true;
}


// Make panel inactive
void FilePanel::setInactive(FXbool force)
{
    // Set active icon
    // activeicon->setIcon(graybuttonicon);
    activeicon->setIcon(NULL);
    activeicon->setTipText(_("Activate panel"));

    // By default we set the panel inactive
    if (force)
    {
        current = next;
        list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), NULL);

        isactive = false;
    }
}


// Make panel focus (i.e. active) when clicked
long FilePanel::onCmdFocus(FXObject* sender, FXSelector sel, void* ptr)
{
    setActive();
    return(1);
}


// Set Pointer to Another FilePanel
void FilePanel::Next(FilePanel* nxt)
{
    next = nxt;
}


// Show or hide drag corner
void FilePanel::showCorner(FXbool show)
{
    if (show)
    {
        corner->show();
    }
    else
    {
        corner->hide();
    }
}


// Show or hide active icon
void FilePanel::showActiveIcon(FXbool show)
{
    if (show)
    {
        activeicon->show();
    }
    else
    {
        activeicon->hide();
    }
}


// Update location history when changing directory (home, up or double click)
void FilePanel::updateLocation()
{
    FXString    item;
    int         i = 0;
    FXComboBox* address = ((XFileExplorer*)mainWindow)->getAddressBox();

    address->setNumVisible(5);
    int      count = address->getNumItems();
    FXString p = list->getDirectory();

    // Remember latest directory in the location address
    if (!count)
    {
        count++;
        address->insertItem(0, address->getText());
    }
    while (i < count)
    {
        item = address->getItem(i++);
        if (streq((const char*)&p[0], (const char*)&item[0]))
        {
            i--;
            break;
        }
    }
    if (i == count)
    {
        address->insertItem(0, list->getDirectory());
        //webviewtext->setText(list->getDirectory());
        //webviewtext->setTextColor(FXRGB(255,255,255));
        //std::cout << webviewtext;
    }

    // Make current directory visible to avoid scrolling again
    list->makeItemVisible(list->getCurrentItem());
}


// We now really do have the clipboard, keep clipboard content
long FilePanel::onClipboardGained(FXObject* sender, FXSelector sel, void* ptr)
{
    FXVerticalFrame::onClipboardGained(sender, sel, ptr);
    return(1);
}


// We lost the clipboard
long FilePanel::onClipboardLost(FXObject* sender, FXSelector sel, void* ptr)
{
    FXVerticalFrame::onClipboardLost(sender, sel, ptr);
    return(1);
}


// Somebody wants our clipboard content
long FilePanel::onClipboardRequest(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    FXuchar* data;
    FXuint   len;

    // Perhaps the target wants to supply its own data for the clipboard
    if (FXVerticalFrame::onClipboardRequest(sender, sel, ptr))
    {
        return(1);
    }

    // Clipboard target is xfelistType (Xfe, Gnome or XFCE)
    if (event->target == xfelistType)
    {
        // Don't modify the clipboard if we are called from updPaste()
        if (!clipboard_locked)
        {
            // Prepend "copy" or "cut" as in the Gnome way and avoid duplicating these strings
            if ((clipboard.find("copy\n") < 0) && (clipboard.find("cut\n") < 0))
            {
                if (clipboard_type == CUT_CLIPBOARD)
                {
                    clipboard = "cut\n" + clipboard;
                }
                else
                {
                    clipboard = "copy\n" + clipboard;
                }
            }
        }

        // Return clipboard content
        if (event->target == xfelistType)
        {
            if (!clipboard.empty())
            {
                len = clipboard.length();
                FXMEMDUP(&data, clipboard.text(), FXuchar, len);
                setDNDData(FROM_CLIPBOARD, event->target, data, len);

                // Return because xfelistType is not compatible with other types
                return(1);
            }
        }
    }

    // Clipboard target is kdelisType (KDE)
    if (event->target == kdelistType)
    {
        // The only data to be passed in this case is "0" for copy and "1" for cut
        // The uri data are passed using the standard uri-list type
        FXString flag;
        if (clipboard_type == CUT_CLIPBOARD)
        {
            flag = "1";
        }
        else
        {
            flag = "0";
        }

        // Return clipboard content
        if (event->target == kdelistType)
        {
            FXMEMDUP(&data, flag.text(), FXuchar, 1);
            setDNDData(FROM_CLIPBOARD, event->target, data, 1);
        }
    }

    // Clipboard target is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    if (event->target == urilistType)
    {
        if (!clipboard.empty())
        {
            len = clipboard.length();
            FXMEMDUP(&data, clipboard.text(), FXuchar, len);
            setDNDData(FROM_CLIPBOARD, event->target, data, len);

            return(1);
        }
    }

    // Clipboard target is utf8Type (to paste file pathes as text to other applications)
    if (event->target == utf8Type)
    {
        if (!clipboard.empty())
        {
            int      beg = 0, end = 0;
            FXString str = "";
            FXString pathname, url;

            // Clipboard don't contain 'copy\n' or 'cut\n' as first line
            if ((clipboard.find("copy\n") < 0) && (clipboard.find("cut\n") < 0))
            {
                // Remove the 'file:' prefix for each file path
                while (1)
                {
                    end = clipboard.find('\n', end);
                    if (end < 0) // Last line
                    {
                        end = clipboard.length();
                        url = clipboard.mid(beg, end-beg+1);
                        pathname = FXURL::decode(FXURL::fileFromURL(url));
                        str += pathname;
                        break;
                    }
                    url = clipboard.mid(beg, end-beg+1);
                    pathname = FXURL::decode(FXURL::fileFromURL(url));
                    str += pathname;
                    end++;
                    beg = end;
                }
                end = str.length();
            }

            // Clipboard contains 'copy\n' or 'cut\n' as first line, thus skip it
            else
            {
                // Start after the 'copy\n' or 'cut\n' prefix
                end = clipboard.find('\n', 0);
                end++;
                beg = end;

                // Remove the 'file:' prefix for each file path
                while (1)
                {
                    end = clipboard.find('\n', end);
                    if (end < 0) // Last line
                    {
                        end = clipboard.length();
                        url = clipboard.mid(beg, end-beg+1);
                        pathname = FXURL::decode(FXURL::fileFromURL(url));
                        str += pathname;
                        break;
                    }
                    url = clipboard.mid(beg, end-beg+1);
                    pathname = FXURL::decode(FXURL::fileFromURL(url));
                    str += pathname;
                    end++;
                    beg = end;
                }
                end = str.length();
            }

            if (!str.empty())
            {
                len = str.length();
                FXMEMDUP(&data, str.text(), FXuchar, len);
                setDNDData(FROM_CLIPBOARD, event->target, data, len);

                return(1);
            }
        }
    }
    return(0);
}


// Copy or cut to clipboard (and add copy / add cut)
long FilePanel::onCmdCopyCut(FXObject*, FXSelector sel, void*)
{
    FXString name, curdir;

    // Clear clipboard if normal copy or cut
    if ((FXSELID(sel) == ID_COPY_CLIPBOARD) || (FXSELID(sel) == ID_CUT_CLIPBOARD))
    {
        clipboard.clear();
    }

    // Add an '\n' at the end if addcopy or addcut
    else
    {
        clipboard += '\n';
    }

    // Clipboard type
    if ((FXSELID(sel) == ID_CUT_CLIPBOARD) || (FXSELID(sel) == ID_ADDCUT_CLIPBOARD))
    {
        clipboard_type = CUT_CLIPBOARD;
    }
    else
    {
        clipboard_type = COPY_CLIPBOARD;
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        // Construct the uri list of files and fill the clipboard with it
        curdir = current->list->getDirectory();

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                name = current->list->getItemText(u).text();
                name = name.section('\t', 0);
                if (curdir == ROOTDIR)
                {
                    clipboard += FXURL::encode(::fileToURI(curdir+name))+"\n";
                }
                else
                {
                    clipboard += FXURL::encode(::fileToURI(curdir+PATHSEPSTRING+name))+"\n";
                }
            }
        }
    }

    // Remove the last \n of the list, for compatibility with some file managers (e.g. nautilus, nemo)
    clipboard.erase(clipboard.length()-1);

    // Acquire the clipboard
    FXDragType types[4];
    types[0] = xfelistType;
    types[1] = kdelistType;
    types[2] = urilistType;
    types[3] = utf8Type;
    if (acquireClipboard(types, 4))
    {
        return(0);
    }

    return(1);
}


// Paste file(s) from clipboard
long FilePanel::onCmdPaste(FXObject*, FXSelector sel, void*)
{
    FXuchar* data;
    FXuint   len;
    int      beg, end, pos;
    FXString chaine, url, param;
    int      num = 0;
    FXbool   from_kde = false;

    // If source is xfelistType (Gnome, XFCE, or Xfe app)
    if (getDNDData(FROM_CLIPBOARD, xfelistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';

        clipboard = (char*)data;

        // Loop over clipboard items
        for (beg = 0; beg < clipboard.length(); beg = end+1)
        {
            if ((end = clipboard.find("\n", beg)) < 0)
            {
                end = clipboard.length();
            }

            // Obtain item url
            url = clipboard.mid(beg, end-beg);

            // Eventually remove the trailing '\r' if any
            if ((pos = url.rfind('\r')) > 0)
            {
                url.erase(pos);
            }

            // Process first item
            if (num == 0)
            {
                // First item should be "copy" or "cut"
                if (url == "copy")
                {
                    clipboard_type = COPY_CLIPBOARD;
                    num++;
                }
                else if (url == "cut")
                {
                    clipboard_type = CUT_CLIPBOARD;
                    num++;
                }

                // If first item is not "copy" nor "cut", process it as a normal url
                // and use default clipboard type
                else
                {
                    // Update the param string
                    param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";

                    // Add one more because the first line "copy" or "cut" was not present
                    num += 2;
                }
            }

            // Process other items
            else
            {
                // Update the param string
                param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";
                num++;
            }
        }

        // Construct the final param string passed to the file management routine
        param = current->list->getDirectory()+"\n" + FXStringVal(num-1) + "\n" + param;

        // Copy or cut operation depending on the clipboard type
        switch (clipboard_type)
        {
        case COPY_CLIPBOARD:
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_COPY);
            break;

        case CUT_CLIPBOARD:
            clipboard.clear();
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_CUT);
            break;
        }
        fromPaste = true;
        handle(this, sel, (void*)param.text());

        // Free data pointer
        FXFREE(&data);

        // Return here because xfelistType is not compatible with other types
        return(1);
    }

    // If source type is kdelistType (KDE)
    if (getDNDData(FROM_CLIPBOARD, kdelistType, data, len))
    {
        from_kde = true;

        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        clipboard = (char*)data;

        // Obtain clipboard type (copy or cut)
        if (clipboard == "1")
        {
            clipboard_type = CUT_CLIPBOARD;
        }
        else
        {
            clipboard_type = COPY_CLIPBOARD;
        }

        FXFREE(&data);
    }


    // If source type is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    if (getDNDData(FROM_CLIPBOARD, urilistType, data, len))
    {
        // For non KDE apps, set action to copy
        if (!from_kde)
        {
            clipboard_type = COPY_CLIPBOARD;
        }

        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        clipboard = (char*)data;

        // Loop over clipboard items
        for (beg = 0; beg < clipboard.length(); beg = end+1)
        {
            if ((end = clipboard.find("\n", beg)) < 0)
            {
                end = clipboard.length();
            }

            // Obtain item url
            url = clipboard.mid(beg, end-beg);

            // Eventually remove the trailing '\r' if any
            if ((pos = url.rfind('\r')) > 0)
            {
                url.erase(pos);
            }

            // Update the param string
            param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";
            num++;
        }

        // Construct the final param string passed to the file management routine
        param = current->list->getDirectory()+"\n" + FXStringVal(num) + "\n" + param;

        // Copy or cut operation depending on the clipboard type
        switch (clipboard_type)
        {
        case COPY_CLIPBOARD:
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_COPY);
            break;

        case CUT_CLIPBOARD:
            clipboard.clear();
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_CUT);
            break;
        }
        fromPaste = true;
        handle(this, sel, (void*)param.text());

        FXFREE(&data);
        return(1);
    }
    return(0);
}


// Execute file with an optional confirm dialog
void FilePanel::execFile(FXString pathname)
{
    int      ret;
    FXString cmd, cmdname;

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // File is executable, but is it a text file?
    FXString str = mimetype(pathname);
    FXbool   isTextFile = true;
    if (strstr(str.text(), "charset=binary"))
    {
        isTextFile = false;
    }

    // With confirmation dialog
    FXbool confirm_execute = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_execute", true);
    if (isTextFile && (confirm_execute == 1))
    {
        FXString msg;
        msg.format(_("File %s is an executable text file, what do you want to do?"), pathname.text());
        ExecuteBox* dlg = new ExecuteBox(this, _("Confirm Execute"), msg);
        FXuint      answer = dlg->execute(PLACEMENT_CURSOR);
        delete dlg;

        // Execute
        if (answer == EXECBOX_CLICKED_EXECUTE)
        {
            cmdname = FXPath::name(pathname);
            cmd = ::quote(pathname);
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // Execute in console mode
        if (answer == EXECBOX_CLICKED_CONSOLE)
        {
            ret = chdir(current->list->getDirectory().text());
            if (ret < 0)
            {
                int errcode = errno;
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
                }
            }

            cmdname = FXPath::name(pathname);
            cmd = ::quote(pathname);

            // Make and show command window
            // The CommandWindow object will delete itself when closed!
            CommandWindow* cmdwin = new CommandWindow(getApp(), _("Command log"), cmd, 30, 80);
            cmdwin->create();
            cmdwin->setIcon(runicon);

            ret = chdir(startlocation.text());
            if (ret < 0)
            {
                int errcode = errno;
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
                }
            }
        }

        // Edit
        if (answer == EXECBOX_CLICKED_EDIT)
        {
            FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
            cmd = txteditor;
            cmdname = cmd;

            // If command exists, run it
            if (::existCommand(cmdname))
            {
                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
            }

            // If command does not exist, call the "Open with..." dialog
            else
            {
                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
            }
        }
    }

    // Without confirmation dialog
    else
    {
        cmdname = FXPath::name(pathname);
        cmd = ::quote(pathname);
#ifdef STARTUP_NOTIFICATION
        runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
        runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
    }
}


// Double Click on File Item
long FilePanel::onCmdItemDoubleClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    FXString cmd, cmdname, filename, pathname;

    // Wait cursor
    getApp()->beginWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);

    // At most one item selected
    if (current->list->getNumSelectedItems() <= 1)
    {
        FXlong item = (FXlong)ptr;
        if (item > -1)
        {
#ifdef STARTUP_NOTIFICATION
            // Startup notification option and exceptions (if any)
            FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
            FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

            // Default programs
            FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
            FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
            FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
            FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
            FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
            FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
            FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
            FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

            // File name and path
            filename = list->getItemFilename(item);
            pathname = list->getItemPathname(item);

            // If directory, open the directory
            if (list->isItemDirectory(item))
            {
                // Does not have access
                if (!::isReadExecutable(pathname))
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _(" Permission to: %s denied."), pathname.text());
                    getApp()->endWaitCursor();
		    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                    return(0);
                }
                if (filename == "..")
                {
                    list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
                    //list->hide();
                }
                else
                {
                    list->setDirectory(pathname);
                }

                // Change directory in tree list
                dirpanel->setDirectory(pathname, true);
                current->updatePath();

                // Update location history
                updateLocation();
            }
            else if (list->isItemFile(item))
            {
                // Update associations dictionary
                FileDict*  assocdict = new FileDict(getApp());
                FileAssoc* association = assocdict->findFileBinding(pathname.text());

                // If there is an association
                if (association)
                {
                    // Use it to open the file
                    if (association->command.section(',', 0) != "")
                    {
                        cmdname = association->command.section(',', 0);

                        // Use a default program if possible
                        switch (progs[cmdname])
                        {
                        case TXTVIEWER:
                            cmdname = txtviewer;
                            break;

                        case TXTEDITOR:
                            cmdname = txteditor;
                            break;

                        case IMGVIEWER:
                            cmdname = imgviewer;
                            break;

                        case IMGEDITOR:
                            cmdname = imgeditor;
                            break;

                        case PDFVIEWER:
                            cmdname = pdfviewer;
                            break;

                        case AUDIOPLAYER:
                            cmdname = audioplayer;
                            break;

                        case VIDEOPLAYER:
                            cmdname = videoplayer;
                            break;

                        case ARCHIVER:
                            cmdname = archiver;
                            break;

                        case NONE: // No program found
                            ;
                            break;
                        }

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
			    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // Or execute the file
                    else if (list->isItemExecutable(item))
                    {
                        execFile(pathname);
                    }

                    // Or call the "Open with..." dialog
                    else
                    {
                        getApp()->endWaitCursor();
			mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }

                // If no association but executable
                else if (list->isItemExecutable(item))
                {
                    execFile(pathname);
                }

                // Other cases
                else
                {
                    getApp()->endWaitCursor();
		    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                    current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                }
            }
        }
    }

    // More than one selected files
    else
    {
        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN), NULL);
    }

    getApp()->endWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);

    return(1);
}


// Single click on File Item
long FilePanel::onCmdItemClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    // Make panel active
    setActive();

    if (single_click != SINGLE_CLICK_NONE)
    {
        // Default programs
        FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
        FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
        FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
        FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
        FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
        FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
        FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
        FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

        // In detailed mode, avoid single click when mouse cursor is not over the first column
        int    x, y;
        FXuint state;
        getCursorPosition(x, y, state);
        FXbool allow = true;
        if (!(list->getListStyle()&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS)) && ((x-list->getXPosition()) > list->getHeaderSize(0)))
        {
            allow = false;
        }

        // Single click with control or shift
        if (state&(CONTROLMASK|SHIFTMASK))
        {
            return(1);
        }

        // Single click without control or shift
        else
        {
            FXString cmd, cmdname, filename, pathname;

            // Wait cursor
            getApp()->beginWaitCursor();

#ifdef STARTUP_NOTIFICATION
            // Startup notification option and exceptions (if any)
            FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
            FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

            FXlong item = (FXlong)ptr;
            if (item > -1)
            {
                // File name and path
                filename = list->getItemFilename(item);
                pathname = list->getItemPathname(item);

                // If directory, open the directory
                if ((single_click != SINGLE_CLICK_NONE) && list->isItemDirectory(item) && allow)
                {
                    // Does not have access
                    if (!::isReadExecutable(pathname))
                    {
                        MessageBox::error(this, BOX_OK_SU, _("Error"), _(" Permission to: %s denied."), pathname.text());
                        getApp()->endWaitCursor();
                        return(0);
                    }
                    if (filename == "..")
                    {
                        list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
                    }
                    else
                    {
                        list->setDirectory(pathname);
                    }

                    // Change directory in tree list
                    dirpanel->setDirectory(pathname, true);
                    current->updatePath();

                    // Update location history
                    updateLocation();
                }

                // If file, use the association if any
                else if ((single_click == SINGLE_CLICK_DIR_FILE) && list->isItemFile(item) && allow)
                {
                    // Update associations dictionary
                    FileDict*  assocdict = new FileDict(getApp());
                    FileAssoc* association = assocdict->findFileBinding(pathname.text());

                    // If there is an association
                    if (association)
                    {
                        // Use it to open the file
                        if (association->command.section(',', 0) != "")
                        {
                            cmdname = association->command.section(',', 0);

                            // Use a default program if possible
                            switch (progs[cmdname])
                            {
                            case TXTVIEWER:
                                cmdname = txtviewer;
                                break;

                            case TXTEDITOR:
                                cmdname = txteditor;
                                break;

                            case IMGVIEWER:
                                cmdname = imgviewer;
                                break;

                            case IMGEDITOR:
                                cmdname = imgeditor;
                                break;

                            case PDFVIEWER:
                                cmdname = pdfviewer;
                                break;

                            case AUDIOPLAYER:
                                cmdname = audioplayer;
                                break;

                            case VIDEOPLAYER:
                                cmdname = videoplayer;
                                break;

                            case ARCHIVER:
                                cmdname = archiver;
                                break;

                            case NONE: // No program found
                                ;
                                break;
                            }

                            // If command exists, run it
                            if (::existCommand(cmdname))
                            {
                                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                            }

                            // If command does not exist, call the "Open with..." dialog
                            else
                            {
                                getApp()->endWaitCursor();
                                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                            }
                        }

                        // Or execute the file
                        else if (list->isItemExecutable(item))
                        {
                            execFile(pathname);
                        }

                        // Or call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // If no association but executable
                    else if (list->isItemExecutable(item))
                    {
                        execFile(pathname);
                    }

                    // Other cases
                    else
                    {
                        getApp()->endWaitCursor();
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }
            }
            getApp()->endWaitCursor();
        }
    }
    return(1);
}


// Go to parent directory
long FilePanel::onCmdDirectoryUp(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
    current->list->setFocus();
    dirpanel->setDirectory(current->list->getDirectory(), true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Go to home directory
long FilePanel::onCmdGoHome(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setDirectory(homedir);
    current->list->setFocus();
    dirpanel->setDirectory(homedir, true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Go to trash directory
long FilePanel::onCmdGoTrash(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setDirectory(trashfileslocation);
    current->list->setFocus();
    dirpanel->setDirectory(trashfileslocation, true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Set the flag that allows to stop the file list refresh
long FilePanel::onCmdStopListRefreshTimer(FXObject*, FXSelector, void*)
{
    stopListRefresh = true;

    return(0);
}


// Copy/Move/Rename/Symlink file(s)
long FilePanel::onCmdFileMan(FXObject* sender, FXSelector sel, void* ptr)
{
    int      num;
    FXString src, targetdir, target, name, source;
    int      firstitem = 0, lastitem = 0;

    // Focus on this panel list
    current->list->setFocus();

    // Confirmation dialog?
    FXbool ask_before_copy = getApp()->reg().readUnsignedEntry("OPTIONS", "ask_before_copy", true);

    // If we are we called from the paste command, get the parameters from the pointer
    if (fromPaste)
    {
        // Reset the flag
        fromPaste = false;

        // Get the parameters
        FXString str = (char*)ptr;
        targetdir = str.section('\n', 0);
        num = FXUIntVal(str.section('\n', 1));
        src = str.after('\n', 2);

        // If no item in clipboard, return
        if (num <= 0)
        {
            return(0);
        }

        // If there is a selected directory in file panel, use it as target directory
        if (current->list->getNumSelectedItems() == 1)
        {
            int item = current->list->getCurrentItem();
            if (current->list->isItemDirectory(item))
            {
                targetdir = list->getItemPathname(item);
            }
        }
    }

    // Obtain the parameters from the file panel
    else
    {
        // Current directory
        FXString curdir = current->list->getDirectory();

        // Number of selected items
        num = current->list->getNumSelectedItems();

        // If no item, return
        if (num <= 0)
        {
            return(0);
        }

        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        // Obtain the list of source files and the target directory
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                if (firstitem == 0)
                {
                    firstitem = u;
                }
                lastitem = u;
                name = current->list->getItemText(u).text();
                name = name.section('\t', 0);
                src += curdir+PATHSEPSTRING+name+"\n";
            }
        }
        targetdir = current->next->list->getDirectory();

        if (!current->next->shown() || (FXSELID(sel) == ID_FILE_RENAME))
        {
            targetdir = current->list->getDirectory();
        }
    }

    // Number of items in the FileList
    int numitems = current->list->getNumItems();

    // Name and directory of the first source file
    source = src.section('\n', 0);
    name = FXPath::name(source);
    FXString dir = FXPath::directory(source);

    // Initialize target name
    if (targetdir != ROOTDIR)
    {
        target = targetdir+PATHSEPSTRING;
    }
    else
    {
        target = targetdir;
    }

    // Configure the command, title, message, etc.
    FXIcon*  icon = NULL;
    FXString command, title, message;
    if (FXSELID(sel) == ID_FILE_COPY)
    {
        command = "copy";
        title = _("Copy");
        icon = copy_bigicon;
        if (num == 1)
        {
            message = _("Copy ");
            message += source;
            if (::isFile(source))
            {
                target += name;
            }

            // Source and target are identical => add a suffix to the name
            FXString tgt = ::cleanPath(target); // Remove trailing / if any
            if ((::identical(source, tgt) && (tgt != current->list->getDirectory())) || // Check we are not within target
                (::isDirectory(source) && (source == tgt+PATHSEPSTRING+FXPath::name(source))))
            {
                target = ::buildCopyName(source);
            }
        }
        else
        {
            message.format(_("Copy %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_RENAME)
    {
        command = "rename";
        title = _("Rename");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Rename ");
            message += name;
            target = name;
            title = _("Rename");
        }
        else
        {
            return(0);
        }
    }
    if (FXSELID(sel) == ID_FILE_COPYTO)
    {
        command = "copy";
        title = _("Copy");
        icon = copy_bigicon;
        if (num == 1)
        {
            message = _("Copy ");
            message += source;
        }
        else
        {
            message.format(_("Copy %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_MOVETO)
    {
        command = "move";
        title = _("Move");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Move ");
            message += source;
            title = _("Move");
        }
        else
        {
            message.format(_("Move %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_CUT)
    {
        command = "move";
        title = _("Move");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Move ");
            message += source;
            if (::isFile(source))
            {
                target += name;
            }
            title = _("Move");
        }
        else
        {
            message.format(_("Move %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_SYMLINK)
    {
        command = "symlink";
        title = _("Symlink");
        icon = link_bigicon;
        if (num == 1)
        {
            message = _("Symlink ");
            message += source;
            target += name;
        }
        else
        {
            message.format(_("Symlink %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }

    // File operation dialog, if needed
    if (ask_before_copy || (source == target) || (FXSELID(sel) == ID_FILE_COPYTO) || (FXSELID(sel) == ID_FILE_MOVETO) || (FXSELID(sel) == ID_FILE_RENAME) || (FXSELID(sel) == ID_FILE_SYMLINK))
    {
        if (num == 1)
        {
            if (FXSELID(sel) == ID_FILE_RENAME)
            {
                if (operationdialogrename == NULL)
                {
                    operationdialogrename = new InputDialog(this, "", "", title, _("To:"), icon);
                }
                operationdialogrename->setTitle(title);
                operationdialogrename->setIcon(icon);
				operationdialogrename->setMessage(message);
                operationdialogrename->setText(target);

                if (::isDirectory(source))  // directory
                {
                    operationdialogrename->selectAll();
                }
                else
                {
                    int pos = target.rfind('.');
                    if (pos <= 0)
                    {
                        operationdialogrename->selectAll(); // no extension or dot file
                    }
                    else
                    {
                        operationdialogrename->setSelection(0, pos);
                    }
                }

                int rc = 1;
                rc = operationdialogrename->execute(PLACEMENT_CURSOR);
                target = operationdialogrename->getText();
                
                // Target name contains '/'
                if (target.contains(PATHSEPCHAR))
                {
					MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in file or folder names, operation cancelled"));
					return(0);
				}

                if (!rc)
                {
                    return(0);
                }
            }
            else
            {
                if (operationdialogsingle == NULL)
                {
                    operationdialogsingle = new BrowseInputDialog(this, "", "", title, _("To:"), icon, BROWSE_INPUT_MIXED);
                }
                operationdialogsingle->setTitle(title);
                operationdialogsingle->setIcon(icon);
                operationdialogsingle->setMessage(message);
                operationdialogsingle->setText(target);

                // Select file name without path
                if (FXSELID(sel) == ID_FILE_SYMLINK)
                {
                    int pos = target.rfind(PATHSEPSTRING);
                    if (pos >= 0)
                    {
                        operationdialogsingle->setSelection(pos+1, target.length());
                    }
                }

                operationdialogsingle->setDirectory(targetdir);
                int rc = 1;
                rc = operationdialogsingle->execute(PLACEMENT_CURSOR);
                target = operationdialogsingle->getText();
                if (!rc)
                {
                    return(0);
                }
            }
        }
        else
        {
            if (operationdialogmultiple == NULL)
            {
                operationdialogmultiple = new BrowseInputDialog(this, "", "", title, _("To folder:"), icon, BROWSE_INPUT_FOLDER);
            }
            operationdialogmultiple->setTitle(title);
            operationdialogmultiple->setIcon(icon);
            operationdialogmultiple->setMessage(message);
            operationdialogmultiple->setText(target);
            operationdialogmultiple->CursorEnd();
            operationdialogmultiple->setDirectory(targetdir);
            int rc = 1;
            rc = operationdialogmultiple->execute(PLACEMENT_CURSOR);
            target = operationdialogmultiple->getText();
            if (!rc)
            {
                return(0);
            }
        }
    }

    // Nothing entered
    if (target == "")
    {
        MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
        return(0);
    }

    // Update target and target parent directory
	target = ::filePath(target,current->list->getDirectory());
	if (::isDirectory(target))
	{
		targetdir = target;
	}
	else
	{
		targetdir = FXPath::directory(target);
	}

    // Target parent directory doesn't exist
    if (!::exists(targetdir))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), targetdir.text());
        return(0);
    }

    // Target parent directory not writable
    if (!::isWritable(targetdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetdir.text());
        return(0);
    }

    // Target parent directory is not a directory
    if (!::isDirectory(targetdir))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("%s is not a folder"), targetdir.text());
        return(0);
    }

    // Multiple sources and non existent destination
    if ((num > 1) && !::exists(target))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), target.text());
        return(0);
    }

    // Multiple sources and target is a file
    if ((num > 1) && ::isFile(target))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("%s is not a folder"), target.text());
        return(0);
    }

    // Target is a directory and is not writable
    if (::isDirectory(target) && !::isWritable(target))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), target.text());
        return(0);
    }

    // Target is a file and its parent directory is not writable
    if (::isFile(target) && !::isWritable(targetdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetdir.text());
        return(0);
    }

    // One source
    File* f = NULL;
    int   ret;
    if (num == 1)
    {
        // An empty source file name corresponds to the ".." file
        // Don't perform any file operation on it!
        if (source == "")
        {
            return(0);
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        if (command == "copy")
        {
            f = new File(this, _("File copy"), COPY, num);
            f->create();

            // If target file is located at trash location, also create the corresponding trashinfo file
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && (target == trashfileslocation))
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(source, trashfileslocation);

                // Adjust target name to get the _N suffix if any
                FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                // Create trashinfo file
                createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                // Copy source to trash target
                ret = f->copy(source, trashtarget);
            }

            // Copy source to target
            else
            {
                ret = f->copy(source, target);
            }

            // An unknown error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
            }
        }
        else if (command == "rename")
        {
            f = new File(this, _("File rename"), RENAME, num);
            f->create();
            ret = f->rename(source, target);

            // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
            {
                FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                ::unlink(trashinfopathname.text());
            }
        }
        else if (command == "move")
        {
            f = new File(this, _("File move"), MOVE, num);
            f->create();

            // If target file is located at trash location, also create the corresponding trashinfo file
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && (target == trashfileslocation))
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(source, trashfileslocation);

                // Adjust target name to get the _N suffix if any
                FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                // Create trashinfo file
                createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                // Move source to trash target
                ret = f->move(source, trashtarget);
            }

            // Move source to target
            else
            {
                ret = f->move(source, target);
            }

            // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
            // Do it silently and don't report any error if it fails
            if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
            {
                FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                ::unlink(trashinfopathname.text());
            }

            // An unknown error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
            }
        }
        else if (command == "symlink")
        {
            f = new File(this, _("Symlink"), SYMLINK, num);
            f->create();
            f->symlink(source, target);
        }
        // Shouldn't happen
        else
        {
            exit(EXIT_FAILURE);
        }

        getApp()->endWaitCursor();
        delete f;
    }

    // Multiple sources
    // Note : rename cannot be used in this case!
    else if (num > 1)
    {
        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        if (command == "copy")
        {
            f = new File(this, _("File copy"), COPY, num);
        }
        else if (command == "move")
        {
            f = new File(this, _("File move"), MOVE, num);
        }
        else if (command == "symlink")
        {
            f = new File(this, _("Symlink"), SYMLINK, num);
        }
        // Shouldn't happen
        else
        {
            exit(EXIT_FAILURE);
        }
        f->create();

        // Initialize file list stop refresh timer and flag
        stopListRefresh = false;
        getApp()->addTimeout(this, ID_STOP_LIST_REFRESH_TIMER, STOP_LIST_REFRESH_INTERVAL);

        // Loop on the multiple files
        for (int i = 0; i < num; i++)
        {
            // Stop refreshing the file list if file operation is long and has many files
            // This avoids flickering and speeds up things a bit
            if (stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
            {
                // Force a last refresh if current panel is destination
                if (current->getDirectory() == targetdir)
                {
                    current->list->onCmdRefresh(0, 0, 0);
                }

                // Force a last refresh if next panel is destination
                if (next->getDirectory() == targetdir)
                {
                    next->list->onCmdRefresh(0, 0, 0);
                }

                // Tell the dir and file list to not refresh anymore
                setAllowRefresh(false);
                next->setAllowRefresh(false);
                dirpanel->setAllowDirsizeRefresh(false);

                // Don't need to stop again
                stopListRefresh = false;
            }

            // Individual source file
            source = src.section('\n', i);

            // File could have already been moved above in the tree
            if (!::exists(source))
            {
                continue;
            }

            // An empty file name corresponds to the ".." file (why?)
            // Don't perform any file operation on it!
            if (source != "")
            {
                if (command == "copy")
                {
                    // If target file is located at trash location, also create the corresponding trashinfo file
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (target == trashfileslocation))
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(source, trashfileslocation);

                        // Adjust target name to get the _N suffix if any
                        FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                        // Create trashinfo file
                        createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                        // Copy source to trash target
                        ret = f->copy(source, trashtarget);
                    }

                    // Copy source to target
                    else
                    {
                        ret = f->copy(source, target);
                    }

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
                        break;
                    }
                }
                else if (command == "move")
                {
                    // If target file is located at trash location, also create the corresponding trashinfo file
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (target == trashfileslocation))
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(source, trashfileslocation);

                        // Adjust target name to get the _N suffix if any
                        FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                        // Create trashinfo file
                        createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                        // Move source to trash target
                        ret = f->move(source, trashtarget);
                    }

                    // Move source to target
                    else
                    {
                        ret = f->move(source, target);
                    }

                    // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
                    // Do it silently and don't report any error if it fails
                    if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
                    {
                        FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                        ::unlink(trashinfopathname.text());
                    }

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
                        break;
                    }
                }
                else if (command == "symlink")
                {
                    ret = f->symlink(source, target);

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the symlink operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Symlink operation cancelled!"));
                        break;
                    }
                }
                // Shouldn't happen
                else
                {
                    exit(EXIT_FAILURE);
                }
            }
        }

        // Reinit timer and refresh flags
        getApp()->removeTimeout(this, ID_STOP_LIST_REFRESH_TIMER);
        current->setAllowRefresh(true);
        next->setAllowRefresh(true);
        dirpanel->setAllowDirsizeRefresh(true);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panels refresh
    next->onCmdRefresh(0, 0, 0);
    current->onCmdRefresh(0, 0, 0);

    // Enable previous or last selected item for keyboard navigation
    if (((FXSELID(sel) == ID_FILE_MOVETO) || (FXSELID(sel) == ID_FILE_RENAME)) && (current->list->getNumItems() < numitems))
    {
        firstitem = (firstitem < 1) ? 0 : firstitem-1;
        current->list->enableItem(firstitem);
        current->list->setCurrentItem(firstitem);
    }
    else
    {
        current->list->enableItem(lastitem);
        current->list->setCurrentItem(lastitem);
    }

    return(1);
}


// Trash files from the file list or the tree list
long FilePanel::onCmdFileTrash(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();

    FXbool confirm_trash = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_trash", true);

    // If we don't have permission to write to the parent directory
    if (!::isWritable(dir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
        return(0);
    }

    // If we don't have permission to write to the trash directory
    if (!::isWritable(trashfileslocation))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to trash location %s: Permission denied"), trashfileslocation.text());
        return(0);
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        if (confirm_trash)
        {
            FXString message;
            if (num == 1)
            {
                FXString pathname;
                for (int u = 0; u < current->list->getNumItems(); u++)
                {
                    if (current->list->isItemSelected(u))
                    {
                        pathname = current->list->getItemPathname(u);
                    }
                }
                if (::isDirectory(pathname))
                {
                    message.format(_("Move folder %s to trash can?"), pathname.text());
                }
                else
                {
                    message.format(_("Move file %s to trash can?"), pathname.text());
                }
            }
            else
            {
                message.format(_("Move %s selected object(s) to trash can?"), FXStringVal(num).text());
            }

            MessageBox box(this, _("Confirm Trash"), message, delete_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
            if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
            {
                return(0);
            }
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Move to trash"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Overwrite initialisations
        FXbool overwrite = false;
        FXbool overwrite_all = false;
        FXbool skip_all = false;

        // Delete selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // If we don't have permission to write to the file
                if (!::isWritable(pathname))
                {
                    // Overwrite dialog if necessary
                    if (!(overwrite_all | skip_all))
                    {
                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("File %s is write-protected, move it anyway to trash can?"), pathname.text());
                        
                        if (num ==1)
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Trash"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;	
							if (answer == 1)
							{
								overwrite = true;
							}
							else
							{
								goto end;
							}
						}  
                        else
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Trash"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Overwrite
							case 1:
								overwrite = true;
								break;

							// Overwrite all
							case 2:
								overwrite_all = true;
								break;

							// Skip
							case 3:
								overwrite = false;
								break;

							// Skip all
							case 4:
								skip_all = true;
								break;
							}
							
						}
                    }
                    if ((overwrite | overwrite_all) & !skip_all)
                    {
                        // Caution!! Don't delete parent directory!!
                        if (filename != "..")
                        {
                            // Trash files path name
                            FXString trashpathname = createTrashpathname(pathname, trashfileslocation);

                            // Create trashinfo file
                            createTrashinfo(pathname, trashpathname, trashfileslocation, trashinfolocation);

                            // Move file to trash files location
                            int ret = f->move(pathname, trashpathname);

                            // An error has occurred
                            if ((ret == 0) && !f->isCancelled())
                            {
                                f->hideProgressDialog();
                                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move to trash operation!"));
                                break;
                            }
                        }
                    }
                    f->showProgressDialog();
                }

                // If we have permission to write
                else
                {
                    // Caution!! Don't delete parent directory!!
                    if (filename != "..")
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(pathname, trashfileslocation);

                        // Create trashinfo file
                        createTrashinfo(pathname, trashpathname, trashfileslocation, trashinfolocation);

                        // Move file to trash files location
                        int ret = f->move(pathname, trashpathname);

                        // An error has occurred
                        if ((ret == 0) && !f->isCancelled())
                        {
                            f->hideProgressDialog();
                            MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move to trash operation!"));
                            break;
                        }
                    }
                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Move to trash file operation cancelled!"));
                        break;
                    }
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// Restore files from trash can
long FilePanel::onCmdFileRestore(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();
    FXbool   confirm_trash = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_trash", true);

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Restore from trash"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Restore (i.e. move to their original location) selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // Don't restore '..' directory
                if (filename != "..")
                {
                    // Obtain trash base name and sub path
                    FXString subpath = pathname;
                    subpath.erase(0, trashfileslocation.length()+1);
                    FXString trashbasename = subpath.before('/');
                    if (trashbasename == "")
                    {
                        trashbasename = name;
                    }
                    subpath.erase(0, trashbasename.length());

                    // Read the .trashinfo file
                    FILE*    fp;
                    char     line[1024];
                    FXbool   success = true;
                    FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+trashbasename+".trashinfo";
                    FXString origpathname = "";

                    if ((fp = fopen(trashinfopathname.text(), "r")) != NULL)
                    {
                        // Read the first two lines and get the strings
                        if (fgets(line, sizeof(line), fp) == NULL)
                        {
                            success = false;
                        }
                        if (fgets(line, sizeof(line), fp) == NULL)
                        {
                            success = false;
                        }
                        if (success)
                        {
                            origpathname = line;
                            origpathname = origpathname.after('=');
                            origpathname = origpathname.before('\n');
                        }
                        fclose(fp);
                        origpathname = origpathname+subpath;
                    }

                    // Confirm restore dialog
                    if (confirm_trash && (u == firstitem))
                    {
                        FXString message;
                        if (num == 1)
                        {
                            if (::isDirectory(pathname))
                            {
                                message.format(_("Restore folder %s to its original location %s ?"), filename.text(), origpathname.text());
                            }
                            else
                            {
                                message.format(_("Restore file %s to its original location %s ?"), filename.text(), origpathname.text());
                            }
                        }
                        else
                        {
                            message.format(_("Restore %s selected object(s) to their original locations?"), FXStringVal(num).text());
                        }
                        f->hideProgressDialog();
                        MessageBox box(this, _("Confirm Restore"), message, restore_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
                        if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
                        {
                            getApp()->endWaitCursor();
                            delete f;
                            return(0);
                        }
                        f->showProgressDialog();
                    }

                    if (origpathname == "")
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("Restore information not available for %s"), pathname.text());
                        goto end;
                    }

                    // If parent dir of the original location does not exist
                    FXString origparentdir = FXPath::directory(origpathname);
                    if (!::exists(origparentdir))
                    {
                        // Ask the user if he wants to create it
                        f->hideProgressDialog();
                        FXString message;
                        message.format(_("Parent folder %s does not exist, do you want to create it?"), origparentdir.text());
                        MessageBox box(this, _("Confirm Restore"), message, restore_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
                        if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
                        {
                            goto end;
                        }
                        else
                        {
                            errno = 0;
                            int ret = mkpath(origparentdir.text(), 0755);
                            int errcode = errno;
                            if (ret == -1)
                            {
                                f->hideProgressDialog();
                                if (errcode)
                                {
                                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't create folder %s: %s"), origparentdir.text(), strerror(errcode));
                                }
                                else
                                {
                                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't create folder %s"), origparentdir.text());
                                }
                                goto end;
                            }
                            f->showProgressDialog();
                        }
                    }

                    // Move file to original location (with restore option)
                    int ret = f->move(pathname, origpathname, true);

                    // An error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the restore from trash operation!"));
                        goto end;
                    }

                    // Silently remove trashinfo file
                    FXString trashfilespathname = trashfileslocation+PATHSEPSTRING+trashbasename;
                    if ((pathname == trashfilespathname) && !::exists(trashfilespathname))
                    {
                        ::unlink(trashinfopathname.text());
                    }
                }
                // If action is cancelled in progress dialog
                if (f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Warning"), _("Restore from trash file operation cancelled!"));
                    goto end;
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// Definitively delete files from the file list or the tree list (no trash can)
long FilePanel::onCmdFileDelete(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();

    FXbool confirm_del = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete", true);
    FXbool confirm_del_emptydir = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete_emptydir", true);

    // If we don't have permission to write to the parent directory
    if (!::isWritable(dir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
        return(0);
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        if (confirm_del)
        {
            FXString message;
            if (num == 1)
            {
                FXString pathname;
                for (int u = 0; u < current->list->getNumItems(); u++)
                {
                    if (current->list->isItemSelected(u))
                    {
                        pathname = current->list->getItemPathname(u);
                    }
                }
                if (::isDirectory(pathname))
                {
                    message.format(_("Definitively delete folder %s ?"), pathname.text());
                }
                else
                {
                    message.format(_("Definitively delete file %s ?"), pathname.text());
                }
            }
            else
            {
                message.format(_("Definitively delete %s selected object(s)?"), FXStringVal(num).text());
            }
            MessageBox box(this, _("Confirm Delete"), message, delete_big_permicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
            if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
            {
                return(0);
            }
        }
        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("File delete"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Overwrite initialisations
        FXbool overwrite = false;
        FXbool overwrite_all = false;
        FXbool skip_all = false;
        FXbool ask_del_empty = true;
        FXbool skip_all_del_emptydir = false;

        // Delete selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // Confirm empty directory deletion
                if (confirm_del & confirm_del_emptydir & ask_del_empty)
                {
                    if ((::isEmptyDir(pathname) == 0) && !::isLink(pathname))
                    {
                        if (skip_all_del_emptydir)
                        {
                            continue;
                        }

                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("Folder %s is not empty, delete it anyway?"), pathname.text());

                        if (num ==1)
                        {
                        	OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							
							if (answer == 0)
							{
								goto end;
							}
						}
                        
                        else
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Yes
							case 1:
								break;

							// Yes for all
							case 2:
								ask_del_empty = false;
								break;

							// Skip
							case 3:
								continue;
								break;

							// Skip all
							case 4:
								skip_all_del_emptydir = true;
								continue;
								break;
							}
						}
						f->showProgressDialog();
                    }
                }

                // If we don't have permission to write to the file
                if (!::isWritable(pathname))
                {
                    // Overwrite dialog if necessary
                    if (!(overwrite_all | skip_all))
                    {
                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("File %s is write-protected, delete it anyway?"), pathname.text());
  
  						if (num == 1)
  						{
                        	OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							if (answer == 1)
							{
								overwrite = true;
							}
							else
							{
								goto end;
							}							
						}
  
 						else
 						{
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Yes
							case 1:
								overwrite = true;
								break;

							// Yes for all
							case 2:
								overwrite_all = true;
								break;

							// Skip
							case 3:
								overwrite = false;
								break;

							// Skip all
							case 4:
								skip_all = true;
								break;
							}
						} 
                    }
                    if ((overwrite | overwrite_all) & !skip_all)
                    {
                        // Caution!! Don't delete parent directory!!
                        if (filename != "..")
                        {
                            // Definitively remove file or folder
                            f->remove(pathname);
                        }
                    }
                    f->showProgressDialog();
                }

                // If we have permission to write
                else
                {
                    // Caution!! Don't delete parent directory!!
                    if (filename != "..")
                    {
                        // Definitively remove file or folder
                        f->remove(pathname);

                        // If is located at trash location, try to also remove the corresponding trashinfo file if it exists
                        // Do it silently and don't report any error if it fails
                        FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                        if (use_trash_can && (pathname.left(trashfileslocation.length()) == trashfileslocation))
                        {
                            FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+filename+".trashinfo";
                            ::unlink(trashinfopathname.text());
                        }
                    }
                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Delete file operation cancelled!"));
                        break;
                    }
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// View/Edit files
long FilePanel::onCmdEdit(FXObject*, FXSelector s, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString   pathname, samecmd, cmd, cmdname, itemslist = " ";
    FileAssoc* association;
    FXbool     same = true;
    FXbool     first = true;

    current->list->setFocus();

    if (current->list->getNumSelectedItems() == 0)
    {
        getApp()->endWaitCursor();
        return(0);
    }

    FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
    FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
    FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
    FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
    FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
    FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
    FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
    FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

    // Update associations dictionary
    FileDict* assocdict = new FileDict(getApp());

    // Check if all files have the same association
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            // Increment number of selected items
            pathname = current->list->getItemPathname(u);
            association = assocdict->findFileBinding(pathname.text());

            // If there is an association
            if (association)
            {
                // Use it to edit/view the files
                if (FXSELID(s) == ID_EDIT) // Edit
                {
                    cmd = association->command.section(',', 2);

                    // Use a default editor if possible
                    switch (progs[cmd])
                    {
                    case TXTEDITOR:
                        cmd = txteditor;
                        break;

                    case IMGEDITOR:
                        cmd = imgeditor;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No default editor found
                        ;
                        break;
                    }

                    if (cmd.length() == 0)
                    {
                        cmd = txteditor;
                    }
                }
                else // Any other is View
                {
                    cmd = association->command.section(',', 1);

                    // Use a default viewer if possible
                    switch (progs[cmd])
                    {
                    case TXTVIEWER:
                        cmd = txtviewer;
                        break;

                    case IMGVIEWER:
                        cmd = imgviewer;
                        break;

                    case PDFVIEWER:
                        cmd = pdfviewer;
                        break;

                    case AUDIOPLAYER:
                        cmd = audioplayer;
                        break;

                    case VIDEOPLAYER:
                        cmd = videoplayer;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No default viewer found
                        ;
                        break;
                    }

                    if (cmd.length() == 0)
                    {
                        cmd = txtviewer;
                    }
                }
                if (cmd.text() != NULL)
                {
                    // First selected item
                    if (first)
                    {
                        samecmd = cmd;
                        first = false;
                    }

                    if (samecmd != cmd)
                    {
                        same = false;
                        break;
                    }

                    // List of selected items
                    itemslist += ::quote(pathname) + " ";
                }
                else
                {
                    same = false;
                    break;
                }
            }

            // No association
            else
            {
                same = false;
                break;
            }
        }
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // Same association for all files : execute the associated or default editor or viewer
    if (same)
    {
        cmdname = samecmd;

        // If command exists, run it
        if (::existCommand(cmdname))
        {
            cmd = cmdname+itemslist;
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
        }
    }

    // Files have different associations : handle them separately
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);

                // Only View / Edit regular files (not directories)
                if (::isFile(pathname))
                {
                    association = assocdict->findFileBinding(pathname.text());

                    // If there is an association
                    if (association)
                    {
                        // Use it to edit/view the file
                        if (FXSELID(s) == ID_EDIT) // Edit
                        {
                            cmd = association->command.section(',', 2);

                            // Use a default editor if possible
                            switch (progs[cmd])
                            {
                            case TXTEDITOR:
                                cmd = txteditor;
                                break;

                            case IMGEDITOR:
                                cmd = imgeditor;
                                break;

                            case ARCHIVER:
                                cmd = archiver;
                                break;
                            }

                            if (cmd.length() == 0)
                            {
                                cmd = txteditor;
                            }
                        }
                        else // Any other is View
                        {
                            cmd = association->command.section(',', 1);

                            // Use a default viewer if possible
                            switch (progs[cmd])
                            {
                            case TXTVIEWER:
                                cmd = txtviewer;
                                break;

                            case IMGVIEWER:
                                cmd = imgviewer;
                                break;

                            case PDFVIEWER:
                                cmd = pdfviewer;
                                break;

                            case AUDIOPLAYER:
                                cmd = audioplayer;
                                break;

                            case VIDEOPLAYER:
                                cmd = videoplayer;
                                break;

                            case ARCHIVER:
                                cmd = archiver;
                                break;

                            case NONE: // No default viewer found
                                ;
                                break;
                            }

                            if (cmd.length() == 0)
                            {
                                cmd = txtviewer;
                            }
                        }

                        if (cmd.text() != NULL)
                        {
                            cmdname = cmd;

                            // If command exists, run it
                            if (::existCommand(cmdname))
                            {
                                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                            }

                            // If command does not exist, call the "Open with..." dialog
                            else
                            {
                                getApp()->endWaitCursor();
                                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                            }
                        }
                    }

                    // No association
                    else
                    {
                        if (FXSELID(s) == ID_EDIT)
                        {
                            cmd = txteditor;
                        }
                        else
                        {
                            cmd = txtviewer;
                        }

                        cmdname = cmd;

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }
                }
            }
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Compare two files
long FilePanel::onCmdCompare(FXObject*, FXSelector s, void*)
{
    current->list->setFocus();
    int num = current->list->getNumSelectedItems();

    // Only one or two selected items can be handled
    if ((num != 1) && (num != 2))
    {
        getApp()->endWaitCursor();
        return(0);
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    FXString filecomparator = getApp()->reg().readStringEntry("PROGS", "filecomparator", DEFAULT_FILECOMPARATOR);
    FXString pathname, cmd, cmdname, itemslist = " ";

    // One selected item
    if (num == 1)
    {
        // Get the selected item
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                itemslist += ::quote(pathname) + " ";
            }
        }

        // Open a dialog to select the other item to be compared
        if (comparedialog == NULL)
        {
            comparedialog = new BrowseInputDialog(this, "", "", _("Compare"), _("With:"), bigcompareicon, BROWSE_INPUT_FILE);
        }
        comparedialog->setIcon(bigcompareicon);
        comparedialog->setMessage(pathname);
        comparedialog->setText("");
        int rc = 1;
        rc = comparedialog->execute(PLACEMENT_CURSOR);

        // Get item path and add it to the list
        FXString str = comparedialog->getText();
        itemslist += ::quote(str);
        if (!rc || (str == ""))
        {
            return(0);
        }
    }

    // Two selected items
    else if (num == 2)
    {
        // Get the two selected items
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                itemslist += ::quote(pathname) + " ";
            }
        }
    }

    // Wait cursor
    getApp()->beginWaitCursor();

    // If command exists, run it
    cmdname = filecomparator;
    if (::existCommand(cmdname))
    {
        cmd = cmdname+itemslist;
#ifdef STARTUP_NOTIFICATION
        runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
        runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
    }

    // If command does not exist, issue an error message
    else
    {
        getApp()->endWaitCursor();
        MessageBox::error(this, BOX_OK, _("Error"), _("Program %s not found. Please define a file comparator program in the Preferences dialog!"), cmdname.text());
    }

    getApp()->endWaitCursor();

    return(1);
}


// File or directory properties
long FilePanel::onCmdProperties(FXObject* sender, FXSelector, void*)
{
    int ret;
    int num, itm;

    current->list->setFocus();

    // If no selected files in the file list, use the selected folder from the tree list (if any)
    num = current->list->getNumSelectedItems(&itm);
    if (num == 0)
    {
		return(0);
    }

    // There is one selected file in the file list
    else if (num == 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        FXString path = current->list->getDirectory();
        FXString filename = current->list->getItemText(itm);
        filename = filename.section('\t', 0);
        PropertiesBox* attrdlg = new PropertiesBox(this, filename, path);
        attrdlg->create();
        attrdlg->show(PLACEMENT_OWNER);
    }

    // There are multiple selected files in the file list
    else if (num > 1)
    {
        ret = chdir(current->list->getDirectory().text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
            }

            return(0);
        }

        FXString  path = current->list->getDirectory();
        FXString* files = new FXString[num];
        FXString* paths = new FXString[num];

        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        int i = 0;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                files[i] = current->list->getItemText(u).section('\t', 0);
                paths[i] = path;
                i++;
            }
        }

        PropertiesBox* attrdlg = new PropertiesBox(this, files, num, paths);
        attrdlg->create();
        attrdlg->show(PLACEMENT_OWNER);
        
        ret = chdir(startlocation.text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
            }

            return(0);
        }
    }

    // Force panel refresh
    return(1);
}


// Create new directory
long FilePanel::onCmdNewDir(FXObject*, FXSelector, void*)
{
    FXString dirname = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString dirpath = current->list->getDirectory();
    if (dirpath != ROOTDIR)
    {
        dirpath += PATHSEPSTRING;
    }

    if (newdirdialog == NULL)
    {
        newdirdialog = new InputDialog(this, "", _("Create new folder:"), _("New Folder"),"",bignewfoldericon);
    }
    newdirdialog->setText("");

    // Accept was pressed
    if (newdirdialog->execute(PLACEMENT_CURSOR))
    {
        if (newdirdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("Folder name is empty, operation cancelled"));
            return(0);
        }

		// Directory name contains '/'
		if (newdirdialog->getText().contains(PATHSEPCHAR))
		{
			MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in folder names, operation cancelled"));
			return(0);
		}

        dirname = dirpath+newdirdialog->getText();
        if (dirname != dirpath)
        {
            // Create the new dir according to the current umask
            int mask;
            mask = umask(0);
            umask(mask);

            // Note that the umask value is in decimal (511 means octal 0777)
            errno = 0;
            int ret = ::mkdir(dirname.text(), 511 & ~mask);
            int errcode = errno;
            if (ret == -1)
            {
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s: %s"), dirname.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s"), dirname.text());
                }
                return(0);
            }
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == dirname)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Create new file
long FilePanel::onCmdNewFile(FXObject*, FXSelector, void*)
{
    FXString filename = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString pathname = current->list->getDirectory();
    if (pathname != ROOTDIR)
    {
        pathname += PATHSEPSTRING;
    }

    if (newfiledialog == NULL)
    {
        newfiledialog = new InputDialog(this, "", _("Create new file:"), _("New File"), "", bignewfileicon, false);
    }
    newfiledialog->setText("");

    // Accept was pressed
    if (newfiledialog->execute(PLACEMENT_CURSOR))
    {
        if (newfiledialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

		// File name contains '/'
		if (newfiledialog->getText().contains(PATHSEPCHAR))
		{
			MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in file names, operation cancelled"));
			return(0);
		}

        filename = pathname+newfiledialog->getText();
        FILE* file;
        if (filename != pathname)
        {
            // Test some error conditions
            if (::exists(filename))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("File or folder %s already exists"), filename.text());
                return(0);
            }
            // Create the new file
            errno = 0;
            if (!(file = fopen(filename.text(), "w+")) || fclose(file))
            {
                if (errno)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create file %s: %s"), filename.text(), strerror(errno));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create file %s"), filename.text());
                }
                return(0);
            }
            // Change the file permissions according to the current umask
            int mask;
            mask = umask(0);
            umask(mask);
            errno = 0;
            int rc = chmod(filename.text(), 438 & ~mask);
            int errcode = errno;
            if (rc)
            {
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't set permissions in %s: %s"), filename.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't set permissions in %s"), filename.text());
                }
            }
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == filename)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Create new symbolic link
long FilePanel::onCmdNewSymlink(FXObject*, FXSelector, void*)
{
    FXString linkname = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString linkpath = current->list->getDirectory();
    if (linkpath != ROOTDIR)
    {
        linkpath += PATHSEPSTRING;
    }

    if (newlinkdialog == NULL)
    {
        newlinkdialog = new InputDialog(this, "", _("Create new symbolic link:"), _("New Symlink"), "", bignewlinkicon, false);
    }
    newlinkdialog->setText("");

    // Accept was pressed
    if (newlinkdialog->execute(PLACEMENT_CURSOR))
    {
        if (newlinkdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }
        linkname = linkpath+newlinkdialog->getText();
        File* f;
        if (linkname != linkpath)
        {
            // Test some error conditions
            if (::exists(linkname))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("File or folder %s already exists"), linkname.text());
                return(0);
            }

            // Select target
            FileDialog browse(this, _("Select the symlink refered file or folder"));
            browse.setDirectory(linkpath);
            browse.setSelectMode(SELECT_FILE_MIXED);
            if (browse.execute())
            {
                FXString linksource = browse.getFilename();

                // Source does not exist
                if (!::exists(linksource))
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Symlink source %s does not exist"), linksource.text());
                    return(0);
                }

                f = new File(this, _("Symlink"), SYMLINK);
                f->create();
                f->symlink(linksource, linkname);
                delete f;
            }
            //else
            //return 0;
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == linkname)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Open single or multiple files
long FilePanel::onCmdOpen(FXObject*, FXSelector, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString   pathname, samecmd, cmd, cmdname, itemslist = " ";
    FileAssoc* association;
    FXbool     same = true;
    FXbool     first = true;

    current->list->setFocus();
    if (current->list->getNumSelectedItems() == 0)
    {
        getApp()->endWaitCursor();
        return(0);
    }

    // Default programs
    FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
    FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
    FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
    FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
    FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
    FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
    FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
    FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

    // Update associations dictionary
    FileDict* assocdict = new FileDict(getApp());

    // Check if all files have the same association
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            // Increment number of selected items
            pathname = current->list->getItemPathname(u);

            // If directory, skip it
            if (::isDirectory(pathname))
            {
                continue;
            }

            // If association found
            association = assocdict->findFileBinding(pathname.text());
            if (association)
            {
                cmd = association->command.section(',', 0);

                // Use a default program if possible
                switch (progs[cmd])
                {
                case TXTVIEWER:
                    cmd = txtviewer;
                    break;

                case TXTEDITOR:
                    cmd = txteditor;
                    break;

                case IMGVIEWER:
                    cmd = imgviewer;
                    break;

                case IMGEDITOR:
                    cmd = imgeditor;
                    break;

                case PDFVIEWER:
                    cmd = pdfviewer;
                    break;

                case AUDIOPLAYER:
                    cmd = audioplayer;
                    break;

                case VIDEOPLAYER:
                    cmd = videoplayer;
                    break;

                case ARCHIVER:
                    cmd = archiver;
                    break;

                case NONE: // No program found
                    ;
                    break;
                }

                if (cmd != "")
                {
                    // First selected item
                    if (first)
                    {
                        samecmd = cmd;
                        first = false;
                    }

                    if (samecmd != cmd)
                    {
                        same = false;
                        break;
                    }

                    // List of selected items
                    itemslist += ::quote(pathname) + " ";
                }
                else
                {
                    same = false;
                    break;
                }
            }
            else
            {
                same = false;
                break;
            }
        }
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // Same command for all files : open them
    if (same && (itemslist != " "))
    {
        cmdname = samecmd;

        // If command exists, run it
        if (::existCommand(cmdname))
        {
            cmd = samecmd+itemslist;
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
        }
    }

    // Files have different commands : handle them separately
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);

                // If directory, skip it
                if (::isDirectory(pathname))
                {
                    continue;
                }

                association = assocdict->findFileBinding(pathname.text());
                if (association)
                {
                    // Use association to open the file
                    cmd = association->command.section(',', 0);

                    // Use a default program if possible
                    switch (progs[cmd])
                    {
                    case TXTVIEWER:
                        cmd = txtviewer;
                        break;

                    case TXTEDITOR:
                        cmd = txteditor;
                        break;

                    case IMGVIEWER:
                        cmd = imgviewer;
                        break;

                    case IMGEDITOR:
                        cmd = imgeditor;
                        break;

                    case PDFVIEWER:
                        cmd = pdfviewer;
                        break;

                    case AUDIOPLAYER:
                        cmd = audioplayer;
                        break;

                    case VIDEOPLAYER:
                        cmd = videoplayer;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No program found
                        ;
                        break;
                    }

                    if (cmd != "")
                    {
                        cmdname = cmd;

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // Or execute the file
                    else if (current->list->isItemExecutable(u))
                    {
                        execFile(pathname);
                    }

                    // Or call the "Open with..." dialog
                    else
                    {
                        getApp()->endWaitCursor();
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }

                // If no association but executable
                else if (current->list->isItemExecutable(u))
                {
                    execFile(pathname);
                }

                // Other cases
                else
                {
                    getApp()->endWaitCursor();
                    current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                }
            }
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Open with
long FilePanel::onCmdOpenWith(FXObject*, FXSelector, void*)
{
    char** str = NULL;

    current->list->setFocus();

    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    FXString cmd = "", cmdname;
    if (opendialog == NULL)
    {
        opendialog = new HistInputDialog(this, "", _("Open selected file(s) with:"), _("Open With"), "", bigfileopenicon, HIST_INPUT_EXECUTABLE_FILE, true, _("A&ssociate"));
    }
    opendialog->setText(cmd);

    // Dialog with history list and associate checkbox
    opendialog->CursorEnd();
    opendialog->selectAll();
    opendialog->clearItems();
    for (int i = 0; i < OpenNum; i++)
    {
        opendialog->appendItem(OpenHistory[i]);
    }
    opendialog->setDirectory(ROOTDIR);
    opendialog->sortItems();
    if (opendialog->execute())
    {
        cmd = opendialog->getText();
        if (cmd == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Handles "associate" checkbox for "open with..." dialog
                if (opendialog->getOption())
                {
                    FXString filename = current->list->getItemFilename(u);
                    FXString ext = filename.rafter('.', 2).lower();

                    if ((ext == "tar.gz") || (ext == "tar.bz2") || (ext == "tar.xz") || (ext == "tar.z")) // Special cases
                    {
                    }
                    else
                    {
                        ext = FXPath::extension(filename).lower();
                    }

                    if (ext == "")
                    {
                        ext = FXPath::name(filename);
                    }

                    FileAssoc* association = current->list->getItemAssoc(u);

                    if (association)
                    {
                        // Update existing association
                        FXString oldfileassoc = getApp()->reg().readStringEntry("FILETYPES", ext.text(), "");
                        oldfileassoc.erase(0, oldfileassoc.section(';', 0).section(',', 0).length());
                        oldfileassoc.prepend(opendialog->getText());
                        getApp()->reg().writeStringEntry("FILETYPES", ext.text(), oldfileassoc.text());

                        // Handle file association
                        str = new char* [2];
                        str[0] = new char[strlen(ext.text())+1];
                        str[1] = new char[strlen(oldfileassoc.text())+1];
                        strlcpy(str[0], ext.text(), ext.length()+1);
                        strlcpy(str[1], oldfileassoc.text(), oldfileassoc.length()+1);
                        mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ASSOC), str);
                    }
                    else
                    {
                        // New association
                        FXString newcmd = opendialog->getText().append(";Document;;;;");
                        getApp()->reg().writeStringEntry("FILETYPES", ext.text(), newcmd.text());

                        // Handle file association
                        str = new char* [2];
                        str[0] = new char[strlen(ext.text())+1];
                        str[1] = new char[strlen(newcmd.text())+1];
                        strlcpy(str[0], ext.text(), ext.length()+1);
                        strlcpy(str[1], newcmd.text(), newcmd.length()+1);
                        mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ASSOC), str);
                    }
                }
                // End

                FXString pathname = current->list->getItemPathname(u);
                cmdname = cmd;
                cmd += " ";
                cmd = cmd+::quote(pathname);
            }
        }

        // Run command if it exists
        getApp()->beginWaitCursor();

#ifdef STARTUP_NOTIFICATION
        // Startup notification option and exceptions (if any)
        FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
        FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

        // If command exists, run it
        if (::existCommand(cmdname))
#ifdef STARTUP_NOTIFICATION
        {
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
        }
#else
        {
            runcmd(cmd, current->list->getDirectory(), startlocation);
        }
#endif
        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
            return(1);
        }

        // Update history list
        OpenNum = opendialog->getHistorySize();
        cmd = opendialog->getText();

        // Check if cmd is a new string, i.e. is not already in history
        FXbool newstr = true;
        for (int i = 0; i < OpenNum-1; i++)
        {
            if (streq(OpenHistory[i], cmd.text()))
            {
                newstr = false;
                break;
            }
        }

        // History limit reached
        if (OpenNum > OPEN_HIST_SIZE)
        {
            OpenNum--;
        }

        // Restore original history order
        opendialog->clearItems();
        for (int i = 0; i < OpenNum; i++)
        {
            opendialog->appendItem(OpenHistory[i]);
		}

        // New string
        if (newstr)
        {
            // FIFO
            strlcpy(OpenHistory[0], cmd.text(), cmd.length()+1);
            for (int i = 1; i < OpenNum; i++)
            {
                strlcpy(OpenHistory[i], opendialog->getHistoryItem(i-1).text(), opendialog->getHistoryItem(i-1).length()+1);
            }
        }

        getApp()->endWaitCursor();
    }

    return(1);
}


long FilePanel::onCmdItemFilter(FXObject* o, FXSelector sel, void*)
{
    if (FilterNum == 0)
    {
        strlcpy(FilterHistory[FilterNum], "*", 2);
        FilterNum++;
    }

    int      i;
    FXString pat = list->getPattern();
    if (filterdialog == NULL)
    {
        filterdialog = new HistInputDialog(this, pat, _("Show files:"), _("Filter"), "", bigfiltericon, HIST_INPUT_FILE);
    }
    filterdialog->CursorEnd();
    filterdialog->selectAll();
    filterdialog->clearItems();
    for (int i = 0; i < FilterNum; i++)
    {
        filterdialog->appendItem(FilterHistory[i]);
    }
    filterdialog->sortItems();

    if (filterdialog->execute() && ((pat = filterdialog->getText()) != ""))
    {
        // Change file list patten
        if (FXSELID(sel) == ID_FILTER_CURRENT)
        {
            current->list->setPattern(pat);
        }
        else
        {
            list->setPattern(pat);
        }

        FXbool newstr = true;
        for (i = 0; i < FilterNum; i++)
        {
            if (streq(FilterHistory[i], pat.text()))
            {
                newstr = false;
                break;
            }
        }
        // Append new string to the list bottom
        if (newstr && (FilterNum < FILTER_HIST_SIZE))
        {
            strlcpy(FilterHistory[FilterNum], pat.text(), pat.length()+1);
            FilterNum++;
        }
    }

    list->setFocus();
    return(1);
}


// Panel context menu
long FilePanel::onCmdPopupMenu(FXObject* o, FXSelector s, void* p)
{
    // Make panel active
    setActive();

    // Check if control key or Shift-F10 or menu was pressed
    if (p != NULL)
    {
        FXEvent* event = (FXEvent*)p;
        if (event->state&CONTROLMASK)
        {
            ctrl = true;
        }
        if ((event->state&SHIFTMASK && event->code == KEY_F10) || event->code == KEY_Menu)
        {
            shiftf10 = true;
        }
    }

    // Use to select the item under cursor when right clicking
    // Only when Shift-F10 was not pressed
    if (!shiftf10 && (list->getNumSelectedItems() <= 1))
    {
        int    x, y;
        FXuint state;
        list->getCursorPosition(x, y, state);

        int item = list->getItemAt(x, y);

        if (list->getCurrentItem() >= 0)
        {
            list->deselectItem(list->getCurrentItem());
        }
        if (item >= 0)
        {
            list->setCurrentItem(item);
            list->selectItem(item);
        }
    }

    // If first item (i.e. the '..' item)
    if ((list->getNumSelectedItems() == 1) && list->isItemSelected(0))
    {
        ctrl = true;
    }

    // If control flag is set, deselect all items
    if (ctrl)
    {
        list->handle(o, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), p);
    }

    // Popup menu pane
    FXMenuPane* menu = new FXMenuPane(this);
    int         x, y;
    FXuint      state;
    getRoot()->getCursorPosition(x, y, state);

    int num, itm;
    num = current->list->getNumSelectedItems(&itm);

    // No selection or control flag set
    if ((num == 0) || current->ctrl)
    {
        // Menu items
        new FXMenuCommand(menu, _("New& file..."), NULL, current, FilePanel::ID_NEW_FILE);
        new FXMenuCommand(menu, _("New f&older..."), NULL, current, FilePanel::ID_NEW_DIR);
        new FXMenuCommand(menu, _("New s&ymlink..."), NULL, current, FilePanel::ID_NEW_SYMLINK);
        new FXMenuCommand(menu, _("Fi&lter..."), NULL, current, FilePanel::ID_FILTER);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(menu);
        new FXMenuCheck(menu, _("&Hidden files"), current->list, FileList::ID_TOGGLE_HIDDEN);
        new FXMenuCheck(menu, _("Thum&bnails"), current->list, FileList::ID_TOGGLE_THUMBNAILS);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("B&ig icons"), current->list, IconList::ID_SHOW_BIG_ICONS);
        new FXMenuRadio(menu, _("&Small icons"), current->list, IconList::ID_SHOW_MINI_ICONS);
        new FXMenuRadio(menu, _("&Full file list"), current->list, IconList::ID_SHOW_DETAILS);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("&Rows"), current->list, FileList::ID_ARRANGE_BY_ROWS);
        new FXMenuRadio(menu, _("&Columns"), current->list, FileList::ID_ARRANGE_BY_COLUMNS);
        new FXMenuCheck(menu, _("Autosize"), current->list, FileList::ID_AUTOSIZE);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("&Name"), current->list, FileList::ID_SORT_BY_NAME);
        new FXMenuRadio(menu, _("Si&ze"), current->list, FileList::ID_SORT_BY_SIZE);
        new FXMenuRadio(menu, _("&Type"), current->list, FileList::ID_SORT_BY_TYPE);
        new FXMenuRadio(menu, _("E&xtension"), current->list, FileList::ID_SORT_BY_EXT);
        new FXMenuRadio(menu, _("&Date"), current->list, FileList::ID_SORT_BY_TIME);
        new FXMenuRadio(menu, _("&User"), current->list, FileList::ID_SORT_BY_USER);
        new FXMenuRadio(menu, _("&Group"), current->list, FileList::ID_SORT_BY_GROUP);
        new FXMenuRadio(menu, _("Per&missions"), current->list, FileList::ID_SORT_BY_PERM);
        new FXMenuRadio(menu, _("Deletion date"), current->list, FileList::ID_SORT_BY_DELTIME);
        new FXMenuSeparator(menu);
        new FXMenuCheck(menu, _("Ignore c&ase"), current->list, FileList::ID_SORT_CASE);
        new FXMenuCheck(menu, _("Fold&ers first"), current->list, FileList::ID_DIRS_FIRST);
        new FXMenuCheck(menu, _("Re&verse order"), current->list, FileList::ID_SORT_REVERSE);
    }
    // Non empty selection
    else
    {
        // Deselect the '..' item
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        // Panel submenu items
        FXMenuPane* submenu = new FXMenuPane(this);
        new FXMenuCommand(submenu, _("Ne&w file..."), NULL, current, FilePanel::ID_NEW_FILE);
        new FXMenuCommand(submenu, _("New f&older..."), NULL, current, FilePanel::ID_NEW_DIR);
        new FXMenuCommand(submenu, _("New s&ymlink..."), NULL, current, FilePanel::ID_NEW_SYMLINK);
        new FXMenuCommand(submenu, _("Fi&lter..."), NULL, current, FilePanel::ID_FILTER);
        new FXMenuSeparator(submenu);
        new FXMenuCommand(submenu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(submenu);
        new FXMenuCheck(submenu, _("&Hidden files"), current->list, FileList::ID_TOGGLE_HIDDEN);
        new FXMenuCheck(submenu, _("Thum&bnails"), current->list, FileList::ID_TOGGLE_THUMBNAILS);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("B&ig icons"), current->list, IconList::ID_SHOW_BIG_ICONS);
        new FXMenuRadio(submenu, _("&Small icons"), current->list, IconList::ID_SHOW_MINI_ICONS);
        new FXMenuRadio(submenu, _("&Full file list"), current->list, IconList::ID_SHOW_DETAILS);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("&Rows"), current->list, FileList::ID_ARRANGE_BY_ROWS);
        new FXMenuRadio(submenu, _("&Columns"), current->list, FileList::ID_ARRANGE_BY_COLUMNS);
        new FXMenuCheck(submenu, _("Autosize"), current->list, FileList::ID_AUTOSIZE);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("&Name"), current->list, FileList::ID_SORT_BY_NAME);
        new FXMenuRadio(submenu, _("Si&ze"), current->list, FileList::ID_SORT_BY_SIZE);
        new FXMenuRadio(submenu, _("&Type"), current->list, FileList::ID_SORT_BY_TYPE);
        new FXMenuRadio(submenu, _("E&xtension"), current->list, FileList::ID_SORT_BY_EXT);
        new FXMenuRadio(submenu, _("&Date"), current->list, FileList::ID_SORT_BY_TIME);
        new FXMenuRadio(submenu, _("&User"), current->list, FileList::ID_SORT_BY_USER);
        new FXMenuRadio(submenu, _("&Group"), current->list, FileList::ID_SORT_BY_GROUP);
        new FXMenuRadio(submenu, _("Per&missions"), current->list, FileList::ID_SORT_BY_PERM);
        new FXMenuRadio(submenu, _("Deletion date"), current->list, FileList::ID_SORT_BY_DELTIME);
        new FXMenuSeparator(submenu);
        new FXMenuCheck(submenu, _("Ignore c&ase"), current->list, FileList::ID_SORT_CASE);
        new FXMenuCheck(submenu, _("Fold&ers first"), current->list, FileList::ID_DIRS_FIRST);
        new FXMenuCheck(submenu, _("Re&verse order"), current->list, FileList::ID_SORT_REVERSE);
        new FXMenuCascade(menu, _("Pane&l"), NULL, submenu);
        new FXMenuSeparator(menu);

#if defined(linux)
        FXString name = current->list->getItemPathname(itm);
        if ((num == 1) && (fsdevices->find(name.text()) || mtdevices->find(name.text())))
        {
            new FXMenuCommand(menu, _("&Mount"), NULL, current, FilePanel::ID_MOUNT);
            new FXMenuCommand(menu, _("Unmount"), NULL, current, FilePanel::ID_UMOUNT);
            new FXMenuSeparator(menu);
        }
#endif

        FXbool ar = false;
        if (current->list->getItem(itm) && current->list->isItemFile(itm))
        {
            new FXMenuCommand(menu, _("Open &with..."), NULL, current, FilePanel::ID_OPEN_WITH);
            new FXMenuCommand(menu, _("&Open"), NULL, current, FilePanel::ID_OPEN);
            FXString name = current->list->getItemText(itm).section('\t', 0);

            // Last and before last file extensions
            FXString ext1 = name.rafter('.', 1).lower();
            FXString ext2 = name.rafter('.', 2).lower();

            // Destination folder name
            FXString extract_to_folder;
            if ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z"))
            {
                extract_to_folder = _("Extr&act to folder ")+name.section('\t', 0).rbefore('.', 2);
            }
            else
            {
                extract_to_folder = _("Extr&act to folder ")+name.section('\t', 0).rbefore('.', 1);
            }

            // Display the extract and package menus according to the archive extensions
            if ((num == 1) && ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
                new FXMenuCommand(menu, extract_to_folder, NULL, current, FilePanel::ID_EXTRACT_TO_FOLDER);
                new FXMenuCommand(menu, _("E&xtract to..."), NULL, current, FilePanel::ID_EXTRACT);
            }
            else if ((num == 1) && ((ext1 == "gz") || (ext1 == "bz2") || (ext1 == "xz") || (ext1 == "z")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
            }
            else if ((num == 1) && ((ext1 == "tar") || (ext1 == "tgz") || (ext1 == "tbz2") || (ext1 == "tbz") || (ext1 == "taz") || (ext1 == "txz") || (ext1 == "zip") || (ext1 == "7z") || (ext1 == "lzh") || (ext1 == "rar") || (ext1 == "ace") || (ext1 == "arj")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
                new FXMenuCommand(menu, extract_to_folder, NULL, current, FilePanel::ID_EXTRACT_TO_FOLDER);
                new FXMenuCommand(menu, _("E&xtract to..."), NULL, current, FilePanel::ID_EXTRACT);
            }
#if defined(linux)
            else if ((num == 1) && ((ext1 == "rpm") || (ext1 == "deb")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&View"), NULL, current, FilePanel::ID_VIEW);
                new FXMenuCommand(menu, _("Install/Up&grade"), NULL, current, ID_PKG_INSTALL);
                new FXMenuCommand(menu, _("Un&install"), NULL, current, ID_PKG_UNINSTALL);
            }
#endif
            // Not archive nor package
            if (!ar)
            {
                new FXMenuCommand(menu, _("&View"), NULL, current, FilePanel::ID_VIEW);
                new FXMenuCommand(menu, _("&Edit"), NULL, current, FilePanel::ID_EDIT);
                if (num == 1)
                {
                    new FXMenuCommand(menu, _("Com&pare..."), NULL, current, FilePanel::ID_COMPARE);
                }
                else
                {
                    new FXMenuCommand(menu, _("Com&pare"), NULL, current, FilePanel::ID_COMPARE);
                }
            }
        }
        if (!ar)
        {
            new FXMenuCommand(menu, _("&Add to archive..."), NULL, current, FilePanel::ID_ADD_TO_ARCH);
        }
#if defined(linux)
        if ((num == 1) && !ar)
        {
            new FXMenuCommand(menu, _("Packages &query "), NULL, current, FilePanel::ID_PKG_QUERY);
        }
#endif

        // Build scripts menu
        new FXMenuSeparator(menu);
        FXString    scriptpath = homedir + PATHSEPSTRING CONFIGPATH PATHSEPSTRING XFECONFIGPATH PATHSEPSTRING SCRIPTPATH;
        FXMenuPane* scriptsmenu = new FXMenuPane(this);
        new FXMenuCascade(menu, _("Scripts"), NULL, scriptsmenu);
        readScriptDir(scriptsmenu, scriptpath);
        new FXMenuSeparator(scriptsmenu);
        new FXMenuCommand(scriptsmenu, _("&Go to script folder"), NULL, this, FilePanel::ID_GO_SCRIPTDIR);

        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("&Copy"), NULL, current, FilePanel::ID_COPY_CLIPBOARD);
        new FXMenuCommand(menu, _("C&ut"), NULL, current, FilePanel::ID_CUT_CLIPBOARD);
        new FXMenuCommand(menu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("Re&name..."), NULL, current, FilePanel::ID_FILE_RENAME);
        new FXMenuCommand(menu, _("Copy &to..."), NULL, current, FilePanel::ID_FILE_COPYTO);
        new FXMenuCommand(menu, _("&Move to..."), NULL, current, FilePanel::ID_FILE_MOVETO);
        new FXMenuCommand(menu, _("Symlin&k to..."), NULL, current, FilePanel::ID_FILE_SYMLINK);
        new FXMenuCommand(menu, _("M&ove to trash"), NULL, current, FilePanel::ID_FILE_TRASH);
        new FXMenuCommand(menu, _("Restore &from trash"), NULL, current, FilePanel::ID_FILE_RESTORE);
        new FXMenuCommand(menu, _("&Delete"), NULL, current, FilePanel::ID_FILE_DELETE);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("Compare &sizes"), NULL, current, FilePanel::ID_DIR_USAGE);
        new FXMenuCommand(menu, _("P&roperties"), NULL, current, FilePanel::ID_PROPERTIES);
    }
    menu->create();

    // Reset flags
    ctrl = false;
    shiftf10 = false;
    allowPopupScroll = true;  // Allow keyboard scrolling


    menu->popup(NULL, x, y);
    getApp()->runModalWhileShown(menu);
    allowPopupScroll = false;

    return(1);
}


// Read all executable file names that are located into the script directory
// Sort entries alphabetically, directories first
int FilePanel::readScriptDir(FXMenuPane* scriptsmenu, FXString dir)
{
    DIR* dp;
    struct dirent** namelist;

    // Open directory
    if ((dp = opendir(dir.text())) == NULL)
    {
        return(0);
    }

    // Eventually add a / at the end of the directory name
    if (dir[dir.length()-1] != '/')
    {
        dir = dir+"/";
    }

	// First, read only directory entries and sort them alphabetically
    int n;
    n = scandir(dir.text(), &namelist, NULL, alphasort);
    if (n < 0)
    {
        perror("scandir");
    }
    else
    {
        for (int k = 0; k < n; k++)
        {
            // Avoid hidden directories and '.' and '..'
            if (namelist[k]->d_name[0] != '.')
            {
                FXString pathname = dir + namelist[k]->d_name;

                // Recurse if non empty directory
                if (::isDirectory(pathname))
                {
                    if (!::isEmptyDir(pathname))
                    {
                        FXMenuPane* submenu = new FXMenuPane(this);
                        new FXMenuCascade(scriptsmenu, namelist[k]->d_name, NULL, submenu);
                        readScriptDir(submenu, pathname);
                    }
                }
            }
            free(namelist[k]);
        }
        free(namelist);
    }

	// Then, read only executable files and sort them alphabetically
    n = scandir(dir.text(), &namelist, NULL, alphasort);
    if (n < 0)
    {
        perror("scandir");
    }
    else
    {
        for (int k = 0; k < n; k++)
        {
			// Add only executable files to the list
			FXString pathname = dir + namelist[k]->d_name;
			if (!::isDirectory(pathname) && isReadExecutable(pathname))
			{
				new FXMenuCommand(scriptsmenu, namelist[k]->d_name + FXString("\t\t") + pathname, miniexecicon, this, FilePanel::ID_RUN_SCRIPT);
			}
            free(namelist[k]);
        }
        free(namelist);
    }

    // Close directory
    (void)closedir(dp);

    return(1);
}


// Run Terminal in the selected directory
long FilePanel::onCmdXTerm(FXObject*, FXSelector, void*)
{
    int ret;

    getApp()->beginWaitCursor();
    ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
        }

        return(0);
    }

    FXString cmd = getApp()->reg().readStringEntry("PROGS", "xterm", "xterm -sb");
    cmd += " &";
    ret = system(cmd.text());
    if (ret < 0)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Can't execute command %s"), cmd.text());
    }

    current->list->setFocus();
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }

        return(0);
    }

    getApp()->endWaitCursor();
    return(1);
}


// Add files or directory to an archive
long FilePanel::onCmdAddToArch(FXObject* o, FXSelector, void*)
{
    int      ret;
    FXString name, ext1, ext2, cmd, archive = "";
    File*    f;

    ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), list->getDirectory().text());
        }

        return(0);
    }

    // Eventually deselect the '..' directory
    if (current->list->isItemSelected(0))
    {
        current->list->deselectItem(0);
    }

    // Return if nothing is selected
    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    // If only one item is selected, use its name as a starting guess for the archive name
    if (current->list->getNumSelectedItems() == 1)
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                name = current->list->getItemFilename(u);
                break;
            }
        }
        archive = name;
    }

    // Initial archive name with full path and default extension
    FXString archpath = current->list->getDirectory();
    if (archpath == PATHSEPSTRING)
    {
        archive = archpath+archive+".tar.gz";
    }
    else
    {
        archive = archpath+PATHSEPSTRING+archive+".tar.gz";
    }

    // Archive dialog
    if (archdialog == NULL)
    {
        archdialog = new ArchInputDialog(this, "");
    }
    archdialog->setText(archive);
    archdialog->CursorEnd();

    if (archdialog->execute())
    {
        if (archdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

        // Get string and preserve escape characters
        archive = ::quote(archdialog->getText());

        // Get extensions of the archive name
        ext1 = archdialog->getText().rafter('.', 1).lower();
        ext2 = archdialog->getText().rafter('.', 2).lower();

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zcvf "+archive+" ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jcvf "+archive+" ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jcvf "+archive+" ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zcvf "+archive+" ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -cvf "+archive+" ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zcvf "+archive+" ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zcvf "+archive+" ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "xz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jcvf "+archive+" ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jcvf "+archive+" ";
        }
        else if (ext1 == "z")
        {
            cmd = "compress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "zip -r "+archive+" ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z a "+archive+" ";
        }

        // Default archive format
        else
        {
            archive += ".tar.gz";
            cmd = "tar -zcvf "+archive+" ";
        }

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Don't include '..' in the list
                name = current->list->getItemFilename(u);
                if (name != "..")
                {
                    cmd += " ";
                    cmd = cmd+::quote(name);
                    cmd += " ";
                }
            }
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Create archive"), ARCHIVE);
        f->create();

        // Create archive
        f->archive(archive, cmd);
        ret = chdir(startlocation.text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
            }

            return(0);
        }

        getApp()->endWaitCursor();
        delete f;

        // Force panel refresh
        onCmdRefresh(0, 0, 0);
    }
    return(1);
}


// Extract archive
long FilePanel::onCmdExtract(FXObject*, FXSelector, void*)
{
    FXString name, ext1, ext2, cmd, dir, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    // File selection dialog
    FileDialog  browse(this, _("Select a destination folder"));
    const char* patterns[] =
    {
        _("All Files"), "*", NULL
    };
    browse.setDirectory(homedir);
    browse.setPatternList(patterns);
    browse.setSelectMode(SELECT_FILE_DIRECTORY);

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        // Archive name and extensions
        name = current->list->getItemText(item).text();

        ext1 = name.section('\t', 0).rafter('.', 1).lower();
        ext2 = name.section('\t', 0).rafter('.', 2).lower();
        name = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jxvf ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -xvf ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gunzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bunzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "unxz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jxvf ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext1 == "z")
        {
            cmd = "uncompress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "unzip -o ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z x -y ";
        }
        else if (ext1 == "rar")
        {
            cmd = "unrar x -o+ ";
        }
        else if (ext1 == "lzh")
        {
            cmd = "lha -xf ";
        }
        else if (ext1 == "ace")
        {
            cmd = "unace x ";
        }
        else if (ext1 == "arj")
        {
            cmd = "arj x -y ";
        }
        else
        {
            cmd = "tar -zxvf ";
        }

        // Final extract command
        cmd += name+" ";


        // Extract archive
        if (browse.execute())
        {
            dir = browse.getFilename();

            if (isWritable(dir))
            {
                // Wait cursor
                getApp()->beginWaitCursor();

                // File object
                f = new File(this, _("Extract archive"), EXTRACT);
                f->create();

                // Extract archive
                f->extract(name, dir, cmd);

                getApp()->endWaitCursor();
                delete f;
            }
            else
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
            }
        }
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Extract archive to a folder name based on the archive name
long FilePanel::onCmdExtractToFolder(FXObject*, FXSelector, void*)
{
    FXString name, pathname, ext1, ext2, cmd, dirname, dirpath, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        // Archive name and extensions
        name = current->list->getItemText(item).text();
        ext1 = name.section('\t', 0).rafter('.', 1).lower();
        ext2 = name.section('\t', 0).rafter('.', 2).lower();

        // Destination folder name
        if ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z"))
        {
            dirname = name.section('\t', 0).rbefore('.', 2);
        }
        else
        {
            dirname = name.section('\t', 0).rbefore('.', 1);
        }

        // Create the new dir according to the current umask
        // Don't complain if directory already exists
        int mask = umask(0);
        umask(mask);
        dirpath = cdir + PATHSEPSTRING + dirname;
        errno = 0;
        int ret = ::mkdir(dirpath.text(), 511 & ~mask);
        int errcode = errno;
        if ((ret == -1) && (errcode != EEXIST))
        {
            if (errcode)
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s: %s"), dirpath.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s"), dirpath.text());
            }
            return(0);
        }

        // Archive pathname
        pathname = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jxvf ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -xvf ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gunzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bunzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "unxz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jxvf ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext1 == "z")
        {
            cmd = "uncompress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "unzip -o ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z x -y ";
        }
        else if (ext1 == "rar")
        {
            cmd = "unrar x -o+ ";
        }
        else if (ext1 == "lzh")
        {
            cmd = "lha -xf ";
        }
        else if (ext1 == "ace")
        {
            cmd = "unace x ";
        }
        else if (ext1 == "arj")
        {
            cmd = "arj x -y ";
        }
        else
        {
            cmd = "tar -zxvf ";
        }

        // Final extract command
        cmd += pathname+" ";

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Extract archive"), EXTRACT);
        f->create();

        // Extract archive
        f->extract(pathname, dirpath, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Extract archive in the current directory
long FilePanel::onCmdExtractHere(FXObject*, FXSelector, void*)
{
    FXString name, ext1, ext2, cmd, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        if (isWritable(cdir))
        {
            // Archive name and extensions
            name = current->list->getItemText(item).text();
            ext1 = name.section('\t', 0).rafter('.', 1);
            lower();
            ext2 = name.section('\t', 0).rafter('.', 2).lower();
            name = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

            // Handle different archive formats
            if (ext2 == "tar.gz")
            {
                cmd = "tar -zxvf ";
            }
            else if (ext2 == "tar.bz2")
            {
                cmd = "tar -jxvf ";
            }
            else if (ext2 == "tar.xz")
            {
                cmd = "tar -Jxvf ";
            }
            else if (ext2 == "tar.z")
            {
                cmd = "tar -Zxvf ";
            }
            else if (ext1 == "tar")
            {
                cmd = "tar -xvf ";
            }
            else if (ext1 == "gz")
            {
                cmd = "gunzip -v ";
            }
            else if (ext1 == "tgz")
            {
                cmd = "tar -zxvf ";
            }
            else if (ext1 == "taz")
            {
                cmd = "tar -Zxvf ";
            }
            else if (ext1 == "bz2")
            {
                cmd = "bunzip2 -v ";
            }
            else if (ext1 == "xz")
            {
                cmd = "unxz -v ";
            }
            else if ((ext1 == "tbz2") || (ext1 == "tbz"))
            {
                cmd = "tar -jxvf ";
            }
            else if (ext1 == "txz")
            {
                cmd = "tar -Jxvf ";
            }
            else if (ext1 == "z")
            {
                cmd = "uncompress -v ";
            }
            else if (ext1 == "zip")
            {
                cmd = "unzip -o ";
            }
            else if (ext1 == "7z")
            {
                cmd = "7z x -y ";
            }
            else if (ext1 == "rar")
            {
                cmd = "unrar x -o+ ";
            }
            else if (ext1 == "lzh")
            {
                cmd = "lha -xf ";
            }
            else if (ext1 == "ace")
            {
                cmd = "unace x ";
            }
            else if (ext1 == "arj")
            {
                cmd = "arj x -y ";
            }
            else
            {
                cmd = "tar -zxvf ";
            }

            // Final extract command
            cmd += name+" ";

            // Wait cursor
            getApp()->beginWaitCursor();

            // File object
            f = new File(this, _("Extract archive"), EXTRACT);
            f->create();

            // Extract archive
            f->extract(name, cdir, cmd);

            getApp()->endWaitCursor();
            delete f;
        }
        else
        {
            MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), cdir.text());
        }
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


#if defined(linux)
// Install/Upgrade package
long FilePanel::onCmdPkgInstall(FXObject*, FXSelector, void*)
{
    FXString name, path, cmd, dir, cdir;
    File*    f;

    cdir = current->list->getDirectory();

    int itm;
    current->list->getNumSelectedItems(&itm);
    if (current->list->getItem(itm))
    {
        name = current->list->getItemText(itm).text();
        name = name.section('\t', 0);
        path = ::quote(cdir + PATHSEPSTRING + name);

        // Command to perform
        FXString ext = FXPath::extension(name);
        if (comparecase(ext, "rpm") == 0)
        {
            cmd = "rpm -Uvh " + path;
        }
        else if (comparecase(ext, "deb") == 0)
        {
            cmd = "dpkg -i "+ path;
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Package Install/Upgrade"), PKG_INSTALL);
        f->create();

        // Install/Upgrade package
        f->pkgInstall(name, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Uninstall package based on its name (package version is ignored)
long FilePanel::onCmdPkgUninstall(FXObject*, FXSelector, void*)
{
    FXString name, cmd, dir, cdir;
    File*    f;

    cdir = current->list->getDirectory();

    int itm;
    current->list->getNumSelectedItems(&itm);
    if (current->list->getItem(itm))
    {
        name = current->list->getItemText(itm).text();
        name = name.section('\t', 0);

        // Command to perform
        FXString ext = FXPath::extension(name);
        if (comparecase(ext, "rpm") == 0)
        {
            name = name.section('-', 0);
            cmd = "rpm -e " + name;
        }
        else if (comparecase(ext, "deb") == 0)
        {
            name = name.section('_', 0);
            cmd = "dpkg -r "+ name;
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Package Uninstall"), PKG_UNINSTALL);
        f->create();

        // Uninstall package
        f->pkgUninstall(name, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


#endif


// Force FilePanel and DirPanel refresh
long FilePanel::onCmdRefresh(FXObject*, FXSelector, void*)
{
    // Refresh panel
    FXString dir = list->getDirectory();
    list->setDirectory(ROOTDIR, false);
    list->setDirectory(dir, false);
    updatePath();
	
	// Focus on current panel
	current-> list->setFocus();

    return(1);
}


// Handle item selection
long FilePanel::onCmdSelect(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setFocus();
    switch (FXSELID(sel))
    {
    case ID_SELECT_ALL:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SELECT_ALL), ptr);
        return(1);

    case ID_DESELECT_ALL:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), ptr);
        return(1);

    case ID_SELECT_INVERSE:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SELECT_INVERSE), ptr);
        return(1);
    }
    return(1);
}


// Handle show commands
long FilePanel::onCmdShow(FXObject* sender, FXSelector sel, void* ptr)
{
    switch (FXSELID(sel))
    {
    case ID_SHOW_BIG_ICONS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_BIG_ICONS), ptr);
        break;

    case ID_SHOW_MINI_ICONS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_MINI_ICONS), ptr);
        break;

    case ID_SHOW_DETAILS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_DETAILS), ptr);
        break;
    }

    // Set focus on current panel list
    current->list->setFocus();

    return(1);
}


// Update show commands
long FilePanel::onUpdShow(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXuint style = current->list->getListStyle();

    switch (FXSELID(sel))
    {
    case ID_SHOW_BIG_ICONS:
        if (style & _ICONLIST_BIG_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_MINI_ICONS:
        if (style & _ICONLIST_MINI_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_DETAILS:
        if (!(style & (_ICONLIST_MINI_ICONS | _ICONLIST_BIG_ICONS)))
        {
            msg = FXWindow::ID_CHECK;
        }
        break;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);

    return(1);
}


// Handle toggle hidden command
long FilePanel::onCmdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_HIDDEN), ptr);
    return(1);
}


// Update toggle hidden command
long FilePanel::onUpdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXbool hidden = current->list->shownHiddenFiles();

    if (hidden == false)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);
    return(1);
}


// Handle toggle thumbnails command
long FilePanel::onCmdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_THUMBNAILS), ptr);
    return(1);
}


// Update toggle hidden command
long FilePanel::onUpdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXbool showthumb = current->list->shownThumbnails();

    if (showthumb == false)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);
    return(1);
}


// Run script
long FilePanel::onCmdRunScript(FXObject* o, FXSelector sel, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString pathname, cmd, itemslist = " ";
    FXString scriptpath = dynamic_cast<FXMenuCommand*>(o)->getHelpText();

    // Construct selected files list
    current->list->setFocus();
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            pathname = current->list->getItemPathname(u);

            // List of selected items
            itemslist += ::quote(pathname) + " ";
        }
    }

    // Construct command line
    cmd = ::quote(scriptpath) + itemslist + " &";

    // Go to the current directory
    int ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
        }
    }

    // Execute command
    static pid_t child_pid = 0;
    switch ((child_pid = fork()))
    {
    case -1:
        fprintf(stderr, _("Error: Fork failed: %s\n"), strerror(errno));
        break;

    case 0:
        execl("/bin/sh", "sh", "-c", cmd.text(), (char*)NULL);
        _exit(EXIT_SUCCESS);
        break;
    }

    // Return to the starting directory
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Go to scripts directory
long FilePanel::onCmdGoScriptDir(FXObject* o, FXSelector sel, void*)
{
    FXString scriptpath = homedir + PATHSEPSTRING CONFIGPATH PATHSEPSTRING XFECONFIGPATH PATHSEPSTRING SCRIPTPATH;

    if (!::exists(scriptpath))
    {
        // Create the script directory according to the umask
        int mask = umask(0);
        umask(mask);
        errno = 0;
        int ret = mkpath(scriptpath.text(), 511 & ~mask);
        int errcode = errno;
        if (ret == -1)
        {
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create script folder %s: %s"), scriptpath.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create script folder %s"), scriptpath.text());
            }

            return(0);
        }
    }

    // Go to scripts directory
    current->list->setDirectory(scriptpath);
    current->list->setFocus();
    dirpanel->setDirectory(scriptpath, true);
    current->updatePath();
    updateLocation();

    return(1);
}


#if defined(linux)
// Mount/Unmount file systems
long FilePanel::onCmdMount(FXObject*, FXSelector sel, void*)
{
    int      ret;
    FXString cmd, msg, text;
    FXuint   op;
    File*    f;
    FXString dir;

    current->list->setFocus();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (current->list->getNumSelectedItems() == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    // If symbolic link, read the linked directory
    if (::isLink(dir))
    {
        dir = ::readLink(dir);
    }

    if (FXSELID(sel) == ID_MOUNT)
    {
        op = MOUNT;
        msg = _("Mount");
		cmd = getApp()->reg().readStringEntry("PROGS", "mount", DEFAULT_MOUNTCMD) + FXString(" ");
    }
    else
    {
        op = UNMOUNT;
        msg = _("Unmount");
	    cmd = getApp()->reg().readStringEntry("PROGS", "unmount", DEFAULT_UMOUNTCMD) + FXString(" ");
    }
    cmd += ::quote(dir);
    cmd += " 2>&1";
    ret = chdir(ROOTDIR);
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), ROOTDIR, strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), ROOTDIR);
        }

        return(0);
    }

    // Wait cursor
    getApp()->beginWaitCursor();

    // File object
    text = msg + _(" file system...");
    f = new File(this, text.text(), op);
    f->create();

    // Mount/unmount file system
    text = msg + _(" the folder:");
    f->mount(dir, text, cmd, op);
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }

        return(0);
    }

    // If action is cancelled in progress dialog
    if (f->isCancelled())
    {
        f->hide();
        text = msg + _(" operation cancelled!");
        MessageBox::error(this, BOX_OK, _("Warning"), "%s", text.text());
        delete f;
        return(0);
    }

    getApp()->endWaitCursor();
    delete f;

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Update the Mount button
long FilePanel::onUpdMount(FXObject* o, FXSelector sel, void*)
{
    FXString dir;

    int num = current->list->getNumSelectedItems();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (num == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    if (fsdevices->find(dir.text()) && !mtdevices->find(dir.text()) && current->list->getNumItems() && !current->list->isItemSelected(0))
    //if (fsdevices->find(dir.text()) && !mtdevices->find(dir.text()) && current->list->getNumItems())
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update the Unmount button
long FilePanel::onUpdUnmount(FXObject* o, FXSelector sel, void*)
{
    FXString dir;

    int num = current->list->getNumSelectedItems();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (num == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    if ((fsdevices->find(dir.text()) || mtdevices->find(dir.text())) && current->list->getNumItems() && !current->list->isItemSelected(0))
    //if ((fsdevices->find(dir.text()) || mtdevices->find(dir.text())) && current->list->getNumItems())
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Query packages data base
long FilePanel::onCmdPkgQuery(FXObject* o, FXSelector sel, void*)
{
    FXString cmd;

    // Name of the current selected file
    FXString file = current->list->getCurrentFile();

    // Command to perform
    if (pkg_format == DEB_PKG)
    {
        cmd = "dpkg -S " + ::quote(file);
    }
    else if (pkg_format == RPM_PKG)
    {
        cmd = "rpm -qf " + ::quote(file);
    }
    else
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("No compatible package manager (rpm or dpkg) found!"));
        return(0);
    }

    // Query command
    cmd += " 2>&1";

    // Wait cursor
    getApp()->beginWaitCursor();

    // Perform the command
    FILE* pcmd = popen(cmd.text(), "r");
    if (!pcmd)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Failed command: %s"), cmd.text());
        return(0);
    }

    // Get command output
    char     text[10000] = { 0 };
    FXString buf;
    while (fgets(text, sizeof(text), pcmd))
    {
        buf += text;
    }
    snprintf(text, sizeof(text)-1, "%s", buf.text());

    // Close the stream and display error message if any
    if ((pclose(pcmd) == -1) && (errno != ECHILD))   // ECHILD can be set if the child was caught by sigHarvest
    {
        getApp()->endWaitCursor();
        MessageBox::error(this, BOX_OK, _("Error"), "%s", text);
        return(0);
    }
    getApp()->endWaitCursor();

    // Get package name, or detect when the file isn't in a package
    FXString str = text;
    if (pkg_format == DEB_PKG)  // DEB based distribution
    {
        int idx = str.find(" ");               // Split output at first whitespace
        FXString pkgname = str.left(idx-1);    // Remove trailing colon
        FXString fname = str.right(str.length()-idx);
        fname.trim();                          // Remove leading space and trailing newline
        if (streq(fname.text(), file.text()))  // No other word than the file name
        {
            str = pkgname.text();
        }
        else
        {
            str = "";
        }
    }
    if (pkg_format == RPM_PKG)   // RPM based distribution
    {
        if (str.find(' ') != -1) // Space character exists in the string
        {
            str = "";
        }
    }

    // Display the related output message
    FXString message;
    if (str == "")
    {
        message.format(_("File %s does not belong to any package."), file.text());
        MessageBox::information(this, BOX_OK, _("Information"), "%s", message.text());
    }
    else
    {
        message.format(_("File %s belongs to the package: %s"), file.text(), str.text());
        MessageBox::information(this, BOX_OK, _("Information"), "%s", message.text());
    }

    return(1);
}


// Update the package query menu
long FilePanel::onUpdPkgQuery(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing is selected or multiple selection
    // or when unique selection and the selected item is a directory

    int num;

    num = current->list->getNumSelectedItems();

    if ((num == 0) || (num > 1))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else // num=1
    {
        int item = current->list->getCurrentItem();
        if ((item >= 0) && current->list->isItemDirectory(item))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }

    return(1);
}


#endif // End #if defined(linux)


// Directory usage on file selection
long FilePanel::onCmdDirUsage(FXObject* o, FXSelector, void*)
{
	FXString name, command, itemslist = " ";
	FXString cmd1 = "/usr/bin/du --apparent-size -k -s ";
	FXString cmd2 = " 2> /dev/null | /usr/bin/sort -rn | /usr/bin/cut -f2 | /usr/bin/xargs -d '\n' /usr/bin/du --apparent-size --total --si -s 2> /dev/null";

    // Enter current directory
    int ret=chdir(current->getDirectory().text());
    if (ret < 0)
    {
        int errcode=errno;
        if (errcode)
        {
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s: %s"),current->getDirectory().text(),strerror(errcode));
		}
        else
        {
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s"),current->getDirectory().text());
		}

        return 0;
    }

    // Eventually deselect the '..' directory
    if (current->list->isItemSelected(0))
    {
        current->list->deselectItem(0);
    }

    // Return if nothing is selected
    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    // Construct selected files list
    current->list->setFocus();
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
 			name = current->list->getItemFilename(u);

            // List of selected items
            itemslist += ::quote(name) + " ";
        }
    }

	// Command to be executed
	command = cmd1 + itemslist + cmd2;

	// Make and show command window
	CommandWindow* cmdwin=new CommandWindow(getApp(),_("Sizes of Selected Object(s)"),command,25,50);
	cmdwin->create();
	cmdwin->setIcon(charticon);

	// The CommandWindow object will delete itself when closed!

	// Return to start location
	ret = chdir(startlocation.text());
	if (ret < 0)
	{
		int errcode = errno;
		if (errcode)
		{
			MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
		}
		else
		{
			MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
		}
	}

    return(1);
}


// Update the status bar and the path linker
long FilePanel::onUpdStatus(FXObject* sender, FXSelector, void*)
{
    // Update the status bar
    int      item = -1;
    FXString str, linkto;
    char     usize[64];
    FXulong  size = 0;
    FXString hsize = _("0 bytes");

    FXString path = list->getDirectory();

    int num = list->getNumSelectedItems();

    // To handle the update rename (ugly, I know)
    if (current == this)
    {
        if (num <= 1)
        {
            selmult = false;
        }
        else if (num > 1)
        {
            selmult = true;
        }
    }

    item = list->getCurrentItem();

    if (num > 1)
    {
		int nbdirs = 0;
        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u) && !list->isItemDirectory(u))
            {
                size += list->getItemFileSize(u);
#if __WORDSIZE == 64
                snprintf(usize, sizeof(usize)-1, "%lu", size);
#else
                snprintf(usize, sizeof(usize)-1, "%llu", size);
#endif
                hsize = ::hSize(usize);
            }
            
            if (list->isItemDirectory(u))
            {
				nbdirs++;
			}
        }
        
        // Don't count the '..' directory
        if (nbdirs >= 1)
        {
			nbdirs--;
		}
		
		int nbfiles = num - nbdirs;
        if (nbdirs <= 1 && nbfiles <= 1)
        {
	        str.format(_("%s in %s selected object(s) (%s folder, %s file)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
        else if (nbdirs <=1 && nbfiles > 1)
        {
	        str.format(_("%s in %s selected object(s) (%s folder, %s files)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
        else if (nbdirs > 1 && nbfiles <= 1)
        {
	        str.format(_("%s in %s selected object(s) (%s folders, %s file)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
		else
		{
	        str.format(_("%s in %s selected object(s) (%s folders, %s files)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
    }
    else
    {
        // Nothing selected
        if ((num == 0) || (item < 0))
        {
            num = list->getNumItems();
            if (num == 1)
            {
                str = _("1 object(s) (1 folder)");
            }
            else
            {
				int nbdirs = 0;
				for (int u = 0; u < num; u++)
				{
					if (list->isItemDirectory(u))
					{
						nbdirs++;
					}
				}       

				int nbfiles = num - nbdirs;
		        str.format(_("%s object(s) (%s folders, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());
				if (nbdirs <= 1 && nbfiles <= 1)
				{
					str.format(_("%s object(s) (%s folder, %s file)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else if (nbdirs <=1 && nbfiles > 1)
				{
					str.format(_("%s object(s) (%s folder, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else if (nbdirs > 1 && nbfiles <= 1)
				{
					str.format(_("%s object(s) (%s folders, %s file)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else
				{
					str.format(_("%s object(s) (%s folders, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
            }
        }
        else
        {
            FXString string = list->getItemText(item);
            FXString name = string.section('\t', 0);
            FXString type = string.section('\t', 2);

            FXString date = string.section('\t', 4);
            FXString usr = string.section('\t', 5);
            FXString grp = string.section('\t', 6);
            FXString perm = string.section('\t', 7);

            if (type.contains(_("Broken link")))
            {
                linkto = ::readLink(path+PATHSEPSTRING+name);
                str = name + "->" + linkto.text() + " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
            else if (type.contains(_("Link")))
            {
                linkto = ::readLink(path+PATHSEPSTRING+name);
                str = name + "->" + linkto.text() + " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
            else
            {
                for (int u = 0; u < list->getNumItems(); u++)
                {
                    if (list->isItemSelected(u) && !list->isItemDirectory(u))
                    {
                        size = list->getItemFileSize(u);
#if __WORDSIZE == 64
                        snprintf(usize, sizeof(usize)-1, "%lu", size);
#else
                        snprintf(usize, sizeof(usize)-1, "%llu", size);
#endif
                        hsize = ::hSize(usize);
                        break;
                    }
                }
                str = hsize+ " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
        }
    }

    statuslabel->setText(str);

    // Add the filter pattern if any
    if ((list->getPattern() != "*") && (list->getPattern() != "*.*"))
    {
        str.format(_(" - Filter: %s"), list->getPattern().text());
        filterlabel->setText(str);
        filterlabel->setTextColor(attenclr);
    }
    else
    {
        filterlabel->setText("");
    }

    return(1);
}


// Update the path text and the path link
void FilePanel::updatePath()
{
    pathlink->setPath(list->getDirectory());
    pathtext->setText(list->getDirectory());
}


// Update the go to parent directory command
long FilePanel::onUpdUp(FXObject* o, FXSelector, void*)
{
    FXButton* button = (FXButton*)o;
    int       style = button->getButtonStyle();

    if (style & TOGGLEBUTTON_TOOLBAR)
    {
        if (current->list->getDirectory() != ROOTDIR)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update the paste button
long FilePanel::onUpdPaste(FXObject* o, FXSelector, void*)
{
    FXuchar* data;
    FXuint   len;
    FXString buf;
    FXbool   clipboard_empty = true;

    // Lock clipboard to prevent changes in method onCmdRequestClipboard()
    clipboard_locked = true;

    // If source is xfelistType (Gnome, XFCE, or Xfe app)
    if (getDNDData(FROM_CLIPBOARD, xfelistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        buf = (char*)data;

        // Check if valid clipboard
        if (buf.find("file:/") >= 0)
        {
            clipboard_empty = false;
        }

        // Free data pointer
        FXFREE(&data);
    }

    // If source type is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    else if (getDNDData(FROM_CLIPBOARD, urilistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        buf = (char*)data;

        // Check if valid clipboard
        if (buf.find("file:/") >= 0)
        {
            clipboard_empty = false;
        }

        // Free data pointer
        FXFREE(&data);
    }

    // Gray out the paste button, if necessary
    if (clipboard_empty)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }

    // Unlock clipboard
    clipboard_locked = false;

    return(1);
}


// Update menu items and toolbar buttons that are related to file operations
long FilePanel::onUpdMenu(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing or only ".." is selected
    int num;

    num = current->list->getNumSelectedItems();
    DirItem* item = (DirItem*)dirpanel->getCurrentItem();

    if ((dirpanel->shown() && item))
    {
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        //else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        //else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }

    return(1);
}


// Update file delete menu item and toolbar button
long FilePanel::onUpdFileDelete(FXObject* o, FXSelector sel, void*)
{
    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    FXbool use_trash_bypass = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_bypass", false);

    if ( (!use_trash_can) | use_trash_bypass)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        //else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update move to trash menu item and toolbar button
long FilePanel::onUpdFileTrash(FXObject* o, FXSelector sel, void*)
{
    // Disable move to trash menu if we are in trash can
    // or if the trash can directory is selected

    FXbool   trashenable = true;
    FXString trashparentdir = trashlocation.rbefore('/');
    FXString curdir = current->list->getDirectory();

    if (curdir.left(trashlocation.length()) == trashlocation)
    {
        trashenable = false;
    }

    if (curdir == trashparentdir)
    {
        FXString pathname;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                if (pathname == trashlocation)
                {
                    trashenable = false;
                }
            }
        }
    }

    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    if (use_trash_can && trashenable)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        //else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update restore from trash menu item and toolbar button
long FilePanel::onUpdFileRestore(FXObject* o, FXSelector sel, void*)
{
    // Enable restore from trash menu if we are in trash can

    FXbool   restoreenable = false;
    FXString curdir = current->list->getDirectory();

    if (curdir.left(trashfileslocation.length()) == trashfileslocation)
    {
        restoreenable = true;
    }

    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    if (use_trash_can && restoreenable)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        //else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update go trash menu item and toolbar button
long FilePanel::onUpdGoTrash(FXObject* o, FXSelector sel, void*)
{
    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);

    if (use_trash_can)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update file open menu
long FilePanel::onUpdOpen(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or a directory (including "..") is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);

    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        if (current->list->getItem(item) && current->list->isItemFile(item))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
    }
    return(1);
}


// Update the status of the menu items that should be disabled when selecting multiple files
long FilePanel::onUpdSelMult(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing is selected or multiple selection or ".." is only selected
    int num;

    num = current->list->getNumSelectedItems();
    DirItem* item = (DirItem*)dirpanel->getCurrentItem();

    if (num == 0)
    {
        if (!item || !dirpanel->shown())
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else if (current->selmult || ((num == 1) && current->list->isItemSelected(0)))
    //else if (current->selmult || (num == 1))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }

    return(1);
}


// Update the file compare menu item
long FilePanel::onUpdCompare(FXObject* o, FXSelector sel, void*)
{
    // Menu item is enabled only when two files are selected
    int num;

    num = current->list->getNumSelectedItems();

    if ((num == 1) || (num == 2))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update Add to archive menu
long FilePanel::onUpdAddToArch(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or ".." is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else if ((num == 1) && current->list->isItemSelected(0))
    //else if ((num == 1))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update scripts menu item
long FilePanel::onUpdRunScript(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or ".." is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update directory usage menu item
long FilePanel::onUpdDirUsage(FXObject* o, FXSelector, void*)
{
    // Menu item is enabled only when at least two items are selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num > 1)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    return(1);
}
#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/time.h>

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "startupnotification.h"
#include "FileDialog.h"
#include "FileList.h"
#include "Properties.h"
#include "XFileExplorer.h"
#include "InputDialog.h"
#include "BrowseInputDialog.h"
#include "ArchInputDialog.h"
#include "HistInputDialog.h"
#include "File.h"
#include "MessageBox.h"
#include "OverwriteBox.h"
#include "CommandWindow.h"
#include "ExecuteBox.h"
#include "PathLinker.h"
#include "FilePanel.h"
#include <string>
#include <iostream>

// Duration (in ms) before we can stop refreshing the file list
// Used for file operations on a large list of files
#define STOP_LIST_REFRESH_INTERVAL    5000

// Number of files before stopping the file list refresh
#define STOP_LIST_REFRESH_NBMAX       100


// Clipboard notes :
// The uri-list type used for Xfe is the same as the Gnome uri-list type
// The standard uri-list type is used for KDE and non Gnome / XFCE file managers
// A special uri-list type that containd only "0" (for copy) or "1" (for cut) is used for KDE compatibility


// Global Variables
extern FXMainWindow* mainWindow;
extern FXString      homedir;
extern FXString      xdgdatahome;

// Clipboard
extern FXString clipboard;
FXuint          clipboard_type = 0;


extern char OpenHistory[OPEN_HIST_SIZE][MAX_COMMAND_SIZE];
extern int  OpenNum;
extern char FilterHistory[FILTER_HIST_SIZE][MAX_PATTERN_SIZE];
extern int  FilterNum;
#if defined(linux)
extern FXStringDict* fsdevices;
extern FXStringDict* mtdevices;
extern FXbool        pkg_format;
#endif

extern FXbool allowPopupScroll;
extern FXuint single_click;


// Map
FXDEFMAP(FilePanel) FilePanelMap[] =
{
    FXMAPFUNC(SEL_CLIPBOARD_LOST, 0, FilePanel::onClipboardLost),
    FXMAPFUNC(SEL_CLIPBOARD_GAINED, 0, FilePanel::onClipboardGained),
    FXMAPFUNC(SEL_CLIPBOARD_REQUEST, 0, FilePanel::onClipboardRequest),
    FXMAPFUNC(SEL_TIMEOUT, FilePanel::ID_STOP_LIST_REFRESH_TIMER, FilePanel::onCmdStopListRefreshTimer),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DIRECTORY_UP, FilePanel::onCmdDirectoryUp),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILTER, FilePanel::onCmdItemFilter),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILTER_CURRENT, FilePanel::onCmdItemFilter),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_HOME, FilePanel::onCmdGoHome),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_TRASH, FilePanel::onCmdGoTrash),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_VIEW, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_MIDDLEBUTTONPRESS, FilePanel::ID_FILELIST, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EDIT, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_COMPARE, FilePanel::onCmdCompare),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PROPERTIES, FilePanel::onCmdProperties),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_XTERM, FilePanel::onCmdXTerm),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_DIR, FilePanel::onCmdNewDir),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_FILE, FilePanel::onCmdNewFile),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_SYMLINK, FilePanel::onCmdNewSymlink),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_COPY, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_CUT, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_COPYTO, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_MOVETO, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_RENAME, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_SYMLINK, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_COPY_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_CUT_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADDCOPY_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADDCUT_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PASTE_CLIPBOARD, FilePanel::onCmdPaste),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_TRASH, FilePanel::onCmdFileTrash),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_RESTORE, FilePanel::onCmdFileRestore),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_DELETE, FilePanel::onCmdFileDelete),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_OPEN_WITH, FilePanel::onCmdOpenWith),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_OPEN, FilePanel::onCmdOpen),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_REFRESH, FilePanel::onCmdRefresh),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_BIG_ICONS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_MINI_ICONS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_DETAILS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_TOGGLE_HIDDEN, FilePanel::onCmdToggleHidden),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_TOGGLE_THUMBNAILS, FilePanel::onCmdToggleThumbnails),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SELECT_ALL, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DESELECT_ALL, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SELECT_INVERSE, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADD_TO_ARCH, FilePanel::onCmdAddToArch),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT, FilePanel::onCmdExtract),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT_TO_FOLDER, FilePanel::onCmdExtractToFolder),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT_HERE, FilePanel::onCmdExtractHere),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_RUN_SCRIPT, FilePanel::onCmdRunScript),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_RUN_SCRIPT, FilePanel::onUpdRunScript),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_SCRIPTDIR, FilePanel::onCmdGoScriptDir),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DIR_USAGE, FilePanel::onCmdDirUsage),
    FXMAPFUNC(SEL_RIGHTBUTTONRELEASE, FilePanel::ID_FILELIST, FilePanel::onCmdPopupMenu),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_POPUP_MENU, FilePanel::onCmdPopupMenu),
    FXMAPFUNC(SEL_DOUBLECLICKED, FilePanel::ID_FILELIST, FilePanel::onCmdItemDoubleClicked),
    FXMAPFUNC(SEL_CLICKED, FilePanel::ID_FILELIST, FilePanel::onCmdItemClicked),
    FXMAPFUNC(SEL_FOCUSIN, FilePanel::ID_FILELIST, FilePanel::onCmdFocus),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_STATUS, FilePanel::onUpdStatus),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_DIRECTORY_UP, FilePanel::onUpdUp),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_COPY_CLIPBOARD, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_CUT_CLIPBOARD, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PASTE_CLIPBOARD, FilePanel::onUpdPaste),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PROPERTIES, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_TRASH, FilePanel::onUpdFileTrash),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_RESTORE, FilePanel::onUpdFileRestore),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_GO_TRASH, FilePanel::onUpdGoTrash),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_DELETE, FilePanel::onUpdFileDelete),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_MOVETO, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_COPYTO, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_RENAME, FilePanel::onUpdSelMult),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_COMPARE, FilePanel::onUpdCompare),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_EDIT, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_VIEW, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_OPEN, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_ADD_TO_ARCH, FilePanel::onUpdAddToArch),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_BIG_ICONS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_MINI_ICONS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_DETAILS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_TOGGLE_HIDDEN, FilePanel::onUpdToggleHidden),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_TOGGLE_THUMBNAILS, FilePanel::onUpdToggleThumbnails),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_DIR_USAGE, FilePanel::onUpdDirUsage),
#if defined(linux)
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_MOUNT, FilePanel::onCmdMount),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_UMOUNT, FilePanel::onCmdMount),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_MOUNT, FilePanel::onUpdMount),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_UMOUNT, FilePanel::onUpdUnmount),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_QUERY, FilePanel::onCmdPkgQuery),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_INSTALL, FilePanel::onCmdPkgInstall),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_UNINSTALL, FilePanel::onCmdPkgUninstall),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PKG_QUERY, FilePanel::onUpdPkgQuery),
#endif
};

// Object implementation
FXIMPLEMENT(FilePanel, FXVerticalFrame, FilePanelMap, ARRAYNUMBER(FilePanelMap))

// Construct File Panel
FilePanel::FilePanel(FXWindow* owner, const char* nm, FXComposite* p, DirPanel* dp, FXuint name_size, FXuint size_size, FXuint type_size, FXuint ext_size,
                     FXuint modd_size, FXuint user_size, FXuint grou_size, FXuint attr_size, FXuint deldate_size, FXuint origpath_size, FXbool showthumbs, FXColor listbackcolor, FXColor listforecolor,
                     FXColor attentioncolor, FXbool smoothscroll, FXuint opts, int x, int y, int w, int h) :
    FXVerticalFrame(p, opts, x, y, w, h, 0, 0, 0, 0)
{
    name = nm;
    dirpanel = dp;
    attenclr = attentioncolor;

    // Global container
    FXVerticalFrame* cont = new FXVerticalFrame(this, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // Container for the path linker
    FXHorizontalFrame* pathframe = new FXHorizontalFrame(cont, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0);

    // File list

    // Smooth scrolling
    FXuint options;
    if (smoothscroll)
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS;
    }
    else
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS|SCROLLERS_DONT_TRACK;
    }

    FXHorizontalFrame* cont2 = new FXHorizontalFrame(cont, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_SUNKEN|FRAME_THICK, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    /*FXVerticalFrame* webview = new FXVerticalFrame(cont2, LAYOUT_FIX_WIDTH|LAYOUT_FILL_Y, 0, 0, 200, 0, 0, 0, 0, 0);
    webview->setBackColor(getApp()->getBackColor());

    FXLabel* webviewbg = new FXLabel(webview, "", webviewbgicon, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    webviewbg->setBackColor(getApp()->getBackColor());

    webviewtext = new FXLabel(webview, "Folder", 0, 0, 10, 100, 0, 0, 10, 10, 0, 0);
    webviewtext->setBackColor(getApp()->getBackColor());

    std::cout << webviewtext;
    std::cout << "\n";


    FXHorizontalFrame* webviewsep = new FXHorizontalFrame(webview, LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, 184, 2);
    webviewsep->setBackColor(FXRGB(102,153,204));

    //std::string iconbg = "test";
    //std::string* ptr = &iconbg;

    //FXEvent *ev=(FXEvent*)ptr;
    //FXDCWindow dc(webviewbg,ev);
    //dc.drawIcon(webviewbgicon,10,10);

    FXLabel* webviewicon = new FXLabel(webview, "", bigfoldericon, LAYOUT_FIX_X|LAYOUT_FIX_Y, 16, 16, 0, 0, 0, 0, 0, 0);
    webviewicon->setBackColor(FXRGBA(255,255,255,0));*/

    list = new FileList(owner, cont2, this, ID_FILELIST, showthumbs, options);
    list->setHeaderSize(0, name_size);
    list->setHeaderSize(1, size_size);
    list->setHeaderSize(2, type_size);
    list->setHeaderSize(3, ext_size);
    list->setHeaderSize(4, modd_size);
    list->setHeaderSize(5, user_size);
    list->setHeaderSize(6, grou_size);
    list->setHeaderSize(7, attr_size);
    list->setHeaderSize(8, deldate_size);
    list->setHeaderSize(9, origpath_size);
    list->setTextColor(listforecolor);
    list->setBackColor(listbackcolor);

    // Path text
    pathtext = new TextLabel(pathframe, 0, this, ID_FILELIST, LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0);
    pathtext->setBackColor(getApp()->getBaseColor());

    // Hide path frame if path link/breadcrums are disabled
    show_pathlink = getApp()->reg().readUnsignedEntry("SETTINGS", "show_pathlinker", true);

    if (show_pathlink == false)
    {
         pathframe->hide();
    }



    // Path linker
    pathlink = new PathLinker(pathframe, list, dirpanel->getList(), JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X);
    //FXButton* dummyicon = new FXButton(pathframe, "", minifoldericon, this, 2, BUTTON_TOOLBAR|JUSTIFY_LEFT|LAYOUT_LEFT);


    // Visually indicate if the panel is active
    activeicon = new FXButton(pathframe, "", minifoldericon, this, FilePanel::ID_FILELIST, BUTTON_TOOLBAR|JUSTIFY_LEFT|LAYOUT_LEFT);



    // Status bar
    statusbar = new FXHorizontalFrame(cont, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|LAYOUT_BOTTOM, 0, 0, 0, 0, 0, 0, 0, 0);

    statusbar->setTarget(this);
    statusbar->setSelector(FXSEL(SEL_UPDATE, FilePanel::ID_STATUS));

    FXString key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "filter", "Ctrl-D");

    FXHorizontalFrame* hframe = new FXHorizontalFrame(statusbar, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0);
    statuslabel = new FXLabel(hframe, _("Status"), NULL, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X|FRAME_SUNKEN);
    filterlabel = new FXLabel(hframe, "", NULL, JUSTIFY_LEFT|LAYOUT_LEFT);

    corner = new FXDragCorner(statusbar);

    // Panel separator
    panelsep = new FXHorizontalSeparator(cont, SEPARATOR_GROOVE|LAYOUT_FILL_X);

    // Initializations
    selmult = false;
    current = NULL;

    // Single click navigation
    single_click = getApp()->reg().readUnsignedEntry("SETTINGS", "single_click", SINGLE_CLICK_NONE);
    if (single_click == SINGLE_CLICK_DIR_FILE)
    {
        list->setDefaultCursor(getApp()->getDefaultCursor(DEF_HAND_CURSOR));
    }

    // Dialogs
    operationdialogsingle = NULL;
    operationdialogrename = NULL;
    operationdialogmultiple = NULL;
    newdirdialog = NULL;
    newfiledialog = NULL;
    newlinkdialog = NULL;
    opendialog = NULL;
    archdialog = NULL;
    filterdialog = NULL;
    comparedialog = NULL;

    // Home and trahscan locations
    trashlocation = xdgdatahome+PATHSEPSTRING TRASHPATH;
    trashfileslocation = xdgdatahome + PATHSEPSTRING TRASHFILESPATH;
    trashinfolocation = xdgdatahome + PATHSEPSTRING TRASHINFOPATH;

    // Start location (we return to the start location after each chdir)
    startlocation = FXSystem::getCurrentDirectory();

    // Initialize clipboard flags
    clipboard_locked = false;
    fromPaste = false;

    // Initialize control flag for right click popup menu
    ctrl = false;

    // Initialize the Shift-F10 flag
    shiftf10 = false;

    // Initialize the active panel flag
    isactive = false;

    // Default programs identifiers
    progs["<txtviewer>"] = TXTVIEWER;
    progs["<txteditor>"] = TXTEDITOR;
    progs["<imgviewer>"] = IMGVIEWER;
    progs["<imgeditor>"] = IMGEDITOR;
    progs["<pdfviewer>"] = PDFVIEWER;
    progs["<audioplayer>"] = AUDIOPLAYER;
    progs["<videoplayer>"] = VIDEOPLAYER;
    progs["<archiver>"] = ARCHIVER;
}


// Create X window
void FilePanel::create()
{
    // Register standard uri-list type
    urilistType = getApp()->registerDragType("text/uri-list");

    // Register special uri-list type used for Gnome, XFCE and Xfe
    xfelistType = getApp()->registerDragType("x-special/gnome-copied-files");

    // Register special uri-list type used for KDE
    kdelistType = getApp()->registerDragType("application/x-kde-cutselection");

    // Register standard UTF-8 text type used for file dialogs
    utf8Type = getApp()->registerDragType("UTF8_STRING");

    // Display or hide path linker
    FXbool show_pathlink = getApp()->reg().readUnsignedEntry("SETTINGS", "show_pathlinker", true);
    if (show_pathlink)
    {
        pathtext->hide();
        pathlink->show();
    }
    else
    {
        pathtext->show();
        pathlink->hide();
    }

    FXVerticalFrame::create();
}


// Destructor
FilePanel::~FilePanel()
{
    delete list;
    delete current;
    delete next;
    delete statuslabel;
    delete filterlabel;
    delete statusbar;
    delete panelsep;
    delete pathlink;
    delete newfiledialog;
    delete newlinkdialog;
    delete newdirdialog;
    delete opendialog;
    delete archdialog;
    delete filterdialog;
    delete comparedialog;
    delete operationdialogsingle;
    delete operationdialogrename;
    delete operationdialogmultiple;
    delete pathtext;
}


// Make panel active
void FilePanel::setActive()
{
    // Set active icon
    // activeicon->setIcon(greenbuttonicon);
    activeicon->setIcon(NULL);
    activeicon->setTipText(_("Panel is active"));

    pathlink->focus();
    current = this;

    // Make dirpanel point on the current directory,
    // but only if Filepanel and Dirpanel directories are different
    if (dirpanel->getDirectory() != current->list->getDirectory())
    {
        dirpanel->setDirectory(current->list->getDirectory(), true);
    }

    // Make dirpanel inactive
    dirpanel->setInactive();

    next->setInactive();
    list->setFocus();

    isactive = true;
}


// Make panel inactive
void FilePanel::setInactive(FXbool force)
{
    // Set active icon
    // activeicon->setIcon(graybuttonicon);
    activeicon->setIcon(NULL);
    activeicon->setTipText(_("Activate panel"));

    // By default we set the panel inactive
    if (force)
    {
        current = next;
        list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), NULL);

        isactive = false;
    }
}


// Make panel focus (i.e. active) when clicked
long FilePanel::onCmdFocus(FXObject* sender, FXSelector sel, void* ptr)
{
    setActive();
    return(1);
}


// Set Pointer to Another FilePanel
void FilePanel::Next(FilePanel* nxt)
{
    next = nxt;
}


// Show or hide drag corner
void FilePanel::showCorner(FXbool show)
{
    if (show)
    {
        corner->show();
    }
    else
    {
        corner->hide();
    }
}


// Show or hide active icon
void FilePanel::showActiveIcon(FXbool show)
{
    if (show)
    {
        activeicon->show();
    }
    else
    {
        activeicon->hide();
    }
}


// Update location history when changing directory (home, up or double click)
void FilePanel::updateLocation()
{
    FXString    item;
    int         i = 0;
    FXComboBox* address = ((XFileExplorer*)mainWindow)->getAddressBox();

    address->setNumVisible(5);
    int      count = address->getNumItems();
    FXString p = list->getDirectory();

    // Remember latest directory in the location address
    if (!count)
    {
        count++;
        address->insertItem(0, address->getText());
    }
    while (i < count)
    {
        item = address->getItem(i++);
        if (streq((const char*)&p[0], (const char*)&item[0]))
        {
            i--;
            break;
        }
    }
    if (i == count)
    {
        address->insertItem(0, list->getDirectory());
        //webviewtext->setText(list->getDirectory());
        //webviewtext->setTextColor(FXRGB(255,255,255));
        //std::cout << webviewtext;
    }

    // Make current directory visible to avoid scrolling again
    list->makeItemVisible(list->getCurrentItem());
}


// We now really do have the clipboard, keep clipboard content
long FilePanel::onClipboardGained(FXObject* sender, FXSelector sel, void* ptr)
{
    FXVerticalFrame::onClipboardGained(sender, sel, ptr);
    return(1);
}


// We lost the clipboard
long FilePanel::onClipboardLost(FXObject* sender, FXSelector sel, void* ptr)
{
    FXVerticalFrame::onClipboardLost(sender, sel, ptr);
    return(1);
}


// Somebody wants our clipboard content
long FilePanel::onClipboardRequest(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    FXuchar* data;
    FXuint   len;

    // Perhaps the target wants to supply its own data for the clipboard
    if (FXVerticalFrame::onClipboardRequest(sender, sel, ptr))
    {
        return(1);
    }

    // Clipboard target is xfelistType (Xfe, Gnome or XFCE)
    if (event->target == xfelistType)
    {
        // Don't modify the clipboard if we are called from updPaste()
        if (!clipboard_locked)
        {
            // Prepend "copy" or "cut" as in the Gnome way and avoid duplicating these strings
            if ((clipboard.find("copy\n") < 0) && (clipboard.find("cut\n") < 0))
            {
                if (clipboard_type == CUT_CLIPBOARD)
                {
                    clipboard = "cut\n" + clipboard;
                }
                else
                {
                    clipboard = "copy\n" + clipboard;
                }
            }
        }

        // Return clipboard content
        if (event->target == xfelistType)
        {
            if (!clipboard.empty())
            {
                len = clipboard.length();
                FXMEMDUP(&data, clipboard.text(), FXuchar, len);
                setDNDData(FROM_CLIPBOARD, event->target, data, len);

                // Return because xfelistType is not compatible with other types
                return(1);
            }
        }
    }

    // Clipboard target is kdelisType (KDE)
    if (event->target == kdelistType)
    {
        // The only data to be passed in this case is "0" for copy and "1" for cut
        // The uri data are passed using the standard uri-list type
        FXString flag;
        if (clipboard_type == CUT_CLIPBOARD)
        {
            flag = "1";
        }
        else
        {
            flag = "0";
        }

        // Return clipboard content
        if (event->target == kdelistType)
        {
            FXMEMDUP(&data, flag.text(), FXuchar, 1);
            setDNDData(FROM_CLIPBOARD, event->target, data, 1);
        }
    }

    // Clipboard target is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    if (event->target == urilistType)
    {
        if (!clipboard.empty())
        {
            len = clipboard.length();
            FXMEMDUP(&data, clipboard.text(), FXuchar, len);
            setDNDData(FROM_CLIPBOARD, event->target, data, len);

            return(1);
        }
    }

    // Clipboard target is utf8Type (to paste file pathes as text to other applications)
    if (event->target == utf8Type)
    {
        if (!clipboard.empty())
        {
            int      beg = 0, end = 0;
            FXString str = "";
            FXString pathname, url;

            // Clipboard don't contain 'copy\n' or 'cut\n' as first line
            if ((clipboard.find("copy\n") < 0) && (clipboard.find("cut\n") < 0))
            {
                // Remove the 'file:' prefix for each file path
                while (1)
                {
                    end = clipboard.find('\n', end);
                    if (end < 0) // Last line
                    {
                        end = clipboard.length();
                        url = clipboard.mid(beg, end-beg+1);
                        pathname = FXURL::decode(FXURL::fileFromURL(url));
                        str += pathname;
                        break;
                    }
                    url = clipboard.mid(beg, end-beg+1);
                    pathname = FXURL::decode(FXURL::fileFromURL(url));
                    str += pathname;
                    end++;
                    beg = end;
                }
                end = str.length();
            }

            // Clipboard contains 'copy\n' or 'cut\n' as first line, thus skip it
            else
            {
                // Start after the 'copy\n' or 'cut\n' prefix
                end = clipboard.find('\n', 0);
                end++;
                beg = end;

                // Remove the 'file:' prefix for each file path
                while (1)
                {
                    end = clipboard.find('\n', end);
                    if (end < 0) // Last line
                    {
                        end = clipboard.length();
                        url = clipboard.mid(beg, end-beg+1);
                        pathname = FXURL::decode(FXURL::fileFromURL(url));
                        str += pathname;
                        break;
                    }
                    url = clipboard.mid(beg, end-beg+1);
                    pathname = FXURL::decode(FXURL::fileFromURL(url));
                    str += pathname;
                    end++;
                    beg = end;
                }
                end = str.length();
            }

            if (!str.empty())
            {
                len = str.length();
                FXMEMDUP(&data, str.text(), FXuchar, len);
                setDNDData(FROM_CLIPBOARD, event->target, data, len);

                return(1);
            }
        }
    }
    return(0);
}


// Copy or cut to clipboard (and add copy / add cut)
long FilePanel::onCmdCopyCut(FXObject*, FXSelector sel, void*)
{
    FXString name, curdir;

    // Clear clipboard if normal copy or cut
    if ((FXSELID(sel) == ID_COPY_CLIPBOARD) || (FXSELID(sel) == ID_CUT_CLIPBOARD))
    {
        clipboard.clear();
    }

    // Add an '\n' at the end if addcopy or addcut
    else
    {
        clipboard += '\n';
    }

    // Clipboard type
    if ((FXSELID(sel) == ID_CUT_CLIPBOARD) || (FXSELID(sel) == ID_ADDCUT_CLIPBOARD))
    {
        clipboard_type = CUT_CLIPBOARD;
    }
    else
    {
        clipboard_type = COPY_CLIPBOARD;
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        /* if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        } */

        // Construct the uri list of files and fill the clipboard with it
        curdir = current->list->getDirectory();

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                name = current->list->getItemText(u).text();
                name = name.section('\t', 0);
                if (curdir == ROOTDIR)
                {
                    clipboard += FXURL::encode(::fileToURI(curdir+name))+"\n";
                }
                else
                {
                    clipboard += FXURL::encode(::fileToURI(curdir+PATHSEPSTRING+name))+"\n";
                }
            }
        }
    }

    // Remove the last \n of the list, for compatibility with some file managers (e.g. nautilus, nemo)
    clipboard.erase(clipboard.length()-1);

    // Acquire the clipboard
    FXDragType types[4];
    types[0] = xfelistType;
    types[1] = kdelistType;
    types[2] = urilistType;
    types[3] = utf8Type;
    if (acquireClipboard(types, 4))
    {
        return(0);
    }

    return(1);
}


// Paste file(s) from clipboard
long FilePanel::onCmdPaste(FXObject*, FXSelector sel, void*)
{
    FXuchar* data;
    FXuint   len;
    int      beg, end, pos;
    FXString chaine, url, param;
    int      num = 0;
    FXbool   from_kde = false;

    // If source is xfelistType (Gnome, XFCE, or Xfe app)
    if (getDNDData(FROM_CLIPBOARD, xfelistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';

        clipboard = (char*)data;

        // Loop over clipboard items
        for (beg = 0; beg < clipboard.length(); beg = end+1)
        {
            if ((end = clipboard.find("\n", beg)) < 0)
            {
                end = clipboard.length();
            }

            // Obtain item url
            url = clipboard.mid(beg, end-beg);

            // Eventually remove the trailing '\r' if any
            if ((pos = url.rfind('\r')) > 0)
            {
                url.erase(pos);
            }

            // Process first item
            if (num == 0)
            {
                // First item should be "copy" or "cut"
                if (url == "copy")
                {
                    clipboard_type = COPY_CLIPBOARD;
                    num++;
                }
                else if (url == "cut")
                {
                    clipboard_type = CUT_CLIPBOARD;
                    num++;
                }

                // If first item is not "copy" nor "cut", process it as a normal url
                // and use default clipboard type
                else
                {
                    // Update the param string
                    param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";

                    // Add one more because the first line "copy" or "cut" was not present
                    num += 2;
                }
            }

            // Process other items
            else
            {
                // Update the param string
                param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";
                num++;
            }
        }

        // Construct the final param string passed to the file management routine
        param = current->list->getDirectory()+"\n" + FXStringVal(num-1) + "\n" + param;

        // Copy or cut operation depending on the clipboard type
        switch (clipboard_type)
        {
        case COPY_CLIPBOARD:
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_COPY);
            break;

        case CUT_CLIPBOARD:
            clipboard.clear();
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_CUT);
            break;
        }
        fromPaste = true;
        handle(this, sel, (void*)param.text());

        // Free data pointer
        FXFREE(&data);

        // Return here because xfelistType is not compatible with other types
        return(1);
    }

    // If source type is kdelistType (KDE)
    if (getDNDData(FROM_CLIPBOARD, kdelistType, data, len))
    {
        from_kde = true;

        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        clipboard = (char*)data;

        // Obtain clipboard type (copy or cut)
        if (clipboard == "1")
        {
            clipboard_type = CUT_CLIPBOARD;
        }
        else
        {
            clipboard_type = COPY_CLIPBOARD;
        }

        FXFREE(&data);
    }


    // If source type is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    if (getDNDData(FROM_CLIPBOARD, urilistType, data, len))
    {
        // For non KDE apps, set action to copy
        if (!from_kde)
        {
            clipboard_type = COPY_CLIPBOARD;
        }

        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        clipboard = (char*)data;

        // Loop over clipboard items
        for (beg = 0; beg < clipboard.length(); beg = end+1)
        {
            if ((end = clipboard.find("\n", beg)) < 0)
            {
                end = clipboard.length();
            }

            // Obtain item url
            url = clipboard.mid(beg, end-beg);

            // Eventually remove the trailing '\r' if any
            if ((pos = url.rfind('\r')) > 0)
            {
                url.erase(pos);
            }

            // Update the param string
            param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";
            num++;
        }

        // Construct the final param string passed to the file management routine
        param = current->list->getDirectory()+"\n" + FXStringVal(num) + "\n" + param;

        // Copy or cut operation depending on the clipboard type
        switch (clipboard_type)
        {
        case COPY_CLIPBOARD:
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_COPY);
            break;

        case CUT_CLIPBOARD:
            clipboard.clear();
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_CUT);
            break;
        }
        fromPaste = true;
        handle(this, sel, (void*)param.text());

        FXFREE(&data);
        return(1);
    }
    return(0);
}


// Execute file with an optional confirm dialog
void FilePanel::execFile(FXString pathname)
{
    int      ret;
    FXString cmd, cmdname;

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // File is executable, but is it a text file?
    FXString str = mimetype(pathname);
    FXbool   isTextFile = true;
    if (strstr(str.text(), "charset=binary"))
    {
        isTextFile = false;
    }

    // With confirmation dialog
    FXbool confirm_execute = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_execute", true);
    if (isTextFile && (confirm_execute == 1))
    {
        FXString msg;
        msg.format(_("File %s is an executable text file, what do you want to do?"), pathname.text());
        ExecuteBox* dlg = new ExecuteBox(this, _("Confirm Execute"), msg);
        FXuint      answer = dlg->execute(PLACEMENT_CURSOR);
        delete dlg;

        // Execute
        if (answer == EXECBOX_CLICKED_EXECUTE)
        {
            cmdname = FXPath::name(pathname);
            cmd = ::quote(pathname);
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // Execute in console mode
        if (answer == EXECBOX_CLICKED_CONSOLE)
        {
            ret = chdir(current->list->getDirectory().text());
            if (ret < 0)
            {
                int errcode = errno;
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
                }
            }

            cmdname = FXPath::name(pathname);
            cmd = ::quote(pathname);

            // Make and show command window
            // The CommandWindow object will delete itself when closed!
            CommandWindow* cmdwin = new CommandWindow(getApp(), _("Command log"), cmd, 30, 80);
            cmdwin->create();
            cmdwin->setIcon(runicon);

            ret = chdir(startlocation.text());
            if (ret < 0)
            {
                int errcode = errno;
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
                }
            }
        }

        // Edit
        if (answer == EXECBOX_CLICKED_EDIT)
        {
            FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
            cmd = txteditor;
            cmdname = cmd;

            // If command exists, run it
            if (::existCommand(cmdname))
            {
                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
            }

            // If command does not exist, call the "Open with..." dialog
            else
            {
                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
            }
        }
    }

    // Without confirmation dialog
    else
    {
        cmdname = FXPath::name(pathname);
        cmd = ::quote(pathname);
#ifdef STARTUP_NOTIFICATION
        runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
        runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
    }
}


// Double Click on File Item
long FilePanel::onCmdItemDoubleClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    FXString cmd, cmdname, filename, pathname;

    // Wait cursor
    getApp()->beginWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);

    // At most one item selected
    if (current->list->getNumSelectedItems() <= 1)
    {
        FXlong item = (FXlong)ptr;
        if (item > -1)
        {
#ifdef STARTUP_NOTIFICATION
            // Startup notification option and exceptions (if any)
            FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
            FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

            // Default programs
            FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
            FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
            FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
            FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
            FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
            FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
            FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
            FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

            // File name and path
            filename = list->getItemFilename(item);
            pathname = list->getItemPathname(item);

            // If directory, open the directory
            if (list->isItemDirectory(item))
            {
                // Does not have access
                if (!::isReadExecutable(pathname))
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _(" Permission to: %s denied."), pathname.text());
                    getApp()->endWaitCursor();
		    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                    return(0);
                }
                if (filename == "..")
                {
                    list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
                    //list->hide();
                }
                else
                {
                    list->setDirectory(pathname);
                }

                // Change directory in tree list
                dirpanel->setDirectory(pathname, true);
                current->updatePath();

                // Update location history
                updateLocation();
            }
            else if (list->isItemFile(item))
            {
                // Update associations dictionary
                FileDict*  assocdict = new FileDict(getApp());
                FileAssoc* association = assocdict->findFileBinding(pathname.text());

                // If there is an association
                if (association)
                {
                    // Use it to open the file
                    if (association->command.section(',', 0) != "")
                    {
                        cmdname = association->command.section(',', 0);

                        // Use a default program if possible
                        switch (progs[cmdname])
                        {
                        case TXTVIEWER:
                            cmdname = txtviewer;
                            break;

                        case TXTEDITOR:
                            cmdname = txteditor;
                            break;

                        case IMGVIEWER:
                            cmdname = imgviewer;
                            break;

                        case IMGEDITOR:
                            cmdname = imgeditor;
                            break;

                        case PDFVIEWER:
                            cmdname = pdfviewer;
                            break;

                        case AUDIOPLAYER:
                            cmdname = audioplayer;
                            break;

                        case VIDEOPLAYER:
                            cmdname = videoplayer;
                            break;

                        case ARCHIVER:
                            cmdname = archiver;
                            break;

                        case NONE: // No program found
                            ;
                            break;
                        }

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
			    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // Or execute the file
                    else if (list->isItemExecutable(item))
                    {
                        execFile(pathname);
                    }

                    // Or call the "Open with..." dialog
                    else
                    {
                        getApp()->endWaitCursor();
			mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }

                // If no association but executable
                else if (list->isItemExecutable(item))
                {
                    execFile(pathname);
                }

                // Other cases
                else
                {
                    getApp()->endWaitCursor();
		    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                    current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                }
            }
        }
    }

    // More than one selected files
    else
    {
        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN), NULL);
    }

    getApp()->endWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);

    return(1);
}


// Single click on File Item
long FilePanel::onCmdItemClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    // Make panel active
    setActive();

    if (single_click != SINGLE_CLICK_NONE)
    {
        // Default programs
        FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
        FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
        FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
        FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
        FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
        FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
        FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
        FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

        // In detailed mode, avoid single click when mouse cursor is not over the first column
        int    x, y;
        FXuint state;
        getCursorPosition(x, y, state);
        FXbool allow = true;
        if (!(list->getListStyle()&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS)) && ((x-list->getXPosition()) > list->getHeaderSize(0)))
        {
            allow = false;
        }

        // Single click with control or shift
        if (state&(CONTROLMASK|SHIFTMASK))
        {
            return(1);
        }

        // Single click without control or shift
        else
        {
            FXString cmd, cmdname, filename, pathname;

            // Wait cursor
            getApp()->beginWaitCursor();

#ifdef STARTUP_NOTIFICATION
            // Startup notification option and exceptions (if any)
            FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
            FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

            FXlong item = (FXlong)ptr;
            if (item > -1)
            {
                // File name and path
                filename = list->getItemFilename(item);
                pathname = list->getItemPathname(item);

                // If directory, open the directory
                if ((single_click != SINGLE_CLICK_NONE) && list->isItemDirectory(item) && allow)
                {
                    // Does not have access
                    if (!::isReadExecutable(pathname))
                    {
                        MessageBox::error(this, BOX_OK_SU, _("Error"), _(" Permission to: %s denied."), pathname.text());
                        getApp()->endWaitCursor();
                        return(0);
                    }
                    if (filename == "..")
                    {
                        list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
                    }
                    else
                    {
                        list->setDirectory(pathname);
                    }

                    // Change directory in tree list
                    dirpanel->setDirectory(pathname, true);
                    current->updatePath();

                    // Update location history
                    updateLocation();
                }

                // If file, use the association if any
                else if ((single_click == SINGLE_CLICK_DIR_FILE) && list->isItemFile(item) && allow)
                {
                    // Update associations dictionary
                    FileDict*  assocdict = new FileDict(getApp());
                    FileAssoc* association = assocdict->findFileBinding(pathname.text());

                    // If there is an association
                    if (association)
                    {
                        // Use it to open the file
                        if (association->command.section(',', 0) != "")
                        {
                            cmdname = association->command.section(',', 0);

                            // Use a default program if possible
                            switch (progs[cmdname])
                            {
                            case TXTVIEWER:
                                cmdname = txtviewer;
                                break;

                            case TXTEDITOR:
                                cmdname = txteditor;
                                break;

                            case IMGVIEWER:
                                cmdname = imgviewer;
                                break;

                            case IMGEDITOR:
                                cmdname = imgeditor;
                                break;

                            case PDFVIEWER:
                                cmdname = pdfviewer;
                                break;

                            case AUDIOPLAYER:
                                cmdname = audioplayer;
                                break;

                            case VIDEOPLAYER:
                                cmdname = videoplayer;
                                break;

                            case ARCHIVER:
                                cmdname = archiver;
                                break;

                            case NONE: // No program found
                                ;
                                break;
                            }

                            // If command exists, run it
                            if (::existCommand(cmdname))
                            {
                                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                            }

                            // If command does not exist, call the "Open with..." dialog
                            else
                            {
                                getApp()->endWaitCursor();
                                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                            }
                        }

                        // Or execute the file
                        else if (list->isItemExecutable(item))
                        {
                            execFile(pathname);
                        }

                        // Or call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // If no association but executable
                    else if (list->isItemExecutable(item))
                    {
                        execFile(pathname);
                    }

                    // Other cases
                    else
                    {
                        getApp()->endWaitCursor();
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }
            }
            getApp()->endWaitCursor();
        }
    }
    return(1);
}


// Go to parent directory
long FilePanel::onCmdDirectoryUp(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
    current->list->setFocus();
    dirpanel->setDirectory(current->list->getDirectory(), true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Go to home directory
long FilePanel::onCmdGoHome(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setDirectory(homedir);
    current->list->setFocus();
    dirpanel->setDirectory(homedir, true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Go to trash directory
long FilePanel::onCmdGoTrash(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setDirectory(trashfileslocation);
    current->list->setFocus();
    dirpanel->setDirectory(trashfileslocation, true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Set the flag that allows to stop the file list refresh
long FilePanel::onCmdStopListRefreshTimer(FXObject*, FXSelector, void*)
{
    stopListRefresh = true;

    return(0);
}


// Copy/Move/Rename/Symlink file(s)
long FilePanel::onCmdFileMan(FXObject* sender, FXSelector sel, void* ptr)
{
    int      num;
    FXString src, targetdir, target, name, source;
    int      firstitem = 0, lastitem = 0;

    // Focus on this panel list
    current->list->setFocus();

    // Confirmation dialog?
    FXbool ask_before_copy = getApp()->reg().readUnsignedEntry("OPTIONS", "ask_before_copy", true);

    // If we are we called from the paste command, get the parameters from the pointer
    if (fromPaste)
    {
        // Reset the flag
        fromPaste = false;

        // Get the parameters
        FXString str = (char*)ptr;
        targetdir = str.section('\n', 0);
        num = FXUIntVal(str.section('\n', 1));
        src = str.after('\n', 2);

        // If no item in clipboard, return
        if (num <= 0)
        {
            return(0);
        }

        // If there is a selected directory in file panel, use it as target directory
        if (current->list->getNumSelectedItems() == 1)
        {
            int item = current->list->getCurrentItem();
            if (current->list->isItemDirectory(item))
            {
                targetdir = list->getItemPathname(item);
            }
        }
    }

    // Obtain the parameters from the file panel
    else
    {
        // Current directory
        FXString curdir = current->list->getDirectory();

        // Number of selected items
        num = current->list->getNumSelectedItems();

        // If no item, return
        if (num <= 0)
        {
            return(0);
        }

        // Eventually deselect the '..' directory
        /* if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        } */

        // Obtain the list of source files and the target directory
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                if (firstitem == 0)
                {
                    firstitem = u;
                }
                lastitem = u;
                name = current->list->getItemText(u).text();
                name = name.section('\t', 0);
                src += curdir+PATHSEPSTRING+name+"\n";
            }
        }
        targetdir = current->next->list->getDirectory();

        if (!current->next->shown() || (FXSELID(sel) == ID_FILE_RENAME))
        {
            targetdir = current->list->getDirectory();
        }
    }

    // Number of items in the FileList
    int numitems = current->list->getNumItems();

    // Name and directory of the first source file
    source = src.section('\n', 0);
    name = FXPath::name(source);
    FXString dir = FXPath::directory(source);

    // Initialize target name
    if (targetdir != ROOTDIR)
    {
        target = targetdir+PATHSEPSTRING;
    }
    else
    {
        target = targetdir;
    }

    // Configure the command, title, message, etc.
    FXIcon*  icon = NULL;
    FXString command, title, message;
    if (FXSELID(sel) == ID_FILE_COPY)
    {
        command = "copy";
        title = _("Copy");
        icon = copy_bigicon;
        if (num == 1)
        {
            message = _("Copy ");
            message += source;
            if (::isFile(source))
            {
                target += name;
            }

            // Source and target are identical => add a suffix to the name
            FXString tgt = ::cleanPath(target); // Remove trailing / if any
            if ((::identical(source, tgt) && (tgt != current->list->getDirectory())) || // Check we are not within target
                (::isDirectory(source) && (source == tgt+PATHSEPSTRING+FXPath::name(source))))
            {
                target = ::buildCopyName(source);
            }
        }
        else
        {
            message.format(_("Copy %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_RENAME)
    {
        command = "rename";
        title = _("Rename");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Rename ");
            message += name;
            target = name;
            title = _("Rename");
        }
        else
        {
            return(0);
        }
    }
    if (FXSELID(sel) == ID_FILE_COPYTO)
    {
        command = "copy";
        title = _("Copy");
        icon = copy_bigicon;
        if (num == 1)
        {
            message = _("Copy ");
            message += source;
        }
        else
        {
            message.format(_("Copy %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_MOVETO)
    {
        command = "move";
        title = _("Move");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Move ");
            message += source;
            title = _("Move");
        }
        else
        {
            message.format(_("Move %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_CUT)
    {
        command = "move";
        title = _("Move");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Move ");
            message += source;
            if (::isFile(source))
            {
                target += name;
            }
            title = _("Move");
        }
        else
        {
            message.format(_("Move %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_SYMLINK)
    {
        command = "symlink";
        title = _("Symlink");
        icon = link_bigicon;
        if (num == 1)
        {
            message = _("Symlink ");
            message += source;
            target += name;
        }
        else
        {
            message.format(_("Symlink %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }

    // File operation dialog, if needed
    if (ask_before_copy || (source == target) || (FXSELID(sel) == ID_FILE_COPYTO) || (FXSELID(sel) == ID_FILE_MOVETO) || (FXSELID(sel) == ID_FILE_RENAME) || (FXSELID(sel) == ID_FILE_SYMLINK))
    {
        if (num == 1)
        {
            if (FXSELID(sel) == ID_FILE_RENAME)
            {
                if (operationdialogrename == NULL)
                {
                    operationdialogrename = new InputDialog(this, "", "", title, _("To:"), icon);
                }
                operationdialogrename->setTitle(title);
                operationdialogrename->setIcon(icon);
				operationdialogrename->setMessage(message);
                operationdialogrename->setText(target);

                if (::isDirectory(source))  // directory
                {
                    operationdialogrename->selectAll();
                }
                else
                {
                    int pos = target.rfind('.');
                    if (pos <= 0)
                    {
                        operationdialogrename->selectAll(); // no extension or dot file
                    }
                    else
                    {
                        operationdialogrename->setSelection(0, pos);
                    }
                }

                int rc = 1;
                rc = operationdialogrename->execute(PLACEMENT_CURSOR);
                target = operationdialogrename->getText();
                
                // Target name contains '/'
                if (target.contains(PATHSEPCHAR))
                {
					MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in file or folder names, operation cancelled"));
					return(0);
				}

                if (!rc)
                {
                    return(0);
                }
            }
            else
            {
                if (operationdialogsingle == NULL)
                {
                    operationdialogsingle = new BrowseInputDialog(this, "", "", title, _("To:"), icon, BROWSE_INPUT_MIXED);
                }
                operationdialogsingle->setTitle(title);
                operationdialogsingle->setIcon(icon);
                operationdialogsingle->setMessage(message);
                operationdialogsingle->setText(target);

                // Select file name without path
                if (FXSELID(sel) == ID_FILE_SYMLINK)
                {
                    int pos = target.rfind(PATHSEPSTRING);
                    if (pos >= 0)
                    {
                        operationdialogsingle->setSelection(pos+1, target.length());
                    }
                }

                operationdialogsingle->setDirectory(targetdir);
                int rc = 1;
                rc = operationdialogsingle->execute(PLACEMENT_CURSOR);
                target = operationdialogsingle->getText();
                if (!rc)
                {
                    return(0);
                }
            }
        }
        else
        {
            if (operationdialogmultiple == NULL)
            {
                operationdialogmultiple = new BrowseInputDialog(this, "", "", title, _("To folder:"), icon, BROWSE_INPUT_FOLDER);
            }
            operationdialogmultiple->setTitle(title);
            operationdialogmultiple->setIcon(icon);
            operationdialogmultiple->setMessage(message);
            operationdialogmultiple->setText(target);
            operationdialogmultiple->CursorEnd();
            operationdialogmultiple->setDirectory(targetdir);
            int rc = 1;
            rc = operationdialogmultiple->execute(PLACEMENT_CURSOR);
            target = operationdialogmultiple->getText();
            if (!rc)
            {
                return(0);
            }
        }
    }

    // Nothing entered
    if (target == "")
    {
        MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
        return(0);
    }

    // Update target and target parent directory
	target = ::filePath(target,current->list->getDirectory());
	if (::isDirectory(target))
	{
		targetdir = target;
	}
	else
	{
		targetdir = FXPath::directory(target);
	}

    // Target parent directory doesn't exist
    if (!::exists(targetdir))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), targetdir.text());
        return(0);
    }

    // Target parent directory not writable
    if (!::isWritable(targetdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetdir.text());
        return(0);
    }

    // Target parent directory is not a directory
    if (!::isDirectory(targetdir))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("%s is not a folder"), targetdir.text());
        return(0);
    }

    // Multiple sources and non existent destination
    if ((num > 1) && !::exists(target))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), target.text());
        return(0);
    }

    // Multiple sources and target is a file
    if ((num > 1) && ::isFile(target))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("%s is not a folder"), target.text());
        return(0);
    }

    // Target is a directory and is not writable
    if (::isDirectory(target) && !::isWritable(target))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), target.text());
        return(0);
    }

    // Target is a file and its parent directory is not writable
    if (::isFile(target) && !::isWritable(targetdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetdir.text());
        return(0);
    }

    // One source
    File* f = NULL;
    int   ret;
    if (num == 1)
    {
        // An empty source file name corresponds to the ".." file
        // Don't perform any file operation on it!
        if (source == "")
        {
            return(0);
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        if (command == "copy")
        {
            f = new File(this, _("File copy"), COPY, num);
            f->create();

            // If target file is located at trash location, also create the corresponding trashinfo file
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && (target == trashfileslocation))
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(source, trashfileslocation);

                // Adjust target name to get the _N suffix if any
                FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                // Create trashinfo file
                createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                // Copy source to trash target
                ret = f->copy(source, trashtarget);
            }

            // Copy source to target
            else
            {
                ret = f->copy(source, target);
            }

            // An unknown error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
            }
        }
        else if (command == "rename")
        {
            f = new File(this, _("File rename"), RENAME, num);
            f->create();
            ret = f->rename(source, target);

            // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
            {
                FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                ::unlink(trashinfopathname.text());
            }
        }
        else if (command == "move")
        {
            f = new File(this, _("File move"), MOVE, num);
            f->create();

            // If target file is located at trash location, also create the corresponding trashinfo file
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && (target == trashfileslocation))
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(source, trashfileslocation);

                // Adjust target name to get the _N suffix if any
                FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                // Create trashinfo file
                createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                // Move source to trash target
                ret = f->move(source, trashtarget);
            }

            // Move source to target
            else
            {
                ret = f->move(source, target);
            }

            // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
            // Do it silently and don't report any error if it fails
            if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
            {
                FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                ::unlink(trashinfopathname.text());
            }

            // An unknown error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
            }
        }
        else if (command == "symlink")
        {
            f = new File(this, _("Symlink"), SYMLINK, num);
            f->create();
            f->symlink(source, target);
        }
        // Shouldn't happen
        else
        {
            exit(EXIT_FAILURE);
        }

        getApp()->endWaitCursor();
        delete f;
    }

    // Multiple sources
    // Note : rename cannot be used in this case!
    else if (num > 1)
    {
        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        if (command == "copy")
        {
            f = new File(this, _("File copy"), COPY, num);
        }
        else if (command == "move")
        {
            f = new File(this, _("File move"), MOVE, num);
        }
        else if (command == "symlink")
        {
            f = new File(this, _("Symlink"), SYMLINK, num);
        }
        // Shouldn't happen
        else
        {
            exit(EXIT_FAILURE);
        }
        f->create();

        // Initialize file list stop refresh timer and flag
        stopListRefresh = false;
        getApp()->addTimeout(this, ID_STOP_LIST_REFRESH_TIMER, STOP_LIST_REFRESH_INTERVAL);

        // Loop on the multiple files
        for (int i = 0; i < num; i++)
        {
            // Stop refreshing the file list if file operation is long and has many files
            // This avoids flickering and speeds up things a bit
            if (stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
            {
                // Force a last refresh if current panel is destination
                if (current->getDirectory() == targetdir)
                {
                    current->list->onCmdRefresh(0, 0, 0);
                }

                // Force a last refresh if next panel is destination
                if (next->getDirectory() == targetdir)
                {
                    next->list->onCmdRefresh(0, 0, 0);
                }

                // Tell the dir and file list to not refresh anymore
                setAllowRefresh(false);
                next->setAllowRefresh(false);
                dirpanel->setAllowDirsizeRefresh(false);

                // Don't need to stop again
                stopListRefresh = false;
            }

            // Individual source file
            source = src.section('\n', i);

            // File could have already been moved above in the tree
            if (!::exists(source))
            {
                continue;
            }

            // An empty file name corresponds to the ".." file (why?)
            // Don't perform any file operation on it!
            if (source != "")
            {
                if (command == "copy")
                {
                    // If target file is located at trash location, also create the corresponding trashinfo file
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (target == trashfileslocation))
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(source, trashfileslocation);

                        // Adjust target name to get the _N suffix if any
                        FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                        // Create trashinfo file
                        createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                        // Copy source to trash target
                        ret = f->copy(source, trashtarget);
                    }

                    // Copy source to target
                    else
                    {
                        ret = f->copy(source, target);
                    }

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
                        break;
                    }
                }
                else if (command == "move")
                {
                    // If target file is located at trash location, also create the corresponding trashinfo file
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (target == trashfileslocation))
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(source, trashfileslocation);

                        // Adjust target name to get the _N suffix if any
                        FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                        // Create trashinfo file
                        createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                        // Move source to trash target
                        ret = f->move(source, trashtarget);
                    }

                    // Move source to target
                    else
                    {
                        ret = f->move(source, target);
                    }

                    // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
                    // Do it silently and don't report any error if it fails
                    if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
                    {
                        FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                        ::unlink(trashinfopathname.text());
                    }

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
                        break;
                    }
                }
                else if (command == "symlink")
                {
                    ret = f->symlink(source, target);

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the symlink operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Symlink operation cancelled!"));
                        break;
                    }
                }
                // Shouldn't happen
                else
                {
                    exit(EXIT_FAILURE);
                }
            }
        }

        // Reinit timer and refresh flags
        getApp()->removeTimeout(this, ID_STOP_LIST_REFRESH_TIMER);
        current->setAllowRefresh(true);
        next->setAllowRefresh(true);
        dirpanel->setAllowDirsizeRefresh(true);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panels refresh
    next->onCmdRefresh(0, 0, 0);
    current->onCmdRefresh(0, 0, 0);

    // Enable previous or last selected item for keyboard navigation
    if (((FXSELID(sel) == ID_FILE_MOVETO) || (FXSELID(sel) == ID_FILE_RENAME)) && (current->list->getNumItems() < numitems))
    {
        firstitem = (firstitem < 1) ? 0 : firstitem-1;
        current->list->enableItem(firstitem);
        current->list->setCurrentItem(firstitem);
    }
    else
    {
        current->list->enableItem(lastitem);
        current->list->setCurrentItem(lastitem);
    }

    return(1);
}


// Trash files from the file list or the tree list
long FilePanel::onCmdFileTrash(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();

    FXbool confirm_trash = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_trash", true);

    // If we don't have permission to write to the parent directory
    if (!::isWritable(dir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
        return(0);
    }

    // If we don't have permission to write to the trash directory
    if (!::isWritable(trashfileslocation))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to trash location %s: Permission denied"), trashfileslocation.text());
        return(0);
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        /* if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        } */

        if (confirm_trash)
        {
            FXString message;
            if (num == 1)
            {
                FXString pathname;
                for (int u = 0; u < current->list->getNumItems(); u++)
                {
                    if (current->list->isItemSelected(u))
                    {
                        pathname = current->list->getItemPathname(u);
                    }
                }
                if (::isDirectory(pathname))
                {
                    message.format(_("Move folder %s to trash can?"), pathname.text());
                }
                else
                {
                    message.format(_("Move file %s to trash can?"), pathname.text());
                }
            }
            else
            {
                message.format(_("Move %s selected object(s) to trash can?"), FXStringVal(num).text());
            }

            MessageBox box(this, _("Confirm Trash"), message, delete_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
            if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
            {
                return(0);
            }
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Move to trash"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Overwrite initialisations
        FXbool overwrite = false;
        FXbool overwrite_all = false;
        FXbool skip_all = false;

        // Delete selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // If we don't have permission to write to the file
                if (!::isWritable(pathname))
                {
                    // Overwrite dialog if necessary
                    if (!(overwrite_all | skip_all))
                    {
                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("File %s is write-protected, move it anyway to trash can?"), pathname.text());
                        
                        if (num ==1)
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Trash"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;	
							if (answer == 1)
							{
								overwrite = true;
							}
							else
							{
								goto end;
							}
						}  
                        else
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Trash"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Overwrite
							case 1:
								overwrite = true;
								break;

							// Overwrite all
							case 2:
								overwrite_all = true;
								break;

							// Skip
							case 3:
								overwrite = false;
								break;

							// Skip all
							case 4:
								skip_all = true;
								break;
							}
							
						}
                    }
                    if ((overwrite | overwrite_all) & !skip_all)
                    {
                        // Caution!! Don't delete parent directory!!
                        if (filename != "..")
                        {
                            // Trash files path name
                            FXString trashpathname = createTrashpathname(pathname, trashfileslocation);

                            // Create trashinfo file
                            createTrashinfo(pathname, trashpathname, trashfileslocation, trashinfolocation);

                            // Move file to trash files location
                            int ret = f->move(pathname, trashpathname);

                            // An error has occurred
                            if ((ret == 0) && !f->isCancelled())
                            {
                                f->hideProgressDialog();
                                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move to trash operation!"));
                                break;
                            }
                        }
                    }
                    f->showProgressDialog();
                }

                // If we have permission to write
                else
                {
                    // Caution!! Don't delete parent directory!!
                    if (filename != "..")
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(pathname, trashfileslocation);

                        // Create trashinfo file
                        createTrashinfo(pathname, trashpathname, trashfileslocation, trashinfolocation);

                        // Move file to trash files location
                        int ret = f->move(pathname, trashpathname);

                        // An error has occurred
                        if ((ret == 0) && !f->isCancelled())
                        {
                            f->hideProgressDialog();
                            MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move to trash operation!"));
                            break;
                        }
                    }
                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Move to trash file operation cancelled!"));
                        break;
                    }
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// Restore files from trash can
long FilePanel::onCmdFileRestore(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();
    FXbool   confirm_trash = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_trash", true);

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        /* if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        } */

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Restore from trash"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Restore (i.e. move to their original location) selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // Don't restore '..' directory
                if (filename != "..")
                {
                    // Obtain trash base name and sub path
                    FXString subpath = pathname;
                    subpath.erase(0, trashfileslocation.length()+1);
                    FXString trashbasename = subpath.before('/');
                    if (trashbasename == "")
                    {
                        trashbasename = name;
                    }
                    subpath.erase(0, trashbasename.length());

                    // Read the .trashinfo file
                    FILE*    fp;
                    char     line[1024];
                    FXbool   success = true;
                    FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+trashbasename+".trashinfo";
                    FXString origpathname = "";

                    if ((fp = fopen(trashinfopathname.text(), "r")) != NULL)
                    {
                        // Read the first two lines and get the strings
                        if (fgets(line, sizeof(line), fp) == NULL)
                        {
                            success = false;
                        }
                        if (fgets(line, sizeof(line), fp) == NULL)
                        {
                            success = false;
                        }
                        if (success)
                        {
                            origpathname = line;
                            origpathname = origpathname.after('=');
                            origpathname = origpathname.before('\n');
                        }
                        fclose(fp);
                        origpathname = origpathname+subpath;
                    }

                    // Confirm restore dialog
                    if (confirm_trash && (u == firstitem))
                    {
                        FXString message;
                        if (num == 1)
                        {
                            if (::isDirectory(pathname))
                            {
                                message.format(_("Restore folder %s to its original location %s ?"), filename.text(), origpathname.text());
                            }
                            else
                            {
                                message.format(_("Restore file %s to its original location %s ?"), filename.text(), origpathname.text());
                            }
                        }
                        else
                        {
                            message.format(_("Restore %s selected object(s) to their original locations?"), FXStringVal(num).text());
                        }
                        f->hideProgressDialog();
                        MessageBox box(this, _("Confirm Restore"), message, restore_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
                        if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
                        {
                            getApp()->endWaitCursor();
                            delete f;
                            return(0);
                        }
                        f->showProgressDialog();
                    }

                    if (origpathname == "")
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("Restore information not available for %s"), pathname.text());
                        goto end;
                    }

                    // If parent dir of the original location does not exist
                    FXString origparentdir = FXPath::directory(origpathname);
                    if (!::exists(origparentdir))
                    {
                        // Ask the user if he wants to create it
                        f->hideProgressDialog();
                        FXString message;
                        message.format(_("Parent folder %s does not exist, do you want to create it?"), origparentdir.text());
                        MessageBox box(this, _("Confirm Restore"), message, restore_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
                        if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
                        {
                            goto end;
                        }
                        else
                        {
                            errno = 0;
                            int ret = mkpath(origparentdir.text(), 0755);
                            int errcode = errno;
                            if (ret == -1)
                            {
                                f->hideProgressDialog();
                                if (errcode)
                                {
                                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't create folder %s: %s"), origparentdir.text(), strerror(errcode));
                                }
                                else
                                {
                                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't create folder %s"), origparentdir.text());
                                }
                                goto end;
                            }
                            f->showProgressDialog();
                        }
                    }

                    // Move file to original location (with restore option)
                    int ret = f->move(pathname, origpathname, true);

                    // An error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the restore from trash operation!"));
                        goto end;
                    }

                    // Silently remove trashinfo file
                    FXString trashfilespathname = trashfileslocation+PATHSEPSTRING+trashbasename;
                    if ((pathname == trashfilespathname) && !::exists(trashfilespathname))
                    {
                        ::unlink(trashinfopathname.text());
                    }
                }
                // If action is cancelled in progress dialog
                if (f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Warning"), _("Restore from trash file operation cancelled!"));
                    goto end;
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// Definitively delete files from the file list or the tree list (no trash can)
long FilePanel::onCmdFileDelete(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();

    FXbool confirm_del = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete", true);
    FXbool confirm_del_emptydir = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete_emptydir", true);

    // If we don't have permission to write to the parent directory
    if (!::isWritable(dir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
        return(0);
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        /* if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        } */

        if (confirm_del)
        {
            FXString message;
            if (num == 1)
            {
                FXString pathname;
                for (int u = 0; u < current->list->getNumItems(); u++)
                {
                    if (current->list->isItemSelected(u))
                    {
                        pathname = current->list->getItemPathname(u);
                    }
                }
                if (::isDirectory(pathname))
                {
                    message.format(_("Definitively delete folder %s ?"), pathname.text());
                }
                else
                {
                    message.format(_("Definitively delete file %s ?"), pathname.text());
                }
            }
            else
            {
                message.format(_("Definitively delete %s selected object(s)?"), FXStringVal(num).text());
            }
            MessageBox box(this, _("Confirm Delete"), message, delete_big_permicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
            if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
            {
                return(0);
            }
        }
        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("File delete"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Overwrite initialisations
        FXbool overwrite = false;
        FXbool overwrite_all = false;
        FXbool skip_all = false;
        FXbool ask_del_empty = true;
        FXbool skip_all_del_emptydir = false;

        // Delete selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // Confirm empty directory deletion
                if (confirm_del & confirm_del_emptydir & ask_del_empty)
                {
                    if ((::isEmptyDir(pathname) == 0) && !::isLink(pathname))
                    {
                        if (skip_all_del_emptydir)
                        {
                            continue;
                        }

                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("Folder %s is not empty, delete it anyway?"), pathname.text());

                        if (num ==1)
                        {
                        	OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							
							if (answer == 0)
							{
								goto end;
							}
						}
                        
                        else
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Yes
							case 1:
								break;

							// Yes for all
							case 2:
								ask_del_empty = false;
								break;

							// Skip
							case 3:
								continue;
								break;

							// Skip all
							case 4:
								skip_all_del_emptydir = true;
								continue;
								break;
							}
						}
						f->showProgressDialog();
                    }
                }

                // If we don't have permission to write to the file
                if (!::isWritable(pathname))
                {
                    // Overwrite dialog if necessary
                    if (!(overwrite_all | skip_all))
                    {
                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("File %s is write-protected, delete it anyway?"), pathname.text());
  
  						if (num == 1)
  						{
                        	OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							if (answer == 1)
							{
								overwrite = true;
							}
							else
							{
								goto end;
							}							
						}
  
 						else
 						{
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Yes
							case 1:
								overwrite = true;
								break;

							// Yes for all
							case 2:
								overwrite_all = true;
								break;

							// Skip
							case 3:
								overwrite = false;
								break;

							// Skip all
							case 4:
								skip_all = true;
								break;
							}
						} 
                    }
                    if ((overwrite | overwrite_all) & !skip_all)
                    {
                        // Caution!! Don't delete parent directory!!
                        if (filename != "..")
                        {
                            // Definitively remove file or folder
                            f->remove(pathname);
                        }
                    }
                    f->showProgressDialog();
                }

                // If we have permission to write
                else
                {
                    // Caution!! Don't delete parent directory!!
                    if (filename != "..")
                    {
                        // Definitively remove file or folder
                        f->remove(pathname);

                        // If is located at trash location, try to also remove the corresponding trashinfo file if it exists
                        // Do it silently and don't report any error if it fails
                        FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                        if (use_trash_can && (pathname.left(trashfileslocation.length()) == trashfileslocation))
                        {
                            FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+filename+".trashinfo";
                            ::unlink(trashinfopathname.text());
                        }
                    }
                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Delete file operation cancelled!"));
                        break;
                    }
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// View/Edit files
long FilePanel::onCmdEdit(FXObject*, FXSelector s, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString   pathname, samecmd, cmd, cmdname, itemslist = " ";
    FileAssoc* association;
    FXbool     same = true;
    FXbool     first = true;

    current->list->setFocus();

    if (current->list->getNumSelectedItems() == 0)
    {
        getApp()->endWaitCursor();
        return(0);
    }

    FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
    FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
    FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
    FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
    FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
    FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
    FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
    FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

    // Update associations dictionary
    FileDict* assocdict = new FileDict(getApp());

    // Check if all files have the same association
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            // Increment number of selected items
            pathname = current->list->getItemPathname(u);
            association = assocdict->findFileBinding(pathname.text());

            // If there is an association
            if (association)
            {
                // Use it to edit/view the files
                if (FXSELID(s) == ID_EDIT) // Edit
                {
                    cmd = association->command.section(',', 2);

                    // Use a default editor if possible
                    switch (progs[cmd])
                    {
                    case TXTEDITOR:
                        cmd = txteditor;
                        break;

                    case IMGEDITOR:
                        cmd = imgeditor;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No default editor found
                        ;
                        break;
                    }

                    if (cmd.length() == 0)
                    {
                        cmd = txteditor;
                    }
                }
                else // Any other is View
                {
                    cmd = association->command.section(',', 1);

                    // Use a default viewer if possible
                    switch (progs[cmd])
                    {
                    case TXTVIEWER:
                        cmd = txtviewer;
                        break;

                    case IMGVIEWER:
                        cmd = imgviewer;
                        break;

                    case PDFVIEWER:
                        cmd = pdfviewer;
                        break;

                    case AUDIOPLAYER:
                        cmd = audioplayer;
                        break;

                    case VIDEOPLAYER:
                        cmd = videoplayer;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No default viewer found
                        ;
                        break;
                    }

                    if (cmd.length() == 0)
                    {
                        cmd = txtviewer;
                    }
                }
                if (cmd.text() != NULL)
                {
                    // First selected item
                    if (first)
                    {
                        samecmd = cmd;
                        first = false;
                    }

                    if (samecmd != cmd)
                    {
                        same = false;
                        break;
                    }

                    // List of selected items
                    itemslist += ::quote(pathname) + " ";
                }
                else
                {
                    same = false;
                    break;
                }
            }

            // No association
            else
            {
                same = false;
                break;
            }
        }
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // Same association for all files : execute the associated or default editor or viewer
    if (same)
    {
        cmdname = samecmd;

        // If command exists, run it
        if (::existCommand(cmdname))
        {
            cmd = cmdname+itemslist;
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
        }
    }

    // Files have different associations : handle them separately
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);

                // Only View / Edit regular files (not directories)
                if (::isFile(pathname))
                {
                    association = assocdict->findFileBinding(pathname.text());

                    // If there is an association
                    if (association)
                    {
                        // Use it to edit/view the file
                        if (FXSELID(s) == ID_EDIT) // Edit
                        {
                            cmd = association->command.section(',', 2);

                            // Use a default editor if possible
                            switch (progs[cmd])
                            {
                            case TXTEDITOR:
                                cmd = txteditor;
                                break;

                            case IMGEDITOR:
                                cmd = imgeditor;
                                break;

                            case ARCHIVER:
                                cmd = archiver;
                                break;
                            }

                            if (cmd.length() == 0)
                            {
                                cmd = txteditor;
                            }
                        }
                        else // Any other is View
                        {
                            cmd = association->command.section(',', 1);

                            // Use a default viewer if possible
                            switch (progs[cmd])
                            {
                            case TXTVIEWER:
                                cmd = txtviewer;
                                break;

                            case IMGVIEWER:
                                cmd = imgviewer;
                                break;

                            case PDFVIEWER:
                                cmd = pdfviewer;
                                break;

                            case AUDIOPLAYER:
                                cmd = audioplayer;
                                break;

                            case VIDEOPLAYER:
                                cmd = videoplayer;
                                break;

                            case ARCHIVER:
                                cmd = archiver;
                                break;

                            case NONE: // No default viewer found
                                ;
                                break;
                            }

                            if (cmd.length() == 0)
                            {
                                cmd = txtviewer;
                            }
                        }

                        if (cmd.text() != NULL)
                        {
                            cmdname = cmd;

                            // If command exists, run it
                            if (::existCommand(cmdname))
                            {
                                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                            }

                            // If command does not exist, call the "Open with..." dialog
                            else
                            {
                                getApp()->endWaitCursor();
                                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                            }
                        }
                    }

                    // No association
                    else
                    {
                        if (FXSELID(s) == ID_EDIT)
                        {
                            cmd = txteditor;
                        }
                        else
                        {
                            cmd = txtviewer;
                        }

                        cmdname = cmd;

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }
                }
            }
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Compare two files
long FilePanel::onCmdCompare(FXObject*, FXSelector s, void*)
{
    current->list->setFocus();
    int num = current->list->getNumSelectedItems();

    // Only one or two selected items can be handled
    if ((num != 1) && (num != 2))
    {
        getApp()->endWaitCursor();
        return(0);
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    FXString filecomparator = getApp()->reg().readStringEntry("PROGS", "filecomparator", DEFAULT_FILECOMPARATOR);
    FXString pathname, cmd, cmdname, itemslist = " ";

    // One selected item
    if (num == 1)
    {
        // Get the selected item
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                itemslist += ::quote(pathname) + " ";
            }
        }

        // Open a dialog to select the other item to be compared
        if (comparedialog == NULL)
        {
            comparedialog = new BrowseInputDialog(this, "", "", _("Compare"), _("With:"), bigcompareicon, BROWSE_INPUT_FILE);
        }
        comparedialog->setIcon(bigcompareicon);
        comparedialog->setMessage(pathname);
        comparedialog->setText("");
        int rc = 1;
        rc = comparedialog->execute(PLACEMENT_CURSOR);

        // Get item path and add it to the list
        FXString str = comparedialog->getText();
        itemslist += ::quote(str);
        if (!rc || (str == ""))
        {
            return(0);
        }
    }

    // Two selected items
    else if (num == 2)
    {
        // Get the two selected items
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                itemslist += ::quote(pathname) + " ";
            }
        }
    }

    // Wait cursor
    getApp()->beginWaitCursor();

    // If command exists, run it
    cmdname = filecomparator;
    if (::existCommand(cmdname))
    {
        cmd = cmdname+itemslist;
#ifdef STARTUP_NOTIFICATION
        runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
        runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
    }

    // If command does not exist, issue an error message
    else
    {
        getApp()->endWaitCursor();
        MessageBox::error(this, BOX_OK, _("Error"), _("Program %s not found. Please define a file comparator program in the Preferences dialog!"), cmdname.text());
    }

    getApp()->endWaitCursor();

    return(1);
}


// File or directory properties
long FilePanel::onCmdProperties(FXObject* sender, FXSelector, void*)
{
    int ret;
    int num, itm;

    current->list->setFocus();

    // If no selected files in the file list, use the selected folder from the tree list (if any)
    num = current->list->getNumSelectedItems(&itm);
    if (num == 0)
    {
		return(0);
    }

    // There is one selected file in the file list
    else if (num == 1)
    {
        // Eventually deselect the '..' directory
        /* if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        } */

        FXString path = current->list->getDirectory();
        FXString filename = current->list->getItemText(itm);
        filename = filename.section('\t', 0);
        PropertiesBox* attrdlg = new PropertiesBox(this, filename, path);
        attrdlg->create();
        attrdlg->show(PLACEMENT_OWNER);
    }

    // There are multiple selected files in the file list
    else if (num > 1)
    {
        ret = chdir(current->list->getDirectory().text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
            }

            return(0);
        }

        FXString  path = current->list->getDirectory();
        FXString* files = new FXString[num];
        FXString* paths = new FXString[num];

        // Eventually deselect the '..' directory
        /* if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        } */

        int i = 0;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                files[i] = current->list->getItemText(u).section('\t', 0);
                paths[i] = path;
                i++;
            }
        }

        PropertiesBox* attrdlg = new PropertiesBox(this, files, num, paths);
        attrdlg->create();
        attrdlg->show(PLACEMENT_OWNER);
        
        ret = chdir(startlocation.text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
            }

            return(0);
        }
    }

    // Force panel refresh
    return(1);
}


// Create new directory
long FilePanel::onCmdNewDir(FXObject*, FXSelector, void*)
{
    FXString dirname = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString dirpath = current->list->getDirectory();
    if (dirpath != ROOTDIR)
    {
        dirpath += PATHSEPSTRING;
    }

    if (newdirdialog == NULL)
    {
        newdirdialog = new InputDialog(this, "", _("Create new folder:"), _("New Folder"),"",bignewfoldericon);
    }
    newdirdialog->setText("");

    // Accept was pressed
    if (newdirdialog->execute(PLACEMENT_CURSOR))
    {
        if (newdirdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("Folder name is empty, operation cancelled"));
            return(0);
        }

		// Directory name contains '/'
		if (newdirdialog->getText().contains(PATHSEPCHAR))
		{
			MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in folder names, operation cancelled"));
			return(0);
		}

        dirname = dirpath+newdirdialog->getText();
        if (dirname != dirpath)
        {
            // Create the new dir according to the current umask
            int mask;
            mask = umask(0);
            umask(mask);

            // Note that the umask value is in decimal (511 means octal 0777)
            errno = 0;
            int ret = ::mkdir(dirname.text(), 511 & ~mask);
            int errcode = errno;
            if (ret == -1)
            {
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s: %s"), dirname.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s"), dirname.text());
                }
                return(0);
            }
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == dirname)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Create new file
long FilePanel::onCmdNewFile(FXObject*, FXSelector, void*)
{
    FXString filename = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString pathname = current->list->getDirectory();
    if (pathname != ROOTDIR)
    {
        pathname += PATHSEPSTRING;
    }

    if (newfiledialog == NULL)
    {
        newfiledialog = new InputDialog(this, "", _("Create new file:"), _("New File"), "", bignewfileicon, false);
    }
    newfiledialog->setText("");

    // Accept was pressed
    if (newfiledialog->execute(PLACEMENT_CURSOR))
    {
        if (newfiledialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

		// File name contains '/'
		if (newfiledialog->getText().contains(PATHSEPCHAR))
		{
			MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in file names, operation cancelled"));
			return(0);
		}

        filename = pathname+newfiledialog->getText();
        FILE* file;
        if (filename != pathname)
        {
            // Test some error conditions
            if (::exists(filename))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("File or folder %s already exists"), filename.text());
                return(0);
            }
            // Create the new file
            errno = 0;
            if (!(file = fopen(filename.text(), "w+")) || fclose(file))
            {
                if (errno)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create file %s: %s"), filename.text(), strerror(errno));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create file %s"), filename.text());
                }
                return(0);
            }
            // Change the file permissions according to the current umask
            int mask;
            mask = umask(0);
            umask(mask);
            errno = 0;
            int rc = chmod(filename.text(), 438 & ~mask);
            int errcode = errno;
            if (rc)
            {
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't set permissions in %s: %s"), filename.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't set permissions in %s"), filename.text());
                }
            }
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == filename)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Create new symbolic link
long FilePanel::onCmdNewSymlink(FXObject*, FXSelector, void*)
{
    FXString linkname = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString linkpath = current->list->getDirectory();
    if (linkpath != ROOTDIR)
    {
        linkpath += PATHSEPSTRING;
    }

    if (newlinkdialog == NULL)
    {
        newlinkdialog = new InputDialog(this, "", _("Create new symbolic link:"), _("New Symlink"), "", bignewlinkicon, false);
    }
    newlinkdialog->setText("");

    // Accept was pressed
    if (newlinkdialog->execute(PLACEMENT_CURSOR))
    {
        if (newlinkdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }
        linkname = linkpath+newlinkdialog->getText();
        File* f;
        if (linkname != linkpath)
        {
            // Test some error conditions
            if (::exists(linkname))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("File or folder %s already exists"), linkname.text());
                return(0);
            }

            // Select target
            FileDialog browse(this, _("Select the symlink refered file or folder"));
            browse.setDirectory(linkpath);
            browse.setSelectMode(SELECT_FILE_MIXED);
            if (browse.execute())
            {
                FXString linksource = browse.getFilename();

                // Source does not exist
                if (!::exists(linksource))
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Symlink source %s does not exist"), linksource.text());
                    return(0);
                }

                f = new File(this, _("Symlink"), SYMLINK);
                f->create();
                f->symlink(linksource, linkname);
                delete f;
            }
            //else
            //return 0;
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == linkname)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Open single or multiple files
long FilePanel::onCmdOpen(FXObject*, FXSelector, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString   pathname, samecmd, cmd, cmdname, itemslist = " ";
    FileAssoc* association;
    FXbool     same = true;
    FXbool     first = true;

    current->list->setFocus();
    if (current->list->getNumSelectedItems() == 0)
    {
        getApp()->endWaitCursor();
        return(0);
    }

    // Default programs
    FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
    FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
    FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
    FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
    FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
    FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
    FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
    FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

    // Update associations dictionary
    FileDict* assocdict = new FileDict(getApp());

    // Check if all files have the same association
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            // Increment number of selected items
            pathname = current->list->getItemPathname(u);

            // If directory, skip it
            if (::isDirectory(pathname))
            {
                continue;
            }

            // If association found
            association = assocdict->findFileBinding(pathname.text());
            if (association)
            {
                cmd = association->command.section(',', 0);

                // Use a default program if possible
                switch (progs[cmd])
                {
                case TXTVIEWER:
                    cmd = txtviewer;
                    break;

                case TXTEDITOR:
                    cmd = txteditor;
                    break;

                case IMGVIEWER:
                    cmd = imgviewer;
                    break;

                case IMGEDITOR:
                    cmd = imgeditor;
                    break;

                case PDFVIEWER:
                    cmd = pdfviewer;
                    break;

                case AUDIOPLAYER:
                    cmd = audioplayer;
                    break;

                case VIDEOPLAYER:
                    cmd = videoplayer;
                    break;

                case ARCHIVER:
                    cmd = archiver;
                    break;

                case NONE: // No program found
                    ;
                    break;
                }

                if (cmd != "")
                {
                    // First selected item
                    if (first)
                    {
                        samecmd = cmd;
                        first = false;
                    }

                    if (samecmd != cmd)
                    {
                        same = false;
                        break;
                    }

                    // List of selected items
                    itemslist += ::quote(pathname) + " ";
                }
                else
                {
                    same = false;
                    break;
                }
            }
            else
            {
                same = false;
                break;
            }
        }
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // Same command for all files : open them
    if (same && (itemslist != " "))
    {
        cmdname = samecmd;

        // If command exists, run it
        if (::existCommand(cmdname))
        {
            cmd = samecmd+itemslist;
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
        }
    }

    // Files have different commands : handle them separately
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);

                // If directory, skip it
                if (::isDirectory(pathname))
                {
                    continue;
                }

                association = assocdict->findFileBinding(pathname.text());
                if (association)
                {
                    // Use association to open the file
                    cmd = association->command.section(',', 0);

                    // Use a default program if possible
                    switch (progs[cmd])
                    {
                    case TXTVIEWER:
                        cmd = txtviewer;
                        break;

                    case TXTEDITOR:
                        cmd = txteditor;
                        break;

                    case IMGVIEWER:
                        cmd = imgviewer;
                        break;

                    case IMGEDITOR:
                        cmd = imgeditor;
                        break;

                    case PDFVIEWER:
                        cmd = pdfviewer;
                        break;

                    case AUDIOPLAYER:
                        cmd = audioplayer;
                        break;

                    case VIDEOPLAYER:
                        cmd = videoplayer;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No program found
                        ;
                        break;
                    }

                    if (cmd != "")
                    {
                        cmdname = cmd;

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // Or execute the file
                    else if (current->list->isItemExecutable(u))
                    {
                        execFile(pathname);
                    }

                    // Or call the "Open with..." dialog
                    else
                    {
                        getApp()->endWaitCursor();
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }

                // If no association but executable
                else if (current->list->isItemExecutable(u))
                {
                    execFile(pathname);
                }

                // Other cases
                else
                {
                    getApp()->endWaitCursor();
                    current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                }
            }
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Open with
long FilePanel::onCmdOpenWith(FXObject*, FXSelector, void*)
{
    char** str = NULL;

    current->list->setFocus();

    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    FXString cmd = "", cmdname;
    if (opendialog == NULL)
    {
        opendialog = new HistInputDialog(this, "", _("Open selected file(s) with:"), _("Open With"), "", bigfileopenicon, HIST_INPUT_EXECUTABLE_FILE, true, _("A&ssociate"));
    }
    opendialog->setText(cmd);

    // Dialog with history list and associate checkbox
    opendialog->CursorEnd();
    opendialog->selectAll();
    opendialog->clearItems();
    for (int i = 0; i < OpenNum; i++)
    {
        opendialog->appendItem(OpenHistory[i]);
    }
    opendialog->setDirectory(ROOTDIR);
    opendialog->sortItems();
    if (opendialog->execute())
    {
        cmd = opendialog->getText();
        if (cmd == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Handles "associate" checkbox for "open with..." dialog
                if (opendialog->getOption())
                {
                    FXString filename = current->list->getItemFilename(u);
                    FXString ext = filename.rafter('.', 2).lower();

                    if ((ext == "tar.gz") || (ext == "tar.bz2") || (ext == "tar.xz") || (ext == "tar.z")) // Special cases
                    {
                    }
                    else
                    {
                        ext = FXPath::extension(filename).lower();
                    }

                    if (ext == "")
                    {
                        ext = FXPath::name(filename);
                    }

                    FileAssoc* association = current->list->getItemAssoc(u);

                    if (association)
                    {
                        // Update existing association
                        FXString oldfileassoc = getApp()->reg().readStringEntry("FILETYPES", ext.text(), "");
                        oldfileassoc.erase(0, oldfileassoc.section(';', 0).section(',', 0).length());
                        oldfileassoc.prepend(opendialog->getText());
                        getApp()->reg().writeStringEntry("FILETYPES", ext.text(), oldfileassoc.text());

                        // Handle file association
                        str = new char* [2];
                        str[0] = new char[strlen(ext.text())+1];
                        str[1] = new char[strlen(oldfileassoc.text())+1];
                        strlcpy(str[0], ext.text(), ext.length()+1);
                        strlcpy(str[1], oldfileassoc.text(), oldfileassoc.length()+1);
                        mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ASSOC), str);
                    }
                    else
                    {
                        // New association
                        FXString newcmd = opendialog->getText().append(";Document;;;;");
                        getApp()->reg().writeStringEntry("FILETYPES", ext.text(), newcmd.text());

                        // Handle file association
                        str = new char* [2];
                        str[0] = new char[strlen(ext.text())+1];
                        str[1] = new char[strlen(newcmd.text())+1];
                        strlcpy(str[0], ext.text(), ext.length()+1);
                        strlcpy(str[1], newcmd.text(), newcmd.length()+1);
                        mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ASSOC), str);
                    }
                }
                // End

                FXString pathname = current->list->getItemPathname(u);
                cmdname = cmd;
                cmd += " ";
                cmd = cmd+::quote(pathname);
            }
        }

        // Run command if it exists
        getApp()->beginWaitCursor();

#ifdef STARTUP_NOTIFICATION
        // Startup notification option and exceptions (if any)
        FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
        FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

        // If command exists, run it
        if (::existCommand(cmdname))
#ifdef STARTUP_NOTIFICATION
        {
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
        }
#else
        {
            runcmd(cmd, current->list->getDirectory(), startlocation);
        }
#endif
        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
            return(1);
        }

        // Update history list
        OpenNum = opendialog->getHistorySize();
        cmd = opendialog->getText();

        // Check if cmd is a new string, i.e. is not already in history
        FXbool newstr = true;
        for (int i = 0; i < OpenNum-1; i++)
        {
            if (streq(OpenHistory[i], cmd.text()))
            {
                newstr = false;
                break;
            }
        }

        // History limit reached
        if (OpenNum > OPEN_HIST_SIZE)
        {
            OpenNum--;
        }

        // Restore original history order
        opendialog->clearItems();
        for (int i = 0; i < OpenNum; i++)
        {
            opendialog->appendItem(OpenHistory[i]);
		}

        // New string
        if (newstr)
        {
            // FIFO
            strlcpy(OpenHistory[0], cmd.text(), cmd.length()+1);
            for (int i = 1; i < OpenNum; i++)
            {
                strlcpy(OpenHistory[i], opendialog->getHistoryItem(i-1).text(), opendialog->getHistoryItem(i-1).length()+1);
            }
        }

        getApp()->endWaitCursor();
    }

    return(1);
}


long FilePanel::onCmdItemFilter(FXObject* o, FXSelector sel, void*)
{
    if (FilterNum == 0)
    {
        strlcpy(FilterHistory[FilterNum], "*", 2);
        FilterNum++;
    }

    int      i;
    FXString pat = list->getPattern();
    if (filterdialog == NULL)
    {
        filterdialog = new HistInputDialog(this, pat, _("Show files:"), _("Filter"), "", bigfiltericon, HIST_INPUT_FILE);
    }
    filterdialog->CursorEnd();
    filterdialog->selectAll();
    filterdialog->clearItems();
    for (int i = 0; i < FilterNum; i++)
    {
        filterdialog->appendItem(FilterHistory[i]);
    }
    filterdialog->sortItems();

    if (filterdialog->execute() && ((pat = filterdialog->getText()) != ""))
    {
        // Change file list patten
        if (FXSELID(sel) == ID_FILTER_CURRENT)
        {
            current->list->setPattern(pat);
        }
        else
        {
            list->setPattern(pat);
        }

        FXbool newstr = true;
        for (i = 0; i < FilterNum; i++)
        {
            if (streq(FilterHistory[i], pat.text()))
            {
                newstr = false;
                break;
            }
        }
        // Append new string to the list bottom
        if (newstr && (FilterNum < FILTER_HIST_SIZE))
        {
            strlcpy(FilterHistory[FilterNum], pat.text(), pat.length()+1);
            FilterNum++;
        }
    }

    list->setFocus();
    return(1);
}


// Panel context menu
long FilePanel::onCmdPopupMenu(FXObject* o, FXSelector s, void* p)
{
    // Make panel active
    setActive();

    // Check if control key or Shift-F10 or menu was pressed
    if (p != NULL)
    {
        FXEvent* event = (FXEvent*)p;
        if (event->state&CONTROLMASK)
        {
            ctrl = true;
        }
        if ((event->state&SHIFTMASK && event->code == KEY_F10) || event->code == KEY_Menu)
        {
            shiftf10 = true;
        }
    }

    // Use to select the item under cursor when right clicking
    // Only when Shift-F10 was not pressed
    if (!shiftf10 && (list->getNumSelectedItems() <= 1))
    {
        int    x, y;
        FXuint state;
        list->getCursorPosition(x, y, state);

        int item = list->getItemAt(x, y);

        if (list->getCurrentItem() >= 0)
        {
            list->deselectItem(list->getCurrentItem());
        }
        if (item >= 0)
        {
            list->setCurrentItem(item);
            list->selectItem(item);
        }
    }

    // If first item (i.e. the '..' item)
    //if ((list->getNumSelectedItems() == 1) && list->isItemSelected(0))
    //{
    //    ctrl = true;
    //}

    // If control flag is set, deselect all items
    if (ctrl)
    {
        list->handle(o, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), p);
    }

    // Popup menu pane
    FXMenuPane* menu = new FXMenuPane(this);
    int         x, y;
    FXuint      state;
    getRoot()->getCursorPosition(x, y, state);

    int num, itm;
    num = current->list->getNumSelectedItems(&itm);

    // No selection or control flag set
    if ((num == 0) || current->ctrl)
    {
        // Menu items
        new FXMenuCommand(menu, _("New& file..."), NULL, current, FilePanel::ID_NEW_FILE);
        new FXMenuCommand(menu, _("New f&older..."), NULL, current, FilePanel::ID_NEW_DIR);
        new FXMenuCommand(menu, _("New s&ymlink..."), NULL, current, FilePanel::ID_NEW_SYMLINK);
        new FXMenuCommand(menu, _("Fi&lter..."), NULL, current, FilePanel::ID_FILTER);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(menu);
        new FXMenuCheck(menu, _("&Hidden files"), current->list, FileList::ID_TOGGLE_HIDDEN);
        new FXMenuCheck(menu, _("Thum&bnails"), current->list, FileList::ID_TOGGLE_THUMBNAILS);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("B&ig icons"), current->list, IconList::ID_SHOW_BIG_ICONS);
        new FXMenuRadio(menu, _("&Small icons"), current->list, IconList::ID_SHOW_MINI_ICONS);
        new FXMenuRadio(menu, _("&Full file list"), current->list, IconList::ID_SHOW_DETAILS);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("&Rows"), current->list, FileList::ID_ARRANGE_BY_ROWS);
        new FXMenuRadio(menu, _("&Columns"), current->list, FileList::ID_ARRANGE_BY_COLUMNS);
        new FXMenuCheck(menu, _("Autosize"), current->list, FileList::ID_AUTOSIZE);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("&Name"), current->list, FileList::ID_SORT_BY_NAME);
        new FXMenuRadio(menu, _("Si&ze"), current->list, FileList::ID_SORT_BY_SIZE);
        new FXMenuRadio(menu, _("&Type"), current->list, FileList::ID_SORT_BY_TYPE);
        new FXMenuRadio(menu, _("E&xtension"), current->list, FileList::ID_SORT_BY_EXT);
        new FXMenuRadio(menu, _("&Date"), current->list, FileList::ID_SORT_BY_TIME);
        new FXMenuRadio(menu, _("&User"), current->list, FileList::ID_SORT_BY_USER);
        new FXMenuRadio(menu, _("&Group"), current->list, FileList::ID_SORT_BY_GROUP);
        new FXMenuRadio(menu, _("Per&missions"), current->list, FileList::ID_SORT_BY_PERM);
        new FXMenuRadio(menu, _("Deletion date"), current->list, FileList::ID_SORT_BY_DELTIME);
        new FXMenuSeparator(menu);
        new FXMenuCheck(menu, _("Ignore c&ase"), current->list, FileList::ID_SORT_CASE);
        new FXMenuCheck(menu, _("Fold&ers first"), current->list, FileList::ID_DIRS_FIRST);
        new FXMenuCheck(menu, _("Re&verse order"), current->list, FileList::ID_SORT_REVERSE);
    }
    // Non empty selection
    else
    {
        // Deselect the '..' item
        /* if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        } */

        // Panel submenu items
        FXMenuPane* submenu = new FXMenuPane(this);
        new FXMenuCommand(submenu, _("Ne&w file..."), NULL, current, FilePanel::ID_NEW_FILE);
        new FXMenuCommand(submenu, _("New f&older..."), NULL, current, FilePanel::ID_NEW_DIR);
        new FXMenuCommand(submenu, _("New s&ymlink..."), NULL, current, FilePanel::ID_NEW_SYMLINK);
        new FXMenuCommand(submenu, _("Fi&lter..."), NULL, current, FilePanel::ID_FILTER);
        new FXMenuSeparator(submenu);
        new FXMenuCommand(submenu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(submenu);
        new FXMenuCheck(submenu, _("&Hidden files"), current->list, FileList::ID_TOGGLE_HIDDEN);
        new FXMenuCheck(submenu, _("Thum&bnails"), current->list, FileList::ID_TOGGLE_THUMBNAILS);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("B&ig icons"), current->list, IconList::ID_SHOW_BIG_ICONS);
        new FXMenuRadio(submenu, _("&Small icons"), current->list, IconList::ID_SHOW_MINI_ICONS);
        new FXMenuRadio(submenu, _("&Full file list"), current->list, IconList::ID_SHOW_DETAILS);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("&Rows"), current->list, FileList::ID_ARRANGE_BY_ROWS);
        new FXMenuRadio(submenu, _("&Columns"), current->list, FileList::ID_ARRANGE_BY_COLUMNS);
        new FXMenuCheck(submenu, _("Autosize"), current->list, FileList::ID_AUTOSIZE);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("&Name"), current->list, FileList::ID_SORT_BY_NAME);
        new FXMenuRadio(submenu, _("Si&ze"), current->list, FileList::ID_SORT_BY_SIZE);
        new FXMenuRadio(submenu, _("&Type"), current->list, FileList::ID_SORT_BY_TYPE);
        new FXMenuRadio(submenu, _("E&xtension"), current->list, FileList::ID_SORT_BY_EXT);
        new FXMenuRadio(submenu, _("&Date"), current->list, FileList::ID_SORT_BY_TIME);
        new FXMenuRadio(submenu, _("&User"), current->list, FileList::ID_SORT_BY_USER);
        new FXMenuRadio(submenu, _("&Group"), current->list, FileList::ID_SORT_BY_GROUP);
        new FXMenuRadio(submenu, _("Per&missions"), current->list, FileList::ID_SORT_BY_PERM);
        new FXMenuRadio(submenu, _("Deletion date"), current->list, FileList::ID_SORT_BY_DELTIME);
        new FXMenuSeparator(submenu);
        new FXMenuCheck(submenu, _("Ignore c&ase"), current->list, FileList::ID_SORT_CASE);
        new FXMenuCheck(submenu, _("Fold&ers first"), current->list, FileList::ID_DIRS_FIRST);
        new FXMenuCheck(submenu, _("Re&verse order"), current->list, FileList::ID_SORT_REVERSE);
        new FXMenuCascade(menu, _("Pane&l"), NULL, submenu);
        new FXMenuSeparator(menu);

#if defined(linux)
        FXString name = current->list->getItemPathname(itm);
        if ((num == 1) && (fsdevices->find(name.text()) || mtdevices->find(name.text())))
        {
            new FXMenuCommand(menu, _("&Mount"), NULL, current, FilePanel::ID_MOUNT);
            new FXMenuCommand(menu, _("Unmount"), NULL, current, FilePanel::ID_UMOUNT);
            new FXMenuSeparator(menu);
        }
#endif

        FXbool ar = false;
        if (current->list->getItem(itm) && current->list->isItemFile(itm))
        {
            new FXMenuCommand(menu, _("Open &with..."), NULL, current, FilePanel::ID_OPEN_WITH);
            new FXMenuCommand(menu, _("&Open"), NULL, current, FilePanel::ID_OPEN);
            FXString name = current->list->getItemText(itm).section('\t', 0);

            // Last and before last file extensions
            FXString ext1 = name.rafter('.', 1).lower();
            FXString ext2 = name.rafter('.', 2).lower();

            // Destination folder name
            FXString extract_to_folder;
            if ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z"))
            {
                extract_to_folder = _("Extr&act to folder ")+name.section('\t', 0).rbefore('.', 2);
            }
            else
            {
                extract_to_folder = _("Extr&act to folder ")+name.section('\t', 0).rbefore('.', 1);
            }

            // Display the extract and package menus according to the archive extensions
            if ((num == 1) && ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
                new FXMenuCommand(menu, extract_to_folder, NULL, current, FilePanel::ID_EXTRACT_TO_FOLDER);
                new FXMenuCommand(menu, _("E&xtract to..."), NULL, current, FilePanel::ID_EXTRACT);
            }
            else if ((num == 1) && ((ext1 == "gz") || (ext1 == "bz2") || (ext1 == "xz") || (ext1 == "z")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
            }
            else if ((num == 1) && ((ext1 == "tar") || (ext1 == "tgz") || (ext1 == "tbz2") || (ext1 == "tbz") || (ext1 == "taz") || (ext1 == "txz") || (ext1 == "zip") || (ext1 == "7z") || (ext1 == "lzh") || (ext1 == "rar") || (ext1 == "ace") || (ext1 == "arj")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
                new FXMenuCommand(menu, extract_to_folder, NULL, current, FilePanel::ID_EXTRACT_TO_FOLDER);
                new FXMenuCommand(menu, _("E&xtract to..."), NULL, current, FilePanel::ID_EXTRACT);
            }
#if defined(linux)
            else if ((num == 1) && ((ext1 == "rpm") || (ext1 == "deb")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&View"), NULL, current, FilePanel::ID_VIEW);
                new FXMenuCommand(menu, _("Install/Up&grade"), NULL, current, ID_PKG_INSTALL);
                new FXMenuCommand(menu, _("Un&install"), NULL, current, ID_PKG_UNINSTALL);
            }
#endif
            // Not archive nor package
            if (!ar)
            {
                new FXMenuCommand(menu, _("&View"), NULL, current, FilePanel::ID_VIEW);
                new FXMenuCommand(menu, _("&Edit"), NULL, current, FilePanel::ID_EDIT);
                if (num == 1)
                {
                    new FXMenuCommand(menu, _("Com&pare..."), NULL, current, FilePanel::ID_COMPARE);
                }
                else
                {
                    new FXMenuCommand(menu, _("Com&pare"), NULL, current, FilePanel::ID_COMPARE);
                }
            }
        }
        if (!ar)
        {
            new FXMenuCommand(menu, _("&Add to archive..."), NULL, current, FilePanel::ID_ADD_TO_ARCH);
        }
#if defined(linux)
        if ((num == 1) && !ar)
        {
            new FXMenuCommand(menu, _("Packages &query "), NULL, current, FilePanel::ID_PKG_QUERY);
        }
#endif

        // Build scripts menu
        new FXMenuSeparator(menu);
        FXString    scriptpath = homedir + PATHSEPSTRING CONFIGPATH PATHSEPSTRING XFECONFIGPATH PATHSEPSTRING SCRIPTPATH;
        FXMenuPane* scriptsmenu = new FXMenuPane(this);
        new FXMenuCascade(menu, _("Scripts"), NULL, scriptsmenu);
        readScriptDir(scriptsmenu, scriptpath);
        new FXMenuSeparator(scriptsmenu);
        new FXMenuCommand(scriptsmenu, _("&Go to script folder"), NULL, this, FilePanel::ID_GO_SCRIPTDIR);

        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("&Copy"), NULL, current, FilePanel::ID_COPY_CLIPBOARD);
        new FXMenuCommand(menu, _("C&ut"), NULL, current, FilePanel::ID_CUT_CLIPBOARD);
        new FXMenuCommand(menu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("Re&name..."), NULL, current, FilePanel::ID_FILE_RENAME);
        new FXMenuCommand(menu, _("Copy &to..."), NULL, current, FilePanel::ID_FILE_COPYTO);
        new FXMenuCommand(menu, _("&Move to..."), NULL, current, FilePanel::ID_FILE_MOVETO);
        new FXMenuCommand(menu, _("Symlin&k to..."), NULL, current, FilePanel::ID_FILE_SYMLINK);
        new FXMenuCommand(menu, _("M&ove to trash"), NULL, current, FilePanel::ID_FILE_TRASH);
        new FXMenuCommand(menu, _("Restore &from trash"), NULL, current, FilePanel::ID_FILE_RESTORE);
        new FXMenuCommand(menu, _("&Delete"), NULL, current, FilePanel::ID_FILE_DELETE);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("Compare &sizes"), NULL, current, FilePanel::ID_DIR_USAGE);
        new FXMenuCommand(menu, _("P&roperties"), NULL, current, FilePanel::ID_PROPERTIES);
    }
    menu->create();

    // Reset flags
    ctrl = false;
    shiftf10 = false;
    allowPopupScroll = true;  // Allow keyboard scrolling


    menu->popup(NULL, x, y);
    getApp()->runModalWhileShown(menu);
    allowPopupScroll = false;

    return(1);
}


// Read all executable file names that are located into the script directory
// Sort entries alphabetically, directories first
int FilePanel::readScriptDir(FXMenuPane* scriptsmenu, FXString dir)
{
    DIR* dp;
    struct dirent** namelist;

    // Open directory
    if ((dp = opendir(dir.text())) == NULL)
    {
        return(0);
    }

    // Eventually add a / at the end of the directory name
    if (dir[dir.length()-1] != '/')
    {
        dir = dir+"/";
    }

	// First, read only directory entries and sort them alphabetically
    int n;
    n = scandir(dir.text(), &namelist, NULL, alphasort);
    if (n < 0)
    {
        perror("scandir");
    }
    else
    {
        for (int k = 0; k < n; k++)
        {
            // Avoid hidden directories and '.' and '..'
            if (namelist[k]->d_name[0] != '.')
            {
                FXString pathname = dir + namelist[k]->d_name;

                // Recurse if non empty directory
                if (::isDirectory(pathname))
                {
                    if (!::isEmptyDir(pathname))
                    {
                        FXMenuPane* submenu = new FXMenuPane(this);
                        new FXMenuCascade(scriptsmenu, namelist[k]->d_name, NULL, submenu);
                        readScriptDir(submenu, pathname);
                    }
                }
            }
            free(namelist[k]);
        }
        free(namelist);
    }

	// Then, read only executable files and sort them alphabetically
    n = scandir(dir.text(), &namelist, NULL, alphasort);
    if (n < 0)
    {
        perror("scandir");
    }
    else
    {
        for (int k = 0; k < n; k++)
        {
			// Add only executable files to the list
			FXString pathname = dir + namelist[k]->d_name;
			if (!::isDirectory(pathname) && isReadExecutable(pathname))
			{
				new FXMenuCommand(scriptsmenu, namelist[k]->d_name + FXString("\t\t") + pathname, miniexecicon, this, FilePanel::ID_RUN_SCRIPT);
			}
            free(namelist[k]);
        }
        free(namelist);
    }

    // Close directory
    (void)closedir(dp);

    return(1);
}


// Run Terminal in the selected directory
long FilePanel::onCmdXTerm(FXObject*, FXSelector, void*)
{
    int ret;

    getApp()->beginWaitCursor();
    ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
        }

        return(0);
    }

    FXString cmd = getApp()->reg().readStringEntry("PROGS", "xterm", "xterm -sb");
    cmd += " &";
    ret = system(cmd.text());
    if (ret < 0)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Can't execute command %s"), cmd.text());
    }

    current->list->setFocus();
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }

        return(0);
    }

    getApp()->endWaitCursor();
    return(1);
}


// Add files or directory to an archive
long FilePanel::onCmdAddToArch(FXObject* o, FXSelector, void*)
{
    int      ret;
    FXString name, ext1, ext2, cmd, archive = "";
    File*    f;

    ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), list->getDirectory().text());
        }

        return(0);
    }

    // Eventually deselect the '..' directory
    /* if (current->list->isItemSelected(0))
    {
        current->list->deselectItem(0);
    } */

    // Return if nothing is selected
    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    // If only one item is selected, use its name as a starting guess for the archive name
    if (current->list->getNumSelectedItems() == 1)
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                name = current->list->getItemFilename(u);
                break;
            }
        }
        archive = name;
    }

    // Initial archive name with full path and default extension
    FXString archpath = current->list->getDirectory();
    if (archpath == PATHSEPSTRING)
    {
        archive = archpath+archive+".tar.gz";
    }
    else
    {
        archive = archpath+PATHSEPSTRING+archive+".tar.gz";
    }

    // Archive dialog
    if (archdialog == NULL)
    {
        archdialog = new ArchInputDialog(this, "");
    }
    archdialog->setText(archive);
    archdialog->CursorEnd();

    if (archdialog->execute())
    {
        if (archdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

        // Get string and preserve escape characters
        archive = ::quote(archdialog->getText());

        // Get extensions of the archive name
        ext1 = archdialog->getText().rafter('.', 1).lower();
        ext2 = archdialog->getText().rafter('.', 2).lower();

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zcvf "+archive+" ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jcvf "+archive+" ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jcvf "+archive+" ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zcvf "+archive+" ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -cvf "+archive+" ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zcvf "+archive+" ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zcvf "+archive+" ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "xz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jcvf "+archive+" ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jcvf "+archive+" ";
        }
        else if (ext1 == "z")
        {
            cmd = "compress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "zip -r "+archive+" ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z a "+archive+" ";
        }

        // Default archive format
        else
        {
            archive += ".tar.gz";
            cmd = "tar -zcvf "+archive+" ";
        }

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Don't include '..' in the list
                name = current->list->getItemFilename(u);
                if (name != "..")
                {
                    cmd += " ";
                    cmd = cmd+::quote(name);
                    cmd += " ";
                }
            }
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Create archive"), ARCHIVE);
        f->create();

        // Create archive
        f->archive(archive, cmd);
        ret = chdir(startlocation.text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
            }

            return(0);
        }

        getApp()->endWaitCursor();
        delete f;

        // Force panel refresh
        onCmdRefresh(0, 0, 0);
    }
    return(1);
}


// Extract archive
long FilePanel::onCmdExtract(FXObject*, FXSelector, void*)
{
    FXString name, ext1, ext2, cmd, dir, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    // File selection dialog
    FileDialog  browse(this, _("Select a destination folder"));
    const char* patterns[] =
    {
        _("All Files"), "*", NULL
    };
    browse.setDirectory(homedir);
    browse.setPatternList(patterns);
    browse.setSelectMode(SELECT_FILE_DIRECTORY);

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        // Archive name and extensions
        name = current->list->getItemText(item).text();

        ext1 = name.section('\t', 0).rafter('.', 1).lower();
        ext2 = name.section('\t', 0).rafter('.', 2).lower();
        name = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jxvf ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -xvf ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gunzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bunzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "unxz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jxvf ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext1 == "z")
        {
            cmd = "uncompress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "unzip -o ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z x -y ";
        }
        else if (ext1 == "rar")
        {
            cmd = "unrar x -o+ ";
        }
        else if (ext1 == "lzh")
        {
            cmd = "lha -xf ";
        }
        else if (ext1 == "ace")
        {
            cmd = "unace x ";
        }
        else if (ext1 == "arj")
        {
            cmd = "arj x -y ";
        }
        else
        {
            cmd = "tar -zxvf ";
        }

        // Final extract command
        cmd += name+" ";


        // Extract archive
        if (browse.execute())
        {
            dir = browse.getFilename();

            if (isWritable(dir))
            {
                // Wait cursor
                getApp()->beginWaitCursor();

                // File object
                f = new File(this, _("Extract archive"), EXTRACT);
                f->create();

                // Extract archive
                f->extract(name, dir, cmd);

                getApp()->endWaitCursor();
                delete f;
            }
            else
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
            }
        }
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Extract archive to a folder name based on the archive name
long FilePanel::onCmdExtractToFolder(FXObject*, FXSelector, void*)
{
    FXString name, pathname, ext1, ext2, cmd, dirname, dirpath, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        // Archive name and extensions
        name = current->list->getItemText(item).text();
        ext1 = name.section('\t', 0).rafter('.', 1).lower();
        ext2 = name.section('\t', 0).rafter('.', 2).lower();

        // Destination folder name
        if ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z"))
        {
            dirname = name.section('\t', 0).rbefore('.', 2);
        }
        else
        {
            dirname = name.section('\t', 0).rbefore('.', 1);
        }

        // Create the new dir according to the current umask
        // Don't complain if directory already exists
        int mask = umask(0);
        umask(mask);
        dirpath = cdir + PATHSEPSTRING + dirname;
        errno = 0;
        int ret = ::mkdir(dirpath.text(), 511 & ~mask);
        int errcode = errno;
        if ((ret == -1) && (errcode != EEXIST))
        {
            if (errcode)
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s: %s"), dirpath.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s"), dirpath.text());
            }
            return(0);
        }

        // Archive pathname
        pathname = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jxvf ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -xvf ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gunzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bunzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "unxz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jxvf ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext1 == "z")
        {
            cmd = "uncompress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "unzip -o ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z x -y ";
        }
        else if (ext1 == "rar")
        {
            cmd = "unrar x -o+ ";
        }
        else if (ext1 == "lzh")
        {
            cmd = "lha -xf ";
        }
        else if (ext1 == "ace")
        {
            cmd = "unace x ";
        }
        else if (ext1 == "arj")
        {
            cmd = "arj x -y ";
        }
        else
        {
            cmd = "tar -zxvf ";
        }

        // Final extract command
        cmd += pathname+" ";

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Extract archive"), EXTRACT);
        f->create();

        // Extract archive
        f->extract(pathname, dirpath, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Extract archive in the current directory
long FilePanel::onCmdExtractHere(FXObject*, FXSelector, void*)
{
    FXString name, ext1, ext2, cmd, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        if (isWritable(cdir))
        {
            // Archive name and extensions
            name = current->list->getItemText(item).text();
            ext1 = name.section('\t', 0).rafter('.', 1);
            lower();
            ext2 = name.section('\t', 0).rafter('.', 2).lower();
            name = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

            // Handle different archive formats
            if (ext2 == "tar.gz")
            {
                cmd = "tar -zxvf ";
            }
            else if (ext2 == "tar.bz2")
            {
                cmd = "tar -jxvf ";
            }
            else if (ext2 == "tar.xz")
            {
                cmd = "tar -Jxvf ";
            }
            else if (ext2 == "tar.z")
            {
                cmd = "tar -Zxvf ";
            }
            else if (ext1 == "tar")
            {
                cmd = "tar -xvf ";
            }
            else if (ext1 == "gz")
            {
                cmd = "gunzip -v ";
            }
            else if (ext1 == "tgz")
            {
                cmd = "tar -zxvf ";
            }
            else if (ext1 == "taz")
            {
                cmd = "tar -Zxvf ";
            }
            else if (ext1 == "bz2")
            {
                cmd = "bunzip2 -v ";
            }
            else if (ext1 == "xz")
            {
                cmd = "unxz -v ";
            }
            else if ((ext1 == "tbz2") || (ext1 == "tbz"))
            {
                cmd = "tar -jxvf ";
            }
            else if (ext1 == "txz")
            {
                cmd = "tar -Jxvf ";
            }
            else if (ext1 == "z")
            {
                cmd = "uncompress -v ";
            }
            else if (ext1 == "zip")
            {
                cmd = "unzip -o ";
            }
            else if (ext1 == "7z")
            {
                cmd = "7z x -y ";
            }
            else if (ext1 == "rar")
            {
                cmd = "unrar x -o+ ";
            }
            else if (ext1 == "lzh")
            {
                cmd = "lha -xf ";
            }
            else if (ext1 == "ace")
            {
                cmd = "unace x ";
            }
            else if (ext1 == "arj")
            {
                cmd = "arj x -y ";
            }
            else
            {
                cmd = "tar -zxvf ";
            }

            // Final extract command
            cmd += name+" ";

            // Wait cursor
            getApp()->beginWaitCursor();

            // File object
            f = new File(this, _("Extract archive"), EXTRACT);
            f->create();

            // Extract archive
            f->extract(name, cdir, cmd);

            getApp()->endWaitCursor();
            delete f;
        }
        else
        {
            MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), cdir.text());
        }
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


#if defined(linux)
// Install/Upgrade package
long FilePanel::onCmdPkgInstall(FXObject*, FXSelector, void*)
{
    FXString name, path, cmd, dir, cdir;
    File*    f;

    cdir = current->list->getDirectory();

    int itm;
    current->list->getNumSelectedItems(&itm);
    if (current->list->getItem(itm))
    {
        name = current->list->getItemText(itm).text();
        name = name.section('\t', 0);
        path = ::quote(cdir + PATHSEPSTRING + name);

        // Command to perform
        FXString ext = FXPath::extension(name);
        if (comparecase(ext, "rpm") == 0)
        {
            cmd = "rpm -Uvh " + path;
        }
        else if (comparecase(ext, "deb") == 0)
        {
            cmd = "dpkg -i "+ path;
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Package Install/Upgrade"), PKG_INSTALL);
        f->create();

        // Install/Upgrade package
        f->pkgInstall(name, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Uninstall package based on its name (package version is ignored)
long FilePanel::onCmdPkgUninstall(FXObject*, FXSelector, void*)
{
    FXString name, cmd, dir, cdir;
    File*    f;

    cdir = current->list->getDirectory();

    int itm;
    current->list->getNumSelectedItems(&itm);
    if (current->list->getItem(itm))
    {
        name = current->list->getItemText(itm).text();
        name = name.section('\t', 0);

        // Command to perform
        FXString ext = FXPath::extension(name);
        if (comparecase(ext, "rpm") == 0)
        {
            name = name.section('-', 0);
            cmd = "rpm -e " + name;
        }
        else if (comparecase(ext, "deb") == 0)
        {
            name = name.section('_', 0);
            cmd = "dpkg -r "+ name;
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Package Uninstall"), PKG_UNINSTALL);
        f->create();

        // Uninstall package
        f->pkgUninstall(name, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


#endif


// Force FilePanel and DirPanel refresh
long FilePanel::onCmdRefresh(FXObject*, FXSelector, void*)
{
    // Refresh panel
    FXString dir = list->getDirectory();
    list->setDirectory(ROOTDIR, false);
    list->setDirectory(dir, false);
    updatePath();
	
	// Focus on current panel
	current-> list->setFocus();

    return(1);
}


// Handle item selection
long FilePanel::onCmdSelect(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setFocus();
    switch (FXSELID(sel))
    {
    case ID_SELECT_ALL:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SELECT_ALL), ptr);
        return(1);

    case ID_DESELECT_ALL:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), ptr);
        return(1);

    case ID_SELECT_INVERSE:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SELECT_INVERSE), ptr);
        return(1);
    }
    return(1);
}


// Handle show commands
long FilePanel::onCmdShow(FXObject* sender, FXSelector sel, void* ptr)
{
    switch (FXSELID(sel))
    {
    case ID_SHOW_BIG_ICONS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_BIG_ICONS), ptr);
        break;

    case ID_SHOW_MINI_ICONS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_MINI_ICONS), ptr);
        break;

    case ID_SHOW_DETAILS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_DETAILS), ptr);
        break;
    }

    // Set focus on current panel list
    current->list->setFocus();

    return(1);
}


// Update show commands
long FilePanel::onUpdShow(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXuint style = current->list->getListStyle();

    switch (FXSELID(sel))
    {
    case ID_SHOW_BIG_ICONS:
        if (style & _ICONLIST_BIG_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_MINI_ICONS:
        if (style & _ICONLIST_MINI_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_DETAILS:
        if (!(style & (_ICONLIST_MINI_ICONS | _ICONLIST_BIG_ICONS)))
        {
            msg = FXWindow::ID_CHECK;
        }
        break;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);

    return(1);
}


// Handle toggle hidden command
long FilePanel::onCmdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_HIDDEN), ptr);
    return(1);
}


// Update toggle hidden command
long FilePanel::onUpdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXbool hidden = current->list->shownHiddenFiles();

    if (hidden == false)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);
    return(1);
}


// Handle toggle thumbnails command
long FilePanel::onCmdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_THUMBNAILS), ptr);
    return(1);
}


// Update toggle hidden command
long FilePanel::onUpdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXbool showthumb = current->list->shownThumbnails();

    if (showthumb == false)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);
    return(1);
}


// Run script
long FilePanel::onCmdRunScript(FXObject* o, FXSelector sel, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString pathname, cmd, itemslist = " ";
    FXString scriptpath = dynamic_cast<FXMenuCommand*>(o)->getHelpText();

    // Construct selected files list
    current->list->setFocus();
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            pathname = current->list->getItemPathname(u);

            // List of selected items
            itemslist += ::quote(pathname) + " ";
        }
    }

    // Construct command line
    cmd = ::quote(scriptpath) + itemslist + " &";

    // Go to the current directory
    int ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
        }
    }

    // Execute command
    static pid_t child_pid = 0;
    switch ((child_pid = fork()))
    {
    case -1:
        fprintf(stderr, _("Error: Fork failed: %s\n"), strerror(errno));
        break;

    case 0:
        execl("/bin/sh", "sh", "-c", cmd.text(), (char*)NULL);
        _exit(EXIT_SUCCESS);
        break;
    }

    // Return to the starting directory
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Go to scripts directory
long FilePanel::onCmdGoScriptDir(FXObject* o, FXSelector sel, void*)
{
    FXString scriptpath = homedir + PATHSEPSTRING CONFIGPATH PATHSEPSTRING XFECONFIGPATH PATHSEPSTRING SCRIPTPATH;

    if (!::exists(scriptpath))
    {
        // Create the script directory according to the umask
        int mask = umask(0);
        umask(mask);
        errno = 0;
        int ret = mkpath(scriptpath.text(), 511 & ~mask);
        int errcode = errno;
        if (ret == -1)
        {
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create script folder %s: %s"), scriptpath.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create script folder %s"), scriptpath.text());
            }

            return(0);
        }
    }

    // Go to scripts directory
    current->list->setDirectory(scriptpath);
    current->list->setFocus();
    dirpanel->setDirectory(scriptpath, true);
    current->updatePath();
    updateLocation();

    return(1);
}


#if defined(linux)
// Mount/Unmount file systems
long FilePanel::onCmdMount(FXObject*, FXSelector sel, void*)
{
    int      ret;
    FXString cmd, msg, text;
    FXuint   op;
    File*    f;
    FXString dir;

    current->list->setFocus();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (current->list->getNumSelectedItems() == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    // If symbolic link, read the linked directory
    if (::isLink(dir))
    {
        dir = ::readLink(dir);
    }

    if (FXSELID(sel) == ID_MOUNT)
    {
        op = MOUNT;
        msg = _("Mount");
		cmd = getApp()->reg().readStringEntry("PROGS", "mount", DEFAULT_MOUNTCMD) + FXString(" ");
    }
    else
    {
        op = UNMOUNT;
        msg = _("Unmount");
	    cmd = getApp()->reg().readStringEntry("PROGS", "unmount", DEFAULT_UMOUNTCMD) + FXString(" ");
    }
    cmd += ::quote(dir);
    cmd += " 2>&1";
    ret = chdir(ROOTDIR);
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), ROOTDIR, strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), ROOTDIR);
        }

        return(0);
    }

    // Wait cursor
    getApp()->beginWaitCursor();

    // File object
    text = msg + _(" file system...");
    f = new File(this, text.text(), op);
    f->create();

    // Mount/unmount file system
    text = msg + _(" the folder:");
    f->mount(dir, text, cmd, op);
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }

        return(0);
    }

    // If action is cancelled in progress dialog
    if (f->isCancelled())
    {
        f->hide();
        text = msg + _(" operation cancelled!");
        MessageBox::error(this, BOX_OK, _("Warning"), "%s", text.text());
        delete f;
        return(0);
    }

    getApp()->endWaitCursor();
    delete f;

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Update the Mount button
long FilePanel::onUpdMount(FXObject* o, FXSelector sel, void*)
{
    FXString dir;

    int num = current->list->getNumSelectedItems();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (num == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    //if (fsdevices->find(dir.text()) && !mtdevices->find(dir.text()) && current->list->getNumItems() && !current->list->isItemSelected(0))
    if (fsdevices->find(dir.text()) && !mtdevices->find(dir.text()))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update the Unmount button
long FilePanel::onUpdUnmount(FXObject* o, FXSelector sel, void*)
{
    FXString dir;

    int num = current->list->getNumSelectedItems();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (num == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    //if ((fsdevices->find(dir.text()) || mtdevices->find(dir.text())) && current->list->getNumItems() && !current->list->isItemSelected(0))
    if ((fsdevices->find(dir.text()) || mtdevices->find(dir.text())))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Query packages data base
long FilePanel::onCmdPkgQuery(FXObject* o, FXSelector sel, void*)
{
    FXString cmd;

    // Name of the current selected file
    FXString file = current->list->getCurrentFile();

    // Command to perform
    if (pkg_format == DEB_PKG)
    {
        cmd = "dpkg -S " + ::quote(file);
    }
    else if (pkg_format == RPM_PKG)
    {
        cmd = "rpm -qf " + ::quote(file);
    }
    else
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("No compatible package manager (rpm or dpkg) found!"));
        return(0);
    }

    // Query command
    cmd += " 2>&1";

    // Wait cursor
    getApp()->beginWaitCursor();

    // Perform the command
    FILE* pcmd = popen(cmd.text(), "r");
    if (!pcmd)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Failed command: %s"), cmd.text());
        return(0);
    }

    // Get command output
    char     text[10000] = { 0 };
    FXString buf;
    while (fgets(text, sizeof(text), pcmd))
    {
        buf += text;
    }
    snprintf(text, sizeof(text)-1, "%s", buf.text());

    // Close the stream and display error message if any
    if ((pclose(pcmd) == -1) && (errno != ECHILD))   // ECHILD can be set if the child was caught by sigHarvest
    {
        getApp()->endWaitCursor();
        MessageBox::error(this, BOX_OK, _("Error"), "%s", text);
        return(0);
    }
    getApp()->endWaitCursor();

    // Get package name, or detect when the file isn't in a package
    FXString str = text;
    if (pkg_format == DEB_PKG)  // DEB based distribution
    {
        int idx = str.find(" ");               // Split output at first whitespace
        FXString pkgname = str.left(idx-1);    // Remove trailing colon
        FXString fname = str.right(str.length()-idx);
        fname.trim();                          // Remove leading space and trailing newline
        if (streq(fname.text(), file.text()))  // No other word than the file name
        {
            str = pkgname.text();
        }
        else
        {
            str = "";
        }
    }
    if (pkg_format == RPM_PKG)   // RPM based distribution
    {
        if (str.find(' ') != -1) // Space character exists in the string
        {
            str = "";
        }
    }

    // Display the related output message
    FXString message;
    if (str == "")
    {
        message.format(_("File %s does not belong to any package."), file.text());
        MessageBox::information(this, BOX_OK, _("Information"), "%s", message.text());
    }
    else
    {
        message.format(_("File %s belongs to the package: %s"), file.text(), str.text());
        MessageBox::information(this, BOX_OK, _("Information"), "%s", message.text());
    }

    return(1);
}


// Update the package query menu
long FilePanel::onUpdPkgQuery(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing is selected or multiple selection
    // or when unique selection and the selected item is a directory

    int num;

    num = current->list->getNumSelectedItems();

    if ((num == 0) || (num > 1))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else // num=1
    {
        int item = current->list->getCurrentItem();
        if ((item >= 0) && current->list->isItemDirectory(item))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }

    return(1);
}


#endif // End #if defined(linux)


// Directory usage on file selection
long FilePanel::onCmdDirUsage(FXObject* o, FXSelector, void*)
{
	FXString name, command, itemslist = " ";
	FXString cmd1 = "/usr/bin/du --apparent-size -k -s ";
	FXString cmd2 = " 2> /dev/null | /usr/bin/sort -rn | /usr/bin/cut -f2 | /usr/bin/xargs -d '\n' /usr/bin/du --apparent-size --total --si -s 2> /dev/null";

    // Enter current directory
    int ret=chdir(current->getDirectory().text());
    if (ret < 0)
    {
        int errcode=errno;
        if (errcode)
        {
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s: %s"),current->getDirectory().text(),strerror(errcode));
		}
        else
        {
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s"),current->getDirectory().text());
		}

        return 0;
    }

    // Eventually deselect the '..' directory
    /* if (current->list->isItemSelected(0))
    {
        current->list->deselectItem(0);
    } */

    // Return if nothing is selected
    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    // Construct selected files list
    current->list->setFocus();
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
 			name = current->list->getItemFilename(u);

            // List of selected items
            itemslist += ::quote(name) + " ";
        }
    }

	// Command to be executed
	command = cmd1 + itemslist + cmd2;

	// Make and show command window
	CommandWindow* cmdwin=new CommandWindow(getApp(),_("Sizes of Selected Object(s)"),command,25,50);
	cmdwin->create();
	cmdwin->setIcon(charticon);

	// The CommandWindow object will delete itself when closed!

	// Return to start location
	ret = chdir(startlocation.text());
	if (ret < 0)
	{
		int errcode = errno;
		if (errcode)
		{
			MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
		}
		else
		{
			MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
		}
	}

    return(1);
}


// Update the status bar and the path linker
long FilePanel::onUpdStatus(FXObject* sender, FXSelector, void*)
{
    // Update the status bar
    int      item = -1;
    FXString str, linkto;
    char     usize[64];
    FXulong  size = 0;
    FXString hsize = _("0 bytes");

    FXString path = list->getDirectory();

    int num = list->getNumSelectedItems();

    // To handle the update rename (ugly, I know)
    if (current == this)
    {
        if (num <= 1)
        {
            selmult = false;
        }
        else if (num > 1)
        {
            selmult = true;
        }
    }

    item = list->getCurrentItem();

    if (num > 1)
    {
		int nbdirs = 0;
        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u) && !list->isItemDirectory(u))
            {
                size += list->getItemFileSize(u);
#if __WORDSIZE == 64
                snprintf(usize, sizeof(usize)-1, "%lu", size);
#else
                snprintf(usize, sizeof(usize)-1, "%llu", size);
#endif
                hsize = ::hSize(usize);
            }
            
            if (list->isItemDirectory(u))
            {
				nbdirs++;
			}
        }
        
        // Don't count the '..' directory
        if (nbdirs >= 1)
        {
			nbdirs--;
		}
		
		int nbfiles = num - nbdirs;
        if (nbdirs <= 1 && nbfiles <= 1)
        {
	        str.format(_("%s in %s selected object(s) (%s folder, %s file)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
        else if (nbdirs <=1 && nbfiles > 1)
        {
	        str.format(_("%s in %s selected object(s) (%s folder, %s files)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
        else if (nbdirs > 1 && nbfiles <= 1)
        {
	        str.format(_("%s in %s selected object(s) (%s folders, %s file)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
		else
		{
	        str.format(_("%s in %s selected object(s) (%s folders, %s files)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
    }
    else
    {
        // Nothing selected
        if ((num == 0) || (item < 0))
        {
            num = list->getNumItems();
            if (num == 1)
            {
                str = _("1 object(s) (1 folder)");
            }
            else
            {
				int nbdirs = 0;
				for (int u = 0; u < num; u++)
				{
					if (list->isItemDirectory(u))
					{
						nbdirs++;
					}
				}       

				int nbfiles = num - nbdirs;
		        str.format(_("%s object(s) (%s folders, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());
				if (nbdirs <= 1 && nbfiles <= 1)
				{
					str.format(_("%s object(s) (%s folder, %s file)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else if (nbdirs <=1 && nbfiles > 1)
				{
					str.format(_("%s object(s) (%s folder, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else if (nbdirs > 1 && nbfiles <= 1)
				{
					str.format(_("%s object(s) (%s folders, %s file)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else
				{
					str.format(_("%s object(s) (%s folders, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
            }
        }
        else
        {
            FXString string = list->getItemText(item);
            FXString name = string.section('\t', 0);
            FXString type = string.section('\t', 2);

            FXString date = string.section('\t', 4);
            FXString usr = string.section('\t', 5);
            FXString grp = string.section('\t', 6);
            FXString perm = string.section('\t', 7);

            if (type.contains(_("Broken link")))
            {
                linkto = ::readLink(path+PATHSEPSTRING+name);
                str = name + "->" + linkto.text() + " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
            else if (type.contains(_("Link")))
            {
                linkto = ::readLink(path+PATHSEPSTRING+name);
                str = name + "->" + linkto.text() + " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
            else
            {
                for (int u = 0; u < list->getNumItems(); u++)
                {
                    if (list->isItemSelected(u) && !list->isItemDirectory(u))
                    {
                        size = list->getItemFileSize(u);
#if __WORDSIZE == 64
                        snprintf(usize, sizeof(usize)-1, "%lu", size);
#else
                        snprintf(usize, sizeof(usize)-1, "%llu", size);
#endif
                        hsize = ::hSize(usize);
                        break;
                    }
                }
                str = hsize+ " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
        }
    }

    statuslabel->setText(str);

    // Add the filter pattern if any
    if ((list->getPattern() != "*") && (list->getPattern() != "*.*"))
    {
        str.format(_(" - Filter: %s"), list->getPattern().text());
        filterlabel->setText(str);
        filterlabel->setTextColor(attenclr);
    }
    else
    {
        filterlabel->setText("");
    }

    return(1);
}


// Update the path text and the path link
void FilePanel::updatePath()
{
    pathlink->setPath(list->getDirectory());
    pathtext->setText(list->getDirectory());
}


// Update the go to parent directory command
long FilePanel::onUpdUp(FXObject* o, FXSelector, void*)
{
    FXButton* button = (FXButton*)o;
    int       style = button->getButtonStyle();

    if (style & TOGGLEBUTTON_TOOLBAR)
    {
        if (current->list->getDirectory() != ROOTDIR)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update the paste button
long FilePanel::onUpdPaste(FXObject* o, FXSelector, void*)
{
    FXuchar* data;
    FXuint   len;
    FXString buf;
    FXbool   clipboard_empty = true;

    // Lock clipboard to prevent changes in method onCmdRequestClipboard()
    clipboard_locked = true;

    // If source is xfelistType (Gnome, XFCE, or Xfe app)
    if (getDNDData(FROM_CLIPBOARD, xfelistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        buf = (char*)data;

        // Check if valid clipboard
        if (buf.find("file:/") >= 0)
        {
            clipboard_empty = false;
        }

        // Free data pointer
        FXFREE(&data);
    }

    // If source type is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    else if (getDNDData(FROM_CLIPBOARD, urilistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        buf = (char*)data;

        // Check if valid clipboard
        if (buf.find("file:/") >= 0)
        {
            clipboard_empty = false;
        }

        // Free data pointer
        FXFREE(&data);
    }

    // Gray out the paste button, if necessary
    if (clipboard_empty)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }

    // Unlock clipboard
    clipboard_locked = false;

    return(1);
}


// Update menu items and toolbar buttons that are related to file operations
long FilePanel::onUpdMenu(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing or only ".." is selected
    int num;

    num = current->list->getNumSelectedItems();
    DirItem* item = (DirItem*)dirpanel->getCurrentItem();

    if ((dirpanel->shown() && item))
    {
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        //else if ((num == 1) && current->list->isItemSelected(0))
        /* else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        } */
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        if (num == 0)
        {
           // o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        /*else if ((num == 1) && current->list->isItemSelected(0))
        else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }*/
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }

    return(1);
}


// Update file delete menu item and toolbar button
long FilePanel::onUpdFileDelete(FXObject* o, FXSelector sel, void*)
{
    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    FXbool use_trash_bypass = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_bypass", false);

    if ( (!use_trash_can) | use_trash_bypass)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        //else if ((num == 1) && current->list->isItemSelected(0))
        /*else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }*/
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update move to trash menu item and toolbar button
long FilePanel::onUpdFileTrash(FXObject* o, FXSelector sel, void*)
{
    // Disable move to trash menu if we are in trash can
    // or if the trash can directory is selected

    FXbool   trashenable = true;
    FXString trashparentdir = trashlocation.rbefore('/');
    FXString curdir = current->list->getDirectory();

    if (curdir.left(trashlocation.length()) == trashlocation)
    {
        trashenable = false;
    }

    if (curdir == trashparentdir)
    {
        FXString pathname;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                if (pathname == trashlocation)
                {
                    trashenable = false;
                }
            }
        }
    }

    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    if (use_trash_can && trashenable)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        //else if ((num == 1) && current->list->isItemSelected(0))
        /*else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }*/
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update restore from trash menu item and toolbar button
long FilePanel::onUpdFileRestore(FXObject* o, FXSelector sel, void*)
{
    // Enable restore from trash menu if we are in trash can

    FXbool   restoreenable = false;
    FXString curdir = current->list->getDirectory();

    if (curdir.left(trashfileslocation.length()) == trashfileslocation)
    {
        restoreenable = true;
    }

    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    if (use_trash_can && restoreenable)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        //else if ((num == 1) && current->list->isItemSelected(0))
        /*else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }*/
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update go trash menu item and toolbar button
long FilePanel::onUpdGoTrash(FXObject* o, FXSelector sel, void*)
{
    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);

    if (use_trash_can)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update file open menu
long FilePanel::onUpdOpen(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or a directory (including "..") is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);

    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        if (current->list->getItem(item) && current->list->isItemFile(item))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
    }
    return(1);
}


// Update the status of the menu items that should be disabled when selecting multiple files
long FilePanel::onUpdSelMult(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing is selected or multiple selection or ".." is only selected
    int num;

    num = current->list->getNumSelectedItems();
    DirItem* item = (DirItem*)dirpanel->getCurrentItem();

    if (num == 0)
    {
        if (!item || !dirpanel->shown())
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    //else if (current->selmult || ((num == 1) && current->list->isItemSelected(0)))
    /*else if (current->selmult || (num == 1))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }*/
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }

    return(1);
}


// Update the file compare menu item
long FilePanel::onUpdCompare(FXObject* o, FXSelector sel, void*)
{
    // Menu item is enabled only when two files are selected
    int num;

    num = current->list->getNumSelectedItems();

    if ((num == 1) || (num == 2))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update Add to archive menu
long FilePanel::onUpdAddToArch(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or ".." is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    //else if ((num == 1) && current->list->isItemSelected(0))
    /*else if ((num == 1))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }*/
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update scripts menu item
long FilePanel::onUpdRunScript(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or ".." is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update directory usage menu item
long FilePanel::onUpdDirUsage(FXObject* o, FXSelector, void*)
{
    // Menu item is enabled only when at least two items are selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num > 1)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    return(1);
}
#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/time.h>

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "startupnotification.h"
#include "FileDialog.h"
#include "FileList.h"
#include "Properties.h"
#include "XFileExplorer.h"
#include "InputDialog.h"
#include "BrowseInputDialog.h"
#include "ArchInputDialog.h"
#include "HistInputDialog.h"
#include "File.h"
#include "MessageBox.h"
#include "OverwriteBox.h"
#include "CommandWindow.h"
#include "ExecuteBox.h"
#include "PathLinker.h"
#include "FilePanel.h"

// Duration (in ms) before we can stop refreshing the file list
// Used for file operations on a large list of files
#define STOP_LIST_REFRESH_INTERVAL    5000

// Number of files before stopping the file list refresh
#define STOP_LIST_REFRESH_NBMAX       100


// Clipboard notes :
// The uri-list type used for Xfe is the same as the Gnome uri-list type
// The standard uri-list type is used for KDE and non Gnome / XFCE file managers
// A special uri-list type that containd only "0" (for copy) or "1" (for cut) is used for KDE compatibility


// Global Variables
extern FXMainWindow* mainWindow;
extern FXString      homedir;
extern FXString      xdgdatahome;

// Clipboard
extern FXString clipboard;
FXuint          clipboard_type = 0;


extern char OpenHistory[OPEN_HIST_SIZE][MAX_COMMAND_SIZE];
extern int  OpenNum;
extern char FilterHistory[FILTER_HIST_SIZE][MAX_PATTERN_SIZE];
extern int  FilterNum;
#if defined(linux)
extern FXStringDict* fsdevices;
extern FXStringDict* mtdevices;
extern FXbool        pkg_format;
#endif

extern FXbool allowPopupScroll;
extern FXuint single_click;


// Map
FXDEFMAP(FilePanel) FilePanelMap[] =
{
    FXMAPFUNC(SEL_CLIPBOARD_LOST, 0, FilePanel::onClipboardLost),
    FXMAPFUNC(SEL_CLIPBOARD_GAINED, 0, FilePanel::onClipboardGained),
    FXMAPFUNC(SEL_CLIPBOARD_REQUEST, 0, FilePanel::onClipboardRequest),
    FXMAPFUNC(SEL_TIMEOUT, FilePanel::ID_STOP_LIST_REFRESH_TIMER, FilePanel::onCmdStopListRefreshTimer),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DIRECTORY_UP, FilePanel::onCmdDirectoryUp),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILTER, FilePanel::onCmdItemFilter),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILTER_CURRENT, FilePanel::onCmdItemFilter),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_HOME, FilePanel::onCmdGoHome),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_TRASH, FilePanel::onCmdGoTrash),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_VIEW, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_MIDDLEBUTTONPRESS, FilePanel::ID_FILELIST, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EDIT, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_COMPARE, FilePanel::onCmdCompare),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PROPERTIES, FilePanel::onCmdProperties),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_XTERM, FilePanel::onCmdXTerm),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_DIR, FilePanel::onCmdNewDir),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_FILE, FilePanel::onCmdNewFile),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_SYMLINK, FilePanel::onCmdNewSymlink),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_COPY, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_CUT, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_COPYTO, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_MOVETO, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_RENAME, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_SYMLINK, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_COPY_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_CUT_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADDCOPY_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADDCUT_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PASTE_CLIPBOARD, FilePanel::onCmdPaste),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_TRASH, FilePanel::onCmdFileTrash),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_RESTORE, FilePanel::onCmdFileRestore),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_DELETE, FilePanel::onCmdFileDelete),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_OPEN_WITH, FilePanel::onCmdOpenWith),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_OPEN, FilePanel::onCmdOpen),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_REFRESH, FilePanel::onCmdRefresh),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_BIG_ICONS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_MINI_ICONS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_DETAILS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_TOGGLE_HIDDEN, FilePanel::onCmdToggleHidden),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_TOGGLE_THUMBNAILS, FilePanel::onCmdToggleThumbnails),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SELECT_ALL, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DESELECT_ALL, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SELECT_INVERSE, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADD_TO_ARCH, FilePanel::onCmdAddToArch),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT, FilePanel::onCmdExtract),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT_TO_FOLDER, FilePanel::onCmdExtractToFolder),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT_HERE, FilePanel::onCmdExtractHere),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_RUN_SCRIPT, FilePanel::onCmdRunScript),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_RUN_SCRIPT, FilePanel::onUpdRunScript),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_SCRIPTDIR, FilePanel::onCmdGoScriptDir),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DIR_USAGE, FilePanel::onCmdDirUsage),
    FXMAPFUNC(SEL_RIGHTBUTTONRELEASE, FilePanel::ID_FILELIST, FilePanel::onCmdPopupMenu),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_POPUP_MENU, FilePanel::onCmdPopupMenu),
    FXMAPFUNC(SEL_DOUBLECLICKED, FilePanel::ID_FILELIST, FilePanel::onCmdItemDoubleClicked),
    FXMAPFUNC(SEL_CLICKED, FilePanel::ID_FILELIST, FilePanel::onCmdItemClicked),
    FXMAPFUNC(SEL_FOCUSIN, FilePanel::ID_FILELIST, FilePanel::onCmdFocus),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_STATUS, FilePanel::onUpdStatus),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_DIRECTORY_UP, FilePanel::onUpdUp),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_COPY_CLIPBOARD, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_CUT_CLIPBOARD, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PASTE_CLIPBOARD, FilePanel::onUpdPaste),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PROPERTIES, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_TRASH, FilePanel::onUpdFileTrash),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_RESTORE, FilePanel::onUpdFileRestore),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_GO_TRASH, FilePanel::onUpdGoTrash),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_DELETE, FilePanel::onUpdFileDelete),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_MOVETO, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_COPYTO, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_RENAME, FilePanel::onUpdSelMult),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_COMPARE, FilePanel::onUpdCompare),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_EDIT, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_VIEW, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_OPEN, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_ADD_TO_ARCH, FilePanel::onUpdAddToArch),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_BIG_ICONS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_MINI_ICONS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_DETAILS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_TOGGLE_HIDDEN, FilePanel::onUpdToggleHidden),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_TOGGLE_THUMBNAILS, FilePanel::onUpdToggleThumbnails),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_DIR_USAGE, FilePanel::onUpdDirUsage),
#if defined(linux)
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_MOUNT, FilePanel::onCmdMount),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_UMOUNT, FilePanel::onCmdMount),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_MOUNT, FilePanel::onUpdMount),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_UMOUNT, FilePanel::onUpdUnmount),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_QUERY, FilePanel::onCmdPkgQuery),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_INSTALL, FilePanel::onCmdPkgInstall),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_UNINSTALL, FilePanel::onCmdPkgUninstall),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PKG_QUERY, FilePanel::onUpdPkgQuery),
#endif
};

// Object implementation
FXIMPLEMENT(FilePanel, FXVerticalFrame, FilePanelMap, ARRAYNUMBER(FilePanelMap))

// Construct File Panel
FilePanel::FilePanel(FXWindow* owner, const char* nm, FXComposite* p, DirPanel* dp, FXuint name_size, FXuint size_size, FXuint type_size, FXuint ext_size,
                     FXuint modd_size, FXuint user_size, FXuint grou_size, FXuint attr_size, FXuint deldate_size, FXuint origpath_size, FXbool showthumbs, FXColor listbackcolor, FXColor listforecolor,
                     FXColor attentioncolor, FXbool smoothscroll, FXuint opts, int x, int y, int w, int h) :
    FXVerticalFrame(p, opts, x, y, w, h, 0, 0, 0, 0)
{
    name = nm;
    dirpanel = dp;
    attenclr = attentioncolor;

    // Global container
    FXVerticalFrame* cont = new FXVerticalFrame(this, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // Container for the path linker
    FXHorizontalFrame* pathframe = new FXHorizontalFrame(cont, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0);

    // File list

    // Smooth scrolling
    FXuint options;
    if (smoothscroll)
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS;
    }
    else
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS|SCROLLERS_DONT_TRACK;
    }

    FXVerticalFrame* cont2 = new FXVerticalFrame(cont, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_SUNKEN|FRAME_THICK, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    list = new FileList(owner, cont2, this, ID_FILELIST, showthumbs, options);
    list->setHeaderSize(0, name_size);
    list->setHeaderSize(1, size_size);
    list->setHeaderSize(2, type_size);
    list->setHeaderSize(3, ext_size);
    list->setHeaderSize(4, modd_size);
    list->setHeaderSize(5, user_size);
    list->setHeaderSize(6, grou_size);
    list->setHeaderSize(7, attr_size);
    list->setHeaderSize(8, deldate_size);
    list->setHeaderSize(9, origpath_size);
    list->setTextColor(listforecolor);
    list->setBackColor(listbackcolor);

    // Visually indicate if the panel is active
    activeicon = new FXButton(pathframe, "", NULL, this, FilePanel::ID_FILELIST, BUTTON_TOOLBAR|JUSTIFY_LEFT|LAYOUT_LEFT);

    // Path text
    // pathtext = new TextLabel(pathframe, 0, this, ID_FILELIST, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    // pathtext->setBackColor(getApp()->getBaseColor());

    // Path linker
    pathlink = new PathLinker(pathframe, list, dirpanel->getList(), JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X);

    // Status bar
    statusbar = new FXHorizontalFrame(cont, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X, 0, 0, 0, 0, 3, 3, 3, 3);

    statusbar->setTarget(this);
    statusbar->setSelector(FXSEL(SEL_UPDATE, FilePanel::ID_STATUS));

    FXString key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "filter", "Ctrl-D");

    FXHorizontalFrame* hframe = new FXHorizontalFrame(statusbar, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0);
    statuslabel = new FXLabel(hframe, _("Status"), NULL, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X|FRAME_SUNKEN);
    filterlabel = new FXLabel(hframe, "", NULL, JUSTIFY_LEFT|LAYOUT_LEFT);

    corner = new FXDragCorner(statusbar);

    // Panel separator
    panelsep = new FXHorizontalSeparator(cont, SEPARATOR_GROOVE|LAYOUT_FILL_X);

    // Initializations
    selmult = false;
    current = NULL;

    // Single click navigation
    single_click = getApp()->reg().readUnsignedEntry("SETTINGS", "single_click", SINGLE_CLICK_NONE);
    if (single_click == SINGLE_CLICK_DIR_FILE)
    {
        list->setDefaultCursor(getApp()->getDefaultCursor(DEF_HAND_CURSOR));
    }

    // Dialogs
    operationdialogsingle = NULL;
    operationdialogrename = NULL;
    operationdialogmultiple = NULL;
    newdirdialog = NULL;
    newfiledialog = NULL;
    newlinkdialog = NULL;
    opendialog = NULL;
    archdialog = NULL;
    filterdialog = NULL;
    comparedialog = NULL;

    // Home and trahscan locations
    trashlocation = xdgdatahome+PATHSEPSTRING TRASHPATH;
    trashfileslocation = xdgdatahome + PATHSEPSTRING TRASHFILESPATH;
    trashinfolocation = xdgdatahome + PATHSEPSTRING TRASHINFOPATH;

    // Start location (we return to the start location after each chdir)
    startlocation = FXSystem::getCurrentDirectory();

    // Initialize clipboard flags
    clipboard_locked = false;
    fromPaste = false;

    // Initialize control flag for right click popup menu
    ctrl = false;

    // Initialize the Shift-F10 flag
    shiftf10 = false;

    // Initialize the active panel flag
    isactive = false;

    // Default programs identifiers
    progs["<txtviewer>"] = TXTVIEWER;
    progs["<txteditor>"] = TXTEDITOR;
    progs["<imgviewer>"] = IMGVIEWER;
    progs["<imgeditor>"] = IMGEDITOR;
    progs["<pdfviewer>"] = PDFVIEWER;
    progs["<audioplayer>"] = AUDIOPLAYER;
    progs["<videoplayer>"] = VIDEOPLAYER;
    progs["<archiver>"] = ARCHIVER;
}


// Create X window
void FilePanel::create()
{
    // Register standard uri-list type
    urilistType = getApp()->registerDragType("text/uri-list");

    // Register special uri-list type used for Gnome, XFCE and Xfe
    xfelistType = getApp()->registerDragType("x-special/gnome-copied-files");

    // Register special uri-list type used for KDE
    kdelistType = getApp()->registerDragType("application/x-kde-cutselection");

    // Register standard UTF-8 text type used for file dialogs
    utf8Type = getApp()->registerDragType("UTF8_STRING");

    // Display or hide path linker
    FXbool show_pathlink = getApp()->reg().readUnsignedEntry("SETTINGS", "show_pathlinker", true);
    if (show_pathlink)
    {
        // pathtext->hide();
        pathlink->show();
    }
    else
    {
        // pathtext->show();
        pathlink->hide();
    }

    FXVerticalFrame::create();
}


// Destructor
FilePanel::~FilePanel()
{
    delete list;
    delete current;
    delete next;
    delete statuslabel;
    delete filterlabel;
    delete statusbar;
    delete panelsep;
    delete pathlink;
    delete newfiledialog;
    delete newlinkdialog;
    delete newdirdialog;
    delete opendialog;
    delete archdialog;
    delete filterdialog;
    delete comparedialog;
    delete operationdialogsingle;
    delete operationdialogrename;
    delete operationdialogmultiple;
    // delete pathtext;
}


// Make panel active
void FilePanel::setActive()
{
    // Set active icon
    // activeicon->setIcon(greenbuttonicon);
    activeicon->setIcon(NULL);
    activeicon->setTipText(_("Panel is active"));

    pathlink->focus();
    current = this;

    // Make dirpanel point on the current directory,
    // but only if Filepanel and Dirpanel directories are different
    if (dirpanel->getDirectory() != current->list->getDirectory())
    {
        dirpanel->setDirectory(current->list->getDirectory(), true);
    }

    // Make dirpanel inactive
    dirpanel->setInactive();

    next->setInactive();
    list->setFocus();

    isactive = true;
}


// Make panel inactive
void FilePanel::setInactive(FXbool force)
{
    // Set active icon
    // activeicon->setIcon(graybuttonicon);
    activeicon->setIcon(NULL);
    activeicon->setTipText(_("Activate panel"));

    // By default we set the panel inactive
    if (force)
    {
        current = next;
        list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), NULL);

        isactive = false;
    }
}


// Make panel focus (i.e. active) when clicked
long FilePanel::onCmdFocus(FXObject* sender, FXSelector sel, void* ptr)
{
    setActive();
    return(1);
}


// Set Pointer to Another FilePanel
void FilePanel::Next(FilePanel* nxt)
{
    next = nxt;
}


// Show or hide drag corner
void FilePanel::showCorner(FXbool show)
{
    if (show)
    {
        corner->show();
    }
    else
    {
        corner->hide();
    }
}


// Show or hide active icon
void FilePanel::showActiveIcon(FXbool show)
{
    if (show)
    {
        activeicon->show();
    }
    else
    {
        activeicon->hide();
    }
}


// Update location history when changing directory (home, up or double click)
void FilePanel::updateLocation()
{
    FXString    item;
    int         i = 0;
    FXComboBox* address = ((XFileExplorer*)mainWindow)->getAddressBox();

    address->setNumVisible(5);
    int      count = address->getNumItems();
    FXString p = list->getDirectory();

    // Remember latest directory in the location address
    if (!count)
    {
        count++;
        address->insertItem(0, address->getText());
    }
    while (i < count)
    {
        item = address->getItem(i++);
        if (streq((const char*)&p[0], (const char*)&item[0]))
        {
            i--;
            break;
        }
    }
    if (i == count)
    {
        address->insertItem(0, list->getDirectory());
    }

    // Make current directory visible to avoid scrolling again
    list->makeItemVisible(list->getCurrentItem());
}


// We now really do have the clipboard, keep clipboard content
long FilePanel::onClipboardGained(FXObject* sender, FXSelector sel, void* ptr)
{
    FXVerticalFrame::onClipboardGained(sender, sel, ptr);
    return(1);
}


// We lost the clipboard
long FilePanel::onClipboardLost(FXObject* sender, FXSelector sel, void* ptr)
{
    FXVerticalFrame::onClipboardLost(sender, sel, ptr);
    return(1);
}


// Somebody wants our clipboard content
long FilePanel::onClipboardRequest(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    FXuchar* data;
    FXuint   len;

    // Perhaps the target wants to supply its own data for the clipboard
    if (FXVerticalFrame::onClipboardRequest(sender, sel, ptr))
    {
        return(1);
    }

    // Clipboard target is xfelistType (Xfe, Gnome or XFCE)
    if (event->target == xfelistType)
    {
        // Don't modify the clipboard if we are called from updPaste()
        if (!clipboard_locked)
        {
            // Prepend "copy" or "cut" as in the Gnome way and avoid duplicating these strings
            if ((clipboard.find("copy\n") < 0) && (clipboard.find("cut\n") < 0))
            {
                if (clipboard_type == CUT_CLIPBOARD)
                {
                    clipboard = "cut\n" + clipboard;
                }
                else
                {
                    clipboard = "copy\n" + clipboard;
                }
            }
        }

        // Return clipboard content
        if (event->target == xfelistType)
        {
            if (!clipboard.empty())
            {
                len = clipboard.length();
                FXMEMDUP(&data, clipboard.text(), FXuchar, len);
                setDNDData(FROM_CLIPBOARD, event->target, data, len);

                // Return because xfelistType is not compatible with other types
                return(1);
            }
        }
    }

    // Clipboard target is kdelisType (KDE)
    if (event->target == kdelistType)
    {
        // The only data to be passed in this case is "0" for copy and "1" for cut
        // The uri data are passed using the standard uri-list type
        FXString flag;
        if (clipboard_type == CUT_CLIPBOARD)
        {
            flag = "1";
        }
        else
        {
            flag = "0";
        }

        // Return clipboard content
        if (event->target == kdelistType)
        {
            FXMEMDUP(&data, flag.text(), FXuchar, 1);
            setDNDData(FROM_CLIPBOARD, event->target, data, 1);
        }
    }

    // Clipboard target is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    if (event->target == urilistType)
    {
        if (!clipboard.empty())
        {
            len = clipboard.length();
            FXMEMDUP(&data, clipboard.text(), FXuchar, len);
            setDNDData(FROM_CLIPBOARD, event->target, data, len);

            return(1);
        }
    }

    // Clipboard target is utf8Type (to paste file pathes as text to other applications)
    if (event->target == utf8Type)
    {
        if (!clipboard.empty())
        {
            int      beg = 0, end = 0;
            FXString str = "";
            FXString pathname, url;

            // Clipboard don't contain 'copy\n' or 'cut\n' as first line
            if ((clipboard.find("copy\n") < 0) && (clipboard.find("cut\n") < 0))
            {
                // Remove the 'file:' prefix for each file path
                while (1)
                {
                    end = clipboard.find('\n', end);
                    if (end < 0) // Last line
                    {
                        end = clipboard.length();
                        url = clipboard.mid(beg, end-beg+1);
                        pathname = FXURL::decode(FXURL::fileFromURL(url));
                        str += pathname;
                        break;
                    }
                    url = clipboard.mid(beg, end-beg+1);
                    pathname = FXURL::decode(FXURL::fileFromURL(url));
                    str += pathname;
                    end++;
                    beg = end;
                }
                end = str.length();
            }

            // Clipboard contains 'copy\n' or 'cut\n' as first line, thus skip it
            else
            {
                // Start after the 'copy\n' or 'cut\n' prefix
                end = clipboard.find('\n', 0);
                end++;
                beg = end;

                // Remove the 'file:' prefix for each file path
                while (1)
                {
                    end = clipboard.find('\n', end);
                    if (end < 0) // Last line
                    {
                        end = clipboard.length();
                        url = clipboard.mid(beg, end-beg+1);
                        pathname = FXURL::decode(FXURL::fileFromURL(url));
                        str += pathname;
                        break;
                    }
                    url = clipboard.mid(beg, end-beg+1);
                    pathname = FXURL::decode(FXURL::fileFromURL(url));
                    str += pathname;
                    end++;
                    beg = end;
                }
                end = str.length();
            }

            if (!str.empty())
            {
                len = str.length();
                FXMEMDUP(&data, str.text(), FXuchar, len);
                setDNDData(FROM_CLIPBOARD, event->target, data, len);

                return(1);
            }
        }
    }
    return(0);
}


// Copy or cut to clipboard (and add copy / add cut)
long FilePanel::onCmdCopyCut(FXObject*, FXSelector sel, void*)
{
    FXString name, curdir;

    // Clear clipboard if normal copy or cut
    if ((FXSELID(sel) == ID_COPY_CLIPBOARD) || (FXSELID(sel) == ID_CUT_CLIPBOARD))
    {
        clipboard.clear();
    }

    // Add an '\n' at the end if addcopy or addcut
    else
    {
        clipboard += '\n';
    }

    // Clipboard type
    if ((FXSELID(sel) == ID_CUT_CLIPBOARD) || (FXSELID(sel) == ID_ADDCUT_CLIPBOARD))
    {
        clipboard_type = CUT_CLIPBOARD;
    }
    else
    {
        clipboard_type = COPY_CLIPBOARD;
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        // Construct the uri list of files and fill the clipboard with it
        curdir = current->list->getDirectory();

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                name = current->list->getItemText(u).text();
                name = name.section('\t', 0);
                if (curdir == ROOTDIR)
                {
                    clipboard += FXURL::encode(::fileToURI(curdir+name))+"\n";
                }
                else
                {
                    clipboard += FXURL::encode(::fileToURI(curdir+PATHSEPSTRING+name))+"\n";
                }
            }
        }
    }

    // Remove the last \n of the list, for compatibility with some file managers (e.g. nautilus, nemo)
    clipboard.erase(clipboard.length()-1);

    // Acquire the clipboard
    FXDragType types[4];
    types[0] = xfelistType;
    types[1] = kdelistType;
    types[2] = urilistType;
    types[3] = utf8Type;
    if (acquireClipboard(types, 4))
    {
        return(0);
    }

    return(1);
}


// Paste file(s) from clipboard
long FilePanel::onCmdPaste(FXObject*, FXSelector sel, void*)
{
    FXuchar* data;
    FXuint   len;
    int      beg, end, pos;
    FXString chaine, url, param;
    int      num = 0;
    FXbool   from_kde = false;

    // If source is xfelistType (Gnome, XFCE, or Xfe app)
    if (getDNDData(FROM_CLIPBOARD, xfelistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';

        clipboard = (char*)data;

        // Loop over clipboard items
        for (beg = 0; beg < clipboard.length(); beg = end+1)
        {
            if ((end = clipboard.find("\n", beg)) < 0)
            {
                end = clipboard.length();
            }

            // Obtain item url
            url = clipboard.mid(beg, end-beg);

            // Eventually remove the trailing '\r' if any
            if ((pos = url.rfind('\r')) > 0)
            {
                url.erase(pos);
            }

            // Process first item
            if (num == 0)
            {
                // First item should be "copy" or "cut"
                if (url == "copy")
                {
                    clipboard_type = COPY_CLIPBOARD;
                    num++;
                }
                else if (url == "cut")
                {
                    clipboard_type = CUT_CLIPBOARD;
                    num++;
                }

                // If first item is not "copy" nor "cut", process it as a normal url
                // and use default clipboard type
                else
                {
                    // Update the param string
                    param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";

                    // Add one more because the first line "copy" or "cut" was not present
                    num += 2;
                }
            }

            // Process other items
            else
            {
                // Update the param string
                param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";
                num++;
            }
        }

        // Construct the final param string passed to the file management routine
        param = current->list->getDirectory()+"\n" + FXStringVal(num-1) + "\n" + param;

        // Copy or cut operation depending on the clipboard type
        switch (clipboard_type)
        {
        case COPY_CLIPBOARD:
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_COPY);
            break;

        case CUT_CLIPBOARD:
            clipboard.clear();
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_CUT);
            break;
        }
        fromPaste = true;
        handle(this, sel, (void*)param.text());

        // Free data pointer
        FXFREE(&data);

        // Return here because xfelistType is not compatible with other types
        return(1);
    }

    // If source type is kdelistType (KDE)
    if (getDNDData(FROM_CLIPBOARD, kdelistType, data, len))
    {
        from_kde = true;

        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        clipboard = (char*)data;

        // Obtain clipboard type (copy or cut)
        if (clipboard == "1")
        {
            clipboard_type = CUT_CLIPBOARD;
        }
        else
        {
            clipboard_type = COPY_CLIPBOARD;
        }

        FXFREE(&data);
    }


    // If source type is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    if (getDNDData(FROM_CLIPBOARD, urilistType, data, len))
    {
        // For non KDE apps, set action to copy
        if (!from_kde)
        {
            clipboard_type = COPY_CLIPBOARD;
        }

        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        clipboard = (char*)data;

        // Loop over clipboard items
        for (beg = 0; beg < clipboard.length(); beg = end+1)
        {
            if ((end = clipboard.find("\n", beg)) < 0)
            {
                end = clipboard.length();
            }

            // Obtain item url
            url = clipboard.mid(beg, end-beg);

            // Eventually remove the trailing '\r' if any
            if ((pos = url.rfind('\r')) > 0)
            {
                url.erase(pos);
            }

            // Update the param string
            param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";
            num++;
        }

        // Construct the final param string passed to the file management routine
        param = current->list->getDirectory()+"\n" + FXStringVal(num) + "\n" + param;

        // Copy or cut operation depending on the clipboard type
        switch (clipboard_type)
        {
        case COPY_CLIPBOARD:
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_COPY);
            break;

        case CUT_CLIPBOARD:
            clipboard.clear();
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_CUT);
            break;
        }
        fromPaste = true;
        handle(this, sel, (void*)param.text());

        FXFREE(&data);
        return(1);
    }
    return(0);
}


// Execute file with an optional confirm dialog
void FilePanel::execFile(FXString pathname)
{
    int      ret;
    FXString cmd, cmdname;

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // File is executable, but is it a text file?
    FXString str = mimetype(pathname);
    FXbool   isTextFile = true;
    if (strstr(str.text(), "charset=binary"))
    {
        isTextFile = false;
    }

    // With confirmation dialog
    FXbool confirm_execute = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_execute", true);
    if (isTextFile && (confirm_execute == 1))
    {
        FXString msg;
        msg.format(_("File %s is an executable text file, what do you want to do?"), pathname.text());
        ExecuteBox* dlg = new ExecuteBox(this, _("Confirm Execute"), msg);
        FXuint      answer = dlg->execute(PLACEMENT_CURSOR);
        delete dlg;

        // Execute
        if (answer == EXECBOX_CLICKED_EXECUTE)
        {
            cmdname = FXPath::name(pathname);
            cmd = ::quote(pathname);
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // Execute in console mode
        if (answer == EXECBOX_CLICKED_CONSOLE)
        {
            ret = chdir(current->list->getDirectory().text());
            if (ret < 0)
            {
                int errcode = errno;
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
                }
            }

            cmdname = FXPath::name(pathname);
            cmd = ::quote(pathname);

            // Make and show command window
            // The CommandWindow object will delete itself when closed!
            CommandWindow* cmdwin = new CommandWindow(getApp(), _("Command log"), cmd, 30, 80);
            cmdwin->create();
            cmdwin->setIcon(runicon);

            ret = chdir(startlocation.text());
            if (ret < 0)
            {
                int errcode = errno;
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
                }
            }
        }

        // Edit
        if (answer == EXECBOX_CLICKED_EDIT)
        {
            FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
            cmd = txteditor;
            cmdname = cmd;

            // If command exists, run it
            if (::existCommand(cmdname))
            {
                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
            }

            // If command does not exist, call the "Open with..." dialog
            else
            {
                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
            }
        }
    }

    // Without confirmation dialog
    else
    {
        cmdname = FXPath::name(pathname);
        cmd = ::quote(pathname);
#ifdef STARTUP_NOTIFICATION
        runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
        runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
    }
}


// Double Click on File Item
long FilePanel::onCmdItemDoubleClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    FXString cmd, cmdname, filename, pathname;

    // Wait cursor
    getApp()->beginWaitCursor();

    // At most one item selected
    if (current->list->getNumSelectedItems() <= 1)
    {
        FXlong item = (FXlong)ptr;
        if (item > -1)
        {
#ifdef STARTUP_NOTIFICATION
            // Startup notification option and exceptions (if any)
            FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
            FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

            // Default programs
            FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
            FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
            FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
            FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
            FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
            FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
            FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
            FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

            // File name and path
            filename = list->getItemFilename(item);
            pathname = list->getItemPathname(item);

            // If directory, open the directory
            if (list->isItemDirectory(item))
            {
                // Does not have access
                if (!::isReadExecutable(pathname))
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _(" Permission to: %s denied."), pathname.text());
                    getApp()->endWaitCursor();
                    return(0);
                }
                if (filename == "..")
                {
                    list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
                }
                else
                {
                    list->setDirectory(pathname);
                }

                // Change directory in tree list
                dirpanel->setDirectory(pathname, true);
                current->updatePath();

                // Update location history
                updateLocation();
            }
            else if (list->isItemFile(item))
            {
                // Update associations dictionary
                FileDict*  assocdict = new FileDict(getApp());
                FileAssoc* association = assocdict->findFileBinding(pathname.text());

                // If there is an association
                if (association)
                {
                    // Use it to open the file
                    if (association->command.section(',', 0) != "")
                    {
                        cmdname = association->command.section(',', 0);

                        // Use a default program if possible
                        switch (progs[cmdname])
                        {
                        case TXTVIEWER:
                            cmdname = txtviewer;
                            break;

                        case TXTEDITOR:
                            cmdname = txteditor;
                            break;

                        case IMGVIEWER:
                            cmdname = imgviewer;
                            break;

                        case IMGEDITOR:
                            cmdname = imgeditor;
                            break;

                        case PDFVIEWER:
                            cmdname = pdfviewer;
                            break;

                        case AUDIOPLAYER:
                            cmdname = audioplayer;
                            break;

                        case VIDEOPLAYER:
                            cmdname = videoplayer;
                            break;

                        case ARCHIVER:
                            cmdname = archiver;
                            break;

                        case NONE: // No program found
                            ;
                            break;
                        }

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // Or execute the file
                    else if (list->isItemExecutable(item))
                    {
                        execFile(pathname);
                    }

                    // Or call the "Open with..." dialog
                    else
                    {
                        getApp()->endWaitCursor();
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }

                // If no association but executable
                else if (list->isItemExecutable(item))
                {
                    execFile(pathname);
                }

                // Other cases
                else
                {
                    getApp()->endWaitCursor();
                    current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                }
            }
        }
    }

    // More than one selected files
    else
    {
        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN), NULL);
    }

    getApp()->endWaitCursor();

    return(1);
}


// Single click on File Item
long FilePanel::onCmdItemClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    // Make panel active
    setActive();

    if (single_click != SINGLE_CLICK_NONE)
    {
        // Default programs
        FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
        FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
        FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
        FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
        FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
        FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
        FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
        FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

        // In detailed mode, avoid single click when mouse cursor is not over the first column
        int    x, y;
        FXuint state;
        getCursorPosition(x, y, state);
        FXbool allow = true;
        if (!(list->getListStyle()&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS)) && ((x-list->getXPosition()) > list->getHeaderSize(0)))
        {
            allow = false;
        }

        // Single click with control or shift
        if (state&(CONTROLMASK|SHIFTMASK))
        {
            return(1);
        }

        // Single click without control or shift
        else
        {
            FXString cmd, cmdname, filename, pathname;

            // Wait cursor
            getApp()->beginWaitCursor();

#ifdef STARTUP_NOTIFICATION
            // Startup notification option and exceptions (if any)
            FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
            FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

            FXlong item = (FXlong)ptr;
            if (item > -1)
            {
                // File name and path
                filename = list->getItemFilename(item);
                pathname = list->getItemPathname(item);

                // If directory, open the directory
                if ((single_click != SINGLE_CLICK_NONE) && list->isItemDirectory(item) && allow)
                {
                    // Does not have access
                    if (!::isReadExecutable(pathname))
                    {
                        MessageBox::error(this, BOX_OK_SU, _("Error"), _(" Permission to: %s denied."), pathname.text());
                        getApp()->endWaitCursor();
                        return(0);
                    }
                    if (filename == "..")
                    {
                        list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
                    }
                    else
                    {
                        list->setDirectory(pathname);
                    }

                    // Change directory in tree list
                    dirpanel->setDirectory(pathname, true);
                    current->updatePath();

                    // Update location history
                    updateLocation();
                }

                // If file, use the association if any
                else if ((single_click == SINGLE_CLICK_DIR_FILE) && list->isItemFile(item) && allow)
                {
                    // Update associations dictionary
                    FileDict*  assocdict = new FileDict(getApp());
                    FileAssoc* association = assocdict->findFileBinding(pathname.text());

                    // If there is an association
                    if (association)
                    {
                        // Use it to open the file
                        if (association->command.section(',', 0) != "")
                        {
                            cmdname = association->command.section(',', 0);

                            // Use a default program if possible
                            switch (progs[cmdname])
                            {
                            case TXTVIEWER:
                                cmdname = txtviewer;
                                break;

                            case TXTEDITOR:
                                cmdname = txteditor;
                                break;

                            case IMGVIEWER:
                                cmdname = imgviewer;
                                break;

                            case IMGEDITOR:
                                cmdname = imgeditor;
                                break;

                            case PDFVIEWER:
                                cmdname = pdfviewer;
                                break;

                            case AUDIOPLAYER:
                                cmdname = audioplayer;
                                break;

                            case VIDEOPLAYER:
                                cmdname = videoplayer;
                                break;

                            case ARCHIVER:
                                cmdname = archiver;
                                break;

                            case NONE: // No program found
                                ;
                                break;
                            }

                            // If command exists, run it
                            if (::existCommand(cmdname))
                            {
                                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                            }

                            // If command does not exist, call the "Open with..." dialog
                            else
                            {
                                getApp()->endWaitCursor();
                                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                            }
                        }

                        // Or execute the file
                        else if (list->isItemExecutable(item))
                        {
                            execFile(pathname);
                        }

                        // Or call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // If no association but executable
                    else if (list->isItemExecutable(item))
                    {
                        execFile(pathname);
                    }

                    // Other cases
                    else
                    {
                        getApp()->endWaitCursor();
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }
            }
            getApp()->endWaitCursor();
        }
    }
    return(1);
}


// Go to parent directory
long FilePanel::onCmdDirectoryUp(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
    current->list->setFocus();
    dirpanel->setDirectory(current->list->getDirectory(), true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Go to home directory
long FilePanel::onCmdGoHome(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setDirectory(homedir);
    current->list->setFocus();
    dirpanel->setDirectory(homedir, true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Go to trash directory
long FilePanel::onCmdGoTrash(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setDirectory(trashfileslocation);
    current->list->setFocus();
    dirpanel->setDirectory(trashfileslocation, true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Set the flag that allows to stop the file list refresh
long FilePanel::onCmdStopListRefreshTimer(FXObject*, FXSelector, void*)
{
    stopListRefresh = true;

    return(0);
}


// Copy/Move/Rename/Symlink file(s)
long FilePanel::onCmdFileMan(FXObject* sender, FXSelector sel, void* ptr)
{
    int      num;
    FXString src, targetdir, target, name, source;
    int      firstitem = 0, lastitem = 0;

    // Focus on this panel list
    current->list->setFocus();

    // Confirmation dialog?
    FXbool ask_before_copy = getApp()->reg().readUnsignedEntry("OPTIONS", "ask_before_copy", true);

    // If we are we called from the paste command, get the parameters from the pointer
    if (fromPaste)
    {
        // Reset the flag
        fromPaste = false;

        // Get the parameters
        FXString str = (char*)ptr;
        targetdir = str.section('\n', 0);
        num = FXUIntVal(str.section('\n', 1));
        src = str.after('\n', 2);

        // If no item in clipboard, return
        if (num <= 0)
        {
            return(0);
        }

        // If there is a selected directory in file panel, use it as target directory
        if (current->list->getNumSelectedItems() == 1)
        {
            int item = current->list->getCurrentItem();
            if (current->list->isItemDirectory(item))
            {
                targetdir = list->getItemPathname(item);
            }
        }
    }

    // Obtain the parameters from the file panel
    else
    {
        // Current directory
        FXString curdir = current->list->getDirectory();

        // Number of selected items
        num = current->list->getNumSelectedItems();

        // If no item, return
        if (num <= 0)
        {
            return(0);
        }

        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        // Obtain the list of source files and the target directory
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                if (firstitem == 0)
                {
                    firstitem = u;
                }
                lastitem = u;
                name = current->list->getItemText(u).text();
                name = name.section('\t', 0);
                src += curdir+PATHSEPSTRING+name+"\n";
            }
        }
        targetdir = current->next->list->getDirectory();

        if (!current->next->shown() || (FXSELID(sel) == ID_FILE_RENAME))
        {
            targetdir = current->list->getDirectory();
        }
    }

    // Number of items in the FileList
    int numitems = current->list->getNumItems();

    // Name and directory of the first source file
    source = src.section('\n', 0);
    name = FXPath::name(source);
    FXString dir = FXPath::directory(source);

    // Initialize target name
    if (targetdir != ROOTDIR)
    {
        target = targetdir+PATHSEPSTRING;
    }
    else
    {
        target = targetdir;
    }

    // Configure the command, title, message, etc.
    FXIcon*  icon = NULL;
    FXString command, title, message;
    if (FXSELID(sel) == ID_FILE_COPY)
    {
        command = "copy";
        title = _("Copy");
        icon = copy_bigicon;
        if (num == 1)
        {
            message = _("Copy ");
            message += source;
            if (::isFile(source))
            {
                target += name;
            }

            // Source and target are identical => add a suffix to the name
            FXString tgt = ::cleanPath(target); // Remove trailing / if any
            if ((::identical(source, tgt) && (tgt != current->list->getDirectory())) || // Check we are not within target
                (::isDirectory(source) && (source == tgt+PATHSEPSTRING+FXPath::name(source))))
            {
                target = ::buildCopyName(source);
            }
        }
        else
        {
            message.format(_("Copy %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_RENAME)
    {
        command = "rename";
        title = _("Rename");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Rename ");
            message += name;
            target = name;
            title = _("Rename");
        }
        else
        {
            return(0);
        }
    }
    if (FXSELID(sel) == ID_FILE_COPYTO)
    {
        command = "copy";
        title = _("Copy");
        icon = copy_bigicon;
        if (num == 1)
        {
            message = _("Copy ");
            message += source;
        }
        else
        {
            message.format(_("Copy %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_MOVETO)
    {
        command = "move";
        title = _("Move");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Move ");
            message += source;
            title = _("Move");
        }
        else
        {
            message.format(_("Move %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_CUT)
    {
        command = "move";
        title = _("Move");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Move ");
            message += source;
            if (::isFile(source))
            {
                target += name;
            }
            title = _("Move");
        }
        else
        {
            message.format(_("Move %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_SYMLINK)
    {
        command = "symlink";
        title = _("Symlink");
        icon = link_bigicon;
        if (num == 1)
        {
            message = _("Symlink ");
            message += source;
            target += name;
        }
        else
        {
            message.format(_("Symlink %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }

    // File operation dialog, if needed
    if (ask_before_copy || (source == target) || (FXSELID(sel) == ID_FILE_COPYTO) || (FXSELID(sel) == ID_FILE_MOVETO) || (FXSELID(sel) == ID_FILE_RENAME) || (FXSELID(sel) == ID_FILE_SYMLINK))
    {
        if (num == 1)
        {
            if (FXSELID(sel) == ID_FILE_RENAME)
            {
                if (operationdialogrename == NULL)
                {
                    operationdialogrename = new InputDialog(this, "", "", title, _("To:"), icon);
                }
                operationdialogrename->setTitle(title);
                operationdialogrename->setIcon(icon);
				operationdialogrename->setMessage(message);
                operationdialogrename->setText(target);

                if (::isDirectory(source))  // directory
                {
                    operationdialogrename->selectAll();
                }
                else
                {
                    int pos = target.rfind('.');
                    if (pos <= 0)
                    {
                        operationdialogrename->selectAll(); // no extension or dot file
                    }
                    else
                    {
                        operationdialogrename->setSelection(0, pos);
                    }
                }

                int rc = 1;
                rc = operationdialogrename->execute(PLACEMENT_CURSOR);
                target = operationdialogrename->getText();
                
                // Target name contains '/'
                if (target.contains(PATHSEPCHAR))
                {
					MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in file or folder names, operation cancelled"));
					return(0);
				}

                if (!rc)
                {
                    return(0);
                }
            }
            else
            {
                if (operationdialogsingle == NULL)
                {
                    operationdialogsingle = new BrowseInputDialog(this, "", "", title, _("To:"), icon, BROWSE_INPUT_MIXED);
                }
                operationdialogsingle->setTitle(title);
                operationdialogsingle->setIcon(icon);
                operationdialogsingle->setMessage(message);
                operationdialogsingle->setText(target);

                // Select file name without path
                if (FXSELID(sel) == ID_FILE_SYMLINK)
                {
                    int pos = target.rfind(PATHSEPSTRING);
                    if (pos >= 0)
                    {
                        operationdialogsingle->setSelection(pos+1, target.length());
                    }
                }

                operationdialogsingle->setDirectory(targetdir);
                int rc = 1;
                rc = operationdialogsingle->execute(PLACEMENT_CURSOR);
                target = operationdialogsingle->getText();
                if (!rc)
                {
                    return(0);
                }
            }
        }
        else
        {
            if (operationdialogmultiple == NULL)
            {
                operationdialogmultiple = new BrowseInputDialog(this, "", "", title, _("To folder:"), icon, BROWSE_INPUT_FOLDER);
            }
            operationdialogmultiple->setTitle(title);
            operationdialogmultiple->setIcon(icon);
            operationdialogmultiple->setMessage(message);
            operationdialogmultiple->setText(target);
            operationdialogmultiple->CursorEnd();
            operationdialogmultiple->setDirectory(targetdir);
            int rc = 1;
            rc = operationdialogmultiple->execute(PLACEMENT_CURSOR);
            target = operationdialogmultiple->getText();
            if (!rc)
            {
                return(0);
            }
        }
    }

    // Nothing entered
    if (target == "")
    {
        MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
        return(0);
    }

    // Update target and target parent directory
	target = ::filePath(target,current->list->getDirectory());
	if (::isDirectory(target))
	{
		targetdir = target;
	}
	else
	{
		targetdir = FXPath::directory(target);
	}

    // Target parent directory doesn't exist
    if (!::exists(targetdir))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), targetdir.text());
        return(0);
    }

    // Target parent directory not writable
    if (!::isWritable(targetdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetdir.text());
        return(0);
    }

    // Target parent directory is not a directory
    if (!::isDirectory(targetdir))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("%s is not a folder"), targetdir.text());
        return(0);
    }

    // Multiple sources and non existent destination
    if ((num > 1) && !::exists(target))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), target.text());
        return(0);
    }

    // Multiple sources and target is a file
    if ((num > 1) && ::isFile(target))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("%s is not a folder"), target.text());
        return(0);
    }

    // Target is a directory and is not writable
    if (::isDirectory(target) && !::isWritable(target))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), target.text());
        return(0);
    }

    // Target is a file and its parent directory is not writable
    if (::isFile(target) && !::isWritable(targetdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetdir.text());
        return(0);
    }

    // One source
    File* f = NULL;
    int   ret;
    if (num == 1)
    {
        // An empty source file name corresponds to the ".." file
        // Don't perform any file operation on it!
        if (source == "")
        {
            return(0);
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        if (command == "copy")
        {
            f = new File(this, _("File copy"), COPY, num);
            f->create();

            // If target file is located at trash location, also create the corresponding trashinfo file
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && (target == trashfileslocation))
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(source, trashfileslocation);

                // Adjust target name to get the _N suffix if any
                FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                // Create trashinfo file
                createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                // Copy source to trash target
                ret = f->copy(source, trashtarget);
            }

            // Copy source to target
            else
            {
                ret = f->copy(source, target);
            }

            // An unknown error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
            }
        }
        else if (command == "rename")
        {
            f = new File(this, _("File rename"), RENAME, num);
            f->create();
            ret = f->rename(source, target);

            // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
            {
                FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                ::unlink(trashinfopathname.text());
            }
        }
        else if (command == "move")
        {
            f = new File(this, _("File move"), MOVE, num);
            f->create();

            // If target file is located at trash location, also create the corresponding trashinfo file
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && (target == trashfileslocation))
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(source, trashfileslocation);

                // Adjust target name to get the _N suffix if any
                FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                // Create trashinfo file
                createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                // Move source to trash target
                ret = f->move(source, trashtarget);
            }

            // Move source to target
            else
            {
                ret = f->move(source, target);
            }

            // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
            // Do it silently and don't report any error if it fails
            if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
            {
                FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                ::unlink(trashinfopathname.text());
            }

            // An unknown error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
            }
        }
        else if (command == "symlink")
        {
            f = new File(this, _("Symlink"), SYMLINK, num);
            f->create();
            f->symlink(source, target);
        }
        // Shouldn't happen
        else
        {
            exit(EXIT_FAILURE);
        }

        getApp()->endWaitCursor();
        delete f;
    }

    // Multiple sources
    // Note : rename cannot be used in this case!
    else if (num > 1)
    {
        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        if (command == "copy")
        {
            f = new File(this, _("File copy"), COPY, num);
        }
        else if (command == "move")
        {
            f = new File(this, _("File move"), MOVE, num);
        }
        else if (command == "symlink")
        {
            f = new File(this, _("Symlink"), SYMLINK, num);
        }
        // Shouldn't happen
        else
        {
            exit(EXIT_FAILURE);
        }
        f->create();

        // Initialize file list stop refresh timer and flag
        stopListRefresh = false;
        getApp()->addTimeout(this, ID_STOP_LIST_REFRESH_TIMER, STOP_LIST_REFRESH_INTERVAL);

        // Loop on the multiple files
        for (int i = 0; i < num; i++)
        {
            // Stop refreshing the file list if file operation is long and has many files
            // This avoids flickering and speeds up things a bit
            if (stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
            {
                // Force a last refresh if current panel is destination
                if (current->getDirectory() == targetdir)
                {
                    current->list->onCmdRefresh(0, 0, 0);
                }

                // Force a last refresh if next panel is destination
                if (next->getDirectory() == targetdir)
                {
                    next->list->onCmdRefresh(0, 0, 0);
                }

                // Tell the dir and file list to not refresh anymore
                setAllowRefresh(false);
                next->setAllowRefresh(false);
                dirpanel->setAllowDirsizeRefresh(false);

                // Don't need to stop again
                stopListRefresh = false;
            }

            // Individual source file
            source = src.section('\n', i);

            // File could have already been moved above in the tree
            if (!::exists(source))
            {
                continue;
            }

            // An empty file name corresponds to the ".." file (why?)
            // Don't perform any file operation on it!
            if (source != "")
            {
                if (command == "copy")
                {
                    // If target file is located at trash location, also create the corresponding trashinfo file
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (target == trashfileslocation))
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(source, trashfileslocation);

                        // Adjust target name to get the _N suffix if any
                        FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                        // Create trashinfo file
                        createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                        // Copy source to trash target
                        ret = f->copy(source, trashtarget);
                    }

                    // Copy source to target
                    else
                    {
                        ret = f->copy(source, target);
                    }

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
                        break;
                    }
                }
                else if (command == "move")
                {
                    // If target file is located at trash location, also create the corresponding trashinfo file
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (target == trashfileslocation))
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(source, trashfileslocation);

                        // Adjust target name to get the _N suffix if any
                        FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                        // Create trashinfo file
                        createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                        // Move source to trash target
                        ret = f->move(source, trashtarget);
                    }

                    // Move source to target
                    else
                    {
                        ret = f->move(source, target);
                    }

                    // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
                    // Do it silently and don't report any error if it fails
                    if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
                    {
                        FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                        ::unlink(trashinfopathname.text());
                    }

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
                        break;
                    }
                }
                else if (command == "symlink")
                {
                    ret = f->symlink(source, target);

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the symlink operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Symlink operation cancelled!"));
                        break;
                    }
                }
                // Shouldn't happen
                else
                {
                    exit(EXIT_FAILURE);
                }
            }
        }

        // Reinit timer and refresh flags
        getApp()->removeTimeout(this, ID_STOP_LIST_REFRESH_TIMER);
        current->setAllowRefresh(true);
        next->setAllowRefresh(true);
        dirpanel->setAllowDirsizeRefresh(true);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panels refresh
    next->onCmdRefresh(0, 0, 0);
    current->onCmdRefresh(0, 0, 0);

    // Enable previous or last selected item for keyboard navigation
    if (((FXSELID(sel) == ID_FILE_MOVETO) || (FXSELID(sel) == ID_FILE_RENAME)) && (current->list->getNumItems() < numitems))
    {
        firstitem = (firstitem < 1) ? 0 : firstitem-1;
        current->list->enableItem(firstitem);
        current->list->setCurrentItem(firstitem);
    }
    else
    {
        current->list->enableItem(lastitem);
        current->list->setCurrentItem(lastitem);
    }

    return(1);
}


// Trash files from the file list or the tree list
long FilePanel::onCmdFileTrash(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();

    FXbool confirm_trash = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_trash", true);

    // If we don't have permission to write to the parent directory
    if (!::isWritable(dir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
        return(0);
    }

    // If we don't have permission to write to the trash directory
    if (!::isWritable(trashfileslocation))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to trash location %s: Permission denied"), trashfileslocation.text());
        return(0);
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        if (confirm_trash)
        {
            FXString message;
            if (num == 1)
            {
                FXString pathname;
                for (int u = 0; u < current->list->getNumItems(); u++)
                {
                    if (current->list->isItemSelected(u))
                    {
                        pathname = current->list->getItemPathname(u);
                    }
                }
                if (::isDirectory(pathname))
                {
                    message.format(_("Move folder %s to trash can?"), pathname.text());
                }
                else
                {
                    message.format(_("Move file %s to trash can?"), pathname.text());
                }
            }
            else
            {
                message.format(_("Move %s selected object(s) to trash can?"), FXStringVal(num).text());
            }

            MessageBox box(this, _("Confirm Trash"), message, delete_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
            if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
            {
                return(0);
            }
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Move to trash"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Overwrite initialisations
        FXbool overwrite = false;
        FXbool overwrite_all = false;
        FXbool skip_all = false;

        // Delete selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // If we don't have permission to write to the file
                if (!::isWritable(pathname))
                {
                    // Overwrite dialog if necessary
                    if (!(overwrite_all | skip_all))
                    {
                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("File %s is write-protected, move it anyway to trash can?"), pathname.text());
                        
                        if (num ==1)
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Trash"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;	
							if (answer == 1)
							{
								overwrite = true;
							}
							else
							{
								goto end;
							}
						}  
                        else
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Trash"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Overwrite
							case 1:
								overwrite = true;
								break;

							// Overwrite all
							case 2:
								overwrite_all = true;
								break;

							// Skip
							case 3:
								overwrite = false;
								break;

							// Skip all
							case 4:
								skip_all = true;
								break;
							}
							
						}
                    }
                    if ((overwrite | overwrite_all) & !skip_all)
                    {
                        // Caution!! Don't delete parent directory!!
                        if (filename != "..")
                        {
                            // Trash files path name
                            FXString trashpathname = createTrashpathname(pathname, trashfileslocation);

                            // Create trashinfo file
                            createTrashinfo(pathname, trashpathname, trashfileslocation, trashinfolocation);

                            // Move file to trash files location
                            int ret = f->move(pathname, trashpathname);

                            // An error has occurred
                            if ((ret == 0) && !f->isCancelled())
                            {
                                f->hideProgressDialog();
                                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move to trash operation!"));
                                break;
                            }
                        }
                    }
                    f->showProgressDialog();
                }

                // If we have permission to write
                else
                {
                    // Caution!! Don't delete parent directory!!
                    if (filename != "..")
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(pathname, trashfileslocation);

                        // Create trashinfo file
                        createTrashinfo(pathname, trashpathname, trashfileslocation, trashinfolocation);

                        // Move file to trash files location
                        int ret = f->move(pathname, trashpathname);

                        // An error has occurred
                        if ((ret == 0) && !f->isCancelled())
                        {
                            f->hideProgressDialog();
                            MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move to trash operation!"));
                            break;
                        }
                    }
                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Move to trash file operation cancelled!"));
                        break;
                    }
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// Restore files from trash can
long FilePanel::onCmdFileRestore(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();
    FXbool   confirm_trash = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_trash", true);

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Restore from trash"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Restore (i.e. move to their original location) selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // Don't restore '..' directory
                if (filename != "..")
                {
                    // Obtain trash base name and sub path
                    FXString subpath = pathname;
                    subpath.erase(0, trashfileslocation.length()+1);
                    FXString trashbasename = subpath.before('/');
                    if (trashbasename == "")
                    {
                        trashbasename = name;
                    }
                    subpath.erase(0, trashbasename.length());

                    // Read the .trashinfo file
                    FILE*    fp;
                    char     line[1024];
                    FXbool   success = true;
                    FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+trashbasename+".trashinfo";
                    FXString origpathname = "";

                    if ((fp = fopen(trashinfopathname.text(), "r")) != NULL)
                    {
                        // Read the first two lines and get the strings
                        if (fgets(line, sizeof(line), fp) == NULL)
                        {
                            success = false;
                        }
                        if (fgets(line, sizeof(line), fp) == NULL)
                        {
                            success = false;
                        }
                        if (success)
                        {
                            origpathname = line;
                            origpathname = origpathname.after('=');
                            origpathname = origpathname.before('\n');
                        }
                        fclose(fp);
                        origpathname = origpathname+subpath;
                    }

                    // Confirm restore dialog
                    if (confirm_trash && (u == firstitem))
                    {
                        FXString message;
                        if (num == 1)
                        {
                            if (::isDirectory(pathname))
                            {
                                message.format(_("Restore folder %s to its original location %s ?"), filename.text(), origpathname.text());
                            }
                            else
                            {
                                message.format(_("Restore file %s to its original location %s ?"), filename.text(), origpathname.text());
                            }
                        }
                        else
                        {
                            message.format(_("Restore %s selected object(s) to their original locations?"), FXStringVal(num).text());
                        }
                        f->hideProgressDialog();
                        MessageBox box(this, _("Confirm Restore"), message, restore_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
                        if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
                        {
                            getApp()->endWaitCursor();
                            delete f;
                            return(0);
                        }
                        f->showProgressDialog();
                    }

                    if (origpathname == "")
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("Restore information not available for %s"), pathname.text());
                        goto end;
                    }

                    // If parent dir of the original location does not exist
                    FXString origparentdir = FXPath::directory(origpathname);
                    if (!::exists(origparentdir))
                    {
                        // Ask the user if he wants to create it
                        f->hideProgressDialog();
                        FXString message;
                        message.format(_("Parent folder %s does not exist, do you want to create it?"), origparentdir.text());
                        MessageBox box(this, _("Confirm Restore"), message, restore_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
                        if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
                        {
                            goto end;
                        }
                        else
                        {
                            errno = 0;
                            int ret = mkpath(origparentdir.text(), 0755);
                            int errcode = errno;
                            if (ret == -1)
                            {
                                f->hideProgressDialog();
                                if (errcode)
                                {
                                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't create folder %s: %s"), origparentdir.text(), strerror(errcode));
                                }
                                else
                                {
                                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't create folder %s"), origparentdir.text());
                                }
                                goto end;
                            }
                            f->showProgressDialog();
                        }
                    }

                    // Move file to original location (with restore option)
                    int ret = f->move(pathname, origpathname, true);

                    // An error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the restore from trash operation!"));
                        goto end;
                    }

                    // Silently remove trashinfo file
                    FXString trashfilespathname = trashfileslocation+PATHSEPSTRING+trashbasename;
                    if ((pathname == trashfilespathname) && !::exists(trashfilespathname))
                    {
                        ::unlink(trashinfopathname.text());
                    }
                }
                // If action is cancelled in progress dialog
                if (f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Warning"), _("Restore from trash file operation cancelled!"));
                    goto end;
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// Definitively delete files from the file list or the tree list (no trash can)
long FilePanel::onCmdFileDelete(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();

    FXbool confirm_del = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete", true);
    FXbool confirm_del_emptydir = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete_emptydir", true);

    // If we don't have permission to write to the parent directory
    if (!::isWritable(dir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
        return(0);
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        if (confirm_del)
        {
            FXString message;
            if (num == 1)
            {
                FXString pathname;
                for (int u = 0; u < current->list->getNumItems(); u++)
                {
                    if (current->list->isItemSelected(u))
                    {
                        pathname = current->list->getItemPathname(u);
                    }
                }
                if (::isDirectory(pathname))
                {
                    message.format(_("Definitively delete folder %s ?"), pathname.text());
                }
                else
                {
                    message.format(_("Definitively delete file %s ?"), pathname.text());
                }
            }
            else
            {
                message.format(_("Definitively delete %s selected object(s)?"), FXStringVal(num).text());
            }
            MessageBox box(this, _("Confirm Delete"), message, delete_big_permicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
            if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
            {
                return(0);
            }
        }
        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("File delete"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Overwrite initialisations
        FXbool overwrite = false;
        FXbool overwrite_all = false;
        FXbool skip_all = false;
        FXbool ask_del_empty = true;
        FXbool skip_all_del_emptydir = false;

        // Delete selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // Confirm empty directory deletion
                if (confirm_del & confirm_del_emptydir & ask_del_empty)
                {
                    if ((::isEmptyDir(pathname) == 0) && !::isLink(pathname))
                    {
                        if (skip_all_del_emptydir)
                        {
                            continue;
                        }

                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("Folder %s is not empty, delete it anyway?"), pathname.text());

                        if (num ==1)
                        {
                        	OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							
							if (answer == 0)
							{
								goto end;
							}
						}
                        
                        else
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Yes
							case 1:
								break;

							// Yes for all
							case 2:
								ask_del_empty = false;
								break;

							// Skip
							case 3:
								continue;
								break;

							// Skip all
							case 4:
								skip_all_del_emptydir = true;
								continue;
								break;
							}
						}
						f->showProgressDialog();
                    }
                }

                // If we don't have permission to write to the file
                if (!::isWritable(pathname))
                {
                    // Overwrite dialog if necessary
                    if (!(overwrite_all | skip_all))
                    {
                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("File %s is write-protected, delete it anyway?"), pathname.text());
  
  						if (num == 1)
  						{
                        	OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							if (answer == 1)
							{
								overwrite = true;
							}
							else
							{
								goto end;
							}							
						}
  
 						else
 						{
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Yes
							case 1:
								overwrite = true;
								break;

							// Yes for all
							case 2:
								overwrite_all = true;
								break;

							// Skip
							case 3:
								overwrite = false;
								break;

							// Skip all
							case 4:
								skip_all = true;
								break;
							}
						} 
                    }
                    if ((overwrite | overwrite_all) & !skip_all)
                    {
                        // Caution!! Don't delete parent directory!!
                        if (filename != "..")
                        {
                            // Definitively remove file or folder
                            f->remove(pathname);
                        }
                    }
                    f->showProgressDialog();
                }

                // If we have permission to write
                else
                {
                    // Caution!! Don't delete parent directory!!
                    if (filename != "..")
                    {
                        // Definitively remove file or folder
                        f->remove(pathname);

                        // If is located at trash location, try to also remove the corresponding trashinfo file if it exists
                        // Do it silently and don't report any error if it fails
                        FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                        if (use_trash_can && (pathname.left(trashfileslocation.length()) == trashfileslocation))
                        {
                            FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+filename+".trashinfo";
                            ::unlink(trashinfopathname.text());
                        }
                    }
                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Delete file operation cancelled!"));
                        break;
                    }
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// View/Edit files
long FilePanel::onCmdEdit(FXObject*, FXSelector s, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString   pathname, samecmd, cmd, cmdname, itemslist = " ";
    FileAssoc* association;
    FXbool     same = true;
    FXbool     first = true;

    current->list->setFocus();

    if (current->list->getNumSelectedItems() == 0)
    {
        getApp()->endWaitCursor();
        return(0);
    }

    FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
    FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
    FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
    FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
    FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
    FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
    FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
    FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

    // Update associations dictionary
    FileDict* assocdict = new FileDict(getApp());

    // Check if all files have the same association
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            // Increment number of selected items
            pathname = current->list->getItemPathname(u);
            association = assocdict->findFileBinding(pathname.text());

            // If there is an association
            if (association)
            {
                // Use it to edit/view the files
                if (FXSELID(s) == ID_EDIT) // Edit
                {
                    cmd = association->command.section(',', 2);

                    // Use a default editor if possible
                    switch (progs[cmd])
                    {
                    case TXTEDITOR:
                        cmd = txteditor;
                        break;

                    case IMGEDITOR:
                        cmd = imgeditor;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No default editor found
                        ;
                        break;
                    }

                    if (cmd.length() == 0)
                    {
                        cmd = txteditor;
                    }
                }
                else // Any other is View
                {
                    cmd = association->command.section(',', 1);

                    // Use a default viewer if possible
                    switch (progs[cmd])
                    {
                    case TXTVIEWER:
                        cmd = txtviewer;
                        break;

                    case IMGVIEWER:
                        cmd = imgviewer;
                        break;

                    case PDFVIEWER:
                        cmd = pdfviewer;
                        break;

                    case AUDIOPLAYER:
                        cmd = audioplayer;
                        break;

                    case VIDEOPLAYER:
                        cmd = videoplayer;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No default viewer found
                        ;
                        break;
                    }

                    if (cmd.length() == 0)
                    {
                        cmd = txtviewer;
                    }
                }
                if (cmd.text() != NULL)
                {
                    // First selected item
                    if (first)
                    {
                        samecmd = cmd;
                        first = false;
                    }

                    if (samecmd != cmd)
                    {
                        same = false;
                        break;
                    }

                    // List of selected items
                    itemslist += ::quote(pathname) + " ";
                }
                else
                {
                    same = false;
                    break;
                }
            }

            // No association
            else
            {
                same = false;
                break;
            }
        }
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // Same association for all files : execute the associated or default editor or viewer
    if (same)
    {
        cmdname = samecmd;

        // If command exists, run it
        if (::existCommand(cmdname))
        {
            cmd = cmdname+itemslist;
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
        }
    }

    // Files have different associations : handle them separately
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);

                // Only View / Edit regular files (not directories)
                if (::isFile(pathname))
                {
                    association = assocdict->findFileBinding(pathname.text());

                    // If there is an association
                    if (association)
                    {
                        // Use it to edit/view the file
                        if (FXSELID(s) == ID_EDIT) // Edit
                        {
                            cmd = association->command.section(',', 2);

                            // Use a default editor if possible
                            switch (progs[cmd])
                            {
                            case TXTEDITOR:
                                cmd = txteditor;
                                break;

                            case IMGEDITOR:
                                cmd = imgeditor;
                                break;

                            case ARCHIVER:
                                cmd = archiver;
                                break;
                            }

                            if (cmd.length() == 0)
                            {
                                cmd = txteditor;
                            }
                        }
                        else // Any other is View
                        {
                            cmd = association->command.section(',', 1);

                            // Use a default viewer if possible
                            switch (progs[cmd])
                            {
                            case TXTVIEWER:
                                cmd = txtviewer;
                                break;

                            case IMGVIEWER:
                                cmd = imgviewer;
                                break;

                            case PDFVIEWER:
                                cmd = pdfviewer;
                                break;

                            case AUDIOPLAYER:
                                cmd = audioplayer;
                                break;

                            case VIDEOPLAYER:
                                cmd = videoplayer;
                                break;

                            case ARCHIVER:
                                cmd = archiver;
                                break;

                            case NONE: // No default viewer found
                                ;
                                break;
                            }

                            if (cmd.length() == 0)
                            {
                                cmd = txtviewer;
                            }
                        }

                        if (cmd.text() != NULL)
                        {
                            cmdname = cmd;

                            // If command exists, run it
                            if (::existCommand(cmdname))
                            {
                                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                            }

                            // If command does not exist, call the "Open with..." dialog
                            else
                            {
                                getApp()->endWaitCursor();
                                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                            }
                        }
                    }

                    // No association
                    else
                    {
                        if (FXSELID(s) == ID_EDIT)
                        {
                            cmd = txteditor;
                        }
                        else
                        {
                            cmd = txtviewer;
                        }

                        cmdname = cmd;

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }
                }
            }
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Compare two files
long FilePanel::onCmdCompare(FXObject*, FXSelector s, void*)
{
    current->list->setFocus();
    int num = current->list->getNumSelectedItems();

    // Only one or two selected items can be handled
    if ((num != 1) && (num != 2))
    {
        getApp()->endWaitCursor();
        return(0);
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    FXString filecomparator = getApp()->reg().readStringEntry("PROGS", "filecomparator", DEFAULT_FILECOMPARATOR);
    FXString pathname, cmd, cmdname, itemslist = " ";

    // One selected item
    if (num == 1)
    {
        // Get the selected item
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                itemslist += ::quote(pathname) + " ";
            }
        }

        // Open a dialog to select the other item to be compared
        if (comparedialog == NULL)
        {
            comparedialog = new BrowseInputDialog(this, "", "", _("Compare"), _("With:"), bigcompareicon, BROWSE_INPUT_FILE);
        }
        comparedialog->setIcon(bigcompareicon);
        comparedialog->setMessage(pathname);
        comparedialog->setText("");
        int rc = 1;
        rc = comparedialog->execute(PLACEMENT_CURSOR);

        // Get item path and add it to the list
        FXString str = comparedialog->getText();
        itemslist += ::quote(str);
        if (!rc || (str == ""))
        {
            return(0);
        }
    }

    // Two selected items
    else if (num == 2)
    {
        // Get the two selected items
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                itemslist += ::quote(pathname) + " ";
            }
        }
    }

    // Wait cursor
    getApp()->beginWaitCursor();

    // If command exists, run it
    cmdname = filecomparator;
    if (::existCommand(cmdname))
    {
        cmd = cmdname+itemslist;
#ifdef STARTUP_NOTIFICATION
        runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
        runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
    }

    // If command does not exist, issue an error message
    else
    {
        getApp()->endWaitCursor();
        MessageBox::error(this, BOX_OK, _("Error"), _("Program %s not found. Please define a file comparator program in the Preferences dialog!"), cmdname.text());
    }

    getApp()->endWaitCursor();

    return(1);
}


// File or directory properties
long FilePanel::onCmdProperties(FXObject* sender, FXSelector, void*)
{
    int ret;
    int num, itm;

    current->list->setFocus();

    // If no selected files in the file list, use the selected folder from the tree list (if any)
    num = current->list->getNumSelectedItems(&itm);
    if (num == 0)
    {
		return(0);
    }

    // There is one selected file in the file list
    else if (num == 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        FXString path = current->list->getDirectory();
        FXString filename = current->list->getItemText(itm);
        filename = filename.section('\t', 0);
        PropertiesBox* attrdlg = new PropertiesBox(this, filename, path);
        attrdlg->create();
        attrdlg->show(PLACEMENT_OWNER);
    }

    // There are multiple selected files in the file list
    else if (num > 1)
    {
        ret = chdir(current->list->getDirectory().text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
            }

            return(0);
        }

        FXString  path = current->list->getDirectory();
        FXString* files = new FXString[num];
        FXString* paths = new FXString[num];

        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        int i = 0;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                files[i] = current->list->getItemText(u).section('\t', 0);
                paths[i] = path;
                i++;
            }
        }

        PropertiesBox* attrdlg = new PropertiesBox(this, files, num, paths);
        attrdlg->create();
        attrdlg->show(PLACEMENT_OWNER);
        
        ret = chdir(startlocation.text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
            }

            return(0);
        }
    }

    // Force panel refresh
    return(1);
}


// Create new directory
long FilePanel::onCmdNewDir(FXObject*, FXSelector, void*)
{
    FXString dirname = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString dirpath = current->list->getDirectory();
    if (dirpath != ROOTDIR)
    {
        dirpath += PATHSEPSTRING;
    }

    if (newdirdialog == NULL)
    {
        newdirdialog = new InputDialog(this, "", _("Create new folder:"), _("New Folder"),"",bignewfoldericon);
    }
    newdirdialog->setText("");

    // Accept was pressed
    if (newdirdialog->execute(PLACEMENT_CURSOR))
    {
        if (newdirdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("Folder name is empty, operation cancelled"));
            return(0);
        }

		// Directory name contains '/'
		if (newdirdialog->getText().contains(PATHSEPCHAR))
		{
			MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in folder names, operation cancelled"));
			return(0);
		}

        dirname = dirpath+newdirdialog->getText();
        if (dirname != dirpath)
        {
            // Create the new dir according to the current umask
            int mask;
            mask = umask(0);
            umask(mask);

            // Note that the umask value is in decimal (511 means octal 0777)
            errno = 0;
            int ret = ::mkdir(dirname.text(), 511 & ~mask);
            int errcode = errno;
            if (ret == -1)
            {
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s: %s"), dirname.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s"), dirname.text());
                }
                return(0);
            }
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == dirname)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Create new file
long FilePanel::onCmdNewFile(FXObject*, FXSelector, void*)
{
    FXString filename = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString pathname = current->list->getDirectory();
    if (pathname != ROOTDIR)
    {
        pathname += PATHSEPSTRING;
    }

    if (newfiledialog == NULL)
    {
        newfiledialog = new InputDialog(this, "", _("Create new file:"), _("New File"), "", bignewfileicon, false);
    }
    newfiledialog->setText("");

    // Accept was pressed
    if (newfiledialog->execute(PLACEMENT_CURSOR))
    {
        if (newfiledialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

		// File name contains '/'
		if (newfiledialog->getText().contains(PATHSEPCHAR))
		{
			MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in file names, operation cancelled"));
			return(0);
		}

        filename = pathname+newfiledialog->getText();
        FILE* file;
        if (filename != pathname)
        {
            // Test some error conditions
            if (::exists(filename))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("File or folder %s already exists"), filename.text());
                return(0);
            }
            // Create the new file
            errno = 0;
            if (!(file = fopen(filename.text(), "w+")) || fclose(file))
            {
                if (errno)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create file %s: %s"), filename.text(), strerror(errno));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create file %s"), filename.text());
                }
                return(0);
            }
            // Change the file permissions according to the current umask
            int mask;
            mask = umask(0);
            umask(mask);
            errno = 0;
            int rc = chmod(filename.text(), 438 & ~mask);
            int errcode = errno;
            if (rc)
            {
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't set permissions in %s: %s"), filename.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't set permissions in %s"), filename.text());
                }
            }
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == filename)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Create new symbolic link
long FilePanel::onCmdNewSymlink(FXObject*, FXSelector, void*)
{
    FXString linkname = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString linkpath = current->list->getDirectory();
    if (linkpath != ROOTDIR)
    {
        linkpath += PATHSEPSTRING;
    }

    if (newlinkdialog == NULL)
    {
        newlinkdialog = new InputDialog(this, "", _("Create new symbolic link:"), _("New Symlink"), "", bignewlinkicon, false);
    }
    newlinkdialog->setText("");

    // Accept was pressed
    if (newlinkdialog->execute(PLACEMENT_CURSOR))
    {
        if (newlinkdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }
        linkname = linkpath+newlinkdialog->getText();
        File* f;
        if (linkname != linkpath)
        {
            // Test some error conditions
            if (::exists(linkname))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("File or folder %s already exists"), linkname.text());
                return(0);
            }

            // Select target
            FileDialog browse(this, _("Select the symlink refered file or folder"));
            browse.setDirectory(linkpath);
            browse.setSelectMode(SELECT_FILE_MIXED);
            if (browse.execute())
            {
                FXString linksource = browse.getFilename();

                // Source does not exist
                if (!::exists(linksource))
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Symlink source %s does not exist"), linksource.text());
                    return(0);
                }

                f = new File(this, _("Symlink"), SYMLINK);
                f->create();
                f->symlink(linksource, linkname);
                delete f;
            }
            //else
            //return 0;
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == linkname)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Open single or multiple files
long FilePanel::onCmdOpen(FXObject*, FXSelector, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString   pathname, samecmd, cmd, cmdname, itemslist = " ";
    FileAssoc* association;
    FXbool     same = true;
    FXbool     first = true;

    current->list->setFocus();
    if (current->list->getNumSelectedItems() == 0)
    {
        getApp()->endWaitCursor();
        return(0);
    }

    // Default programs
    FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
    FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
    FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
    FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
    FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
    FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
    FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
    FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

    // Update associations dictionary
    FileDict* assocdict = new FileDict(getApp());

    // Check if all files have the same association
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            // Increment number of selected items
            pathname = current->list->getItemPathname(u);

            // If directory, skip it
            if (::isDirectory(pathname))
            {
                continue;
            }

            // If association found
            association = assocdict->findFileBinding(pathname.text());
            if (association)
            {
                cmd = association->command.section(',', 0);

                // Use a default program if possible
                switch (progs[cmd])
                {
                case TXTVIEWER:
                    cmd = txtviewer;
                    break;

                case TXTEDITOR:
                    cmd = txteditor;
                    break;

                case IMGVIEWER:
                    cmd = imgviewer;
                    break;

                case IMGEDITOR:
                    cmd = imgeditor;
                    break;

                case PDFVIEWER:
                    cmd = pdfviewer;
                    break;

                case AUDIOPLAYER:
                    cmd = audioplayer;
                    break;

                case VIDEOPLAYER:
                    cmd = videoplayer;
                    break;

                case ARCHIVER:
                    cmd = archiver;
                    break;

                case NONE: // No program found
                    ;
                    break;
                }

                if (cmd != "")
                {
                    // First selected item
                    if (first)
                    {
                        samecmd = cmd;
                        first = false;
                    }

                    if (samecmd != cmd)
                    {
                        same = false;
                        break;
                    }

                    // List of selected items
                    itemslist += ::quote(pathname) + " ";
                }
                else
                {
                    same = false;
                    break;
                }
            }
            else
            {
                same = false;
                break;
            }
        }
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // Same command for all files : open them
    if (same && (itemslist != " "))
    {
        cmdname = samecmd;

        // If command exists, run it
        if (::existCommand(cmdname))
        {
            cmd = samecmd+itemslist;
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
        }
    }

    // Files have different commands : handle them separately
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);

                // If directory, skip it
                if (::isDirectory(pathname))
                {
                    continue;
                }

                association = assocdict->findFileBinding(pathname.text());
                if (association)
                {
                    // Use association to open the file
                    cmd = association->command.section(',', 0);

                    // Use a default program if possible
                    switch (progs[cmd])
                    {
                    case TXTVIEWER:
                        cmd = txtviewer;
                        break;

                    case TXTEDITOR:
                        cmd = txteditor;
                        break;

                    case IMGVIEWER:
                        cmd = imgviewer;
                        break;

                    case IMGEDITOR:
                        cmd = imgeditor;
                        break;

                    case PDFVIEWER:
                        cmd = pdfviewer;
                        break;

                    case AUDIOPLAYER:
                        cmd = audioplayer;
                        break;

                    case VIDEOPLAYER:
                        cmd = videoplayer;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No program found
                        ;
                        break;
                    }

                    if (cmd != "")
                    {
                        cmdname = cmd;

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // Or execute the file
                    else if (current->list->isItemExecutable(u))
                    {
                        execFile(pathname);
                    }

                    // Or call the "Open with..." dialog
                    else
                    {
                        getApp()->endWaitCursor();
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }

                // If no association but executable
                else if (current->list->isItemExecutable(u))
                {
                    execFile(pathname);
                }

                // Other cases
                else
                {
                    getApp()->endWaitCursor();
                    current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                }
            }
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Open with
long FilePanel::onCmdOpenWith(FXObject*, FXSelector, void*)
{
    char** str = NULL;

    current->list->setFocus();

    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    FXString cmd = "", cmdname;
    if (opendialog == NULL)
    {
        opendialog = new HistInputDialog(this, "", _("Open selected file(s) with:"), _("Open With"), "", bigfileopenicon, HIST_INPUT_EXECUTABLE_FILE, true, _("A&ssociate"));
    }
    opendialog->setText(cmd);

    // Dialog with history list and associate checkbox
    opendialog->CursorEnd();
    opendialog->selectAll();
    opendialog->clearItems();
    for (int i = 0; i < OpenNum; i++)
    {
        opendialog->appendItem(OpenHistory[i]);
    }
    opendialog->setDirectory(ROOTDIR);
    opendialog->sortItems();
    if (opendialog->execute())
    {
        cmd = opendialog->getText();
        if (cmd == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Handles "associate" checkbox for "open with..." dialog
                if (opendialog->getOption())
                {
                    FXString filename = current->list->getItemFilename(u);
                    FXString ext = filename.rafter('.', 2).lower();

                    if ((ext == "tar.gz") || (ext == "tar.bz2") || (ext == "tar.xz") || (ext == "tar.z")) // Special cases
                    {
                    }
                    else
                    {
                        ext = FXPath::extension(filename).lower();
                    }

                    if (ext == "")
                    {
                        ext = FXPath::name(filename);
                    }

                    FileAssoc* association = current->list->getItemAssoc(u);

                    if (association)
                    {
                        // Update existing association
                        FXString oldfileassoc = getApp()->reg().readStringEntry("FILETYPES", ext.text(), "");
                        oldfileassoc.erase(0, oldfileassoc.section(';', 0).section(',', 0).length());
                        oldfileassoc.prepend(opendialog->getText());
                        getApp()->reg().writeStringEntry("FILETYPES", ext.text(), oldfileassoc.text());

                        // Handle file association
                        str = new char* [2];
                        str[0] = new char[strlen(ext.text())+1];
                        str[1] = new char[strlen(oldfileassoc.text())+1];
                        strlcpy(str[0], ext.text(), ext.length()+1);
                        strlcpy(str[1], oldfileassoc.text(), oldfileassoc.length()+1);
                        mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ASSOC), str);
                    }
                    else
                    {
                        // New association
                        FXString newcmd = opendialog->getText().append(";Document;;;;");
                        getApp()->reg().writeStringEntry("FILETYPES", ext.text(), newcmd.text());

                        // Handle file association
                        str = new char* [2];
                        str[0] = new char[strlen(ext.text())+1];
                        str[1] = new char[strlen(newcmd.text())+1];
                        strlcpy(str[0], ext.text(), ext.length()+1);
                        strlcpy(str[1], newcmd.text(), newcmd.length()+1);
                        mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ASSOC), str);
                    }
                }
                // End

                FXString pathname = current->list->getItemPathname(u);
                cmdname = cmd;
                cmd += " ";
                cmd = cmd+::quote(pathname);
            }
        }

        // Run command if it exists
        getApp()->beginWaitCursor();

#ifdef STARTUP_NOTIFICATION
        // Startup notification option and exceptions (if any)
        FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
        FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

        // If command exists, run it
        if (::existCommand(cmdname))
#ifdef STARTUP_NOTIFICATION
        {
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
        }
#else
        {
            runcmd(cmd, current->list->getDirectory(), startlocation);
        }
#endif
        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
            return(1);
        }

        // Update history list
        OpenNum = opendialog->getHistorySize();
        cmd = opendialog->getText();

        // Check if cmd is a new string, i.e. is not already in history
        FXbool newstr = true;
        for (int i = 0; i < OpenNum-1; i++)
        {
            if (streq(OpenHistory[i], cmd.text()))
            {
                newstr = false;
                break;
            }
        }

        // History limit reached
        if (OpenNum > OPEN_HIST_SIZE)
        {
            OpenNum--;
        }

        // Restore original history order
        opendialog->clearItems();
        for (int i = 0; i < OpenNum; i++)
        {
            opendialog->appendItem(OpenHistory[i]);
		}

        // New string
        if (newstr)
        {
            // FIFO
            strlcpy(OpenHistory[0], cmd.text(), cmd.length()+1);
            for (int i = 1; i < OpenNum; i++)
            {
                strlcpy(OpenHistory[i], opendialog->getHistoryItem(i-1).text(), opendialog->getHistoryItem(i-1).length()+1);
            }
        }

        getApp()->endWaitCursor();
    }

    return(1);
}


long FilePanel::onCmdItemFilter(FXObject* o, FXSelector sel, void*)
{
    if (FilterNum == 0)
    {
        strlcpy(FilterHistory[FilterNum], "*", 2);
        FilterNum++;
    }

    int      i;
    FXString pat = list->getPattern();
    if (filterdialog == NULL)
    {
        filterdialog = new HistInputDialog(this, pat, _("Show files:"), _("Filter"), "", bigfiltericon, HIST_INPUT_FILE);
    }
    filterdialog->CursorEnd();
    filterdialog->selectAll();
    filterdialog->clearItems();
    for (int i = 0; i < FilterNum; i++)
    {
        filterdialog->appendItem(FilterHistory[i]);
    }
    filterdialog->sortItems();

    if (filterdialog->execute() && ((pat = filterdialog->getText()) != ""))
    {
        // Change file list patten
        if (FXSELID(sel) == ID_FILTER_CURRENT)
        {
            current->list->setPattern(pat);
        }
        else
        {
            list->setPattern(pat);
        }

        FXbool newstr = true;
        for (i = 0; i < FilterNum; i++)
        {
            if (streq(FilterHistory[i], pat.text()))
            {
                newstr = false;
                break;
            }
        }
        // Append new string to the list bottom
        if (newstr && (FilterNum < FILTER_HIST_SIZE))
        {
            strlcpy(FilterHistory[FilterNum], pat.text(), pat.length()+1);
            FilterNum++;
        }
    }

    list->setFocus();
    return(1);
}


// Panel context menu
long FilePanel::onCmdPopupMenu(FXObject* o, FXSelector s, void* p)
{
    // Make panel active
    setActive();

    // Check if control key or Shift-F10 or menu was pressed
    if (p != NULL)
    {
        FXEvent* event = (FXEvent*)p;
        if (event->state&CONTROLMASK)
        {
            ctrl = true;
        }
        if ((event->state&SHIFTMASK && event->code == KEY_F10) || event->code == KEY_Menu)
        {
            shiftf10 = true;
        }
    }

    // Use to select the item under cursor when right clicking
    // Only when Shift-F10 was not pressed
    if (!shiftf10 && (list->getNumSelectedItems() <= 1))
    {
        int    x, y;
        FXuint state;
        list->getCursorPosition(x, y, state);

        int item = list->getItemAt(x, y);

        if (list->getCurrentItem() >= 0)
        {
            list->deselectItem(list->getCurrentItem());
        }
        if (item >= 0)
        {
            list->setCurrentItem(item);
            list->selectItem(item);
        }
    }

    // If first item (i.e. the '..' item)
    if ((list->getNumSelectedItems() == 1) && list->isItemSelected(0))
    {
        ctrl = true;
    }

    // If control flag is set, deselect all items
    if (ctrl)
    {
        list->handle(o, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), p);
    }

    // Popup menu pane
    FXMenuPane* menu = new FXMenuPane(this);
    int         x, y;
    FXuint      state;
    getRoot()->getCursorPosition(x, y, state);

    int num, itm;
    num = current->list->getNumSelectedItems(&itm);

    // No selection or control flag set
    if ((num == 0) || current->ctrl)
    {
        // Menu items
        new FXMenuCommand(menu, _("New& file..."), NULL, current, FilePanel::ID_NEW_FILE);
        new FXMenuCommand(menu, _("New f&older..."), NULL, current, FilePanel::ID_NEW_DIR);
        new FXMenuCommand(menu, _("New s&ymlink..."), NULL, current, FilePanel::ID_NEW_SYMLINK);
        new FXMenuCommand(menu, _("Fi&lter..."), NULL, current, FilePanel::ID_FILTER);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(menu);
        new FXMenuCheck(menu, _("&Hidden files"), current->list, FileList::ID_TOGGLE_HIDDEN);
        new FXMenuCheck(menu, _("Thum&bnails"), current->list, FileList::ID_TOGGLE_THUMBNAILS);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("B&ig icons"), current->list, IconList::ID_SHOW_BIG_ICONS);
        new FXMenuRadio(menu, _("&Small icons"), current->list, IconList::ID_SHOW_MINI_ICONS);
        new FXMenuRadio(menu, _("&Full file list"), current->list, IconList::ID_SHOW_DETAILS);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("&Rows"), current->list, FileList::ID_ARRANGE_BY_ROWS);
        new FXMenuRadio(menu, _("&Columns"), current->list, FileList::ID_ARRANGE_BY_COLUMNS);
        new FXMenuCheck(menu, _("Autosize"), current->list, FileList::ID_AUTOSIZE);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("&Name"), current->list, FileList::ID_SORT_BY_NAME);
        new FXMenuRadio(menu, _("Si&ze"), current->list, FileList::ID_SORT_BY_SIZE);
        new FXMenuRadio(menu, _("&Type"), current->list, FileList::ID_SORT_BY_TYPE);
        new FXMenuRadio(menu, _("E&xtension"), current->list, FileList::ID_SORT_BY_EXT);
        new FXMenuRadio(menu, _("&Date"), current->list, FileList::ID_SORT_BY_TIME);
        new FXMenuRadio(menu, _("&User"), current->list, FileList::ID_SORT_BY_USER);
        new FXMenuRadio(menu, _("&Group"), current->list, FileList::ID_SORT_BY_GROUP);
        new FXMenuRadio(menu, _("Per&missions"), current->list, FileList::ID_SORT_BY_PERM);
        new FXMenuRadio(menu, _("Deletion date"), current->list, FileList::ID_SORT_BY_DELTIME);
        new FXMenuSeparator(menu);
        new FXMenuCheck(menu, _("Ignore c&ase"), current->list, FileList::ID_SORT_CASE);
        new FXMenuCheck(menu, _("Fold&ers first"), current->list, FileList::ID_DIRS_FIRST);
        new FXMenuCheck(menu, _("Re&verse order"), current->list, FileList::ID_SORT_REVERSE);
    }
    // Non empty selection
    else
    {
        // Deselect the '..' item
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        // Panel submenu items
        FXMenuPane* submenu = new FXMenuPane(this);
        new FXMenuCommand(submenu, _("Ne&w file..."), NULL, current, FilePanel::ID_NEW_FILE);
        new FXMenuCommand(submenu, _("New f&older..."), NULL, current, FilePanel::ID_NEW_DIR);
        new FXMenuCommand(submenu, _("New s&ymlink..."), NULL, current, FilePanel::ID_NEW_SYMLINK);
        new FXMenuCommand(submenu, _("Fi&lter..."), NULL, current, FilePanel::ID_FILTER);
        new FXMenuSeparator(submenu);
        new FXMenuCommand(submenu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(submenu);
        new FXMenuCheck(submenu, _("&Hidden files"), current->list, FileList::ID_TOGGLE_HIDDEN);
        new FXMenuCheck(submenu, _("Thum&bnails"), current->list, FileList::ID_TOGGLE_THUMBNAILS);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("B&ig icons"), current->list, IconList::ID_SHOW_BIG_ICONS);
        new FXMenuRadio(submenu, _("&Small icons"), current->list, IconList::ID_SHOW_MINI_ICONS);
        new FXMenuRadio(submenu, _("&Full file list"), current->list, IconList::ID_SHOW_DETAILS);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("&Rows"), current->list, FileList::ID_ARRANGE_BY_ROWS);
        new FXMenuRadio(submenu, _("&Columns"), current->list, FileList::ID_ARRANGE_BY_COLUMNS);
        new FXMenuCheck(submenu, _("Autosize"), current->list, FileList::ID_AUTOSIZE);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("&Name"), current->list, FileList::ID_SORT_BY_NAME);
        new FXMenuRadio(submenu, _("Si&ze"), current->list, FileList::ID_SORT_BY_SIZE);
        new FXMenuRadio(submenu, _("&Type"), current->list, FileList::ID_SORT_BY_TYPE);
        new FXMenuRadio(submenu, _("E&xtension"), current->list, FileList::ID_SORT_BY_EXT);
        new FXMenuRadio(submenu, _("&Date"), current->list, FileList::ID_SORT_BY_TIME);
        new FXMenuRadio(submenu, _("&User"), current->list, FileList::ID_SORT_BY_USER);
        new FXMenuRadio(submenu, _("&Group"), current->list, FileList::ID_SORT_BY_GROUP);
        new FXMenuRadio(submenu, _("Per&missions"), current->list, FileList::ID_SORT_BY_PERM);
        new FXMenuRadio(submenu, _("Deletion date"), current->list, FileList::ID_SORT_BY_DELTIME);
        new FXMenuSeparator(submenu);
        new FXMenuCheck(submenu, _("Ignore c&ase"), current->list, FileList::ID_SORT_CASE);
        new FXMenuCheck(submenu, _("Fold&ers first"), current->list, FileList::ID_DIRS_FIRST);
        new FXMenuCheck(submenu, _("Re&verse order"), current->list, FileList::ID_SORT_REVERSE);
        new FXMenuCascade(menu, _("Pane&l"), NULL, submenu);
        new FXMenuSeparator(menu);

#if defined(linux)
        FXString name = current->list->getItemPathname(itm);
        if ((num == 1) && (fsdevices->find(name.text()) || mtdevices->find(name.text())))
        {
            new FXMenuCommand(menu, _("&Mount"), NULL, current, FilePanel::ID_MOUNT);
            new FXMenuCommand(menu, _("Unmount"), NULL, current, FilePanel::ID_UMOUNT);
            new FXMenuSeparator(menu);
        }
#endif

        FXbool ar = false;
        if (current->list->getItem(itm) && current->list->isItemFile(itm))
        {
            new FXMenuCommand(menu, _("Open &with..."), NULL, current, FilePanel::ID_OPEN_WITH);
            new FXMenuCommand(menu, _("&Open"), NULL, current, FilePanel::ID_OPEN);
            FXString name = current->list->getItemText(itm).section('\t', 0);

            // Last and before last file extensions
            FXString ext1 = name.rafter('.', 1).lower();
            FXString ext2 = name.rafter('.', 2).lower();

            // Destination folder name
            FXString extract_to_folder;
            if ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z"))
            {
                extract_to_folder = _("Extr&act to folder ")+name.section('\t', 0).rbefore('.', 2);
            }
            else
            {
                extract_to_folder = _("Extr&act to folder ")+name.section('\t', 0).rbefore('.', 1);
            }

            // Display the extract and package menus according to the archive extensions
            if ((num == 1) && ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
                new FXMenuCommand(menu, extract_to_folder, NULL, current, FilePanel::ID_EXTRACT_TO_FOLDER);
                new FXMenuCommand(menu, _("E&xtract to..."), NULL, current, FilePanel::ID_EXTRACT);
            }
            else if ((num == 1) && ((ext1 == "gz") || (ext1 == "bz2") || (ext1 == "xz") || (ext1 == "z")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
            }
            else if ((num == 1) && ((ext1 == "tar") || (ext1 == "tgz") || (ext1 == "tbz2") || (ext1 == "tbz") || (ext1 == "taz") || (ext1 == "txz") || (ext1 == "zip") || (ext1 == "7z") || (ext1 == "lzh") || (ext1 == "rar") || (ext1 == "ace") || (ext1 == "arj")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
                new FXMenuCommand(menu, extract_to_folder, NULL, current, FilePanel::ID_EXTRACT_TO_FOLDER);
                new FXMenuCommand(menu, _("E&xtract to..."), NULL, current, FilePanel::ID_EXTRACT);
            }
#if defined(linux)
            else if ((num == 1) && ((ext1 == "rpm") || (ext1 == "deb")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&View"), NULL, current, FilePanel::ID_VIEW);
                new FXMenuCommand(menu, _("Install/Up&grade"), NULL, current, ID_PKG_INSTALL);
                new FXMenuCommand(menu, _("Un&install"), NULL, current, ID_PKG_UNINSTALL);
            }
#endif
            // Not archive nor package
            if (!ar)
            {
                new FXMenuCommand(menu, _("&View"), NULL, current, FilePanel::ID_VIEW);
                new FXMenuCommand(menu, _("&Edit"), NULL, current, FilePanel::ID_EDIT);
                if (num == 1)
                {
                    new FXMenuCommand(menu, _("Com&pare..."), NULL, current, FilePanel::ID_COMPARE);
                }
                else
                {
                    new FXMenuCommand(menu, _("Com&pare"), NULL, current, FilePanel::ID_COMPARE);
                }
            }
        }
        if (!ar)
        {
            new FXMenuCommand(menu, _("&Add to archive..."), NULL, current, FilePanel::ID_ADD_TO_ARCH);
        }
#if defined(linux)
        if ((num == 1) && !ar)
        {
            new FXMenuCommand(menu, _("Packages &query "), NULL, current, FilePanel::ID_PKG_QUERY);
        }
#endif

        // Build scripts menu
        new FXMenuSeparator(menu);
        FXString    scriptpath = homedir + PATHSEPSTRING CONFIGPATH PATHSEPSTRING XFECONFIGPATH PATHSEPSTRING SCRIPTPATH;
        FXMenuPane* scriptsmenu = new FXMenuPane(this);
        new FXMenuCascade(menu, _("Scripts"), NULL, scriptsmenu);
        readScriptDir(scriptsmenu, scriptpath);
        new FXMenuSeparator(scriptsmenu);
        new FXMenuCommand(scriptsmenu, _("&Go to script folder"), NULL, this, FilePanel::ID_GO_SCRIPTDIR);

        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("&Copy"), NULL, current, FilePanel::ID_COPY_CLIPBOARD);
        new FXMenuCommand(menu, _("C&ut"), NULL, current, FilePanel::ID_CUT_CLIPBOARD);
        new FXMenuCommand(menu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("Re&name..."), NULL, current, FilePanel::ID_FILE_RENAME);
        new FXMenuCommand(menu, _("Copy &to..."), NULL, current, FilePanel::ID_FILE_COPYTO);
        new FXMenuCommand(menu, _("&Move to..."), NULL, current, FilePanel::ID_FILE_MOVETO);
        new FXMenuCommand(menu, _("Symlin&k to..."), NULL, current, FilePanel::ID_FILE_SYMLINK);
        new FXMenuCommand(menu, _("M&ove to trash"), NULL, current, FilePanel::ID_FILE_TRASH);
        new FXMenuCommand(menu, _("Restore &from trash"), NULL, current, FilePanel::ID_FILE_RESTORE);
        new FXMenuCommand(menu, _("&Delete"), NULL, current, FilePanel::ID_FILE_DELETE);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("Compare &sizes"), NULL, current, FilePanel::ID_DIR_USAGE);
        new FXMenuCommand(menu, _("P&roperties"), NULL, current, FilePanel::ID_PROPERTIES);
    }
    menu->create();

    // Reset flags
    ctrl = false;
    shiftf10 = false;
    allowPopupScroll = true;  // Allow keyboard scrolling


    menu->popup(NULL, x, y);
    getApp()->runModalWhileShown(menu);
    allowPopupScroll = false;

    return(1);
}


// Read all executable file names that are located into the script directory
// Sort entries alphabetically, directories first
int FilePanel::readScriptDir(FXMenuPane* scriptsmenu, FXString dir)
{
    DIR* dp;
    struct dirent** namelist;

    // Open directory
    if ((dp = opendir(dir.text())) == NULL)
    {
        return(0);
    }

    // Eventually add a / at the end of the directory name
    if (dir[dir.length()-1] != '/')
    {
        dir = dir+"/";
    }

	// First, read only directory entries and sort them alphabetically
    int n;
    n = scandir(dir.text(), &namelist, NULL, alphasort);
    if (n < 0)
    {
        perror("scandir");
    }
    else
    {
        for (int k = 0; k < n; k++)
        {
            // Avoid hidden directories and '.' and '..'
            if (namelist[k]->d_name[0] != '.')
            {
                FXString pathname = dir + namelist[k]->d_name;

                // Recurse if non empty directory
                if (::isDirectory(pathname))
                {
                    if (!::isEmptyDir(pathname))
                    {
                        FXMenuPane* submenu = new FXMenuPane(this);
                        new FXMenuCascade(scriptsmenu, namelist[k]->d_name, NULL, submenu);
                        readScriptDir(submenu, pathname);
                    }
                }
            }
            free(namelist[k]);
        }
        free(namelist);
    }

	// Then, read only executable files and sort them alphabetically
    n = scandir(dir.text(), &namelist, NULL, alphasort);
    if (n < 0)
    {
        perror("scandir");
    }
    else
    {
        for (int k = 0; k < n; k++)
        {
			// Add only executable files to the list
			FXString pathname = dir + namelist[k]->d_name;
			if (!::isDirectory(pathname) && isReadExecutable(pathname))
			{
				new FXMenuCommand(scriptsmenu, namelist[k]->d_name + FXString("\t\t") + pathname, miniexecicon, this, FilePanel::ID_RUN_SCRIPT);
			}
            free(namelist[k]);
        }
        free(namelist);
    }

    // Close directory
    (void)closedir(dp);

    return(1);
}


// Run Terminal in the selected directory
long FilePanel::onCmdXTerm(FXObject*, FXSelector, void*)
{
    int ret;

    getApp()->beginWaitCursor();
    ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
        }

        return(0);
    }

    FXString cmd = getApp()->reg().readStringEntry("PROGS", "xterm", "xterm -sb");
    cmd += " &";
    ret = system(cmd.text());
    if (ret < 0)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Can't execute command %s"), cmd.text());
    }

    current->list->setFocus();
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }

        return(0);
    }

    getApp()->endWaitCursor();
    return(1);
}


// Add files or directory to an archive
long FilePanel::onCmdAddToArch(FXObject* o, FXSelector, void*)
{
    int      ret;
    FXString name, ext1, ext2, cmd, archive = "";
    File*    f;

    ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), list->getDirectory().text());
        }

        return(0);
    }

    // Eventually deselect the '..' directory
    if (current->list->isItemSelected(0))
    {
        current->list->deselectItem(0);
    }

    // Return if nothing is selected
    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    // If only one item is selected, use its name as a starting guess for the archive name
    if (current->list->getNumSelectedItems() == 1)
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                name = current->list->getItemFilename(u);
                break;
            }
        }
        archive = name;
    }

    // Initial archive name with full path and default extension
    FXString archpath = current->list->getDirectory();
    if (archpath == PATHSEPSTRING)
    {
        archive = archpath+archive+".tar.gz";
    }
    else
    {
        archive = archpath+PATHSEPSTRING+archive+".tar.gz";
    }

    // Archive dialog
    if (archdialog == NULL)
    {
        archdialog = new ArchInputDialog(this, "");
    }
    archdialog->setText(archive);
    archdialog->CursorEnd();

    if (archdialog->execute())
    {
        if (archdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

        // Get string and preserve escape characters
        archive = ::quote(archdialog->getText());

        // Get extensions of the archive name
        ext1 = archdialog->getText().rafter('.', 1).lower();
        ext2 = archdialog->getText().rafter('.', 2).lower();

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zcvf "+archive+" ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jcvf "+archive+" ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jcvf "+archive+" ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zcvf "+archive+" ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -cvf "+archive+" ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zcvf "+archive+" ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zcvf "+archive+" ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "xz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jcvf "+archive+" ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jcvf "+archive+" ";
        }
        else if (ext1 == "z")
        {
            cmd = "compress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "zip -r "+archive+" ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z a "+archive+" ";
        }

        // Default archive format
        else
        {
            archive += ".tar.gz";
            cmd = "tar -zcvf "+archive+" ";
        }

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Don't include '..' in the list
                name = current->list->getItemFilename(u);
                if (name != "..")
                {
                    cmd += " ";
                    cmd = cmd+::quote(name);
                    cmd += " ";
                }
            }
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Create archive"), ARCHIVE);
        f->create();

        // Create archive
        f->archive(archive, cmd);
        ret = chdir(startlocation.text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
            }

            return(0);
        }

        getApp()->endWaitCursor();
        delete f;

        // Force panel refresh
        onCmdRefresh(0, 0, 0);
    }
    return(1);
}


// Extract archive
long FilePanel::onCmdExtract(FXObject*, FXSelector, void*)
{
    FXString name, ext1, ext2, cmd, dir, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    // File selection dialog
    FileDialog  browse(this, _("Select a destination folder"));
    const char* patterns[] =
    {
        _("All Files"), "*", NULL
    };
    browse.setDirectory(homedir);
    browse.setPatternList(patterns);
    browse.setSelectMode(SELECT_FILE_DIRECTORY);

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        // Archive name and extensions
        name = current->list->getItemText(item).text();

        ext1 = name.section('\t', 0).rafter('.', 1).lower();
        ext2 = name.section('\t', 0).rafter('.', 2).lower();
        name = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jxvf ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -xvf ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gunzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bunzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "unxz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jxvf ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext1 == "z")
        {
            cmd = "uncompress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "unzip -o ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z x -y ";
        }
        else if (ext1 == "rar")
        {
            cmd = "unrar x -o+ ";
        }
        else if (ext1 == "lzh")
        {
            cmd = "lha -xf ";
        }
        else if (ext1 == "ace")
        {
            cmd = "unace x ";
        }
        else if (ext1 == "arj")
        {
            cmd = "arj x -y ";
        }
        else
        {
            cmd = "tar -zxvf ";
        }

        // Final extract command
        cmd += name+" ";


        // Extract archive
        if (browse.execute())
        {
            dir = browse.getFilename();

            if (isWritable(dir))
            {
                // Wait cursor
                getApp()->beginWaitCursor();

                // File object
                f = new File(this, _("Extract archive"), EXTRACT);
                f->create();

                // Extract archive
                f->extract(name, dir, cmd);

                getApp()->endWaitCursor();
                delete f;
            }
            else
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
            }
        }
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Extract archive to a folder name based on the archive name
long FilePanel::onCmdExtractToFolder(FXObject*, FXSelector, void*)
{
    FXString name, pathname, ext1, ext2, cmd, dirname, dirpath, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        // Archive name and extensions
        name = current->list->getItemText(item).text();
        ext1 = name.section('\t', 0).rafter('.', 1).lower();
        ext2 = name.section('\t', 0).rafter('.', 2).lower();

        // Destination folder name
        if ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z"))
        {
            dirname = name.section('\t', 0).rbefore('.', 2);
        }
        else
        {
            dirname = name.section('\t', 0).rbefore('.', 1);
        }

        // Create the new dir according to the current umask
        // Don't complain if directory already exists
        int mask = umask(0);
        umask(mask);
        dirpath = cdir + PATHSEPSTRING + dirname;
        errno = 0;
        int ret = ::mkdir(dirpath.text(), 511 & ~mask);
        int errcode = errno;
        if ((ret == -1) && (errcode != EEXIST))
        {
            if (errcode)
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s: %s"), dirpath.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s"), dirpath.text());
            }
            return(0);
        }

        // Archive pathname
        pathname = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jxvf ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -xvf ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gunzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bunzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "unxz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jxvf ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext1 == "z")
        {
            cmd = "uncompress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "unzip -o ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z x -y ";
        }
        else if (ext1 == "rar")
        {
            cmd = "unrar x -o+ ";
        }
        else if (ext1 == "lzh")
        {
            cmd = "lha -xf ";
        }
        else if (ext1 == "ace")
        {
            cmd = "unace x ";
        }
        else if (ext1 == "arj")
        {
            cmd = "arj x -y ";
        }
        else
        {
            cmd = "tar -zxvf ";
        }

        // Final extract command
        cmd += pathname+" ";

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Extract archive"), EXTRACT);
        f->create();

        // Extract archive
        f->extract(pathname, dirpath, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Extract archive in the current directory
long FilePanel::onCmdExtractHere(FXObject*, FXSelector, void*)
{
    FXString name, ext1, ext2, cmd, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        if (isWritable(cdir))
        {
            // Archive name and extensions
            name = current->list->getItemText(item).text();
            ext1 = name.section('\t', 0).rafter('.', 1);
            lower();
            ext2 = name.section('\t', 0).rafter('.', 2).lower();
            name = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

            // Handle different archive formats
            if (ext2 == "tar.gz")
            {
                cmd = "tar -zxvf ";
            }
            else if (ext2 == "tar.bz2")
            {
                cmd = "tar -jxvf ";
            }
            else if (ext2 == "tar.xz")
            {
                cmd = "tar -Jxvf ";
            }
            else if (ext2 == "tar.z")
            {
                cmd = "tar -Zxvf ";
            }
            else if (ext1 == "tar")
            {
                cmd = "tar -xvf ";
            }
            else if (ext1 == "gz")
            {
                cmd = "gunzip -v ";
            }
            else if (ext1 == "tgz")
            {
                cmd = "tar -zxvf ";
            }
            else if (ext1 == "taz")
            {
                cmd = "tar -Zxvf ";
            }
            else if (ext1 == "bz2")
            {
                cmd = "bunzip2 -v ";
            }
            else if (ext1 == "xz")
            {
                cmd = "unxz -v ";
            }
            else if ((ext1 == "tbz2") || (ext1 == "tbz"))
            {
                cmd = "tar -jxvf ";
            }
            else if (ext1 == "txz")
            {
                cmd = "tar -Jxvf ";
            }
            else if (ext1 == "z")
            {
                cmd = "uncompress -v ";
            }
            else if (ext1 == "zip")
            {
                cmd = "unzip -o ";
            }
            else if (ext1 == "7z")
            {
                cmd = "7z x -y ";
            }
            else if (ext1 == "rar")
            {
                cmd = "unrar x -o+ ";
            }
            else if (ext1 == "lzh")
            {
                cmd = "lha -xf ";
            }
            else if (ext1 == "ace")
            {
                cmd = "unace x ";
            }
            else if (ext1 == "arj")
            {
                cmd = "arj x -y ";
            }
            else
            {
                cmd = "tar -zxvf ";
            }

            // Final extract command
            cmd += name+" ";

            // Wait cursor
            getApp()->beginWaitCursor();

            // File object
            f = new File(this, _("Extract archive"), EXTRACT);
            f->create();

            // Extract archive
            f->extract(name, cdir, cmd);

            getApp()->endWaitCursor();
            delete f;
        }
        else
        {
            MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), cdir.text());
        }
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


#if defined(linux)
// Install/Upgrade package
long FilePanel::onCmdPkgInstall(FXObject*, FXSelector, void*)
{
    FXString name, path, cmd, dir, cdir;
    File*    f;

    cdir = current->list->getDirectory();

    int itm;
    current->list->getNumSelectedItems(&itm);
    if (current->list->getItem(itm))
    {
        name = current->list->getItemText(itm).text();
        name = name.section('\t', 0);
        path = ::quote(cdir + PATHSEPSTRING + name);

        // Command to perform
        FXString ext = FXPath::extension(name);
        if (comparecase(ext, "rpm") == 0)
        {
            cmd = "rpm -Uvh " + path;
        }
        else if (comparecase(ext, "deb") == 0)
        {
            cmd = "dpkg -i "+ path;
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Package Install/Upgrade"), PKG_INSTALL);
        f->create();

        // Install/Upgrade package
        f->pkgInstall(name, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Uninstall package based on its name (package version is ignored)
long FilePanel::onCmdPkgUninstall(FXObject*, FXSelector, void*)
{
    FXString name, cmd, dir, cdir;
    File*    f;

    cdir = current->list->getDirectory();

    int itm;
    current->list->getNumSelectedItems(&itm);
    if (current->list->getItem(itm))
    {
        name = current->list->getItemText(itm).text();
        name = name.section('\t', 0);

        // Command to perform
        FXString ext = FXPath::extension(name);
        if (comparecase(ext, "rpm") == 0)
        {
            name = name.section('-', 0);
            cmd = "rpm -e " + name;
        }
        else if (comparecase(ext, "deb") == 0)
        {
            name = name.section('_', 0);
            cmd = "dpkg -r "+ name;
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Package Uninstall"), PKG_UNINSTALL);
        f->create();

        // Uninstall package
        f->pkgUninstall(name, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


#endif


// Force FilePanel and DirPanel refresh
long FilePanel::onCmdRefresh(FXObject*, FXSelector, void*)
{
    // Refresh panel
    FXString dir = list->getDirectory();
    list->setDirectory(ROOTDIR, false);
    list->setDirectory(dir, false);
    updatePath();
	
	// Focus on current panel
	current-> list->setFocus();

    return(1);
}


// Handle item selection
long FilePanel::onCmdSelect(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setFocus();
    switch (FXSELID(sel))
    {
    case ID_SELECT_ALL:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SELECT_ALL), ptr);
        return(1);

    case ID_DESELECT_ALL:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), ptr);
        return(1);

    case ID_SELECT_INVERSE:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SELECT_INVERSE), ptr);
        return(1);
    }
    return(1);
}


// Handle show commands
long FilePanel::onCmdShow(FXObject* sender, FXSelector sel, void* ptr)
{
    switch (FXSELID(sel))
    {
    case ID_SHOW_BIG_ICONS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_BIG_ICONS), ptr);
        break;

    case ID_SHOW_MINI_ICONS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_MINI_ICONS), ptr);
        break;

    case ID_SHOW_DETAILS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_DETAILS), ptr);
        break;
    }

    // Set focus on current panel list
    current->list->setFocus();

    return(1);
}


// Update show commands
long FilePanel::onUpdShow(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXuint style = current->list->getListStyle();

    switch (FXSELID(sel))
    {
    case ID_SHOW_BIG_ICONS:
        if (style & _ICONLIST_BIG_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_MINI_ICONS:
        if (style & _ICONLIST_MINI_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_DETAILS:
        if (!(style & (_ICONLIST_MINI_ICONS | _ICONLIST_BIG_ICONS)))
        {
            msg = FXWindow::ID_CHECK;
        }
        break;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);

    return(1);
}


// Handle toggle hidden command
long FilePanel::onCmdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_HIDDEN), ptr);
    return(1);
}


// Update toggle hidden command
long FilePanel::onUpdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXbool hidden = current->list->shownHiddenFiles();

    if (hidden == false)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);
    return(1);
}


// Handle toggle thumbnails command
long FilePanel::onCmdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_THUMBNAILS), ptr);
    return(1);
}


// Update toggle hidden command
long FilePanel::onUpdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXbool showthumb = current->list->shownThumbnails();

    if (showthumb == false)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);
    return(1);
}


// Run script
long FilePanel::onCmdRunScript(FXObject* o, FXSelector sel, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString pathname, cmd, itemslist = " ";
    FXString scriptpath = dynamic_cast<FXMenuCommand*>(o)->getHelpText();

    // Construct selected files list
    current->list->setFocus();
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            pathname = current->list->getItemPathname(u);

            // List of selected items
            itemslist += ::quote(pathname) + " ";
        }
    }

    // Construct command line
    cmd = ::quote(scriptpath) + itemslist + " &";

    // Go to the current directory
    int ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
        }
    }

    // Execute command
    static pid_t child_pid = 0;
    switch ((child_pid = fork()))
    {
    case -1:
        fprintf(stderr, _("Error: Fork failed: %s\n"), strerror(errno));
        break;

    case 0:
        execl("/bin/sh", "sh", "-c", cmd.text(), (char*)NULL);
        _exit(EXIT_SUCCESS);
        break;
    }

    // Return to the starting directory
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Go to scripts directory
long FilePanel::onCmdGoScriptDir(FXObject* o, FXSelector sel, void*)
{
    FXString scriptpath = homedir + PATHSEPSTRING CONFIGPATH PATHSEPSTRING XFECONFIGPATH PATHSEPSTRING SCRIPTPATH;

    if (!::exists(scriptpath))
    {
        // Create the script directory according to the umask
        int mask = umask(0);
        umask(mask);
        errno = 0;
        int ret = mkpath(scriptpath.text(), 511 & ~mask);
        int errcode = errno;
        if (ret == -1)
        {
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create script folder %s: %s"), scriptpath.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create script folder %s"), scriptpath.text());
            }

            return(0);
        }
    }

    // Go to scripts directory
    current->list->setDirectory(scriptpath);
    current->list->setFocus();
    dirpanel->setDirectory(scriptpath, true);
    current->updatePath();
    updateLocation();

    return(1);
}


#if defined(linux)
// Mount/Unmount file systems
long FilePanel::onCmdMount(FXObject*, FXSelector sel, void*)
{
    int      ret;
    FXString cmd, msg, text;
    FXuint   op;
    File*    f;
    FXString dir;

    current->list->setFocus();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (current->list->getNumSelectedItems() == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    // If symbolic link, read the linked directory
    if (::isLink(dir))
    {
        dir = ::readLink(dir);
    }

    if (FXSELID(sel) == ID_MOUNT)
    {
        op = MOUNT;
        msg = _("Mount");
		cmd = getApp()->reg().readStringEntry("PROGS", "mount", DEFAULT_MOUNTCMD) + FXString(" ");
    }
    else
    {
        op = UNMOUNT;
        msg = _("Unmount");
	    cmd = getApp()->reg().readStringEntry("PROGS", "unmount", DEFAULT_UMOUNTCMD) + FXString(" ");
    }
    cmd += ::quote(dir);
    cmd += " 2>&1";
    ret = chdir(ROOTDIR);
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), ROOTDIR, strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), ROOTDIR);
        }

        return(0);
    }

    // Wait cursor
    getApp()->beginWaitCursor();

    // File object
    text = msg + _(" file system...");
    f = new File(this, text.text(), op);
    f->create();

    // Mount/unmount file system
    text = msg + _(" the folder:");
    f->mount(dir, text, cmd, op);
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }

        return(0);
    }

    // If action is cancelled in progress dialog
    if (f->isCancelled())
    {
        f->hide();
        text = msg + _(" operation cancelled!");
        MessageBox::error(this, BOX_OK, _("Warning"), "%s", text.text());
        delete f;
        return(0);
    }

    getApp()->endWaitCursor();
    delete f;

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Update the Mount button
long FilePanel::onUpdMount(FXObject* o, FXSelector sel, void*)
{
    FXString dir;

    int num = current->list->getNumSelectedItems();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (num == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    if (fsdevices->find(dir.text()) && !mtdevices->find(dir.text()) && current->list->getNumItems() && !current->list->isItemSelected(0))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update the Unmount button
long FilePanel::onUpdUnmount(FXObject* o, FXSelector sel, void*)
{
    FXString dir;

    int num = current->list->getNumSelectedItems();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (num == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    if ((fsdevices->find(dir.text()) || mtdevices->find(dir.text())) && current->list->getNumItems() && !current->list->isItemSelected(0))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Query packages data base
long FilePanel::onCmdPkgQuery(FXObject* o, FXSelector sel, void*)
{
    FXString cmd;

    // Name of the current selected file
    FXString file = current->list->getCurrentFile();

    // Command to perform
    if (pkg_format == DEB_PKG)
    {
        cmd = "dpkg -S " + ::quote(file);
    }
    else if (pkg_format == RPM_PKG)
    {
        cmd = "rpm -qf " + ::quote(file);
    }
    else
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("No compatible package manager (rpm or dpkg) found!"));
        return(0);
    }

    // Query command
    cmd += " 2>&1";

    // Wait cursor
    getApp()->beginWaitCursor();

    // Perform the command
    FILE* pcmd = popen(cmd.text(), "r");
    if (!pcmd)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Failed command: %s"), cmd.text());
        return(0);
    }

    // Get command output
    char     text[10000] = { 0 };
    FXString buf;
    while (fgets(text, sizeof(text), pcmd))
    {
        buf += text;
    }
    snprintf(text, sizeof(text)-1, "%s", buf.text());

    // Close the stream and display error message if any
    if ((pclose(pcmd) == -1) && (errno != ECHILD))   // ECHILD can be set if the child was caught by sigHarvest
    {
        getApp()->endWaitCursor();
        MessageBox::error(this, BOX_OK, _("Error"), "%s", text);
        return(0);
    }
    getApp()->endWaitCursor();

    // Get package name, or detect when the file isn't in a package
    FXString str = text;
    if (pkg_format == DEB_PKG)  // DEB based distribution
    {
        int idx = str.find(" ");               // Split output at first whitespace
        FXString pkgname = str.left(idx-1);    // Remove trailing colon
        FXString fname = str.right(str.length()-idx);
        fname.trim();                          // Remove leading space and trailing newline
        if (streq(fname.text(), file.text()))  // No other word than the file name
        {
            str = pkgname.text();
        }
        else
        {
            str = "";
        }
    }
    if (pkg_format == RPM_PKG)   // RPM based distribution
    {
        if (str.find(' ') != -1) // Space character exists in the string
        {
            str = "";
        }
    }

    // Display the related output message
    FXString message;
    if (str == "")
    {
        message.format(_("File %s does not belong to any package."), file.text());
        MessageBox::information(this, BOX_OK, _("Information"), "%s", message.text());
    }
    else
    {
        message.format(_("File %s belongs to the package: %s"), file.text(), str.text());
        MessageBox::information(this, BOX_OK, _("Information"), "%s", message.text());
    }

    return(1);
}


// Update the package query menu
long FilePanel::onUpdPkgQuery(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing is selected or multiple selection
    // or when unique selection and the selected item is a directory

    int num;

    num = current->list->getNumSelectedItems();

    if ((num == 0) || (num > 1))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else // num=1
    {
        int item = current->list->getCurrentItem();
        if ((item >= 0) && current->list->isItemDirectory(item))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }

    return(1);
}


#endif // End #if defined(linux)


// Directory usage on file selection
long FilePanel::onCmdDirUsage(FXObject* o, FXSelector, void*)
{
	FXString name, command, itemslist = " ";
	FXString cmd1 = "/usr/bin/du --apparent-size -k -s ";
	FXString cmd2 = " 2> /dev/null | /usr/bin/sort -rn | /usr/bin/cut -f2 | /usr/bin/xargs -d '\n' /usr/bin/du --apparent-size --total --si -s 2> /dev/null";

    // Enter current directory
    int ret=chdir(current->getDirectory().text());
    if (ret < 0)
    {
        int errcode=errno;
        if (errcode)
        {
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s: %s"),current->getDirectory().text(),strerror(errcode));
		}
        else
        {
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s"),current->getDirectory().text());
		}

        return 0;
    }

    // Eventually deselect the '..' directory
    if (current->list->isItemSelected(0))
    {
        current->list->deselectItem(0);
    }

    // Return if nothing is selected
    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    // Construct selected files list
    current->list->setFocus();
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
 			name = current->list->getItemFilename(u);

            // List of selected items
            itemslist += ::quote(name) + " ";
        }
    }

	// Command to be executed
	command = cmd1 + itemslist + cmd2;

	// Make and show command window
	CommandWindow* cmdwin=new CommandWindow(getApp(),_("Sizes of Selected Object(s)"),command,25,50);
	cmdwin->create();
	cmdwin->setIcon(charticon);

	// The CommandWindow object will delete itself when closed!

	// Return to start location
	ret = chdir(startlocation.text());
	if (ret < 0)
	{
		int errcode = errno;
		if (errcode)
		{
			MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
		}
		else
		{
			MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
		}
	}

    return(1);
}


// Update the status bar and the path linker
long FilePanel::onUpdStatus(FXObject* sender, FXSelector, void*)
{
    // Update the status bar
    int      item = -1;
    FXString str, linkto;
    char     usize[64];
    FXulong  size = 0;
    FXString hsize = _("0 bytes");

    FXString path = list->getDirectory();

    int num = list->getNumSelectedItems();

    // To handle the update rename (ugly, I know)
    if (current == this)
    {
        if (num <= 1)
        {
            selmult = false;
        }
        else if (num > 1)
        {
            selmult = true;
        }
    }

    item = list->getCurrentItem();

    if (num > 1)
    {
		int nbdirs = 0;
        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u) && !list->isItemDirectory(u))
            {
                size += list->getItemFileSize(u);
#if __WORDSIZE == 64
                snprintf(usize, sizeof(usize)-1, "%lu", size);
#else
                snprintf(usize, sizeof(usize)-1, "%llu", size);
#endif
                hsize = ::hSize(usize);
            }
            
            if (list->isItemDirectory(u))
            {
				nbdirs++;
			}
        }
        
        // Don't count the '..' directory
        if (nbdirs >= 1)
        {
			nbdirs--;
		}
		
		int nbfiles = num - nbdirs;
        if (nbdirs <= 1 && nbfiles <= 1)
        {
	        str.format(_("%s in %s selected object(s) (%s folder, %s file)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
        else if (nbdirs <=1 && nbfiles > 1)
        {
	        str.format(_("%s in %s selected object(s) (%s folder, %s files)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
        else if (nbdirs > 1 && nbfiles <= 1)
        {
	        str.format(_("%s in %s selected object(s) (%s folders, %s file)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
		else
		{
	        str.format(_("%s in %s selected object(s) (%s folders, %s files)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
    }
    else
    {
        // Nothing selected
        if ((num == 0) || (item < 0))
        {
            num = list->getNumItems();
            if (num == 1)
            {
                str = _("1 object(s) (1 folder)");
            }
            else
            {
				int nbdirs = 0;
				for (int u = 0; u < num; u++)
				{
					if (list->isItemDirectory(u))
					{
						nbdirs++;
					}
				}       

				int nbfiles = num - nbdirs;
		        str.format(_("%s object(s) (%s folders, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());
				if (nbdirs <= 1 && nbfiles <= 1)
				{
					str.format(_("%s object(s) (%s folder, %s file)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else if (nbdirs <=1 && nbfiles > 1)
				{
					str.format(_("%s object(s) (%s folder, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else if (nbdirs > 1 && nbfiles <= 1)
				{
					str.format(_("%s object(s) (%s folders, %s file)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else
				{
					str.format(_("%s object(s) (%s folders, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
            }
        }
        else
        {
            FXString string = list->getItemText(item);
            FXString name = string.section('\t', 0);
            FXString type = string.section('\t', 2);

            FXString date = string.section('\t', 4);
            FXString usr = string.section('\t', 5);
            FXString grp = string.section('\t', 6);
            FXString perm = string.section('\t', 7);

            if (type.contains(_("Broken link")))
            {
                linkto = ::readLink(path+PATHSEPSTRING+name);
                str = name + "->" + linkto.text() + " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
            else if (type.contains(_("Link")))
            {
                linkto = ::readLink(path+PATHSEPSTRING+name);
                str = name + "->" + linkto.text() + " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
            else
            {
                for (int u = 0; u < list->getNumItems(); u++)
                {
                    if (list->isItemSelected(u) && !list->isItemDirectory(u))
                    {
                        size = list->getItemFileSize(u);
#if __WORDSIZE == 64
                        snprintf(usize, sizeof(usize)-1, "%lu", size);
#else
                        snprintf(usize, sizeof(usize)-1, "%llu", size);
#endif
                        hsize = ::hSize(usize);
                        break;
                    }
                }
                str = hsize+ " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
        }
    }

    statuslabel->setText(str);

    // Add the filter pattern if any
    if ((list->getPattern() != "*") && (list->getPattern() != "*.*"))
    {
        str.format(_(" - Filter: %s"), list->getPattern().text());
        filterlabel->setText(str);
        filterlabel->setTextColor(attenclr);
    }
    else
    {
        filterlabel->setText("");
    }

    return(1);
}


// Update the path text and the path link
void FilePanel::updatePath()
{
    // pathlink->setPath(list->getDirectory());
    // pathtext->setText(list->getDirectory());
}


// Update the go to parent directory command
long FilePanel::onUpdUp(FXObject* o, FXSelector, void*)
{
    FXButton* button = (FXButton*)o;
    int       style = button->getButtonStyle();

    if (style & TOGGLEBUTTON_TOOLBAR)
    {
        if (current->list->getDirectory() != ROOTDIR)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update the paste button
long FilePanel::onUpdPaste(FXObject* o, FXSelector, void*)
{
    FXuchar* data;
    FXuint   len;
    FXString buf;
    FXbool   clipboard_empty = true;

    // Lock clipboard to prevent changes in method onCmdRequestClipboard()
    clipboard_locked = true;

    // If source is xfelistType (Gnome, XFCE, or Xfe app)
    if (getDNDData(FROM_CLIPBOARD, xfelistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        buf = (char*)data;

        // Check if valid clipboard
        if (buf.find("file:/") >= 0)
        {
            clipboard_empty = false;
        }

        // Free data pointer
        FXFREE(&data);
    }

    // If source type is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    else if (getDNDData(FROM_CLIPBOARD, urilistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        buf = (char*)data;

        // Check if valid clipboard
        if (buf.find("file:/") >= 0)
        {
            clipboard_empty = false;
        }

        // Free data pointer
        FXFREE(&data);
    }

    // Gray out the paste button, if necessary
    if (clipboard_empty)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }

    // Unlock clipboard
    clipboard_locked = false;

    return(1);
}


// Update menu items and toolbar buttons that are related to file operations
long FilePanel::onUpdMenu(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing or only ".." is selected
    int num;

    num = current->list->getNumSelectedItems();
    DirItem* item = (DirItem*)dirpanel->getCurrentItem();

    if ((dirpanel->shown() && item))
    {
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }

    return(1);
}


// Update file delete menu item and toolbar button
long FilePanel::onUpdFileDelete(FXObject* o, FXSelector sel, void*)
{
    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    FXbool use_trash_bypass = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_bypass", false);

    if ( (!use_trash_can) | use_trash_bypass)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update move to trash menu item and toolbar button
long FilePanel::onUpdFileTrash(FXObject* o, FXSelector sel, void*)
{
    // Disable move to trash menu if we are in trash can
    // or if the trash can directory is selected

    FXbool   trashenable = true;
    FXString trashparentdir = trashlocation.rbefore('/');
    FXString curdir = current->list->getDirectory();

    if (curdir.left(trashlocation.length()) == trashlocation)
    {
        trashenable = false;
    }

    if (curdir == trashparentdir)
    {
        FXString pathname;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                if (pathname == trashlocation)
                {
                    trashenable = false;
                }
            }
        }
    }

    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    if (use_trash_can && trashenable)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update restore from trash menu item and toolbar button
long FilePanel::onUpdFileRestore(FXObject* o, FXSelector sel, void*)
{
    // Enable restore from trash menu if we are in trash can

    FXbool   restoreenable = false;
    FXString curdir = current->list->getDirectory();

    if (curdir.left(trashfileslocation.length()) == trashfileslocation)
    {
        restoreenable = true;
    }

    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    if (use_trash_can && restoreenable)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update go trash menu item and toolbar button
long FilePanel::onUpdGoTrash(FXObject* o, FXSelector sel, void*)
{
    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);

    if (use_trash_can)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update file open menu
long FilePanel::onUpdOpen(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or a directory (including "..") is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);

    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        if (current->list->getItem(item) && current->list->isItemFile(item))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
    }
    return(1);
}


// Update the status of the menu items that should be disabled when selecting multiple files
long FilePanel::onUpdSelMult(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing is selected or multiple selection or ".." is only selected
    int num;

    num = current->list->getNumSelectedItems();
    DirItem* item = (DirItem*)dirpanel->getCurrentItem();

    if (num == 0)
    {
        if (!item || !dirpanel->shown())
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else if (current->selmult || ((num == 1) && current->list->isItemSelected(0)))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }

    return(1);
}


// Update the file compare menu item
long FilePanel::onUpdCompare(FXObject* o, FXSelector sel, void*)
{
    // Menu item is enabled only when two files are selected
    int num;

    num = current->list->getNumSelectedItems();

    if ((num == 1) || (num == 2))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update Add to archive menu
long FilePanel::onUpdAddToArch(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or ".." is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else if ((num == 1) && current->list->isItemSelected(0))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update scripts menu item
long FilePanel::onUpdRunScript(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or ".." is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update directory usage menu item
long FilePanel::onUpdDirUsage(FXObject* o, FXSelector, void*)
{
    // Menu item is enabled only when at least two items are selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num > 1)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    return(1);
}
#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/time.h>

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "startupnotification.h"
#include "FileDialog.h"
#include "FileList.h"
#include "Properties.h"
#include "XFileExplorer.h"
#include "InputDialog.h"
#include "BrowseInputDialog.h"
#include "ArchInputDialog.h"
#include "HistInputDialog.h"
#include "File.h"
#include "MessageBox.h"
#include "OverwriteBox.h"
#include "CommandWindow.h"
#include "ExecuteBox.h"
#include "PathLinker.h"
#include "FilePanel.h"
#include <string>
#include <iostream>

// Duration (in ms) before we can stop refreshing the file list
// Used for file operations on a large list of files
#define STOP_LIST_REFRESH_INTERVAL    5000

// Number of files before stopping the file list refresh
#define STOP_LIST_REFRESH_NBMAX       100


// Clipboard notes :
// The uri-list type used for Xfe is the same as the Gnome uri-list type
// The standard uri-list type is used for KDE and non Gnome / XFCE file managers
// A special uri-list type that containd only "0" (for copy) or "1" (for cut) is used for KDE compatibility


// Global Variables
extern FXMainWindow* mainWindow;
extern FXString      homedir;
extern FXString      xdgdatahome;

// Clipboard
extern FXString clipboard;
FXuint          clipboard_type = 0;


extern char OpenHistory[OPEN_HIST_SIZE][MAX_COMMAND_SIZE];
extern int  OpenNum;
extern char FilterHistory[FILTER_HIST_SIZE][MAX_PATTERN_SIZE];
extern int  FilterNum;
#if defined(linux)
extern FXStringDict* fsdevices;
extern FXStringDict* mtdevices;
extern FXbool        pkg_format;
#endif

extern FXbool allowPopupScroll;
extern FXuint single_click;


// Map
FXDEFMAP(FilePanel) FilePanelMap[] =
{
    FXMAPFUNC(SEL_CLIPBOARD_LOST, 0, FilePanel::onClipboardLost),
    FXMAPFUNC(SEL_CLIPBOARD_GAINED, 0, FilePanel::onClipboardGained),
    FXMAPFUNC(SEL_CLIPBOARD_REQUEST, 0, FilePanel::onClipboardRequest),
    FXMAPFUNC(SEL_TIMEOUT, FilePanel::ID_STOP_LIST_REFRESH_TIMER, FilePanel::onCmdStopListRefreshTimer),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DIRECTORY_UP, FilePanel::onCmdDirectoryUp),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILTER, FilePanel::onCmdItemFilter),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILTER_CURRENT, FilePanel::onCmdItemFilter),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_HOME, FilePanel::onCmdGoHome),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_TRASH, FilePanel::onCmdGoTrash),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_VIEW, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_MIDDLEBUTTONPRESS, FilePanel::ID_FILELIST, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EDIT, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_COMPARE, FilePanel::onCmdCompare),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PROPERTIES, FilePanel::onCmdProperties),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_XTERM, FilePanel::onCmdXTerm),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_DIR, FilePanel::onCmdNewDir),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_FILE, FilePanel::onCmdNewFile),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_SYMLINK, FilePanel::onCmdNewSymlink),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_COPY, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_CUT, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_COPYTO, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_MOVETO, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_RENAME, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_SYMLINK, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_COPY_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_CUT_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADDCOPY_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADDCUT_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PASTE_CLIPBOARD, FilePanel::onCmdPaste),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_TRASH, FilePanel::onCmdFileTrash),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_RESTORE, FilePanel::onCmdFileRestore),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_DELETE, FilePanel::onCmdFileDelete),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_OPEN_WITH, FilePanel::onCmdOpenWith),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_OPEN, FilePanel::onCmdOpen),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_REFRESH, FilePanel::onCmdRefresh),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_BIG_ICONS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_MINI_ICONS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_DETAILS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_TOGGLE_HIDDEN, FilePanel::onCmdToggleHidden),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_TOGGLE_THUMBNAILS, FilePanel::onCmdToggleThumbnails),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SELECT_ALL, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DESELECT_ALL, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SELECT_INVERSE, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADD_TO_ARCH, FilePanel::onCmdAddToArch),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT, FilePanel::onCmdExtract),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT_TO_FOLDER, FilePanel::onCmdExtractToFolder),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT_HERE, FilePanel::onCmdExtractHere),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_RUN_SCRIPT, FilePanel::onCmdRunScript),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_RUN_SCRIPT, FilePanel::onUpdRunScript),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_SCRIPTDIR, FilePanel::onCmdGoScriptDir),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DIR_USAGE, FilePanel::onCmdDirUsage),
    FXMAPFUNC(SEL_RIGHTBUTTONRELEASE, FilePanel::ID_FILELIST, FilePanel::onCmdPopupMenu),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_POPUP_MENU, FilePanel::onCmdPopupMenu),
    FXMAPFUNC(SEL_DOUBLECLICKED, FilePanel::ID_FILELIST, FilePanel::onCmdItemDoubleClicked),
    FXMAPFUNC(SEL_CLICKED, FilePanel::ID_FILELIST, FilePanel::onCmdItemClicked),
    FXMAPFUNC(SEL_FOCUSIN, FilePanel::ID_FILELIST, FilePanel::onCmdFocus),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_STATUS, FilePanel::onUpdStatus),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_DIRECTORY_UP, FilePanel::onUpdUp),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_COPY_CLIPBOARD, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_CUT_CLIPBOARD, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PASTE_CLIPBOARD, FilePanel::onUpdPaste),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PROPERTIES, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_TRASH, FilePanel::onUpdFileTrash),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_RESTORE, FilePanel::onUpdFileRestore),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_GO_TRASH, FilePanel::onUpdGoTrash),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_DELETE, FilePanel::onUpdFileDelete),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_MOVETO, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_COPYTO, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_RENAME, FilePanel::onUpdSelMult),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_COMPARE, FilePanel::onUpdCompare),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_EDIT, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_VIEW, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_OPEN, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_ADD_TO_ARCH, FilePanel::onUpdAddToArch),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_BIG_ICONS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_MINI_ICONS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_DETAILS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_TOGGLE_HIDDEN, FilePanel::onUpdToggleHidden),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_TOGGLE_THUMBNAILS, FilePanel::onUpdToggleThumbnails),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_DIR_USAGE, FilePanel::onUpdDirUsage),
#if defined(linux)
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_MOUNT, FilePanel::onCmdMount),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_UMOUNT, FilePanel::onCmdMount),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_MOUNT, FilePanel::onUpdMount),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_UMOUNT, FilePanel::onUpdUnmount),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_QUERY, FilePanel::onCmdPkgQuery),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_INSTALL, FilePanel::onCmdPkgInstall),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_UNINSTALL, FilePanel::onCmdPkgUninstall),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PKG_QUERY, FilePanel::onUpdPkgQuery),
#endif
};

// Object implementation
FXIMPLEMENT(FilePanel, FXVerticalFrame, FilePanelMap, ARRAYNUMBER(FilePanelMap))

// Construct File Panel
FilePanel::FilePanel(FXWindow* owner, const char* nm, FXComposite* p, DirPanel* dp, FXuint name_size, FXuint size_size, FXuint type_size, FXuint ext_size,
                     FXuint modd_size, FXuint user_size, FXuint grou_size, FXuint attr_size, FXuint deldate_size, FXuint origpath_size, FXbool showthumbs, FXColor listbackcolor, FXColor listforecolor,
                     FXColor attentioncolor, FXbool smoothscroll, FXuint opts, int x, int y, int w, int h) :
    FXVerticalFrame(p, opts, x, y, w, h, 0, 0, 0, 0)
{
    name = nm;
    dirpanel = dp;
    attenclr = attentioncolor;

    // Global container
    FXVerticalFrame* cont = new FXVerticalFrame(this, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // Container for the path linker
    FXHorizontalFrame* pathframe = new FXHorizontalFrame(cont, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0);

    // File list

    // Smooth scrolling
    FXuint options;
    if (smoothscroll)
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS;
    }
    else
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS|SCROLLERS_DONT_TRACK;
    }

    FXHorizontalFrame* cont2 = new FXHorizontalFrame(cont, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_SUNKEN|FRAME_THICK, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    /*FXVerticalFrame* webview = new FXVerticalFrame(cont2, LAYOUT_FIX_WIDTH|LAYOUT_FILL_Y, 0, 0, 200, 0, 0, 0, 0, 0);
    webview->setBackColor(getApp()->getBackColor());

    FXLabel* webviewbg = new FXLabel(webview, "", webviewbgicon, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    webviewbg->setBackColor(getApp()->getBackColor());

    webviewtext = new FXLabel(webview, "Folder", 0, 0, 10, 100, 0, 0, 10, 10, 0, 0);
    webviewtext->setBackColor(getApp()->getBackColor());

    std::cout << webviewtext;
    std::cout << "\n";


    FXHorizontalFrame* webviewsep = new FXHorizontalFrame(webview, LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, 184, 2);
    webviewsep->setBackColor(FXRGB(102,153,204));

    //std::string iconbg = "test";
    //std::string* ptr = &iconbg;

    //FXEvent *ev=(FXEvent*)ptr;
    //FXDCWindow dc(webviewbg,ev);
    //dc.drawIcon(webviewbgicon,10,10);

    FXLabel* webviewicon = new FXLabel(webview, "", bigfoldericon, LAYOUT_FIX_X|LAYOUT_FIX_Y, 16, 16, 0, 0, 0, 0, 0, 0);
    webviewicon->setBackColor(FXRGBA(255,255,255,0));*/

    list = new FileList(owner, cont2, this, ID_FILELIST, showthumbs, options);
    list->setHeaderSize(0, name_size);
    list->setHeaderSize(1, size_size);
    list->setHeaderSize(2, type_size);
    list->setHeaderSize(3, ext_size);
    list->setHeaderSize(4, modd_size);
    list->setHeaderSize(5, user_size);
    list->setHeaderSize(6, grou_size);
    list->setHeaderSize(7, attr_size);
    list->setHeaderSize(8, deldate_size);
    list->setHeaderSize(9, origpath_size);
    list->setTextColor(listforecolor);
    list->setBackColor(listbackcolor);

    // Path text
    pathtext = new TextLabel(pathframe, 0, this, ID_FILELIST, LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0);
    pathtext->setBackColor(getApp()->getBaseColor());

    // Hide path frame if path link/breadcrums are disabled
    show_pathlink = getApp()->reg().readUnsignedEntry("SETTINGS", "show_pathlinker", true);

    if (show_pathlink == false)
    {
         pathframe->hide();
    }



    // Path linker
    pathlink = new PathLinker(pathframe, list, dirpanel->getList(), JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X);
    //FXButton* dummyicon = new FXButton(pathframe, "", minifoldericon, this, 2, BUTTON_TOOLBAR|JUSTIFY_LEFT|LAYOUT_LEFT);


    // Visually indicate if the panel is active
    activeicon = new FXButton(pathframe, "", minifoldericon, this, FilePanel::ID_FILELIST, BUTTON_TOOLBAR|JUSTIFY_LEFT|LAYOUT_LEFT);



    // Status bar
    statusbar = new FXHorizontalFrame(cont, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|LAYOUT_BOTTOM, 0, 0, 0, 0, 0, 0, 0, 0);

    statusbar->setTarget(this);
    statusbar->setSelector(FXSEL(SEL_UPDATE, FilePanel::ID_STATUS));

    FXString key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "filter", "Ctrl-D");

    FXHorizontalFrame* hframe = new FXHorizontalFrame(statusbar, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0);
    statuslabel = new FXLabel(hframe, _("Status"), NULL, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X|FRAME_SUNKEN);
    filterlabel = new FXLabel(hframe, "", NULL, JUSTIFY_LEFT|LAYOUT_LEFT);

    corner = new FXDragCorner(statusbar);

    // Panel separator
    panelsep = new FXHorizontalSeparator(cont, SEPARATOR_GROOVE|LAYOUT_FILL_X);

    // Initializations
    selmult = false;
    current = NULL;

    // Single click navigation
    single_click = getApp()->reg().readUnsignedEntry("SETTINGS", "single_click", SINGLE_CLICK_NONE);
    if (single_click == SINGLE_CLICK_DIR_FILE)
    {
        list->setDefaultCursor(getApp()->getDefaultCursor(DEF_HAND_CURSOR));
    }

    // Dialogs
    operationdialogsingle = NULL;
    operationdialogrename = NULL;
    operationdialogmultiple = NULL;
    newdirdialog = NULL;
    newfiledialog = NULL;
    newlinkdialog = NULL;
    opendialog = NULL;
    archdialog = NULL;
    filterdialog = NULL;
    comparedialog = NULL;

    // Home and trahscan locations
    trashlocation = xdgdatahome+PATHSEPSTRING TRASHPATH;
    trashfileslocation = xdgdatahome + PATHSEPSTRING TRASHFILESPATH;
    trashinfolocation = xdgdatahome + PATHSEPSTRING TRASHINFOPATH;

    // Start location (we return to the start location after each chdir)
    startlocation = FXSystem::getCurrentDirectory();

    // Initialize clipboard flags
    clipboard_locked = false;
    fromPaste = false;

    // Initialize control flag for right click popup menu
    ctrl = false;

    // Initialize the Shift-F10 flag
    shiftf10 = false;

    // Initialize the active panel flag
    isactive = false;

    // Default programs identifiers
    progs["<txtviewer>"] = TXTVIEWER;
    progs["<txteditor>"] = TXTEDITOR;
    progs["<imgviewer>"] = IMGVIEWER;
    progs["<imgeditor>"] = IMGEDITOR;
    progs["<pdfviewer>"] = PDFVIEWER;
    progs["<audioplayer>"] = AUDIOPLAYER;
    progs["<videoplayer>"] = VIDEOPLAYER;
    progs["<archiver>"] = ARCHIVER;
}


// Create X window
void FilePanel::create()
{
    // Register standard uri-list type
    urilistType = getApp()->registerDragType("text/uri-list");

    // Register special uri-list type used for Gnome, XFCE and Xfe
    xfelistType = getApp()->registerDragType("x-special/gnome-copied-files");

    // Register special uri-list type used for KDE
    kdelistType = getApp()->registerDragType("application/x-kde-cutselection");

    // Register standard UTF-8 text type used for file dialogs
    utf8Type = getApp()->registerDragType("UTF8_STRING");

    // Display or hide path linker
    FXbool show_pathlink = getApp()->reg().readUnsignedEntry("SETTINGS", "show_pathlinker", true);
    if (show_pathlink)
    {
        pathtext->hide();
        pathlink->show();
    }
    else
    {
        pathtext->show();
        pathlink->hide();
    }

    FXVerticalFrame::create();
}


// Destructor
FilePanel::~FilePanel()
{
    delete list;
    delete current;
    delete next;
    delete statuslabel;
    delete filterlabel;
    delete statusbar;
    delete panelsep;
    delete pathlink;
    delete newfiledialog;
    delete newlinkdialog;
    delete newdirdialog;
    delete opendialog;
    delete archdialog;
    delete filterdialog;
    delete comparedialog;
    delete operationdialogsingle;
    delete operationdialogrename;
    delete operationdialogmultiple;
    delete pathtext;
}


// Make panel active
void FilePanel::setActive()
{
    // Set active icon
    // activeicon->setIcon(greenbuttonicon);
    activeicon->setIcon(NULL);
    activeicon->setTipText(_("Panel is active"));

    pathlink->focus();
    current = this;

    // Make dirpanel point on the current directory,
    // but only if Filepanel and Dirpanel directories are different
    if (dirpanel->getDirectory() != current->list->getDirectory())
    {
        dirpanel->setDirectory(current->list->getDirectory(), true);
    }

    // Make dirpanel inactive
    dirpanel->setInactive();

    next->setInactive();
    list->setFocus();

    isactive = true;
}


// Make panel inactive
void FilePanel::setInactive(FXbool force)
{
    // Set active icon
    // activeicon->setIcon(graybuttonicon);
    activeicon->setIcon(NULL);
    activeicon->setTipText(_("Activate panel"));

    // By default we set the panel inactive
    if (force)
    {
        current = next;
        list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), NULL);

        isactive = false;
    }
}


// Make panel focus (i.e. active) when clicked
long FilePanel::onCmdFocus(FXObject* sender, FXSelector sel, void* ptr)
{
    setActive();
    return(1);
}


// Set Pointer to Another FilePanel
void FilePanel::Next(FilePanel* nxt)
{
    next = nxt;
}


// Show or hide drag corner
void FilePanel::showCorner(FXbool show)
{
    if (show)
    {
        corner->show();
    }
    else
    {
        corner->hide();
    }
}


// Show or hide active icon
void FilePanel::showActiveIcon(FXbool show)
{
    if (show)
    {
        activeicon->show();
    }
    else
    {
        activeicon->hide();
    }
}


// Update location history when changing directory (home, up or double click)
void FilePanel::updateLocation()
{
    FXString    item;
    int         i = 0;
    FXComboBox* address = ((XFileExplorer*)mainWindow)->getAddressBox();

    address->setNumVisible(5);
    int      count = address->getNumItems();
    FXString p = list->getDirectory();

    // Remember latest directory in the location address
    if (!count)
    {
        count++;
        address->insertItem(0, address->getText());
    }
    while (i < count)
    {
        item = address->getItem(i++);
        if (streq((const char*)&p[0], (const char*)&item[0]))
        {
            i--;
            break;
        }
    }
    if (i == count)
    {
        address->insertItem(0, list->getDirectory());
        //webviewtext->setText(list->getDirectory());
        //webviewtext->setTextColor(FXRGB(255,255,255));
        //std::cout << webviewtext;
    }

    // Make current directory visible to avoid scrolling again
    list->makeItemVisible(list->getCurrentItem());
}


// We now really do have the clipboard, keep clipboard content
long FilePanel::onClipboardGained(FXObject* sender, FXSelector sel, void* ptr)
{
    FXVerticalFrame::onClipboardGained(sender, sel, ptr);
    return(1);
}


// We lost the clipboard
long FilePanel::onClipboardLost(FXObject* sender, FXSelector sel, void* ptr)
{
    FXVerticalFrame::onClipboardLost(sender, sel, ptr);
    return(1);
}


// Somebody wants our clipboard content
long FilePanel::onClipboardRequest(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    FXuchar* data;
    FXuint   len;

    // Perhaps the target wants to supply its own data for the clipboard
    if (FXVerticalFrame::onClipboardRequest(sender, sel, ptr))
    {
        return(1);
    }

    // Clipboard target is xfelistType (Xfe, Gnome or XFCE)
    if (event->target == xfelistType)
    {
        // Don't modify the clipboard if we are called from updPaste()
        if (!clipboard_locked)
        {
            // Prepend "copy" or "cut" as in the Gnome way and avoid duplicating these strings
            if ((clipboard.find("copy\n") < 0) && (clipboard.find("cut\n") < 0))
            {
                if (clipboard_type == CUT_CLIPBOARD)
                {
                    clipboard = "cut\n" + clipboard;
                }
                else
                {
                    clipboard = "copy\n" + clipboard;
                }
            }
        }

        // Return clipboard content
        if (event->target == xfelistType)
        {
            if (!clipboard.empty())
            {
                len = clipboard.length();
                FXMEMDUP(&data, clipboard.text(), FXuchar, len);
                setDNDData(FROM_CLIPBOARD, event->target, data, len);

                // Return because xfelistType is not compatible with other types
                return(1);
            }
        }
    }

    // Clipboard target is kdelisType (KDE)
    if (event->target == kdelistType)
    {
        // The only data to be passed in this case is "0" for copy and "1" for cut
        // The uri data are passed using the standard uri-list type
        FXString flag;
        if (clipboard_type == CUT_CLIPBOARD)
        {
            flag = "1";
        }
        else
        {
            flag = "0";
        }

        // Return clipboard content
        if (event->target == kdelistType)
        {
            FXMEMDUP(&data, flag.text(), FXuchar, 1);
            setDNDData(FROM_CLIPBOARD, event->target, data, 1);
        }
    }

    // Clipboard target is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    if (event->target == urilistType)
    {
        if (!clipboard.empty())
        {
            len = clipboard.length();
            FXMEMDUP(&data, clipboard.text(), FXuchar, len);
            setDNDData(FROM_CLIPBOARD, event->target, data, len);

            return(1);
        }
    }

    // Clipboard target is utf8Type (to paste file pathes as text to other applications)
    if (event->target == utf8Type)
    {
        if (!clipboard.empty())
        {
            int      beg = 0, end = 0;
            FXString str = "";
            FXString pathname, url;

            // Clipboard don't contain 'copy\n' or 'cut\n' as first line
            if ((clipboard.find("copy\n") < 0) && (clipboard.find("cut\n") < 0))
            {
                // Remove the 'file:' prefix for each file path
                while (1)
                {
                    end = clipboard.find('\n', end);
                    if (end < 0) // Last line
                    {
                        end = clipboard.length();
                        url = clipboard.mid(beg, end-beg+1);
                        pathname = FXURL::decode(FXURL::fileFromURL(url));
                        str += pathname;
                        break;
                    }
                    url = clipboard.mid(beg, end-beg+1);
                    pathname = FXURL::decode(FXURL::fileFromURL(url));
                    str += pathname;
                    end++;
                    beg = end;
                }
                end = str.length();
            }

            // Clipboard contains 'copy\n' or 'cut\n' as first line, thus skip it
            else
            {
                // Start after the 'copy\n' or 'cut\n' prefix
                end = clipboard.find('\n', 0);
                end++;
                beg = end;

                // Remove the 'file:' prefix for each file path
                while (1)
                {
                    end = clipboard.find('\n', end);
                    if (end < 0) // Last line
                    {
                        end = clipboard.length();
                        url = clipboard.mid(beg, end-beg+1);
                        pathname = FXURL::decode(FXURL::fileFromURL(url));
                        str += pathname;
                        break;
                    }
                    url = clipboard.mid(beg, end-beg+1);
                    pathname = FXURL::decode(FXURL::fileFromURL(url));
                    str += pathname;
                    end++;
                    beg = end;
                }
                end = str.length();
            }

            if (!str.empty())
            {
                len = str.length();
                FXMEMDUP(&data, str.text(), FXuchar, len);
                setDNDData(FROM_CLIPBOARD, event->target, data, len);

                return(1);
            }
        }
    }
    return(0);
}


// Copy or cut to clipboard (and add copy / add cut)
long FilePanel::onCmdCopyCut(FXObject*, FXSelector sel, void*)
{
    FXString name, curdir;

    // Clear clipboard if normal copy or cut
    if ((FXSELID(sel) == ID_COPY_CLIPBOARD) || (FXSELID(sel) == ID_CUT_CLIPBOARD))
    {
        clipboard.clear();
    }

    // Add an '\n' at the end if addcopy or addcut
    else
    {
        clipboard += '\n';
    }

    // Clipboard type
    if ((FXSELID(sel) == ID_CUT_CLIPBOARD) || (FXSELID(sel) == ID_ADDCUT_CLIPBOARD))
    {
        clipboard_type = CUT_CLIPBOARD;
    }
    else
    {
        clipboard_type = COPY_CLIPBOARD;
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        // Construct the uri list of files and fill the clipboard with it
        curdir = current->list->getDirectory();

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                name = current->list->getItemText(u).text();
                name = name.section('\t', 0);
                if (curdir == ROOTDIR)
                {
                    clipboard += FXURL::encode(::fileToURI(curdir+name))+"\n";
                }
                else
                {
                    clipboard += FXURL::encode(::fileToURI(curdir+PATHSEPSTRING+name))+"\n";
                }
            }
        }
    }

    // Remove the last \n of the list, for compatibility with some file managers (e.g. nautilus, nemo)
    clipboard.erase(clipboard.length()-1);

    // Acquire the clipboard
    FXDragType types[4];
    types[0] = xfelistType;
    types[1] = kdelistType;
    types[2] = urilistType;
    types[3] = utf8Type;
    if (acquireClipboard(types, 4))
    {
        return(0);
    }

    return(1);
}


// Paste file(s) from clipboard
long FilePanel::onCmdPaste(FXObject*, FXSelector sel, void*)
{
    FXuchar* data;
    FXuint   len;
    int      beg, end, pos;
    FXString chaine, url, param;
    int      num = 0;
    FXbool   from_kde = false;

    // If source is xfelistType (Gnome, XFCE, or Xfe app)
    if (getDNDData(FROM_CLIPBOARD, xfelistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';

        clipboard = (char*)data;

        // Loop over clipboard items
        for (beg = 0; beg < clipboard.length(); beg = end+1)
        {
            if ((end = clipboard.find("\n", beg)) < 0)
            {
                end = clipboard.length();
            }

            // Obtain item url
            url = clipboard.mid(beg, end-beg);

            // Eventually remove the trailing '\r' if any
            if ((pos = url.rfind('\r')) > 0)
            {
                url.erase(pos);
            }

            // Process first item
            if (num == 0)
            {
                // First item should be "copy" or "cut"
                if (url == "copy")
                {
                    clipboard_type = COPY_CLIPBOARD;
                    num++;
                }
                else if (url == "cut")
                {
                    clipboard_type = CUT_CLIPBOARD;
                    num++;
                }

                // If first item is not "copy" nor "cut", process it as a normal url
                // and use default clipboard type
                else
                {
                    // Update the param string
                    param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";

                    // Add one more because the first line "copy" or "cut" was not present
                    num += 2;
                }
            }

            // Process other items
            else
            {
                // Update the param string
                param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";
                num++;
            }
        }

        // Construct the final param string passed to the file management routine
        param = current->list->getDirectory()+"\n" + FXStringVal(num-1) + "\n" + param;

        // Copy or cut operation depending on the clipboard type
        switch (clipboard_type)
        {
        case COPY_CLIPBOARD:
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_COPY);
            break;

        case CUT_CLIPBOARD:
            clipboard.clear();
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_CUT);
            break;
        }
        fromPaste = true;
        handle(this, sel, (void*)param.text());

        // Free data pointer
        FXFREE(&data);

        // Return here because xfelistType is not compatible with other types
        return(1);
    }

    // If source type is kdelistType (KDE)
    if (getDNDData(FROM_CLIPBOARD, kdelistType, data, len))
    {
        from_kde = true;

        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        clipboard = (char*)data;

        // Obtain clipboard type (copy or cut)
        if (clipboard == "1")
        {
            clipboard_type = CUT_CLIPBOARD;
        }
        else
        {
            clipboard_type = COPY_CLIPBOARD;
        }

        FXFREE(&data);
    }


    // If source type is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    if (getDNDData(FROM_CLIPBOARD, urilistType, data, len))
    {
        // For non KDE apps, set action to copy
        if (!from_kde)
        {
            clipboard_type = COPY_CLIPBOARD;
        }

        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        clipboard = (char*)data;

        // Loop over clipboard items
        for (beg = 0; beg < clipboard.length(); beg = end+1)
        {
            if ((end = clipboard.find("\n", beg)) < 0)
            {
                end = clipboard.length();
            }

            // Obtain item url
            url = clipboard.mid(beg, end-beg);

            // Eventually remove the trailing '\r' if any
            if ((pos = url.rfind('\r')) > 0)
            {
                url.erase(pos);
            }

            // Update the param string
            param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";
            num++;
        }

        // Construct the final param string passed to the file management routine
        param = current->list->getDirectory()+"\n" + FXStringVal(num) + "\n" + param;

        // Copy or cut operation depending on the clipboard type
        switch (clipboard_type)
        {
        case COPY_CLIPBOARD:
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_COPY);
            break;

        case CUT_CLIPBOARD:
            clipboard.clear();
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_CUT);
            break;
        }
        fromPaste = true;
        handle(this, sel, (void*)param.text());

        FXFREE(&data);
        return(1);
    }
    return(0);
}


// Execute file with an optional confirm dialog
void FilePanel::execFile(FXString pathname)
{
    int      ret;
    FXString cmd, cmdname;

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // File is executable, but is it a text file?
    FXString str = mimetype(pathname);
    FXbool   isTextFile = true;
    if (strstr(str.text(), "charset=binary"))
    {
        isTextFile = false;
    }

    // With confirmation dialog
    FXbool confirm_execute = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_execute", true);
    if (isTextFile && (confirm_execute == 1))
    {
        FXString msg;
        msg.format(_("File %s is an executable text file, what do you want to do?"), pathname.text());
        ExecuteBox* dlg = new ExecuteBox(this, _("Confirm Execute"), msg);
        FXuint      answer = dlg->execute(PLACEMENT_CURSOR);
        delete dlg;

        // Execute
        if (answer == EXECBOX_CLICKED_EXECUTE)
        {
            cmdname = FXPath::name(pathname);
            cmd = ::quote(pathname);
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // Execute in console mode
        if (answer == EXECBOX_CLICKED_CONSOLE)
        {
            ret = chdir(current->list->getDirectory().text());
            if (ret < 0)
            {
                int errcode = errno;
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
                }
            }

            cmdname = FXPath::name(pathname);
            cmd = ::quote(pathname);

            // Make and show command window
            // The CommandWindow object will delete itself when closed!
            CommandWindow* cmdwin = new CommandWindow(getApp(), _("Command log"), cmd, 30, 80);
            cmdwin->create();
            cmdwin->setIcon(runicon);

            ret = chdir(startlocation.text());
            if (ret < 0)
            {
                int errcode = errno;
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
                }
            }
        }

        // Edit
        if (answer == EXECBOX_CLICKED_EDIT)
        {
            FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
            cmd = txteditor;
            cmdname = cmd;

            // If command exists, run it
            if (::existCommand(cmdname))
            {
                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
            }

            // If command does not exist, call the "Open with..." dialog
            else
            {
                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
            }
        }
    }

    // Without confirmation dialog
    else
    {
        cmdname = FXPath::name(pathname);
        cmd = ::quote(pathname);
#ifdef STARTUP_NOTIFICATION
        runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
        runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
    }
}


// Double Click on File Item
long FilePanel::onCmdItemDoubleClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    FXString cmd, cmdname, filename, pathname;

    // Wait cursor
    getApp()->beginWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);

    // At most one item selected
    if (current->list->getNumSelectedItems() <= 1)
    {
        FXlong item = (FXlong)ptr;
        if (item > -1)
        {
#ifdef STARTUP_NOTIFICATION
            // Startup notification option and exceptions (if any)
            FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
            FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

            // Default programs
            FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
            FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
            FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
            FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
            FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
            FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
            FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
            FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

            // File name and path
            filename = list->getItemFilename(item);
            pathname = list->getItemPathname(item);

            // If directory, open the directory
            if (list->isItemDirectory(item))
            {
                // Does not have access
                if (!::isReadExecutable(pathname))
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _(" Permission to: %s denied."), pathname.text());
                    getApp()->endWaitCursor();
		    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                    return(0);
                }
                if (filename == "..")
                {
                    list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
                    //list->hide();
                }
                else
                {
                    list->setDirectory(pathname);
                }

                // Change directory in tree list
                dirpanel->setDirectory(pathname, true);
                current->updatePath();

                // Update location history
                updateLocation();
            }
            else if (list->isItemFile(item))
            {
                // Update associations dictionary
                FileDict*  assocdict = new FileDict(getApp());
                FileAssoc* association = assocdict->findFileBinding(pathname.text());

                // If there is an association
                if (association)
                {
                    // Use it to open the file
                    if (association->command.section(',', 0) != "")
                    {
                        cmdname = association->command.section(',', 0);

                        // Use a default program if possible
                        switch (progs[cmdname])
                        {
                        case TXTVIEWER:
                            cmdname = txtviewer;
                            break;

                        case TXTEDITOR:
                            cmdname = txteditor;
                            break;

                        case IMGVIEWER:
                            cmdname = imgviewer;
                            break;

                        case IMGEDITOR:
                            cmdname = imgeditor;
                            break;

                        case PDFVIEWER:
                            cmdname = pdfviewer;
                            break;

                        case AUDIOPLAYER:
                            cmdname = audioplayer;
                            break;

                        case VIDEOPLAYER:
                            cmdname = videoplayer;
                            break;

                        case ARCHIVER:
                            cmdname = archiver;
                            break;

                        case NONE: // No program found
                            ;
                            break;
                        }

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
			    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // Or execute the file
                    else if (list->isItemExecutable(item))
                    {
                        execFile(pathname);
                    }

                    // Or call the "Open with..." dialog
                    else
                    {
                        getApp()->endWaitCursor();
			mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }

                // If no association but executable
                else if (list->isItemExecutable(item))
                {
                    execFile(pathname);
                }

                // Other cases
                else
                {
                    getApp()->endWaitCursor();
		    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                    current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                }
            }
        }
    }

    // More than one selected files
    else
    {
        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN), NULL);
    }

    getApp()->endWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);

    return(1);
}


// Single click on File Item
long FilePanel::onCmdItemClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    // Make panel active
    setActive();

    if (single_click != SINGLE_CLICK_NONE)
    {
        // Default programs
        FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
        FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
        FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
        FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
        FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
        FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
        FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
        FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

        // In detailed mode, avoid single click when mouse cursor is not over the first column
        int    x, y;
        FXuint state;
        getCursorPosition(x, y, state);
        FXbool allow = true;
        if (!(list->getListStyle()&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS)) && ((x-list->getXPosition()) > list->getHeaderSize(0)))
        {
            allow = false;
        }

        // Single click with control or shift
        if (state&(CONTROLMASK|SHIFTMASK))
        {
            return(1);
        }

        // Single click without control or shift
        else
        {
            FXString cmd, cmdname, filename, pathname;

            // Wait cursor
            getApp()->beginWaitCursor();

#ifdef STARTUP_NOTIFICATION
            // Startup notification option and exceptions (if any)
            FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
            FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

            FXlong item = (FXlong)ptr;
            if (item > -1)
            {
                // File name and path
                filename = list->getItemFilename(item);
                pathname = list->getItemPathname(item);

                // If directory, open the directory
                if ((single_click != SINGLE_CLICK_NONE) && list->isItemDirectory(item) && allow)
                {
                    // Does not have access
                    if (!::isReadExecutable(pathname))
                    {
                        MessageBox::error(this, BOX_OK_SU, _("Error"), _(" Permission to: %s denied."), pathname.text());
                        getApp()->endWaitCursor();
                        return(0);
                    }
                    if (filename == "..")
                    {
                        list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
                    }
                    else
                    {
                        list->setDirectory(pathname);
                    }

                    // Change directory in tree list
                    dirpanel->setDirectory(pathname, true);
                    current->updatePath();

                    // Update location history
                    updateLocation();
                }

                // If file, use the association if any
                else if ((single_click == SINGLE_CLICK_DIR_FILE) && list->isItemFile(item) && allow)
                {
                    // Update associations dictionary
                    FileDict*  assocdict = new FileDict(getApp());
                    FileAssoc* association = assocdict->findFileBinding(pathname.text());

                    // If there is an association
                    if (association)
                    {
                        // Use it to open the file
                        if (association->command.section(',', 0) != "")
                        {
                            cmdname = association->command.section(',', 0);

                            // Use a default program if possible
                            switch (progs[cmdname])
                            {
                            case TXTVIEWER:
                                cmdname = txtviewer;
                                break;

                            case TXTEDITOR:
                                cmdname = txteditor;
                                break;

                            case IMGVIEWER:
                                cmdname = imgviewer;
                                break;

                            case IMGEDITOR:
                                cmdname = imgeditor;
                                break;

                            case PDFVIEWER:
                                cmdname = pdfviewer;
                                break;

                            case AUDIOPLAYER:
                                cmdname = audioplayer;
                                break;

                            case VIDEOPLAYER:
                                cmdname = videoplayer;
                                break;

                            case ARCHIVER:
                                cmdname = archiver;
                                break;

                            case NONE: // No program found
                                ;
                                break;
                            }

                            // If command exists, run it
                            if (::existCommand(cmdname))
                            {
                                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                            }

                            // If command does not exist, call the "Open with..." dialog
                            else
                            {
                                getApp()->endWaitCursor();
                                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                            }
                        }

                        // Or execute the file
                        else if (list->isItemExecutable(item))
                        {
                            execFile(pathname);
                        }

                        // Or call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // If no association but executable
                    else if (list->isItemExecutable(item))
                    {
                        execFile(pathname);
                    }

                    // Other cases
                    else
                    {
                        getApp()->endWaitCursor();
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }
            }
            getApp()->endWaitCursor();
        }
    }
    return(1);
}


// Go to parent directory
long FilePanel::onCmdDirectoryUp(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
    current->list->setFocus();
    dirpanel->setDirectory(current->list->getDirectory(), true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Go to home directory
long FilePanel::onCmdGoHome(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setDirectory(homedir);
    current->list->setFocus();
    dirpanel->setDirectory(homedir, true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Go to trash directory
long FilePanel::onCmdGoTrash(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setDirectory(trashfileslocation);
    current->list->setFocus();
    dirpanel->setDirectory(trashfileslocation, true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Set the flag that allows to stop the file list refresh
long FilePanel::onCmdStopListRefreshTimer(FXObject*, FXSelector, void*)
{
    stopListRefresh = true;

    return(0);
}


// Copy/Move/Rename/Symlink file(s)
long FilePanel::onCmdFileMan(FXObject* sender, FXSelector sel, void* ptr)
{
    int      num;
    FXString src, targetdir, target, name, source;
    int      firstitem = 0, lastitem = 0;

    // Focus on this panel list
    current->list->setFocus();

    // Confirmation dialog?
    FXbool ask_before_copy = getApp()->reg().readUnsignedEntry("OPTIONS", "ask_before_copy", true);

    // If we are we called from the paste command, get the parameters from the pointer
    if (fromPaste)
    {
        // Reset the flag
        fromPaste = false;

        // Get the parameters
        FXString str = (char*)ptr;
        targetdir = str.section('\n', 0);
        num = FXUIntVal(str.section('\n', 1));
        src = str.after('\n', 2);

        // If no item in clipboard, return
        if (num <= 0)
        {
            return(0);
        }

        // If there is a selected directory in file panel, use it as target directory
        if (current->list->getNumSelectedItems() == 1)
        {
            int item = current->list->getCurrentItem();
            if (current->list->isItemDirectory(item))
            {
                targetdir = list->getItemPathname(item);
            }
        }
    }

    // Obtain the parameters from the file panel
    else
    {
        // Current directory
        FXString curdir = current->list->getDirectory();

        // Number of selected items
        num = current->list->getNumSelectedItems();

        // If no item, return
        if (num <= 0)
        {
            return(0);
        }

        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        // Obtain the list of source files and the target directory
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                if (firstitem == 0)
                {
                    firstitem = u;
                }
                lastitem = u;
                name = current->list->getItemText(u).text();
                name = name.section('\t', 0);
                src += curdir+PATHSEPSTRING+name+"\n";
            }
        }
        targetdir = current->next->list->getDirectory();

        if (!current->next->shown() || (FXSELID(sel) == ID_FILE_RENAME))
        {
            targetdir = current->list->getDirectory();
        }
    }

    // Number of items in the FileList
    int numitems = current->list->getNumItems();

    // Name and directory of the first source file
    source = src.section('\n', 0);
    name = FXPath::name(source);
    FXString dir = FXPath::directory(source);

    // Initialize target name
    if (targetdir != ROOTDIR)
    {
        target = targetdir+PATHSEPSTRING;
    }
    else
    {
        target = targetdir;
    }

    // Configure the command, title, message, etc.
    FXIcon*  icon = NULL;
    FXString command, title, message;
    if (FXSELID(sel) == ID_FILE_COPY)
    {
        command = "copy";
        title = _("Copy");
        icon = copy_bigicon;
        if (num == 1)
        {
            message = _("Copy ");
            message += source;
            if (::isFile(source))
            {
                target += name;
            }

            // Source and target are identical => add a suffix to the name
            FXString tgt = ::cleanPath(target); // Remove trailing / if any
            if ((::identical(source, tgt) && (tgt != current->list->getDirectory())) || // Check we are not within target
                (::isDirectory(source) && (source == tgt+PATHSEPSTRING+FXPath::name(source))))
            {
                target = ::buildCopyName(source);
            }
        }
        else
        {
            message.format(_("Copy %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_RENAME)
    {
        command = "rename";
        title = _("Rename");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Rename ");
            message += name;
            target = name;
            title = _("Rename");
        }
        else
        {
            return(0);
        }
    }
    if (FXSELID(sel) == ID_FILE_COPYTO)
    {
        command = "copy";
        title = _("Copy");
        icon = copy_bigicon;
        if (num == 1)
        {
            message = _("Copy ");
            message += source;
        }
        else
        {
            message.format(_("Copy %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_MOVETO)
    {
        command = "move";
        title = _("Move");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Move ");
            message += source;
            title = _("Move");
        }
        else
        {
            message.format(_("Move %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_CUT)
    {
        command = "move";
        title = _("Move");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Move ");
            message += source;
            if (::isFile(source))
            {
                target += name;
            }
            title = _("Move");
        }
        else
        {
            message.format(_("Move %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_SYMLINK)
    {
        command = "symlink";
        title = _("Symlink");
        icon = link_bigicon;
        if (num == 1)
        {
            message = _("Symlink ");
            message += source;
            target += name;
        }
        else
        {
            message.format(_("Symlink %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }

    // File operation dialog, if needed
    if (ask_before_copy || (source == target) || (FXSELID(sel) == ID_FILE_COPYTO) || (FXSELID(sel) == ID_FILE_MOVETO) || (FXSELID(sel) == ID_FILE_RENAME) || (FXSELID(sel) == ID_FILE_SYMLINK))
    {
        if (num == 1)
        {
            if (FXSELID(sel) == ID_FILE_RENAME)
            {
                if (operationdialogrename == NULL)
                {
                    operationdialogrename = new InputDialog(this, "", "", title, _("To:"), icon);
                }
                operationdialogrename->setTitle(title);
                operationdialogrename->setIcon(icon);
				operationdialogrename->setMessage(message);
                operationdialogrename->setText(target);

                if (::isDirectory(source))  // directory
                {
                    operationdialogrename->selectAll();
                }
                else
                {
                    int pos = target.rfind('.');
                    if (pos <= 0)
                    {
                        operationdialogrename->selectAll(); // no extension or dot file
                    }
                    else
                    {
                        operationdialogrename->setSelection(0, pos);
                    }
                }

                int rc = 1;
                rc = operationdialogrename->execute(PLACEMENT_CURSOR);
                target = operationdialogrename->getText();
                
                // Target name contains '/'
                if (target.contains(PATHSEPCHAR))
                {
					MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in file or folder names, operation cancelled"));
					return(0);
				}

                if (!rc)
                {
                    return(0);
                }
            }
            else
            {
                if (operationdialogsingle == NULL)
                {
                    operationdialogsingle = new BrowseInputDialog(this, "", "", title, _("To:"), icon, BROWSE_INPUT_MIXED);
                }
                operationdialogsingle->setTitle(title);
                operationdialogsingle->setIcon(icon);
                operationdialogsingle->setMessage(message);
                operationdialogsingle->setText(target);

                // Select file name without path
                if (FXSELID(sel) == ID_FILE_SYMLINK)
                {
                    int pos = target.rfind(PATHSEPSTRING);
                    if (pos >= 0)
                    {
                        operationdialogsingle->setSelection(pos+1, target.length());
                    }
                }

                operationdialogsingle->setDirectory(targetdir);
                int rc = 1;
                rc = operationdialogsingle->execute(PLACEMENT_CURSOR);
                target = operationdialogsingle->getText();
                if (!rc)
                {
                    return(0);
                }
            }
        }
        else
        {
            if (operationdialogmultiple == NULL)
            {
                operationdialogmultiple = new BrowseInputDialog(this, "", "", title, _("To folder:"), icon, BROWSE_INPUT_FOLDER);
            }
            operationdialogmultiple->setTitle(title);
            operationdialogmultiple->setIcon(icon);
            operationdialogmultiple->setMessage(message);
            operationdialogmultiple->setText(target);
            operationdialogmultiple->CursorEnd();
            operationdialogmultiple->setDirectory(targetdir);
            int rc = 1;
            rc = operationdialogmultiple->execute(PLACEMENT_CURSOR);
            target = operationdialogmultiple->getText();
            if (!rc)
            {
                return(0);
            }
        }
    }

    // Nothing entered
    if (target == "")
    {
        MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
        return(0);
    }

    // Update target and target parent directory
	target = ::filePath(target,current->list->getDirectory());
	if (::isDirectory(target))
	{
		targetdir = target;
	}
	else
	{
		targetdir = FXPath::directory(target);
	}

    // Target parent directory doesn't exist
    if (!::exists(targetdir))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), targetdir.text());
        return(0);
    }

    // Target parent directory not writable
    if (!::isWritable(targetdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetdir.text());
        return(0);
    }

    // Target parent directory is not a directory
    if (!::isDirectory(targetdir))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("%s is not a folder"), targetdir.text());
        return(0);
    }

    // Multiple sources and non existent destination
    if ((num > 1) && !::exists(target))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), target.text());
        return(0);
    }

    // Multiple sources and target is a file
    if ((num > 1) && ::isFile(target))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("%s is not a folder"), target.text());
        return(0);
    }

    // Target is a directory and is not writable
    if (::isDirectory(target) && !::isWritable(target))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), target.text());
        return(0);
    }

    // Target is a file and its parent directory is not writable
    if (::isFile(target) && !::isWritable(targetdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetdir.text());
        return(0);
    }

    // One source
    File* f = NULL;
    int   ret;
    if (num == 1)
    {
        // An empty source file name corresponds to the ".." file
        // Don't perform any file operation on it!
        if (source == "")
        {
            return(0);
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        if (command == "copy")
        {
            f = new File(this, _("File copy"), COPY, num);
            f->create();

            // If target file is located at trash location, also create the corresponding trashinfo file
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && (target == trashfileslocation))
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(source, trashfileslocation);

                // Adjust target name to get the _N suffix if any
                FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                // Create trashinfo file
                createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                // Copy source to trash target
                ret = f->copy(source, trashtarget);
            }

            // Copy source to target
            else
            {
                ret = f->copy(source, target);
            }

            // An unknown error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
            }
        }
        else if (command == "rename")
        {
            f = new File(this, _("File rename"), RENAME, num);
            f->create();
            ret = f->rename(source, target);

            // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
            {
                FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                ::unlink(trashinfopathname.text());
            }
        }
        else if (command == "move")
        {
            f = new File(this, _("File move"), MOVE, num);
            f->create();

            // If target file is located at trash location, also create the corresponding trashinfo file
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && (target == trashfileslocation))
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(source, trashfileslocation);

                // Adjust target name to get the _N suffix if any
                FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                // Create trashinfo file
                createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                // Move source to trash target
                ret = f->move(source, trashtarget);
            }

            // Move source to target
            else
            {
                ret = f->move(source, target);
            }

            // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
            // Do it silently and don't report any error if it fails
            if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
            {
                FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                ::unlink(trashinfopathname.text());
            }

            // An unknown error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
            }
        }
        else if (command == "symlink")
        {
            f = new File(this, _("Symlink"), SYMLINK, num);
            f->create();
            f->symlink(source, target);
        }
        // Shouldn't happen
        else
        {
            exit(EXIT_FAILURE);
        }

        getApp()->endWaitCursor();
        delete f;
    }

    // Multiple sources
    // Note : rename cannot be used in this case!
    else if (num > 1)
    {
        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        if (command == "copy")
        {
            f = new File(this, _("File copy"), COPY, num);
        }
        else if (command == "move")
        {
            f = new File(this, _("File move"), MOVE, num);
        }
        else if (command == "symlink")
        {
            f = new File(this, _("Symlink"), SYMLINK, num);
        }
        // Shouldn't happen
        else
        {
            exit(EXIT_FAILURE);
        }
        f->create();

        // Initialize file list stop refresh timer and flag
        stopListRefresh = false;
        getApp()->addTimeout(this, ID_STOP_LIST_REFRESH_TIMER, STOP_LIST_REFRESH_INTERVAL);

        // Loop on the multiple files
        for (int i = 0; i < num; i++)
        {
            // Stop refreshing the file list if file operation is long and has many files
            // This avoids flickering and speeds up things a bit
            if (stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
            {
                // Force a last refresh if current panel is destination
                if (current->getDirectory() == targetdir)
                {
                    current->list->onCmdRefresh(0, 0, 0);
                }

                // Force a last refresh if next panel is destination
                if (next->getDirectory() == targetdir)
                {
                    next->list->onCmdRefresh(0, 0, 0);
                }

                // Tell the dir and file list to not refresh anymore
                setAllowRefresh(false);
                next->setAllowRefresh(false);
                dirpanel->setAllowDirsizeRefresh(false);

                // Don't need to stop again
                stopListRefresh = false;
            }

            // Individual source file
            source = src.section('\n', i);

            // File could have already been moved above in the tree
            if (!::exists(source))
            {
                continue;
            }

            // An empty file name corresponds to the ".." file (why?)
            // Don't perform any file operation on it!
            if (source != "")
            {
                if (command == "copy")
                {
                    // If target file is located at trash location, also create the corresponding trashinfo file
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (target == trashfileslocation))
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(source, trashfileslocation);

                        // Adjust target name to get the _N suffix if any
                        FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                        // Create trashinfo file
                        createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                        // Copy source to trash target
                        ret = f->copy(source, trashtarget);
                    }

                    // Copy source to target
                    else
                    {
                        ret = f->copy(source, target);
                    }

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
                        break;
                    }
                }
                else if (command == "move")
                {
                    // If target file is located at trash location, also create the corresponding trashinfo file
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (target == trashfileslocation))
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(source, trashfileslocation);

                        // Adjust target name to get the _N suffix if any
                        FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                        // Create trashinfo file
                        createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                        // Move source to trash target
                        ret = f->move(source, trashtarget);
                    }

                    // Move source to target
                    else
                    {
                        ret = f->move(source, target);
                    }

                    // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
                    // Do it silently and don't report any error if it fails
                    if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
                    {
                        FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                        ::unlink(trashinfopathname.text());
                    }

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
                        break;
                    }
                }
                else if (command == "symlink")
                {
                    ret = f->symlink(source, target);

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the symlink operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Symlink operation cancelled!"));
                        break;
                    }
                }
                // Shouldn't happen
                else
                {
                    exit(EXIT_FAILURE);
                }
            }
        }

        // Reinit timer and refresh flags
        getApp()->removeTimeout(this, ID_STOP_LIST_REFRESH_TIMER);
        current->setAllowRefresh(true);
        next->setAllowRefresh(true);
        dirpanel->setAllowDirsizeRefresh(true);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panels refresh
    next->onCmdRefresh(0, 0, 0);
    current->onCmdRefresh(0, 0, 0);

    // Enable previous or last selected item for keyboard navigation
    if (((FXSELID(sel) == ID_FILE_MOVETO) || (FXSELID(sel) == ID_FILE_RENAME)) && (current->list->getNumItems() < numitems))
    {
        firstitem = (firstitem < 1) ? 0 : firstitem-1;
        current->list->enableItem(firstitem);
        current->list->setCurrentItem(firstitem);
    }
    else
    {
        current->list->enableItem(lastitem);
        current->list->setCurrentItem(lastitem);
    }

    return(1);
}


// Trash files from the file list or the tree list
long FilePanel::onCmdFileTrash(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();

    FXbool confirm_trash = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_trash", true);

    // If we don't have permission to write to the parent directory
    if (!::isWritable(dir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
        return(0);
    }

    // If we don't have permission to write to the trash directory
    if (!::isWritable(trashfileslocation))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to trash location %s: Permission denied"), trashfileslocation.text());
        return(0);
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        if (confirm_trash)
        {
            FXString message;
            if (num == 1)
            {
                FXString pathname;
                for (int u = 0; u < current->list->getNumItems(); u++)
                {
                    if (current->list->isItemSelected(u))
                    {
                        pathname = current->list->getItemPathname(u);
                    }
                }
                if (::isDirectory(pathname))
                {
                    message.format(_("Move folder %s to trash can?"), pathname.text());
                }
                else
                {
                    message.format(_("Move file %s to trash can?"), pathname.text());
                }
            }
            else
            {
                message.format(_("Move %s selected object(s) to trash can?"), FXStringVal(num).text());
            }

            MessageBox box(this, _("Confirm Trash"), message, delete_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
            if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
            {
                return(0);
            }
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Move to trash"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Overwrite initialisations
        FXbool overwrite = false;
        FXbool overwrite_all = false;
        FXbool skip_all = false;

        // Delete selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // If we don't have permission to write to the file
                if (!::isWritable(pathname))
                {
                    // Overwrite dialog if necessary
                    if (!(overwrite_all | skip_all))
                    {
                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("File %s is write-protected, move it anyway to trash can?"), pathname.text());
                        
                        if (num ==1)
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Trash"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;	
							if (answer == 1)
							{
								overwrite = true;
							}
							else
							{
								goto end;
							}
						}  
                        else
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Trash"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Overwrite
							case 1:
								overwrite = true;
								break;

							// Overwrite all
							case 2:
								overwrite_all = true;
								break;

							// Skip
							case 3:
								overwrite = false;
								break;

							// Skip all
							case 4:
								skip_all = true;
								break;
							}
							
						}
                    }
                    if ((overwrite | overwrite_all) & !skip_all)
                    {
                        // Caution!! Don't delete parent directory!!
                        if (filename != "..")
                        {
                            // Trash files path name
                            FXString trashpathname = createTrashpathname(pathname, trashfileslocation);

                            // Create trashinfo file
                            createTrashinfo(pathname, trashpathname, trashfileslocation, trashinfolocation);

                            // Move file to trash files location
                            int ret = f->move(pathname, trashpathname);

                            // An error has occurred
                            if ((ret == 0) && !f->isCancelled())
                            {
                                f->hideProgressDialog();
                                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move to trash operation!"));
                                break;
                            }
                        }
                    }
                    f->showProgressDialog();
                }

                // If we have permission to write
                else
                {
                    // Caution!! Don't delete parent directory!!
                    if (filename != "..")
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(pathname, trashfileslocation);

                        // Create trashinfo file
                        createTrashinfo(pathname, trashpathname, trashfileslocation, trashinfolocation);

                        // Move file to trash files location
                        int ret = f->move(pathname, trashpathname);

                        // An error has occurred
                        if ((ret == 0) && !f->isCancelled())
                        {
                            f->hideProgressDialog();
                            MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move to trash operation!"));
                            break;
                        }
                    }
                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Move to trash file operation cancelled!"));
                        break;
                    }
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// Restore files from trash can
long FilePanel::onCmdFileRestore(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();
    FXbool   confirm_trash = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_trash", true);

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Restore from trash"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Restore (i.e. move to their original location) selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // Don't restore '..' directory
                if (filename != "..")
                {
                    // Obtain trash base name and sub path
                    FXString subpath = pathname;
                    subpath.erase(0, trashfileslocation.length()+1);
                    FXString trashbasename = subpath.before('/');
                    if (trashbasename == "")
                    {
                        trashbasename = name;
                    }
                    subpath.erase(0, trashbasename.length());

                    // Read the .trashinfo file
                    FILE*    fp;
                    char     line[1024];
                    FXbool   success = true;
                    FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+trashbasename+".trashinfo";
                    FXString origpathname = "";

                    if ((fp = fopen(trashinfopathname.text(), "r")) != NULL)
                    {
                        // Read the first two lines and get the strings
                        if (fgets(line, sizeof(line), fp) == NULL)
                        {
                            success = false;
                        }
                        if (fgets(line, sizeof(line), fp) == NULL)
                        {
                            success = false;
                        }
                        if (success)
                        {
                            origpathname = line;
                            origpathname = origpathname.after('=');
                            origpathname = origpathname.before('\n');
                        }
                        fclose(fp);
                        origpathname = origpathname+subpath;
                    }

                    // Confirm restore dialog
                    if (confirm_trash && (u == firstitem))
                    {
                        FXString message;
                        if (num == 1)
                        {
                            if (::isDirectory(pathname))
                            {
                                message.format(_("Restore folder %s to its original location %s ?"), filename.text(), origpathname.text());
                            }
                            else
                            {
                                message.format(_("Restore file %s to its original location %s ?"), filename.text(), origpathname.text());
                            }
                        }
                        else
                        {
                            message.format(_("Restore %s selected object(s) to their original locations?"), FXStringVal(num).text());
                        }
                        f->hideProgressDialog();
                        MessageBox box(this, _("Confirm Restore"), message, restore_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
                        if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
                        {
                            getApp()->endWaitCursor();
                            delete f;
                            return(0);
                        }
                        f->showProgressDialog();
                    }

                    if (origpathname == "")
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("Restore information not available for %s"), pathname.text());
                        goto end;
                    }

                    // If parent dir of the original location does not exist
                    FXString origparentdir = FXPath::directory(origpathname);
                    if (!::exists(origparentdir))
                    {
                        // Ask the user if he wants to create it
                        f->hideProgressDialog();
                        FXString message;
                        message.format(_("Parent folder %s does not exist, do you want to create it?"), origparentdir.text());
                        MessageBox box(this, _("Confirm Restore"), message, restore_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
                        if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
                        {
                            goto end;
                        }
                        else
                        {
                            errno = 0;
                            int ret = mkpath(origparentdir.text(), 0755);
                            int errcode = errno;
                            if (ret == -1)
                            {
                                f->hideProgressDialog();
                                if (errcode)
                                {
                                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't create folder %s: %s"), origparentdir.text(), strerror(errcode));
                                }
                                else
                                {
                                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't create folder %s"), origparentdir.text());
                                }
                                goto end;
                            }
                            f->showProgressDialog();
                        }
                    }

                    // Move file to original location (with restore option)
                    int ret = f->move(pathname, origpathname, true);

                    // An error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the restore from trash operation!"));
                        goto end;
                    }

                    // Silently remove trashinfo file
                    FXString trashfilespathname = trashfileslocation+PATHSEPSTRING+trashbasename;
                    if ((pathname == trashfilespathname) && !::exists(trashfilespathname))
                    {
                        ::unlink(trashinfopathname.text());
                    }
                }
                // If action is cancelled in progress dialog
                if (f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Warning"), _("Restore from trash file operation cancelled!"));
                    goto end;
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// Definitively delete files from the file list or the tree list (no trash can)
long FilePanel::onCmdFileDelete(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();

    FXbool confirm_del = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete", true);
    FXbool confirm_del_emptydir = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete_emptydir", true);

    // If we don't have permission to write to the parent directory
    if (!::isWritable(dir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
        return(0);
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        if (confirm_del)
        {
            FXString message;
            if (num == 1)
            {
                FXString pathname;
                for (int u = 0; u < current->list->getNumItems(); u++)
                {
                    if (current->list->isItemSelected(u))
                    {
                        pathname = current->list->getItemPathname(u);
                    }
                }
                if (::isDirectory(pathname))
                {
                    message.format(_("Definitively delete folder %s ?"), pathname.text());
                }
                else
                {
                    message.format(_("Definitively delete file %s ?"), pathname.text());
                }
            }
            else
            {
                message.format(_("Definitively delete %s selected object(s)?"), FXStringVal(num).text());
            }
            MessageBox box(this, _("Confirm Delete"), message, delete_big_permicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
            if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
            {
                return(0);
            }
        }
        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("File delete"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Overwrite initialisations
        FXbool overwrite = false;
        FXbool overwrite_all = false;
        FXbool skip_all = false;
        FXbool ask_del_empty = true;
        FXbool skip_all_del_emptydir = false;

        // Delete selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // Confirm empty directory deletion
                if (confirm_del & confirm_del_emptydir & ask_del_empty)
                {
                    if ((::isEmptyDir(pathname) == 0) && !::isLink(pathname))
                    {
                        if (skip_all_del_emptydir)
                        {
                            continue;
                        }

                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("Folder %s is not empty, delete it anyway?"), pathname.text());

                        if (num ==1)
                        {
                        	OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							
							if (answer == 0)
							{
								goto end;
							}
						}
                        
                        else
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Yes
							case 1:
								break;

							// Yes for all
							case 2:
								ask_del_empty = false;
								break;

							// Skip
							case 3:
								continue;
								break;

							// Skip all
							case 4:
								skip_all_del_emptydir = true;
								continue;
								break;
							}
						}
						f->showProgressDialog();
                    }
                }

                // If we don't have permission to write to the file
                if (!::isWritable(pathname))
                {
                    // Overwrite dialog if necessary
                    if (!(overwrite_all | skip_all))
                    {
                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("File %s is write-protected, delete it anyway?"), pathname.text());
  
  						if (num == 1)
  						{
                        	OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							if (answer == 1)
							{
								overwrite = true;
							}
							else
							{
								goto end;
							}							
						}
  
 						else
 						{
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Yes
							case 1:
								overwrite = true;
								break;

							// Yes for all
							case 2:
								overwrite_all = true;
								break;

							// Skip
							case 3:
								overwrite = false;
								break;

							// Skip all
							case 4:
								skip_all = true;
								break;
							}
						} 
                    }
                    if ((overwrite | overwrite_all) & !skip_all)
                    {
                        // Caution!! Don't delete parent directory!!
                        if (filename != "..")
                        {
                            // Definitively remove file or folder
                            f->remove(pathname);
                        }
                    }
                    f->showProgressDialog();
                }

                // If we have permission to write
                else
                {
                    // Caution!! Don't delete parent directory!!
                    if (filename != "..")
                    {
                        // Definitively remove file or folder
                        f->remove(pathname);

                        // If is located at trash location, try to also remove the corresponding trashinfo file if it exists
                        // Do it silently and don't report any error if it fails
                        FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                        if (use_trash_can && (pathname.left(trashfileslocation.length()) == trashfileslocation))
                        {
                            FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+filename+".trashinfo";
                            ::unlink(trashinfopathname.text());
                        }
                    }
                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Delete file operation cancelled!"));
                        break;
                    }
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// View/Edit files
long FilePanel::onCmdEdit(FXObject*, FXSelector s, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString   pathname, samecmd, cmd, cmdname, itemslist = " ";
    FileAssoc* association;
    FXbool     same = true;
    FXbool     first = true;

    current->list->setFocus();

    if (current->list->getNumSelectedItems() == 0)
    {
        getApp()->endWaitCursor();
        return(0);
    }

    FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
    FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
    FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
    FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
    FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
    FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
    FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
    FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

    // Update associations dictionary
    FileDict* assocdict = new FileDict(getApp());

    // Check if all files have the same association
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            // Increment number of selected items
            pathname = current->list->getItemPathname(u);
            association = assocdict->findFileBinding(pathname.text());

            // If there is an association
            if (association)
            {
                // Use it to edit/view the files
                if (FXSELID(s) == ID_EDIT) // Edit
                {
                    cmd = association->command.section(',', 2);

                    // Use a default editor if possible
                    switch (progs[cmd])
                    {
                    case TXTEDITOR:
                        cmd = txteditor;
                        break;

                    case IMGEDITOR:
                        cmd = imgeditor;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No default editor found
                        ;
                        break;
                    }

                    if (cmd.length() == 0)
                    {
                        cmd = txteditor;
                    }
                }
                else // Any other is View
                {
                    cmd = association->command.section(',', 1);

                    // Use a default viewer if possible
                    switch (progs[cmd])
                    {
                    case TXTVIEWER:
                        cmd = txtviewer;
                        break;

                    case IMGVIEWER:
                        cmd = imgviewer;
                        break;

                    case PDFVIEWER:
                        cmd = pdfviewer;
                        break;

                    case AUDIOPLAYER:
                        cmd = audioplayer;
                        break;

                    case VIDEOPLAYER:
                        cmd = videoplayer;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No default viewer found
                        ;
                        break;
                    }

                    if (cmd.length() == 0)
                    {
                        cmd = txtviewer;
                    }
                }
                if (cmd.text() != NULL)
                {
                    // First selected item
                    if (first)
                    {
                        samecmd = cmd;
                        first = false;
                    }

                    if (samecmd != cmd)
                    {
                        same = false;
                        break;
                    }

                    // List of selected items
                    itemslist += ::quote(pathname) + " ";
                }
                else
                {
                    same = false;
                    break;
                }
            }

            // No association
            else
            {
                same = false;
                break;
            }
        }
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // Same association for all files : execute the associated or default editor or viewer
    if (same)
    {
        cmdname = samecmd;

        // If command exists, run it
        if (::existCommand(cmdname))
        {
            cmd = cmdname+itemslist;
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
        }
    }

    // Files have different associations : handle them separately
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);

                // Only View / Edit regular files (not directories)
                if (::isFile(pathname))
                {
                    association = assocdict->findFileBinding(pathname.text());

                    // If there is an association
                    if (association)
                    {
                        // Use it to edit/view the file
                        if (FXSELID(s) == ID_EDIT) // Edit
                        {
                            cmd = association->command.section(',', 2);

                            // Use a default editor if possible
                            switch (progs[cmd])
                            {
                            case TXTEDITOR:
                                cmd = txteditor;
                                break;

                            case IMGEDITOR:
                                cmd = imgeditor;
                                break;

                            case ARCHIVER:
                                cmd = archiver;
                                break;
                            }

                            if (cmd.length() == 0)
                            {
                                cmd = txteditor;
                            }
                        }
                        else // Any other is View
                        {
                            cmd = association->command.section(',', 1);

                            // Use a default viewer if possible
                            switch (progs[cmd])
                            {
                            case TXTVIEWER:
                                cmd = txtviewer;
                                break;

                            case IMGVIEWER:
                                cmd = imgviewer;
                                break;

                            case PDFVIEWER:
                                cmd = pdfviewer;
                                break;

                            case AUDIOPLAYER:
                                cmd = audioplayer;
                                break;

                            case VIDEOPLAYER:
                                cmd = videoplayer;
                                break;

                            case ARCHIVER:
                                cmd = archiver;
                                break;

                            case NONE: // No default viewer found
                                ;
                                break;
                            }

                            if (cmd.length() == 0)
                            {
                                cmd = txtviewer;
                            }
                        }

                        if (cmd.text() != NULL)
                        {
                            cmdname = cmd;

                            // If command exists, run it
                            if (::existCommand(cmdname))
                            {
                                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                            }

                            // If command does not exist, call the "Open with..." dialog
                            else
                            {
                                getApp()->endWaitCursor();
                                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                            }
                        }
                    }

                    // No association
                    else
                    {
                        if (FXSELID(s) == ID_EDIT)
                        {
                            cmd = txteditor;
                        }
                        else
                        {
                            cmd = txtviewer;
                        }

                        cmdname = cmd;

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }
                }
            }
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Compare two files
long FilePanel::onCmdCompare(FXObject*, FXSelector s, void*)
{
    current->list->setFocus();
    int num = current->list->getNumSelectedItems();

    // Only one or two selected items can be handled
    if ((num != 1) && (num != 2))
    {
        getApp()->endWaitCursor();
        return(0);
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    FXString filecomparator = getApp()->reg().readStringEntry("PROGS", "filecomparator", DEFAULT_FILECOMPARATOR);
    FXString pathname, cmd, cmdname, itemslist = " ";

    // One selected item
    if (num == 1)
    {
        // Get the selected item
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                itemslist += ::quote(pathname) + " ";
            }
        }

        // Open a dialog to select the other item to be compared
        if (comparedialog == NULL)
        {
            comparedialog = new BrowseInputDialog(this, "", "", _("Compare"), _("With:"), bigcompareicon, BROWSE_INPUT_FILE);
        }
        comparedialog->setIcon(bigcompareicon);
        comparedialog->setMessage(pathname);
        comparedialog->setText("");
        int rc = 1;
        rc = comparedialog->execute(PLACEMENT_CURSOR);

        // Get item path and add it to the list
        FXString str = comparedialog->getText();
        itemslist += ::quote(str);
        if (!rc || (str == ""))
        {
            return(0);
        }
    }

    // Two selected items
    else if (num == 2)
    {
        // Get the two selected items
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                itemslist += ::quote(pathname) + " ";
            }
        }
    }

    // Wait cursor
    getApp()->beginWaitCursor();

    // If command exists, run it
    cmdname = filecomparator;
    if (::existCommand(cmdname))
    {
        cmd = cmdname+itemslist;
#ifdef STARTUP_NOTIFICATION
        runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
        runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
    }

    // If command does not exist, issue an error message
    else
    {
        getApp()->endWaitCursor();
        MessageBox::error(this, BOX_OK, _("Error"), _("Program %s not found. Please define a file comparator program in the Preferences dialog!"), cmdname.text());
    }

    getApp()->endWaitCursor();

    return(1);
}


// File or directory properties
long FilePanel::onCmdProperties(FXObject* sender, FXSelector, void*)
{
    int ret;
    int num, itm;

    current->list->setFocus();

    // If no selected files in the file list, use the selected folder from the tree list (if any)
    num = current->list->getNumSelectedItems(&itm);
    if (num == 0)
    {
		return(0);
    }

    // There is one selected file in the file list
    else if (num == 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        FXString path = current->list->getDirectory();
        FXString filename = current->list->getItemText(itm);
        filename = filename.section('\t', 0);
        PropertiesBox* attrdlg = new PropertiesBox(this, filename, path);
        attrdlg->create();
        attrdlg->show(PLACEMENT_OWNER);
    }

    // There are multiple selected files in the file list
    else if (num > 1)
    {
        ret = chdir(current->list->getDirectory().text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
            }

            return(0);
        }

        FXString  path = current->list->getDirectory();
        FXString* files = new FXString[num];
        FXString* paths = new FXString[num];

        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        int i = 0;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                files[i] = current->list->getItemText(u).section('\t', 0);
                paths[i] = path;
                i++;
            }
        }

        PropertiesBox* attrdlg = new PropertiesBox(this, files, num, paths);
        attrdlg->create();
        attrdlg->show(PLACEMENT_OWNER);
        
        ret = chdir(startlocation.text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
            }

            return(0);
        }
    }

    // Force panel refresh
    return(1);
}


// Create new directory
long FilePanel::onCmdNewDir(FXObject*, FXSelector, void*)
{
    FXString dirname = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString dirpath = current->list->getDirectory();
    if (dirpath != ROOTDIR)
    {
        dirpath += PATHSEPSTRING;
    }

    if (newdirdialog == NULL)
    {
        newdirdialog = new InputDialog(this, "", _("Create new folder:"), _("New Folder"),"",bignewfoldericon);
    }
    newdirdialog->setText("");

    // Accept was pressed
    if (newdirdialog->execute(PLACEMENT_CURSOR))
    {
        if (newdirdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("Folder name is empty, operation cancelled"));
            return(0);
        }

		// Directory name contains '/'
		if (newdirdialog->getText().contains(PATHSEPCHAR))
		{
			MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in folder names, operation cancelled"));
			return(0);
		}

        dirname = dirpath+newdirdialog->getText();
        if (dirname != dirpath)
        {
            // Create the new dir according to the current umask
            int mask;
            mask = umask(0);
            umask(mask);

            // Note that the umask value is in decimal (511 means octal 0777)
            errno = 0;
            int ret = ::mkdir(dirname.text(), 511 & ~mask);
            int errcode = errno;
            if (ret == -1)
            {
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s: %s"), dirname.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s"), dirname.text());
                }
                return(0);
            }
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == dirname)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Create new file
long FilePanel::onCmdNewFile(FXObject*, FXSelector, void*)
{
    FXString filename = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString pathname = current->list->getDirectory();
    if (pathname != ROOTDIR)
    {
        pathname += PATHSEPSTRING;
    }

    if (newfiledialog == NULL)
    {
        newfiledialog = new InputDialog(this, "", _("Create new file:"), _("New File"), "", bignewfileicon, false);
    }
    newfiledialog->setText("");

    // Accept was pressed
    if (newfiledialog->execute(PLACEMENT_CURSOR))
    {
        if (newfiledialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

		// File name contains '/'
		if (newfiledialog->getText().contains(PATHSEPCHAR))
		{
			MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in file names, operation cancelled"));
			return(0);
		}

        filename = pathname+newfiledialog->getText();
        FILE* file;
        if (filename != pathname)
        {
            // Test some error conditions
            if (::exists(filename))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("File or folder %s already exists"), filename.text());
                return(0);
            }
            // Create the new file
            errno = 0;
            if (!(file = fopen(filename.text(), "w+")) || fclose(file))
            {
                if (errno)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create file %s: %s"), filename.text(), strerror(errno));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create file %s"), filename.text());
                }
                return(0);
            }
            // Change the file permissions according to the current umask
            int mask;
            mask = umask(0);
            umask(mask);
            errno = 0;
            int rc = chmod(filename.text(), 438 & ~mask);
            int errcode = errno;
            if (rc)
            {
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't set permissions in %s: %s"), filename.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't set permissions in %s"), filename.text());
                }
            }
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == filename)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Create new symbolic link
long FilePanel::onCmdNewSymlink(FXObject*, FXSelector, void*)
{
    FXString linkname = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString linkpath = current->list->getDirectory();
    if (linkpath != ROOTDIR)
    {
        linkpath += PATHSEPSTRING;
    }

    if (newlinkdialog == NULL)
    {
        newlinkdialog = new InputDialog(this, "", _("Create new symbolic link:"), _("New Symlink"), "", bignewlinkicon, false);
    }
    newlinkdialog->setText("");

    // Accept was pressed
    if (newlinkdialog->execute(PLACEMENT_CURSOR))
    {
        if (newlinkdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }
        linkname = linkpath+newlinkdialog->getText();
        File* f;
        if (linkname != linkpath)
        {
            // Test some error conditions
            if (::exists(linkname))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("File or folder %s already exists"), linkname.text());
                return(0);
            }

            // Select target
            FileDialog browse(this, _("Select the symlink refered file or folder"));
            browse.setDirectory(linkpath);
            browse.setSelectMode(SELECT_FILE_MIXED);
            if (browse.execute())
            {
                FXString linksource = browse.getFilename();

                // Source does not exist
                if (!::exists(linksource))
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Symlink source %s does not exist"), linksource.text());
                    return(0);
                }

                f = new File(this, _("Symlink"), SYMLINK);
                f->create();
                f->symlink(linksource, linkname);
                delete f;
            }
            //else
            //return 0;
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == linkname)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Open single or multiple files
long FilePanel::onCmdOpen(FXObject*, FXSelector, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString   pathname, samecmd, cmd, cmdname, itemslist = " ";
    FileAssoc* association;
    FXbool     same = true;
    FXbool     first = true;

    current->list->setFocus();
    if (current->list->getNumSelectedItems() == 0)
    {
        getApp()->endWaitCursor();
        return(0);
    }

    // Default programs
    FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
    FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
    FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
    FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
    FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
    FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
    FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
    FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

    // Update associations dictionary
    FileDict* assocdict = new FileDict(getApp());

    // Check if all files have the same association
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            // Increment number of selected items
            pathname = current->list->getItemPathname(u);

            // If directory, skip it
            if (::isDirectory(pathname))
            {
                continue;
            }

            // If association found
            association = assocdict->findFileBinding(pathname.text());
            if (association)
            {
                cmd = association->command.section(',', 0);

                // Use a default program if possible
                switch (progs[cmd])
                {
                case TXTVIEWER:
                    cmd = txtviewer;
                    break;

                case TXTEDITOR:
                    cmd = txteditor;
                    break;

                case IMGVIEWER:
                    cmd = imgviewer;
                    break;

                case IMGEDITOR:
                    cmd = imgeditor;
                    break;

                case PDFVIEWER:
                    cmd = pdfviewer;
                    break;

                case AUDIOPLAYER:
                    cmd = audioplayer;
                    break;

                case VIDEOPLAYER:
                    cmd = videoplayer;
                    break;

                case ARCHIVER:
                    cmd = archiver;
                    break;

                case NONE: // No program found
                    ;
                    break;
                }

                if (cmd != "")
                {
                    // First selected item
                    if (first)
                    {
                        samecmd = cmd;
                        first = false;
                    }

                    if (samecmd != cmd)
                    {
                        same = false;
                        break;
                    }

                    // List of selected items
                    itemslist += ::quote(pathname) + " ";
                }
                else
                {
                    same = false;
                    break;
                }
            }
            else
            {
                same = false;
                break;
            }
        }
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // Same command for all files : open them
    if (same && (itemslist != " "))
    {
        cmdname = samecmd;

        // If command exists, run it
        if (::existCommand(cmdname))
        {
            cmd = samecmd+itemslist;
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
        }
    }

    // Files have different commands : handle them separately
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);

                // If directory, skip it
                if (::isDirectory(pathname))
                {
                    continue;
                }

                association = assocdict->findFileBinding(pathname.text());
                if (association)
                {
                    // Use association to open the file
                    cmd = association->command.section(',', 0);

                    // Use a default program if possible
                    switch (progs[cmd])
                    {
                    case TXTVIEWER:
                        cmd = txtviewer;
                        break;

                    case TXTEDITOR:
                        cmd = txteditor;
                        break;

                    case IMGVIEWER:
                        cmd = imgviewer;
                        break;

                    case IMGEDITOR:
                        cmd = imgeditor;
                        break;

                    case PDFVIEWER:
                        cmd = pdfviewer;
                        break;

                    case AUDIOPLAYER:
                        cmd = audioplayer;
                        break;

                    case VIDEOPLAYER:
                        cmd = videoplayer;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No program found
                        ;
                        break;
                    }

                    if (cmd != "")
                    {
                        cmdname = cmd;

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // Or execute the file
                    else if (current->list->isItemExecutable(u))
                    {
                        execFile(pathname);
                    }

                    // Or call the "Open with..." dialog
                    else
                    {
                        getApp()->endWaitCursor();
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }

                // If no association but executable
                else if (current->list->isItemExecutable(u))
                {
                    execFile(pathname);
                }

                // Other cases
                else
                {
                    getApp()->endWaitCursor();
                    current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                }
            }
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Open with
long FilePanel::onCmdOpenWith(FXObject*, FXSelector, void*)
{
    char** str = NULL;

    current->list->setFocus();

    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    FXString cmd = "", cmdname;
    if (opendialog == NULL)
    {
        opendialog = new HistInputDialog(this, "", _("Open selected file(s) with:"), _("Open With"), "", bigfileopenicon, HIST_INPUT_EXECUTABLE_FILE, true, _("A&ssociate"));
    }
    opendialog->setText(cmd);

    // Dialog with history list and associate checkbox
    opendialog->CursorEnd();
    opendialog->selectAll();
    opendialog->clearItems();
    for (int i = 0; i < OpenNum; i++)
    {
        opendialog->appendItem(OpenHistory[i]);
    }
    opendialog->setDirectory(ROOTDIR);
    opendialog->sortItems();
    if (opendialog->execute())
    {
        cmd = opendialog->getText();
        if (cmd == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Handles "associate" checkbox for "open with..." dialog
                if (opendialog->getOption())
                {
                    FXString filename = current->list->getItemFilename(u);
                    FXString ext = filename.rafter('.', 2).lower();

                    if ((ext == "tar.gz") || (ext == "tar.bz2") || (ext == "tar.xz") || (ext == "tar.z")) // Special cases
                    {
                    }
                    else
                    {
                        ext = FXPath::extension(filename).lower();
                    }

                    if (ext == "")
                    {
                        ext = FXPath::name(filename);
                    }

                    FileAssoc* association = current->list->getItemAssoc(u);

                    if (association)
                    {
                        // Update existing association
                        FXString oldfileassoc = getApp()->reg().readStringEntry("FILETYPES", ext.text(), "");
                        oldfileassoc.erase(0, oldfileassoc.section(';', 0).section(',', 0).length());
                        oldfileassoc.prepend(opendialog->getText());
                        getApp()->reg().writeStringEntry("FILETYPES", ext.text(), oldfileassoc.text());

                        // Handle file association
                        str = new char* [2];
                        str[0] = new char[strlen(ext.text())+1];
                        str[1] = new char[strlen(oldfileassoc.text())+1];
                        strlcpy(str[0], ext.text(), ext.length()+1);
                        strlcpy(str[1], oldfileassoc.text(), oldfileassoc.length()+1);
                        mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ASSOC), str);
                    }
                    else
                    {
                        // New association
                        FXString newcmd = opendialog->getText().append(";Document;;;;");
                        getApp()->reg().writeStringEntry("FILETYPES", ext.text(), newcmd.text());

                        // Handle file association
                        str = new char* [2];
                        str[0] = new char[strlen(ext.text())+1];
                        str[1] = new char[strlen(newcmd.text())+1];
                        strlcpy(str[0], ext.text(), ext.length()+1);
                        strlcpy(str[1], newcmd.text(), newcmd.length()+1);
                        mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ASSOC), str);
                    }
                }
                // End

                FXString pathname = current->list->getItemPathname(u);
                cmdname = cmd;
                cmd += " ";
                cmd = cmd+::quote(pathname);
            }
        }

        // Run command if it exists
        getApp()->beginWaitCursor();

#ifdef STARTUP_NOTIFICATION
        // Startup notification option and exceptions (if any)
        FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
        FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

        // If command exists, run it
        if (::existCommand(cmdname))
#ifdef STARTUP_NOTIFICATION
        {
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
        }
#else
        {
            runcmd(cmd, current->list->getDirectory(), startlocation);
        }
#endif
        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
            return(1);
        }

        // Update history list
        OpenNum = opendialog->getHistorySize();
        cmd = opendialog->getText();

        // Check if cmd is a new string, i.e. is not already in history
        FXbool newstr = true;
        for (int i = 0; i < OpenNum-1; i++)
        {
            if (streq(OpenHistory[i], cmd.text()))
            {
                newstr = false;
                break;
            }
        }

        // History limit reached
        if (OpenNum > OPEN_HIST_SIZE)
        {
            OpenNum--;
        }

        // Restore original history order
        opendialog->clearItems();
        for (int i = 0; i < OpenNum; i++)
        {
            opendialog->appendItem(OpenHistory[i]);
		}

        // New string
        if (newstr)
        {
            // FIFO
            strlcpy(OpenHistory[0], cmd.text(), cmd.length()+1);
            for (int i = 1; i < OpenNum; i++)
            {
                strlcpy(OpenHistory[i], opendialog->getHistoryItem(i-1).text(), opendialog->getHistoryItem(i-1).length()+1);
            }
        }

        getApp()->endWaitCursor();
    }

    return(1);
}


long FilePanel::onCmdItemFilter(FXObject* o, FXSelector sel, void*)
{
    if (FilterNum == 0)
    {
        strlcpy(FilterHistory[FilterNum], "*", 2);
        FilterNum++;
    }

    int      i;
    FXString pat = list->getPattern();
    if (filterdialog == NULL)
    {
        filterdialog = new HistInputDialog(this, pat, _("Show files:"), _("Filter"), "", bigfiltericon, HIST_INPUT_FILE);
    }
    filterdialog->CursorEnd();
    filterdialog->selectAll();
    filterdialog->clearItems();
    for (int i = 0; i < FilterNum; i++)
    {
        filterdialog->appendItem(FilterHistory[i]);
    }
    filterdialog->sortItems();

    if (filterdialog->execute() && ((pat = filterdialog->getText()) != ""))
    {
        // Change file list patten
        if (FXSELID(sel) == ID_FILTER_CURRENT)
        {
            current->list->setPattern(pat);
        }
        else
        {
            list->setPattern(pat);
        }

        FXbool newstr = true;
        for (i = 0; i < FilterNum; i++)
        {
            if (streq(FilterHistory[i], pat.text()))
            {
                newstr = false;
                break;
            }
        }
        // Append new string to the list bottom
        if (newstr && (FilterNum < FILTER_HIST_SIZE))
        {
            strlcpy(FilterHistory[FilterNum], pat.text(), pat.length()+1);
            FilterNum++;
        }
    }

    list->setFocus();
    return(1);
}


// Panel context menu
long FilePanel::onCmdPopupMenu(FXObject* o, FXSelector s, void* p)
{
    // Make panel active
    setActive();

    // Check if control key or Shift-F10 or menu was pressed
    if (p != NULL)
    {
        FXEvent* event = (FXEvent*)p;
        if (event->state&CONTROLMASK)
        {
            ctrl = true;
        }
        if ((event->state&SHIFTMASK && event->code == KEY_F10) || event->code == KEY_Menu)
        {
            shiftf10 = true;
        }
    }

    // Use to select the item under cursor when right clicking
    // Only when Shift-F10 was not pressed
    if (!shiftf10 && (list->getNumSelectedItems() <= 1))
    {
        int    x, y;
        FXuint state;
        list->getCursorPosition(x, y, state);

        int item = list->getItemAt(x, y);

        if (list->getCurrentItem() >= 0)
        {
            list->deselectItem(list->getCurrentItem());
        }
        if (item >= 0)
        {
            list->setCurrentItem(item);
            list->selectItem(item);
        }
    }

    // If first item (i.e. the '..' item)
    if ((list->getNumSelectedItems() == 1) && list->isItemSelected(0))
    {
        ctrl = true;
    }

    // If control flag is set, deselect all items
    if (ctrl)
    {
        list->handle(o, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), p);
    }

    // Popup menu pane
    FXMenuPane* menu = new FXMenuPane(this);
    int         x, y;
    FXuint      state;
    getRoot()->getCursorPosition(x, y, state);

    int num, itm;
    num = current->list->getNumSelectedItems(&itm);

    // No selection or control flag set
    if ((num == 0) || current->ctrl)
    {
        // Menu items
        new FXMenuCommand(menu, _("New& file..."), NULL, current, FilePanel::ID_NEW_FILE);
        new FXMenuCommand(menu, _("New f&older..."), NULL, current, FilePanel::ID_NEW_DIR);
        new FXMenuCommand(menu, _("New s&ymlink..."), NULL, current, FilePanel::ID_NEW_SYMLINK);
        new FXMenuCommand(menu, _("Fi&lter..."), NULL, current, FilePanel::ID_FILTER);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(menu);
        new FXMenuCheck(menu, _("&Hidden files"), current->list, FileList::ID_TOGGLE_HIDDEN);
        new FXMenuCheck(menu, _("Thum&bnails"), current->list, FileList::ID_TOGGLE_THUMBNAILS);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("B&ig icons"), current->list, IconList::ID_SHOW_BIG_ICONS);
        new FXMenuRadio(menu, _("&Small icons"), current->list, IconList::ID_SHOW_MINI_ICONS);
        new FXMenuRadio(menu, _("&Full file list"), current->list, IconList::ID_SHOW_DETAILS);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("&Rows"), current->list, FileList::ID_ARRANGE_BY_ROWS);
        new FXMenuRadio(menu, _("&Columns"), current->list, FileList::ID_ARRANGE_BY_COLUMNS);
        new FXMenuCheck(menu, _("Autosize"), current->list, FileList::ID_AUTOSIZE);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("&Name"), current->list, FileList::ID_SORT_BY_NAME);
        new FXMenuRadio(menu, _("Si&ze"), current->list, FileList::ID_SORT_BY_SIZE);
        new FXMenuRadio(menu, _("&Type"), current->list, FileList::ID_SORT_BY_TYPE);
        new FXMenuRadio(menu, _("E&xtension"), current->list, FileList::ID_SORT_BY_EXT);
        new FXMenuRadio(menu, _("&Date"), current->list, FileList::ID_SORT_BY_TIME);
        new FXMenuRadio(menu, _("&User"), current->list, FileList::ID_SORT_BY_USER);
        new FXMenuRadio(menu, _("&Group"), current->list, FileList::ID_SORT_BY_GROUP);
        new FXMenuRadio(menu, _("Per&missions"), current->list, FileList::ID_SORT_BY_PERM);
        new FXMenuRadio(menu, _("Deletion date"), current->list, FileList::ID_SORT_BY_DELTIME);
        new FXMenuSeparator(menu);
        new FXMenuCheck(menu, _("Ignore c&ase"), current->list, FileList::ID_SORT_CASE);
        new FXMenuCheck(menu, _("Fold&ers first"), current->list, FileList::ID_DIRS_FIRST);
        new FXMenuCheck(menu, _("Re&verse order"), current->list, FileList::ID_SORT_REVERSE);
    }
    // Non empty selection
    else
    {
        // Deselect the '..' item
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        // Panel submenu items
        FXMenuPane* submenu = new FXMenuPane(this);
        new FXMenuCommand(submenu, _("Ne&w file..."), NULL, current, FilePanel::ID_NEW_FILE);
        new FXMenuCommand(submenu, _("New f&older..."), NULL, current, FilePanel::ID_NEW_DIR);
        new FXMenuCommand(submenu, _("New s&ymlink..."), NULL, current, FilePanel::ID_NEW_SYMLINK);
        new FXMenuCommand(submenu, _("Fi&lter..."), NULL, current, FilePanel::ID_FILTER);
        new FXMenuSeparator(submenu);
        new FXMenuCommand(submenu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(submenu);
        new FXMenuCheck(submenu, _("&Hidden files"), current->list, FileList::ID_TOGGLE_HIDDEN);
        new FXMenuCheck(submenu, _("Thum&bnails"), current->list, FileList::ID_TOGGLE_THUMBNAILS);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("B&ig icons"), current->list, IconList::ID_SHOW_BIG_ICONS);
        new FXMenuRadio(submenu, _("&Small icons"), current->list, IconList::ID_SHOW_MINI_ICONS);
        new FXMenuRadio(submenu, _("&Full file list"), current->list, IconList::ID_SHOW_DETAILS);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("&Rows"), current->list, FileList::ID_ARRANGE_BY_ROWS);
        new FXMenuRadio(submenu, _("&Columns"), current->list, FileList::ID_ARRANGE_BY_COLUMNS);
        new FXMenuCheck(submenu, _("Autosize"), current->list, FileList::ID_AUTOSIZE);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("&Name"), current->list, FileList::ID_SORT_BY_NAME);
        new FXMenuRadio(submenu, _("Si&ze"), current->list, FileList::ID_SORT_BY_SIZE);
        new FXMenuRadio(submenu, _("&Type"), current->list, FileList::ID_SORT_BY_TYPE);
        new FXMenuRadio(submenu, _("E&xtension"), current->list, FileList::ID_SORT_BY_EXT);
        new FXMenuRadio(submenu, _("&Date"), current->list, FileList::ID_SORT_BY_TIME);
        new FXMenuRadio(submenu, _("&User"), current->list, FileList::ID_SORT_BY_USER);
        new FXMenuRadio(submenu, _("&Group"), current->list, FileList::ID_SORT_BY_GROUP);
        new FXMenuRadio(submenu, _("Per&missions"), current->list, FileList::ID_SORT_BY_PERM);
        new FXMenuRadio(submenu, _("Deletion date"), current->list, FileList::ID_SORT_BY_DELTIME);
        new FXMenuSeparator(submenu);
        new FXMenuCheck(submenu, _("Ignore c&ase"), current->list, FileList::ID_SORT_CASE);
        new FXMenuCheck(submenu, _("Fold&ers first"), current->list, FileList::ID_DIRS_FIRST);
        new FXMenuCheck(submenu, _("Re&verse order"), current->list, FileList::ID_SORT_REVERSE);
        new FXMenuCascade(menu, _("Pane&l"), NULL, submenu);
        new FXMenuSeparator(menu);

#if defined(linux)
        FXString name = current->list->getItemPathname(itm);
        if ((num == 1) && (fsdevices->find(name.text()) || mtdevices->find(name.text())))
        {
            new FXMenuCommand(menu, _("&Mount"), NULL, current, FilePanel::ID_MOUNT);
            new FXMenuCommand(menu, _("Unmount"), NULL, current, FilePanel::ID_UMOUNT);
            new FXMenuSeparator(menu);
        }
#endif

        FXbool ar = false;
        if (current->list->getItem(itm) && current->list->isItemFile(itm))
        {
            new FXMenuCommand(menu, _("Open &with..."), NULL, current, FilePanel::ID_OPEN_WITH);
            new FXMenuCommand(menu, _("&Open"), NULL, current, FilePanel::ID_OPEN);
            FXString name = current->list->getItemText(itm).section('\t', 0);

            // Last and before last file extensions
            FXString ext1 = name.rafter('.', 1).lower();
            FXString ext2 = name.rafter('.', 2).lower();

            // Destination folder name
            FXString extract_to_folder;
            if ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z"))
            {
                extract_to_folder = _("Extr&act to folder ")+name.section('\t', 0).rbefore('.', 2);
            }
            else
            {
                extract_to_folder = _("Extr&act to folder ")+name.section('\t', 0).rbefore('.', 1);
            }

            // Display the extract and package menus according to the archive extensions
            if ((num == 1) && ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
                new FXMenuCommand(menu, extract_to_folder, NULL, current, FilePanel::ID_EXTRACT_TO_FOLDER);
                new FXMenuCommand(menu, _("E&xtract to..."), NULL, current, FilePanel::ID_EXTRACT);
            }
            else if ((num == 1) && ((ext1 == "gz") || (ext1 == "bz2") || (ext1 == "xz") || (ext1 == "z")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
            }
            else if ((num == 1) && ((ext1 == "tar") || (ext1 == "tgz") || (ext1 == "tbz2") || (ext1 == "tbz") || (ext1 == "taz") || (ext1 == "txz") || (ext1 == "zip") || (ext1 == "7z") || (ext1 == "lzh") || (ext1 == "rar") || (ext1 == "ace") || (ext1 == "arj")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
                new FXMenuCommand(menu, extract_to_folder, NULL, current, FilePanel::ID_EXTRACT_TO_FOLDER);
                new FXMenuCommand(menu, _("E&xtract to..."), NULL, current, FilePanel::ID_EXTRACT);
            }
#if defined(linux)
            else if ((num == 1) && ((ext1 == "rpm") || (ext1 == "deb")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&View"), NULL, current, FilePanel::ID_VIEW);
                new FXMenuCommand(menu, _("Install/Up&grade"), NULL, current, ID_PKG_INSTALL);
                new FXMenuCommand(menu, _("Un&install"), NULL, current, ID_PKG_UNINSTALL);
            }
#endif
            // Not archive nor package
            if (!ar)
            {
                new FXMenuCommand(menu, _("&View"), NULL, current, FilePanel::ID_VIEW);
                new FXMenuCommand(menu, _("&Edit"), NULL, current, FilePanel::ID_EDIT);
                if (num == 1)
                {
                    new FXMenuCommand(menu, _("Com&pare..."), NULL, current, FilePanel::ID_COMPARE);
                }
                else
                {
                    new FXMenuCommand(menu, _("Com&pare"), NULL, current, FilePanel::ID_COMPARE);
                }
            }
        }
        if (!ar)
        {
            new FXMenuCommand(menu, _("&Add to archive..."), NULL, current, FilePanel::ID_ADD_TO_ARCH);
        }
#if defined(linux)
        if ((num == 1) && !ar)
        {
            new FXMenuCommand(menu, _("Packages &query "), NULL, current, FilePanel::ID_PKG_QUERY);
        }
#endif

        // Build scripts menu
        new FXMenuSeparator(menu);
        FXString    scriptpath = homedir + PATHSEPSTRING CONFIGPATH PATHSEPSTRING XFECONFIGPATH PATHSEPSTRING SCRIPTPATH;
        FXMenuPane* scriptsmenu = new FXMenuPane(this);
        new FXMenuCascade(menu, _("Scripts"), NULL, scriptsmenu);
        readScriptDir(scriptsmenu, scriptpath);
        new FXMenuSeparator(scriptsmenu);
        new FXMenuCommand(scriptsmenu, _("&Go to script folder"), NULL, this, FilePanel::ID_GO_SCRIPTDIR);

        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("&Copy"), NULL, current, FilePanel::ID_COPY_CLIPBOARD);
        new FXMenuCommand(menu, _("C&ut"), NULL, current, FilePanel::ID_CUT_CLIPBOARD);
        new FXMenuCommand(menu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("Re&name..."), NULL, current, FilePanel::ID_FILE_RENAME);
        new FXMenuCommand(menu, _("Copy &to..."), NULL, current, FilePanel::ID_FILE_COPYTO);
        new FXMenuCommand(menu, _("&Move to..."), NULL, current, FilePanel::ID_FILE_MOVETO);
        new FXMenuCommand(menu, _("Symlin&k to..."), NULL, current, FilePanel::ID_FILE_SYMLINK);
        new FXMenuCommand(menu, _("M&ove to trash"), NULL, current, FilePanel::ID_FILE_TRASH);
        new FXMenuCommand(menu, _("Restore &from trash"), NULL, current, FilePanel::ID_FILE_RESTORE);
        new FXMenuCommand(menu, _("&Delete"), NULL, current, FilePanel::ID_FILE_DELETE);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("Compare &sizes"), NULL, current, FilePanel::ID_DIR_USAGE);
        new FXMenuCommand(menu, _("P&roperties"), NULL, current, FilePanel::ID_PROPERTIES);
    }
    menu->create();

    // Reset flags
    ctrl = false;
    shiftf10 = false;
    allowPopupScroll = true;  // Allow keyboard scrolling


    menu->popup(NULL, x, y);
    getApp()->runModalWhileShown(menu);
    allowPopupScroll = false;

    return(1);
}


// Read all executable file names that are located into the script directory
// Sort entries alphabetically, directories first
int FilePanel::readScriptDir(FXMenuPane* scriptsmenu, FXString dir)
{
    DIR* dp;
    struct dirent** namelist;

    // Open directory
    if ((dp = opendir(dir.text())) == NULL)
    {
        return(0);
    }

    // Eventually add a / at the end of the directory name
    if (dir[dir.length()-1] != '/')
    {
        dir = dir+"/";
    }

	// First, read only directory entries and sort them alphabetically
    int n;
    n = scandir(dir.text(), &namelist, NULL, alphasort);
    if (n < 0)
    {
        perror("scandir");
    }
    else
    {
        for (int k = 0; k < n; k++)
        {
            // Avoid hidden directories and '.' and '..'
            if (namelist[k]->d_name[0] != '.')
            {
                FXString pathname = dir + namelist[k]->d_name;

                // Recurse if non empty directory
                if (::isDirectory(pathname))
                {
                    if (!::isEmptyDir(pathname))
                    {
                        FXMenuPane* submenu = new FXMenuPane(this);
                        new FXMenuCascade(scriptsmenu, namelist[k]->d_name, NULL, submenu);
                        readScriptDir(submenu, pathname);
                    }
                }
            }
            free(namelist[k]);
        }
        free(namelist);
    }

	// Then, read only executable files and sort them alphabetically
    n = scandir(dir.text(), &namelist, NULL, alphasort);
    if (n < 0)
    {
        perror("scandir");
    }
    else
    {
        for (int k = 0; k < n; k++)
        {
			// Add only executable files to the list
			FXString pathname = dir + namelist[k]->d_name;
			if (!::isDirectory(pathname) && isReadExecutable(pathname))
			{
				new FXMenuCommand(scriptsmenu, namelist[k]->d_name + FXString("\t\t") + pathname, miniexecicon, this, FilePanel::ID_RUN_SCRIPT);
			}
            free(namelist[k]);
        }
        free(namelist);
    }

    // Close directory
    (void)closedir(dp);

    return(1);
}


// Run Terminal in the selected directory
long FilePanel::onCmdXTerm(FXObject*, FXSelector, void*)
{
    int ret;

    getApp()->beginWaitCursor();
    ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
        }

        return(0);
    }

    FXString cmd = getApp()->reg().readStringEntry("PROGS", "xterm", "xterm -sb");
    cmd += " &";
    ret = system(cmd.text());
    if (ret < 0)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Can't execute command %s"), cmd.text());
    }

    current->list->setFocus();
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }

        return(0);
    }

    getApp()->endWaitCursor();
    return(1);
}


// Add files or directory to an archive
long FilePanel::onCmdAddToArch(FXObject* o, FXSelector, void*)
{
    int      ret;
    FXString name, ext1, ext2, cmd, archive = "";
    File*    f;

    ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), list->getDirectory().text());
        }

        return(0);
    }

    // Eventually deselect the '..' directory
    if (current->list->isItemSelected(0))
    {
        current->list->deselectItem(0);
    }

    // Return if nothing is selected
    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    // If only one item is selected, use its name as a starting guess for the archive name
    if (current->list->getNumSelectedItems() == 1)
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                name = current->list->getItemFilename(u);
                break;
            }
        }
        archive = name;
    }

    // Initial archive name with full path and default extension
    FXString archpath = current->list->getDirectory();
    if (archpath == PATHSEPSTRING)
    {
        archive = archpath+archive+".tar.gz";
    }
    else
    {
        archive = archpath+PATHSEPSTRING+archive+".tar.gz";
    }

    // Archive dialog
    if (archdialog == NULL)
    {
        archdialog = new ArchInputDialog(this, "");
    }
    archdialog->setText(archive);
    archdialog->CursorEnd();

    if (archdialog->execute())
    {
        if (archdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

        // Get string and preserve escape characters
        archive = ::quote(archdialog->getText());

        // Get extensions of the archive name
        ext1 = archdialog->getText().rafter('.', 1).lower();
        ext2 = archdialog->getText().rafter('.', 2).lower();

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zcvf "+archive+" ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jcvf "+archive+" ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jcvf "+archive+" ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zcvf "+archive+" ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -cvf "+archive+" ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zcvf "+archive+" ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zcvf "+archive+" ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "xz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jcvf "+archive+" ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jcvf "+archive+" ";
        }
        else if (ext1 == "z")
        {
            cmd = "compress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "zip -r "+archive+" ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z a "+archive+" ";
        }

        // Default archive format
        else
        {
            archive += ".tar.gz";
            cmd = "tar -zcvf "+archive+" ";
        }

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Don't include '..' in the list
                name = current->list->getItemFilename(u);
                if (name != "..")
                {
                    cmd += " ";
                    cmd = cmd+::quote(name);
                    cmd += " ";
                }
            }
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Create archive"), ARCHIVE);
        f->create();

        // Create archive
        f->archive(archive, cmd);
        ret = chdir(startlocation.text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
            }

            return(0);
        }

        getApp()->endWaitCursor();
        delete f;

        // Force panel refresh
        onCmdRefresh(0, 0, 0);
    }
    return(1);
}


// Extract archive
long FilePanel::onCmdExtract(FXObject*, FXSelector, void*)
{
    FXString name, ext1, ext2, cmd, dir, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    // File selection dialog
    FileDialog  browse(this, _("Select a destination folder"));
    const char* patterns[] =
    {
        _("All Files"), "*", NULL
    };
    browse.setDirectory(homedir);
    browse.setPatternList(patterns);
    browse.setSelectMode(SELECT_FILE_DIRECTORY);

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        // Archive name and extensions
        name = current->list->getItemText(item).text();

        ext1 = name.section('\t', 0).rafter('.', 1).lower();
        ext2 = name.section('\t', 0).rafter('.', 2).lower();
        name = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jxvf ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -xvf ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gunzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bunzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "unxz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jxvf ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext1 == "z")
        {
            cmd = "uncompress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "unzip -o ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z x -y ";
        }
        else if (ext1 == "rar")
        {
            cmd = "unrar x -o+ ";
        }
        else if (ext1 == "lzh")
        {
            cmd = "lha -xf ";
        }
        else if (ext1 == "ace")
        {
            cmd = "unace x ";
        }
        else if (ext1 == "arj")
        {
            cmd = "arj x -y ";
        }
        else
        {
            cmd = "tar -zxvf ";
        }

        // Final extract command
        cmd += name+" ";


        // Extract archive
        if (browse.execute())
        {
            dir = browse.getFilename();

            if (isWritable(dir))
            {
                // Wait cursor
                getApp()->beginWaitCursor();

                // File object
                f = new File(this, _("Extract archive"), EXTRACT);
                f->create();

                // Extract archive
                f->extract(name, dir, cmd);

                getApp()->endWaitCursor();
                delete f;
            }
            else
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
            }
        }
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Extract archive to a folder name based on the archive name
long FilePanel::onCmdExtractToFolder(FXObject*, FXSelector, void*)
{
    FXString name, pathname, ext1, ext2, cmd, dirname, dirpath, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        // Archive name and extensions
        name = current->list->getItemText(item).text();
        ext1 = name.section('\t', 0).rafter('.', 1).lower();
        ext2 = name.section('\t', 0).rafter('.', 2).lower();

        // Destination folder name
        if ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z"))
        {
            dirname = name.section('\t', 0).rbefore('.', 2);
        }
        else
        {
            dirname = name.section('\t', 0).rbefore('.', 1);
        }

        // Create the new dir according to the current umask
        // Don't complain if directory already exists
        int mask = umask(0);
        umask(mask);
        dirpath = cdir + PATHSEPSTRING + dirname;
        errno = 0;
        int ret = ::mkdir(dirpath.text(), 511 & ~mask);
        int errcode = errno;
        if ((ret == -1) && (errcode != EEXIST))
        {
            if (errcode)
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s: %s"), dirpath.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s"), dirpath.text());
            }
            return(0);
        }

        // Archive pathname
        pathname = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jxvf ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -xvf ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gunzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bunzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "unxz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jxvf ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext1 == "z")
        {
            cmd = "uncompress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "unzip -o ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z x -y ";
        }
        else if (ext1 == "rar")
        {
            cmd = "unrar x -o+ ";
        }
        else if (ext1 == "lzh")
        {
            cmd = "lha -xf ";
        }
        else if (ext1 == "ace")
        {
            cmd = "unace x ";
        }
        else if (ext1 == "arj")
        {
            cmd = "arj x -y ";
        }
        else
        {
            cmd = "tar -zxvf ";
        }

        // Final extract command
        cmd += pathname+" ";

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Extract archive"), EXTRACT);
        f->create();

        // Extract archive
        f->extract(pathname, dirpath, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Extract archive in the current directory
long FilePanel::onCmdExtractHere(FXObject*, FXSelector, void*)
{
    FXString name, ext1, ext2, cmd, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        if (isWritable(cdir))
        {
            // Archive name and extensions
            name = current->list->getItemText(item).text();
            ext1 = name.section('\t', 0).rafter('.', 1);
            lower();
            ext2 = name.section('\t', 0).rafter('.', 2).lower();
            name = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

            // Handle different archive formats
            if (ext2 == "tar.gz")
            {
                cmd = "tar -zxvf ";
            }
            else if (ext2 == "tar.bz2")
            {
                cmd = "tar -jxvf ";
            }
            else if (ext2 == "tar.xz")
            {
                cmd = "tar -Jxvf ";
            }
            else if (ext2 == "tar.z")
            {
                cmd = "tar -Zxvf ";
            }
            else if (ext1 == "tar")
            {
                cmd = "tar -xvf ";
            }
            else if (ext1 == "gz")
            {
                cmd = "gunzip -v ";
            }
            else if (ext1 == "tgz")
            {
                cmd = "tar -zxvf ";
            }
            else if (ext1 == "taz")
            {
                cmd = "tar -Zxvf ";
            }
            else if (ext1 == "bz2")
            {
                cmd = "bunzip2 -v ";
            }
            else if (ext1 == "xz")
            {
                cmd = "unxz -v ";
            }
            else if ((ext1 == "tbz2") || (ext1 == "tbz"))
            {
                cmd = "tar -jxvf ";
            }
            else if (ext1 == "txz")
            {
                cmd = "tar -Jxvf ";
            }
            else if (ext1 == "z")
            {
                cmd = "uncompress -v ";
            }
            else if (ext1 == "zip")
            {
                cmd = "unzip -o ";
            }
            else if (ext1 == "7z")
            {
                cmd = "7z x -y ";
            }
            else if (ext1 == "rar")
            {
                cmd = "unrar x -o+ ";
            }
            else if (ext1 == "lzh")
            {
                cmd = "lha -xf ";
            }
            else if (ext1 == "ace")
            {
                cmd = "unace x ";
            }
            else if (ext1 == "arj")
            {
                cmd = "arj x -y ";
            }
            else
            {
                cmd = "tar -zxvf ";
            }

            // Final extract command
            cmd += name+" ";

            // Wait cursor
            getApp()->beginWaitCursor();

            // File object
            f = new File(this, _("Extract archive"), EXTRACT);
            f->create();

            // Extract archive
            f->extract(name, cdir, cmd);

            getApp()->endWaitCursor();
            delete f;
        }
        else
        {
            MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), cdir.text());
        }
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


#if defined(linux)
// Install/Upgrade package
long FilePanel::onCmdPkgInstall(FXObject*, FXSelector, void*)
{
    FXString name, path, cmd, dir, cdir;
    File*    f;

    cdir = current->list->getDirectory();

    int itm;
    current->list->getNumSelectedItems(&itm);
    if (current->list->getItem(itm))
    {
        name = current->list->getItemText(itm).text();
        name = name.section('\t', 0);
        path = ::quote(cdir + PATHSEPSTRING + name);

        // Command to perform
        FXString ext = FXPath::extension(name);
        if (comparecase(ext, "rpm") == 0)
        {
            cmd = "rpm -Uvh " + path;
        }
        else if (comparecase(ext, "deb") == 0)
        {
            cmd = "dpkg -i "+ path;
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Package Install/Upgrade"), PKG_INSTALL);
        f->create();

        // Install/Upgrade package
        f->pkgInstall(name, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Uninstall package based on its name (package version is ignored)
long FilePanel::onCmdPkgUninstall(FXObject*, FXSelector, void*)
{
    FXString name, cmd, dir, cdir;
    File*    f;

    cdir = current->list->getDirectory();

    int itm;
    current->list->getNumSelectedItems(&itm);
    if (current->list->getItem(itm))
    {
        name = current->list->getItemText(itm).text();
        name = name.section('\t', 0);

        // Command to perform
        FXString ext = FXPath::extension(name);
        if (comparecase(ext, "rpm") == 0)
        {
            name = name.section('-', 0);
            cmd = "rpm -e " + name;
        }
        else if (comparecase(ext, "deb") == 0)
        {
            name = name.section('_', 0);
            cmd = "dpkg -r "+ name;
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Package Uninstall"), PKG_UNINSTALL);
        f->create();

        // Uninstall package
        f->pkgUninstall(name, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


#endif


// Force FilePanel and DirPanel refresh
long FilePanel::onCmdRefresh(FXObject*, FXSelector, void*)
{
    // Refresh panel
    FXString dir = list->getDirectory();
    list->setDirectory(ROOTDIR, false);
    list->setDirectory(dir, false);
    updatePath();
	
	// Focus on current panel
	current-> list->setFocus();

    return(1);
}


// Handle item selection
long FilePanel::onCmdSelect(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setFocus();
    switch (FXSELID(sel))
    {
    case ID_SELECT_ALL:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SELECT_ALL), ptr);
        return(1);

    case ID_DESELECT_ALL:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), ptr);
        return(1);

    case ID_SELECT_INVERSE:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SELECT_INVERSE), ptr);
        return(1);
    }
    return(1);
}


// Handle show commands
long FilePanel::onCmdShow(FXObject* sender, FXSelector sel, void* ptr)
{
    switch (FXSELID(sel))
    {
    case ID_SHOW_BIG_ICONS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_BIG_ICONS), ptr);
        break;

    case ID_SHOW_MINI_ICONS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_MINI_ICONS), ptr);
        break;

    case ID_SHOW_DETAILS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_DETAILS), ptr);
        break;
    }

    // Set focus on current panel list
    current->list->setFocus();

    return(1);
}


// Update show commands
long FilePanel::onUpdShow(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXuint style = current->list->getListStyle();

    switch (FXSELID(sel))
    {
    case ID_SHOW_BIG_ICONS:
        if (style & _ICONLIST_BIG_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_MINI_ICONS:
        if (style & _ICONLIST_MINI_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_DETAILS:
        if (!(style & (_ICONLIST_MINI_ICONS | _ICONLIST_BIG_ICONS)))
        {
            msg = FXWindow::ID_CHECK;
        }
        break;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);

    return(1);
}


// Handle toggle hidden command
long FilePanel::onCmdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_HIDDEN), ptr);
    return(1);
}


// Update toggle hidden command
long FilePanel::onUpdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXbool hidden = current->list->shownHiddenFiles();

    if (hidden == false)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);
    return(1);
}


// Handle toggle thumbnails command
long FilePanel::onCmdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_THUMBNAILS), ptr);
    return(1);
}


// Update toggle hidden command
long FilePanel::onUpdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXbool showthumb = current->list->shownThumbnails();

    if (showthumb == false)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);
    return(1);
}


// Run script
long FilePanel::onCmdRunScript(FXObject* o, FXSelector sel, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString pathname, cmd, itemslist = " ";
    FXString scriptpath = dynamic_cast<FXMenuCommand*>(o)->getHelpText();

    // Construct selected files list
    current->list->setFocus();
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            pathname = current->list->getItemPathname(u);

            // List of selected items
            itemslist += ::quote(pathname) + " ";
        }
    }

    // Construct command line
    cmd = ::quote(scriptpath) + itemslist + " &";

    // Go to the current directory
    int ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
        }
    }

    // Execute command
    static pid_t child_pid = 0;
    switch ((child_pid = fork()))
    {
    case -1:
        fprintf(stderr, _("Error: Fork failed: %s\n"), strerror(errno));
        break;

    case 0:
        execl("/bin/sh", "sh", "-c", cmd.text(), (char*)NULL);
        _exit(EXIT_SUCCESS);
        break;
    }

    // Return to the starting directory
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Go to scripts directory
long FilePanel::onCmdGoScriptDir(FXObject* o, FXSelector sel, void*)
{
    FXString scriptpath = homedir + PATHSEPSTRING CONFIGPATH PATHSEPSTRING XFECONFIGPATH PATHSEPSTRING SCRIPTPATH;

    if (!::exists(scriptpath))
    {
        // Create the script directory according to the umask
        int mask = umask(0);
        umask(mask);
        errno = 0;
        int ret = mkpath(scriptpath.text(), 511 & ~mask);
        int errcode = errno;
        if (ret == -1)
        {
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create script folder %s: %s"), scriptpath.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create script folder %s"), scriptpath.text());
            }

            return(0);
        }
    }

    // Go to scripts directory
    current->list->setDirectory(scriptpath);
    current->list->setFocus();
    dirpanel->setDirectory(scriptpath, true);
    current->updatePath();
    updateLocation();

    return(1);
}


#if defined(linux)
// Mount/Unmount file systems
long FilePanel::onCmdMount(FXObject*, FXSelector sel, void*)
{
    int      ret;
    FXString cmd, msg, text;
    FXuint   op;
    File*    f;
    FXString dir;

    current->list->setFocus();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (current->list->getNumSelectedItems() == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    // If symbolic link, read the linked directory
    if (::isLink(dir))
    {
        dir = ::readLink(dir);
    }

    if (FXSELID(sel) == ID_MOUNT)
    {
        op = MOUNT;
        msg = _("Mount");
		cmd = getApp()->reg().readStringEntry("PROGS", "mount", DEFAULT_MOUNTCMD) + FXString(" ");
    }
    else
    {
        op = UNMOUNT;
        msg = _("Unmount");
	    cmd = getApp()->reg().readStringEntry("PROGS", "unmount", DEFAULT_UMOUNTCMD) + FXString(" ");
    }
    cmd += ::quote(dir);
    cmd += " 2>&1";
    ret = chdir(ROOTDIR);
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), ROOTDIR, strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), ROOTDIR);
        }

        return(0);
    }

    // Wait cursor
    getApp()->beginWaitCursor();

    // File object
    text = msg + _(" file system...");
    f = new File(this, text.text(), op);
    f->create();

    // Mount/unmount file system
    text = msg + _(" the folder:");
    f->mount(dir, text, cmd, op);
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }

        return(0);
    }

    // If action is cancelled in progress dialog
    if (f->isCancelled())
    {
        f->hide();
        text = msg + _(" operation cancelled!");
        MessageBox::error(this, BOX_OK, _("Warning"), "%s", text.text());
        delete f;
        return(0);
    }

    getApp()->endWaitCursor();
    delete f;

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Update the Mount button
long FilePanel::onUpdMount(FXObject* o, FXSelector sel, void*)
{
    FXString dir;

    int num = current->list->getNumSelectedItems();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (num == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    if (fsdevices->find(dir.text()) && !mtdevices->find(dir.text()) && current->list->getNumItems() && !current->list->isItemSelected(0))
    //if (fsdevices->find(dir.text()) && !mtdevices->find(dir.text()) && current->list->getNumItems())
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update the Unmount button
long FilePanel::onUpdUnmount(FXObject* o, FXSelector sel, void*)
{
    FXString dir;

    int num = current->list->getNumSelectedItems();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (num == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    if ((fsdevices->find(dir.text()) || mtdevices->find(dir.text())) && current->list->getNumItems() && !current->list->isItemSelected(0))
    //if ((fsdevices->find(dir.text()) || mtdevices->find(dir.text())) && current->list->getNumItems())
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Query packages data base
long FilePanel::onCmdPkgQuery(FXObject* o, FXSelector sel, void*)
{
    FXString cmd;

    // Name of the current selected file
    FXString file = current->list->getCurrentFile();

    // Command to perform
    if (pkg_format == DEB_PKG)
    {
        cmd = "dpkg -S " + ::quote(file);
    }
    else if (pkg_format == RPM_PKG)
    {
        cmd = "rpm -qf " + ::quote(file);
    }
    else
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("No compatible package manager (rpm or dpkg) found!"));
        return(0);
    }

    // Query command
    cmd += " 2>&1";

    // Wait cursor
    getApp()->beginWaitCursor();

    // Perform the command
    FILE* pcmd = popen(cmd.text(), "r");
    if (!pcmd)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Failed command: %s"), cmd.text());
        return(0);
    }

    // Get command output
    char     text[10000] = { 0 };
    FXString buf;
    while (fgets(text, sizeof(text), pcmd))
    {
        buf += text;
    }
    snprintf(text, sizeof(text)-1, "%s", buf.text());

    // Close the stream and display error message if any
    if ((pclose(pcmd) == -1) && (errno != ECHILD))   // ECHILD can be set if the child was caught by sigHarvest
    {
        getApp()->endWaitCursor();
        MessageBox::error(this, BOX_OK, _("Error"), "%s", text);
        return(0);
    }
    getApp()->endWaitCursor();

    // Get package name, or detect when the file isn't in a package
    FXString str = text;
    if (pkg_format == DEB_PKG)  // DEB based distribution
    {
        int idx = str.find(" ");               // Split output at first whitespace
        FXString pkgname = str.left(idx-1);    // Remove trailing colon
        FXString fname = str.right(str.length()-idx);
        fname.trim();                          // Remove leading space and trailing newline
        if (streq(fname.text(), file.text()))  // No other word than the file name
        {
            str = pkgname.text();
        }
        else
        {
            str = "";
        }
    }
    if (pkg_format == RPM_PKG)   // RPM based distribution
    {
        if (str.find(' ') != -1) // Space character exists in the string
        {
            str = "";
        }
    }

    // Display the related output message
    FXString message;
    if (str == "")
    {
        message.format(_("File %s does not belong to any package."), file.text());
        MessageBox::information(this, BOX_OK, _("Information"), "%s", message.text());
    }
    else
    {
        message.format(_("File %s belongs to the package: %s"), file.text(), str.text());
        MessageBox::information(this, BOX_OK, _("Information"), "%s", message.text());
    }

    return(1);
}


// Update the package query menu
long FilePanel::onUpdPkgQuery(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing is selected or multiple selection
    // or when unique selection and the selected item is a directory

    int num;

    num = current->list->getNumSelectedItems();

    if ((num == 0) || (num > 1))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else // num=1
    {
        int item = current->list->getCurrentItem();
        if ((item >= 0) && current->list->isItemDirectory(item))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }

    return(1);
}


#endif // End #if defined(linux)


// Directory usage on file selection
long FilePanel::onCmdDirUsage(FXObject* o, FXSelector, void*)
{
	FXString name, command, itemslist = " ";
	FXString cmd1 = "/usr/bin/du --apparent-size -k -s ";
	FXString cmd2 = " 2> /dev/null | /usr/bin/sort -rn | /usr/bin/cut -f2 | /usr/bin/xargs -d '\n' /usr/bin/du --apparent-size --total --si -s 2> /dev/null";

    // Enter current directory
    int ret=chdir(current->getDirectory().text());
    if (ret < 0)
    {
        int errcode=errno;
        if (errcode)
        {
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s: %s"),current->getDirectory().text(),strerror(errcode));
		}
        else
        {
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s"),current->getDirectory().text());
		}

        return 0;
    }

    // Eventually deselect the '..' directory
    if (current->list->isItemSelected(0))
    {
        current->list->deselectItem(0);
    }

    // Return if nothing is selected
    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    // Construct selected files list
    current->list->setFocus();
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
 			name = current->list->getItemFilename(u);

            // List of selected items
            itemslist += ::quote(name) + " ";
        }
    }

	// Command to be executed
	command = cmd1 + itemslist + cmd2;

	// Make and show command window
	CommandWindow* cmdwin=new CommandWindow(getApp(),_("Sizes of Selected Object(s)"),command,25,50);
	cmdwin->create();
	cmdwin->setIcon(charticon);

	// The CommandWindow object will delete itself when closed!

	// Return to start location
	ret = chdir(startlocation.text());
	if (ret < 0)
	{
		int errcode = errno;
		if (errcode)
		{
			MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
		}
		else
		{
			MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
		}
	}

    return(1);
}


// Update the status bar and the path linker
long FilePanel::onUpdStatus(FXObject* sender, FXSelector, void*)
{
    // Update the status bar
    int      item = -1;
    FXString str, linkto;
    char     usize[64];
    FXulong  size = 0;
    FXString hsize = _("0 bytes");

    FXString path = list->getDirectory();

    int num = list->getNumSelectedItems();

    // To handle the update rename (ugly, I know)
    if (current == this)
    {
        if (num <= 1)
        {
            selmult = false;
        }
        else if (num > 1)
        {
            selmult = true;
        }
    }

    item = list->getCurrentItem();

    if (num > 1)
    {
		int nbdirs = 0;
        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u) && !list->isItemDirectory(u))
            {
                size += list->getItemFileSize(u);
#if __WORDSIZE == 64
                snprintf(usize, sizeof(usize)-1, "%lu", size);
#else
                snprintf(usize, sizeof(usize)-1, "%llu", size);
#endif
                hsize = ::hSize(usize);
            }
            
            if (list->isItemDirectory(u))
            {
				nbdirs++;
			}
        }
        
        // Don't count the '..' directory
        if (nbdirs >= 1)
        {
			nbdirs--;
		}
		
		int nbfiles = num - nbdirs;
        if (nbdirs <= 1 && nbfiles <= 1)
        {
	        str.format(_("%s in %s selected object(s) (%s folder, %s file)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
        else if (nbdirs <=1 && nbfiles > 1)
        {
	        str.format(_("%s in %s selected object(s) (%s folder, %s files)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
        else if (nbdirs > 1 && nbfiles <= 1)
        {
	        str.format(_("%s in %s selected object(s) (%s folders, %s file)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
		else
		{
	        str.format(_("%s in %s selected object(s) (%s folders, %s files)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
    }
    else
    {
        // Nothing selected
        if ((num == 0) || (item < 0))
        {
            num = list->getNumItems();
            if (num == 1)
            {
                str = _("1 object(s) (1 folder)");
            }
            else
            {
				int nbdirs = 0;
				for (int u = 0; u < num; u++)
				{
					if (list->isItemDirectory(u))
					{
						nbdirs++;
					}
				}       

				int nbfiles = num - nbdirs;
		        str.format(_("%s object(s) (%s folders, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());
				if (nbdirs <= 1 && nbfiles <= 1)
				{
					str.format(_("%s object(s) (%s folder, %s file)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else if (nbdirs <=1 && nbfiles > 1)
				{
					str.format(_("%s object(s) (%s folder, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else if (nbdirs > 1 && nbfiles <= 1)
				{
					str.format(_("%s object(s) (%s folders, %s file)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else
				{
					str.format(_("%s object(s) (%s folders, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
            }
        }
        else
        {
            FXString string = list->getItemText(item);
            FXString name = string.section('\t', 0);
            FXString type = string.section('\t', 2);

            FXString date = string.section('\t', 4);
            FXString usr = string.section('\t', 5);
            FXString grp = string.section('\t', 6);
            FXString perm = string.section('\t', 7);

            if (type.contains(_("Broken link")))
            {
                linkto = ::readLink(path+PATHSEPSTRING+name);
                str = name + "->" + linkto.text() + " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
            else if (type.contains(_("Link")))
            {
                linkto = ::readLink(path+PATHSEPSTRING+name);
                str = name + "->" + linkto.text() + " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
            else
            {
                for (int u = 0; u < list->getNumItems(); u++)
                {
                    if (list->isItemSelected(u) && !list->isItemDirectory(u))
                    {
                        size = list->getItemFileSize(u);
#if __WORDSIZE == 64
                        snprintf(usize, sizeof(usize)-1, "%lu", size);
#else
                        snprintf(usize, sizeof(usize)-1, "%llu", size);
#endif
                        hsize = ::hSize(usize);
                        break;
                    }
                }
                str = hsize+ " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
        }
    }

    statuslabel->setText(str);

    // Add the filter pattern if any
    if ((list->getPattern() != "*") && (list->getPattern() != "*.*"))
    {
        str.format(_(" - Filter: %s"), list->getPattern().text());
        filterlabel->setText(str);
        filterlabel->setTextColor(attenclr);
    }
    else
    {
        filterlabel->setText("");
    }

    return(1);
}


// Update the path text and the path link
void FilePanel::updatePath()
{
    pathlink->setPath(list->getDirectory());
    pathtext->setText(list->getDirectory());
}


// Update the go to parent directory command
long FilePanel::onUpdUp(FXObject* o, FXSelector, void*)
{
    FXButton* button = (FXButton*)o;
    int       style = button->getButtonStyle();

    if (style & TOGGLEBUTTON_TOOLBAR)
    {
        if (current->list->getDirectory() != ROOTDIR)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update the paste button
long FilePanel::onUpdPaste(FXObject* o, FXSelector, void*)
{
    FXuchar* data;
    FXuint   len;
    FXString buf;
    FXbool   clipboard_empty = true;

    // Lock clipboard to prevent changes in method onCmdRequestClipboard()
    clipboard_locked = true;

    // If source is xfelistType (Gnome, XFCE, or Xfe app)
    if (getDNDData(FROM_CLIPBOARD, xfelistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        buf = (char*)data;

        // Check if valid clipboard
        if (buf.find("file:/") >= 0)
        {
            clipboard_empty = false;
        }

        // Free data pointer
        FXFREE(&data);
    }

    // If source type is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    else if (getDNDData(FROM_CLIPBOARD, urilistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        buf = (char*)data;

        // Check if valid clipboard
        if (buf.find("file:/") >= 0)
        {
            clipboard_empty = false;
        }

        // Free data pointer
        FXFREE(&data);
    }

    // Gray out the paste button, if necessary
    if (clipboard_empty)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }

    // Unlock clipboard
    clipboard_locked = false;

    return(1);
}


// Update menu items and toolbar buttons that are related to file operations
long FilePanel::onUpdMenu(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing or only ".." is selected
    int num;

    num = current->list->getNumSelectedItems();
    DirItem* item = (DirItem*)dirpanel->getCurrentItem();

    if ((dirpanel->shown() && item))
    {
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        //else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        //else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }

    return(1);
}


// Update file delete menu item and toolbar button
long FilePanel::onUpdFileDelete(FXObject* o, FXSelector sel, void*)
{
    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    FXbool use_trash_bypass = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_bypass", false);

    if ( (!use_trash_can) | use_trash_bypass)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        //else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update move to trash menu item and toolbar button
long FilePanel::onUpdFileTrash(FXObject* o, FXSelector sel, void*)
{
    // Disable move to trash menu if we are in trash can
    // or if the trash can directory is selected

    FXbool   trashenable = true;
    FXString trashparentdir = trashlocation.rbefore('/');
    FXString curdir = current->list->getDirectory();

    if (curdir.left(trashlocation.length()) == trashlocation)
    {
        trashenable = false;
    }

    if (curdir == trashparentdir)
    {
        FXString pathname;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                if (pathname == trashlocation)
                {
                    trashenable = false;
                }
            }
        }
    }

    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    if (use_trash_can && trashenable)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        //else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update restore from trash menu item and toolbar button
long FilePanel::onUpdFileRestore(FXObject* o, FXSelector sel, void*)
{
    // Enable restore from trash menu if we are in trash can

    FXbool   restoreenable = false;
    FXString curdir = current->list->getDirectory();

    if (curdir.left(trashfileslocation.length()) == trashfileslocation)
    {
        restoreenable = true;
    }

    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    if (use_trash_can && restoreenable)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        //else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update go trash menu item and toolbar button
long FilePanel::onUpdGoTrash(FXObject* o, FXSelector sel, void*)
{
    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);

    if (use_trash_can)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update file open menu
long FilePanel::onUpdOpen(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or a directory (including "..") is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);

    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        if (current->list->getItem(item) && current->list->isItemFile(item))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
    }
    return(1);
}


// Update the status of the menu items that should be disabled when selecting multiple files
long FilePanel::onUpdSelMult(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing is selected or multiple selection or ".." is only selected
    int num;

    num = current->list->getNumSelectedItems();
    DirItem* item = (DirItem*)dirpanel->getCurrentItem();

    if (num == 0)
    {
        if (!item || !dirpanel->shown())
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else if (current->selmult || ((num == 1) && current->list->isItemSelected(0)))
    //else if (current->selmult || (num == 1))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }

    return(1);
}


// Update the file compare menu item
long FilePanel::onUpdCompare(FXObject* o, FXSelector sel, void*)
{
    // Menu item is enabled only when two files are selected
    int num;

    num = current->list->getNumSelectedItems();

    if ((num == 1) || (num == 2))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update Add to archive menu
long FilePanel::onUpdAddToArch(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or ".." is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else if ((num == 1) && current->list->isItemSelected(0))
    //else if ((num == 1))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update scripts menu item
long FilePanel::onUpdRunScript(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or ".." is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update directory usage menu item
long FilePanel::onUpdDirUsage(FXObject* o, FXSelector, void*)
{
    // Menu item is enabled only when at least two items are selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num > 1)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    return(1);
}
#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/time.h>

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "startupnotification.h"
#include "FileDialog.h"
#include "FileList.h"
#include "Properties.h"
#include "XFileExplorer.h"
#include "InputDialog.h"
#include "BrowseInputDialog.h"
#include "ArchInputDialog.h"
#include "HistInputDialog.h"
#include "File.h"
#include "MessageBox.h"
#include "OverwriteBox.h"
#include "CommandWindow.h"
#include "ExecuteBox.h"
#include "PathLinker.h"
#include "FilePanel.h"
#include <string>
#include <iostream>

// Duration (in ms) before we can stop refreshing the file list
// Used for file operations on a large list of files
#define STOP_LIST_REFRESH_INTERVAL    5000

// Number of files before stopping the file list refresh
#define STOP_LIST_REFRESH_NBMAX       100


// Clipboard notes :
// The uri-list type used for Xfe is the same as the Gnome uri-list type
// The standard uri-list type is used for KDE and non Gnome / XFCE file managers
// A special uri-list type that containd only "0" (for copy) or "1" (for cut) is used for KDE compatibility


// Global Variables
//extern FXMainWindow* mainWindow;
extern FXString      homedir;
extern FXString      xdgdatahome;

// Clipboard
extern FXString clipboard;
FXuint          clipboard_type = 0;


extern char OpenHistory[OPEN_HIST_SIZE][MAX_COMMAND_SIZE];
extern int  OpenNum;
extern char FilterHistory[FILTER_HIST_SIZE][MAX_PATTERN_SIZE];
extern int  FilterNum;
#if defined(linux)
extern FXStringDict* fsdevices;
extern FXStringDict* mtdevices;
extern FXbool        pkg_format;
#endif

extern FXbool allowPopupScroll;
extern FXuint single_click;


// Map
FXDEFMAP(FilePanel) FilePanelMap[] =
{
    FXMAPFUNC(SEL_CLIPBOARD_LOST, 0, FilePanel::onClipboardLost),
    FXMAPFUNC(SEL_CLIPBOARD_GAINED, 0, FilePanel::onClipboardGained),
    FXMAPFUNC(SEL_CLIPBOARD_REQUEST, 0, FilePanel::onClipboardRequest),
    FXMAPFUNC(SEL_TIMEOUT, FilePanel::ID_STOP_LIST_REFRESH_TIMER, FilePanel::onCmdStopListRefreshTimer),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DIRECTORY_UP, FilePanel::onCmdDirectoryUp),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILTER, FilePanel::onCmdItemFilter),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILTER_CURRENT, FilePanel::onCmdItemFilter),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_HOME, FilePanel::onCmdGoHome),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_TRASH, FilePanel::onCmdGoTrash),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_VIEW, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_MIDDLEBUTTONPRESS, FilePanel::ID_FILELIST, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EDIT, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_COMPARE, FilePanel::onCmdCompare),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PROPERTIES, FilePanel::onCmdProperties),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_XTERM, FilePanel::onCmdXTerm),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_DIR, FilePanel::onCmdNewDir),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_FILE, FilePanel::onCmdNewFile),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_SYMLINK, FilePanel::onCmdNewSymlink),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_COPY, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_CUT, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_COPYTO, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_MOVETO, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_RENAME, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_SYMLINK, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_COPY_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_CUT_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADDCOPY_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADDCUT_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PASTE_CLIPBOARD, FilePanel::onCmdPaste),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_TRASH, FilePanel::onCmdFileTrash),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_RESTORE, FilePanel::onCmdFileRestore),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_DELETE, FilePanel::onCmdFileDelete),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_OPEN_WITH, FilePanel::onCmdOpenWith),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_OPEN, FilePanel::onCmdOpen),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_REFRESH, FilePanel::onCmdRefresh),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_BIG_ICONS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_MINI_ICONS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_DETAILS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_TOGGLE_HIDDEN, FilePanel::onCmdToggleHidden),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_TOGGLE_THUMBNAILS, FilePanel::onCmdToggleThumbnails),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SELECT_ALL, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DESELECT_ALL, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SELECT_INVERSE, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADD_TO_ARCH, FilePanel::onCmdAddToArch),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT, FilePanel::onCmdExtract),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT_TO_FOLDER, FilePanel::onCmdExtractToFolder),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT_HERE, FilePanel::onCmdExtractHere),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_RUN_SCRIPT, FilePanel::onCmdRunScript),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_RUN_SCRIPT, FilePanel::onUpdRunScript),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_SCRIPTDIR, FilePanel::onCmdGoScriptDir),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DIR_USAGE, FilePanel::onCmdDirUsage),
    FXMAPFUNC(SEL_RIGHTBUTTONRELEASE, FilePanel::ID_FILELIST, FilePanel::onCmdPopupMenu),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_POPUP_MENU, FilePanel::onCmdPopupMenu),
    FXMAPFUNC(SEL_DOUBLECLICKED, FilePanel::ID_FILELIST, FilePanel::onCmdItemDoubleClicked),
    FXMAPFUNC(SEL_CLICKED, FilePanel::ID_FILELIST, FilePanel::onCmdItemClicked),
    FXMAPFUNC(SEL_FOCUSIN, FilePanel::ID_FILELIST, FilePanel::onCmdFocus),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_STATUS, FilePanel::onUpdStatus),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_DIRECTORY_UP, FilePanel::onUpdUp),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_COPY_CLIPBOARD, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_CUT_CLIPBOARD, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PASTE_CLIPBOARD, FilePanel::onUpdPaste),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PROPERTIES, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_TRASH, FilePanel::onUpdFileTrash),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_RESTORE, FilePanel::onUpdFileRestore),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_GO_TRASH, FilePanel::onUpdGoTrash),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_DELETE, FilePanel::onUpdFileDelete),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_MOVETO, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_COPYTO, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_RENAME, FilePanel::onUpdSelMult),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_COMPARE, FilePanel::onUpdCompare),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_EDIT, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_VIEW, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_OPEN, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_ADD_TO_ARCH, FilePanel::onUpdAddToArch),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_BIG_ICONS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_MINI_ICONS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_DETAILS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_TOGGLE_HIDDEN, FilePanel::onUpdToggleHidden),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_TOGGLE_THUMBNAILS, FilePanel::onUpdToggleThumbnails),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_DIR_USAGE, FilePanel::onUpdDirUsage),
#if defined(linux)
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_MOUNT, FilePanel::onCmdMount),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_UMOUNT, FilePanel::onCmdMount),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_MOUNT, FilePanel::onUpdMount),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_UMOUNT, FilePanel::onUpdUnmount),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_QUERY, FilePanel::onCmdPkgQuery),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_INSTALL, FilePanel::onCmdPkgInstall),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_UNINSTALL, FilePanel::onCmdPkgUninstall),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PKG_QUERY, FilePanel::onUpdPkgQuery),
#endif
};

// Object implementation
FXIMPLEMENT(FilePanel, FXVerticalFrame, FilePanelMap, ARRAYNUMBER(FilePanelMap))

// Function to draw header on webview
static void xpWebviewHeader(FXPacker* tb, const char* txt, FXColor bgcolor)
{
	FXHorizontalFrame* headerCont = new FXHorizontalFrame(tb, LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 12, 2, 8, 6, 0, 0);
	FXHorizontalFrame* headerCont2 = new FXHorizontalFrame(headerCont, LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 6, 0, 6, 5, 0, 0);
        FXLabel* headerText = new FXLabel(headerCont2, txt, NULL, 0, 0, 0, 14, 0, 8, 6, 0, 0);
        headerCont2->setBackColor(bgcolor);

	// bug: im a lazy fuck so im using static colors instead of grabbing the fox toolkit ones (for now)
        headerCont->setBackColor(FXRGB(255,255,255));
}

// Construct File Panel
FilePanel::FilePanel(FXWindow* owner, const char* nm, FXComposite* p, DirPanel* dp, FXuint name_size, FXuint size_size, FXuint type_size, FXuint ext_size,
                     FXuint modd_size, FXuint user_size, FXuint grou_size, FXuint attr_size, FXuint deldate_size, FXuint origpath_size, FXbool showthumbs, FXColor listbackcolor, FXColor listforecolor,
                     FXColor attentioncolor, FXbool smoothscroll, FXuint opts, int x, int y, int w, int h) :
    FXVerticalFrame(p, opts, x, y, w, h, 0, 0, 0, 0)
{
    name = nm;
    dirpanel = dp;
    attenclr = attentioncolor;

    // Global container
    FXVerticalFrame* cont = new FXVerticalFrame(this, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // Container for the path linker
    FXHorizontalFrame* pathframe = new FXHorizontalFrame(cont, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0);

    // File list

    // Smooth scrolling
    FXuint options;
    if (smoothscroll)
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS;
    }
    else
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS|SCROLLERS_DONT_TRACK;
    }

    FXHorizontalFrame* cont2 = new FXHorizontalFrame(cont, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_SUNKEN|FRAME_THICK, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    if(webviewxp)
    {
    FXVerticalFrame* webview = new FXVerticalFrame(cont2, LAYOUT_FIX_WIDTH|LAYOUT_FILL_Y, 0, 0, 210, 0, 0, 0, 0, 0);
    webview->setBackColor(getApp()->getBackColor());

    //xpWebviewHeader(webview, "test", getApp()->getBaseColor());

    FXLabel* webviewbg = new FXLabel(webview, "", webviewxp, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    webviewbg->setBackColor(getApp()->getBackColor());
/*    } else {

    if(webviewbgicon)
    {
    FXVerticalFrame* webview = new FXVerticalFrame(cont2, LAYOUT_FIX_WIDTH|LAYOUT_FILL_Y, 0, 0, 200, 0, 0, 0, 0, 0);
    webview->setBackColor(getApp()->getBackColor());

    FXLabel* webviewbg = new FXLabel(webview, "", webviewbgicon, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    webviewbg->setBackColor(getApp()->getBackColor());

    webviewtext = new FXLabel(webview, "Folder", 0, 0, 10, 100, 0, 0, 10, 10, 0, 0);
    webviewtext->setBackColor(getApp()->getBackColor());

    std::cout << webviewtext;
    std::cout << "\n";


    FXHorizontalFrame* webviewsep = new FXHorizontalFrame(webview, LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, 184, 2);
    webviewsep->setBackColor(FXRGB(102,153,204));

    //std::string iconbg = "test";
    //std::string* ptr = &iconbg;

    //FXEvent *ev=(FXEvent*)ptr;
    //FXDCWindow dc(webviewbg,ev);
    //dc.drawIcon(webviewbgicon,10,10);

    FXLabel* webviewicon = new FXLabel(webview, "", bigfoldericon, LAYOUT_FIX_X|LAYOUT_FIX_Y, 16, 16, 0, 0, 0, 0, 0, 0);
    webviewicon->setBackColor(FXRGBA(255,255,255,0));
    } */
    }

    list = new FileList(owner, cont2, this, ID_FILELIST, showthumbs, options);
    list->setHeaderSize(0, name_size);
    list->setHeaderSize(1, size_size);
    list->setHeaderSize(2, type_size);
    list->setHeaderSize(3, ext_size);
    list->setHeaderSize(4, modd_size);
    list->setHeaderSize(5, user_size);
    list->setHeaderSize(6, grou_size);
    list->setHeaderSize(7, attr_size);
    list->setHeaderSize(8, deldate_size);
    list->setHeaderSize(9, origpath_size);
    list->setTextColor(listforecolor);
    list->setBackColor(listbackcolor);

    // Path text
    pathtext = new TextLabel(pathframe, 0, this, ID_FILELIST, LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0);
    pathtext->setBackColor(getApp()->getBaseColor());

    // Hide path frame if path link/breadcrums are disabled
    show_pathlink = getApp()->reg().readUnsignedEntry("SETTINGS", "show_pathlinker", true);

    if (show_pathlink == false)
    {
         pathframe->hide();
    }



    // Path linker
    pathlink = new PathLinker(pathframe, list, dirpanel->getList(), JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X);
    //FXButton* dummyicon = new FXButton(pathframe, "", minifoldericon, this, 2, BUTTON_TOOLBAR|JUSTIFY_LEFT|LAYOUT_LEFT);


    // Visually indicate if the panel is active
    activeicon = new FXButton(pathframe, "", minifoldericon, this, FilePanel::ID_FILELIST, BUTTON_TOOLBAR|JUSTIFY_LEFT|LAYOUT_LEFT);



    // Status bar
    FXPacker* statusbarcont = new FXPacker(cont, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|LAYOUT_BOTTOM, 0, 0, 0, 0, 0, 0, 1, 0);
    statusbar = new FXHorizontalFrame(statusbarcont, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_X|LAYOUT_SIDE_LEFT, 0, 0, 0, 0, 0, 0, 0, 0);

    statusbar->setTarget(this);
    statusbar->setSelector(FXSEL(SEL_UPDATE, FilePanel::ID_STATUS));

    FXString key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "filter", "Ctrl-D");

    FXHorizontalFrame* hframe = new FXHorizontalFrame(statusbar, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 2);
    statuslabel = new FXLabel(hframe, _("Status"), NULL, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X|FRAME_SUNKEN, 0, 0, 0, 0, 1, 0, 0, 0);

    // sizestatusct = new FXHorizontalFrame(hframe, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X|FRAME_SUNKEN|LAYOUT_FIX_WIDTH, 0, 0, 76, 0, 0, 0, 0, 0);
    sizestatusct = new FXLabel(hframe, _(" "), NULL, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X|FRAME_SUNKEN|LAYOUT_FIX_WIDTH, 0, 0, 76, 0, 1, 0, 0, 0);
    FXHorizontalFrame* locationstatusct = new FXHorizontalFrame(hframe, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X|FRAME_SUNKEN|LAYOUT_FIX_WIDTH, 0, 0, 153, 0, 0, 0, 0, 0);
    //FXLabel* locationstatusic = new FXLabel(locationstatusct, "", tbcomputericon, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FIX_X, 2, 0, 0, 0, 0, 0, 0, 0);
    FXLabel* locationstatusic = new FXLabel(locationstatusct, "", tbcomputericon, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FIX_X, 2, 0, 0, 0, 0, 0, 0, 0);
    FXLabel* locationstatuslb = new FXLabel(locationstatusct, "My Computer", NULL, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FIX_X, 22, 0, 0, 0, 0, 0, 0, 0);

    filterlabel = new FXLabel(hframe, "", NULL, JUSTIFY_LEFT|LAYOUT_LEFT, 0, 0, 0, 0, 4, 17, 0, 0);
    filterlabel->hide();
    //FXVerticalFrame* cornercont = new FXVerticalFrame(statusbar, LAYOUT_RIGHT|LAYOUT_BOTTOM|FRAME_NONE|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, 12, 12, 0, 0, 0, 0, 0, 0);

    corner = new FXPacker(statusbarcont, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_RIGHT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT|LAYOUT_SIDE_RIGHT|LAYOUT_BOTTOM, 0, 0, 13, 13, 0, 0, 0, 0, 0, 0);
    realcorner = new FXDragCorner(corner);
    //corner = new FXLabel(statusbarcont, "", resizecorner, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_RIGHT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT|LAYOUT_SIDE_RIGHT|LAYOUT_BOTTOM, 0, 0, 13, 13, 0, 0, 0, 0);
    // Panel separator
    panelsep = new FXHorizontalSeparator(cont, SEPARATOR_GROOVE|LAYOUT_FILL_X);

    // Initializations
    selmult = false;
    current = NULL;

    // Single click navigation
    single_click = getApp()->reg().readUnsignedEntry("SETTINGS", "single_click", SINGLE_CLICK_NONE);
    if (single_click == SINGLE_CLICK_DIR_FILE)
    {
        list->setDefaultCursor(getApp()->getDefaultCursor(DEF_HAND_CURSOR));
    }

    // Dialogs
    operationdialogsingle = NULL;
    operationdialogrename = NULL;
    operationdialogmultiple = NULL;
    newdirdialog = NULL;
    newfiledialog = NULL;
    newlinkdialog = NULL;
    opendialog = NULL;
    archdialog = NULL;
    filterdialog = NULL;
    comparedialog = NULL;

    // Home and trahscan locations
    trashlocation = xdgdatahome+PATHSEPSTRING TRASHPATH;
    trashfileslocation = xdgdatahome + PATHSEPSTRING TRASHFILESPATH;
    trashinfolocation = xdgdatahome + PATHSEPSTRING TRASHINFOPATH;

    // Start location (we return to the start location after each chdir)
    startlocation = FXSystem::getCurrentDirectory();

    // Initialize clipboard flags
    clipboard_locked = false;
    fromPaste = false;

    // Initialize control flag for right click popup menu
    ctrl = false;

    // Initialize the Shift-F10 flag
    shiftf10 = false;

    // Initialize the active panel flag
    isactive = false;

    // Default programs identifiers
    progs["<txtviewer>"] = TXTVIEWER;
    progs["<txteditor>"] = TXTEDITOR;
    progs["<imgviewer>"] = IMGVIEWER;
    progs["<imgeditor>"] = IMGEDITOR;
    progs["<pdfviewer>"] = PDFVIEWER;
    progs["<audioplayer>"] = AUDIOPLAYER;
    progs["<videoplayer>"] = VIDEOPLAYER;
    progs["<archiver>"] = ARCHIVER;
}


// Create X window
void FilePanel::create()
{
    // Register standard uri-list type
    urilistType = getApp()->registerDragType("text/uri-list");

    // Register special uri-list type used for Gnome, XFCE and Xfe
    xfelistType = getApp()->registerDragType("x-special/gnome-copied-files");

    // Register special uri-list type used for KDE
    kdelistType = getApp()->registerDragType("application/x-kde-cutselection");

    // Register standard UTF-8 text type used for file dialogs
    utf8Type = getApp()->registerDragType("UTF8_STRING");

    // Display or hide path linker
    FXbool show_pathlink = getApp()->reg().readUnsignedEntry("SETTINGS", "show_pathlinker", true);
    if (show_pathlink)
    {
        pathtext->hide();
        pathlink->show();
    }
    else
    {
        pathtext->show();
        pathlink->hide();
    }

    FXVerticalFrame::create();
}


// Destructor
FilePanel::~FilePanel()
{
    delete list;
    delete current;
    delete next;
    delete sizestatusct;
    delete statuslabel;
    delete filterlabel;
    delete statusbar;
    delete panelsep;
    delete pathlink;
    delete newfiledialog;
    delete newlinkdialog;
    delete newdirdialog;
    delete opendialog;
    delete archdialog;
    delete filterdialog;
    delete comparedialog;
    delete operationdialogsingle;
    delete operationdialogrename;
    delete operationdialogmultiple;
    delete pathtext;
}


// Make panel active
void FilePanel::setActive()
{
    // Set active icon
    // activeicon->setIcon(greenbuttonicon);
    activeicon->setIcon(NULL);
    activeicon->setTipText(_("Panel is active"));

    pathlink->focus();
    current = this;

    // Make dirpanel point on the current directory,
    // but only if Filepanel and Dirpanel directories are different
    if (dirpanel->getDirectory() != current->list->getDirectory())
    {
        dirpanel->setDirectory(current->list->getDirectory(), true);
    }

    // Make dirpanel inactive
    dirpanel->setInactive();

    next->setInactive();
    list->setFocus();

    isactive = true;
}


// Make panel inactive
void FilePanel::setInactive(FXbool force)
{
    // Set active icon
    // activeicon->setIcon(graybuttonicon);
    activeicon->setIcon(NULL);
    activeicon->setTipText(_("Activate panel"));

    // By default we set the panel inactive
    if (force)
    {
        current = next;
        list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), NULL);

        isactive = false;
    }
}


// Make panel focus (i.e. active) when clicked
long FilePanel::onCmdFocus(FXObject* sender, FXSelector sel, void* ptr)
{
    setActive();
    return(1);
}


// Set Pointer to Another FilePanel
void FilePanel::Next(FilePanel* nxt)
{
    next = nxt;
}


// Show or hide drag corner
void FilePanel::showCorner(FXbool show)
{
    if (show)
    {
        corner->show();
    }
    else
    {
        corner->hide();
    }
}


// Show or hide active icon
void FilePanel::showActiveIcon(FXbool show)
{
    if (show)
    {
        activeicon->show();
    }
    else
    {
        activeicon->hide();
    }
}


// Update location history when changing directory (home, up or double click)
void FilePanel::updateLocation()
{
    FXString    item;
    int         i = 0;
    FXComboBox* address = ((XFileExplorer*)mainWindow)->getAddressBox();

    address->setNumVisible(5);
    int      count = address->getNumItems();
    FXString p = list->getDirectory();

    // Remember latest directory in the location address
    if (!count)
    {
        count++;
        address->insertItem(0, address->getText());
    }
    while (i < count)
    {
        item = address->getItem(i++);
        if (streq((const char*)&p[0], (const char*)&item[0]))
        {
            i--;
            break;
        }
    }
    if (i == count)
    {
        address->insertItem(0, list->getDirectory());
        //webviewtext->setText(list->getDirectory());
        //webviewtext->setTextColor(FXRGB(255,255,255));
        //std::cout << webviewtext;
    }

    // Make current directory visible to avoid scrolling again
    list->makeItemVisible(list->getCurrentItem());
}


// We now really do have the clipboard, keep clipboard content
long FilePanel::onClipboardGained(FXObject* sender, FXSelector sel, void* ptr)
{
    FXVerticalFrame::onClipboardGained(sender, sel, ptr);
    return(1);
}


// We lost the clipboard
long FilePanel::onClipboardLost(FXObject* sender, FXSelector sel, void* ptr)
{
    FXVerticalFrame::onClipboardLost(sender, sel, ptr);
    return(1);
}


// Somebody wants our clipboard content
long FilePanel::onClipboardRequest(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    FXuchar* data;
    FXuint   len;

    // Perhaps the target wants to supply its own data for the clipboard
    if (FXVerticalFrame::onClipboardRequest(sender, sel, ptr))
    {
        return(1);
    }

    // Clipboard target is xfelistType (Xfe, Gnome or XFCE)
    if (event->target == xfelistType)
    {
        // Don't modify the clipboard if we are called from updPaste()
        if (!clipboard_locked)
        {
            // Prepend "copy" or "cut" as in the Gnome way and avoid duplicating these strings
            if ((clipboard.find("copy\n") < 0) && (clipboard.find("cut\n") < 0))
            {
                if (clipboard_type == CUT_CLIPBOARD)
                {
                    clipboard = "cut\n" + clipboard;
                }
                else
                {
                    clipboard = "copy\n" + clipboard;
                }
            }
        }

        // Return clipboard content
        if (event->target == xfelistType)
        {
            if (!clipboard.empty())
            {
                len = clipboard.length();
                FXMEMDUP(&data, clipboard.text(), FXuchar, len);
                setDNDData(FROM_CLIPBOARD, event->target, data, len);

                // Return because xfelistType is not compatible with other types
                return(1);
            }
        }
    }

    // Clipboard target is kdelisType (KDE)
    if (event->target == kdelistType)
    {
        // The only data to be passed in this case is "0" for copy and "1" for cut
        // The uri data are passed using the standard uri-list type
        FXString flag;
        if (clipboard_type == CUT_CLIPBOARD)
        {
            flag = "1";
        }
        else
        {
            flag = "0";
        }

        // Return clipboard content
        if (event->target == kdelistType)
        {
            FXMEMDUP(&data, flag.text(), FXuchar, 1);
            setDNDData(FROM_CLIPBOARD, event->target, data, 1);
        }
    }

    // Clipboard target is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    if (event->target == urilistType)
    {
        if (!clipboard.empty())
        {
            len = clipboard.length();
            FXMEMDUP(&data, clipboard.text(), FXuchar, len);
            setDNDData(FROM_CLIPBOARD, event->target, data, len);

            return(1);
        }
    }

    // Clipboard target is utf8Type (to paste file pathes as text to other applications)
    if (event->target == utf8Type)
    {
        if (!clipboard.empty())
        {
            int      beg = 0, end = 0;
            FXString str = "";
            FXString pathname, url;

            // Clipboard don't contain 'copy\n' or 'cut\n' as first line
            if ((clipboard.find("copy\n") < 0) && (clipboard.find("cut\n") < 0))
            {
                // Remove the 'file:' prefix for each file path
                while (1)
                {
                    end = clipboard.find('\n', end);
                    if (end < 0) // Last line
                    {
                        end = clipboard.length();
                        url = clipboard.mid(beg, end-beg+1);
                        pathname = FXURL::decode(FXURL::fileFromURL(url));
                        str += pathname;
                        break;
                    }
                    url = clipboard.mid(beg, end-beg+1);
                    pathname = FXURL::decode(FXURL::fileFromURL(url));
                    str += pathname;
                    end++;
                    beg = end;
                }
                end = str.length();
            }

            // Clipboard contains 'copy\n' or 'cut\n' as first line, thus skip it
            else
            {
                // Start after the 'copy\n' or 'cut\n' prefix
                end = clipboard.find('\n', 0);
                end++;
                beg = end;

                // Remove the 'file:' prefix for each file path
                while (1)
                {
                    end = clipboard.find('\n', end);
                    if (end < 0) // Last line
                    {
                        end = clipboard.length();
                        url = clipboard.mid(beg, end-beg+1);
                        pathname = FXURL::decode(FXURL::fileFromURL(url));
                        str += pathname;
                        break;
                    }
                    url = clipboard.mid(beg, end-beg+1);
                    pathname = FXURL::decode(FXURL::fileFromURL(url));
                    str += pathname;
                    end++;
                    beg = end;
                }
                end = str.length();
            }

            if (!str.empty())
            {
                len = str.length();
                FXMEMDUP(&data, str.text(), FXuchar, len);
                setDNDData(FROM_CLIPBOARD, event->target, data, len);

                return(1);
            }
        }
    }
    return(0);
}


// Copy or cut to clipboard (and add copy / add cut)
long FilePanel::onCmdCopyCut(FXObject*, FXSelector sel, void*)
{
    FXString name, curdir;

    // Clear clipboard if normal copy or cut
    if ((FXSELID(sel) == ID_COPY_CLIPBOARD) || (FXSELID(sel) == ID_CUT_CLIPBOARD))
    {
        clipboard.clear();
    }

    // Add an '\n' at the end if addcopy or addcut
    else
    {
        clipboard += '\n';
    }

    // Clipboard type
    if ((FXSELID(sel) == ID_CUT_CLIPBOARD) || (FXSELID(sel) == ID_ADDCUT_CLIPBOARD))
    {
        clipboard_type = CUT_CLIPBOARD;
    }
    else
    {
        clipboard_type = COPY_CLIPBOARD;
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        // Construct the uri list of files and fill the clipboard with it
        curdir = current->list->getDirectory();

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                name = current->list->getItemText(u).text();
                name = name.section('\t', 0);
                if (curdir == ROOTDIR)
                {
                    clipboard += FXURL::encode(::fileToURI(curdir+name))+"\n";
                }
                else
                {
                    clipboard += FXURL::encode(::fileToURI(curdir+PATHSEPSTRING+name))+"\n";
                }
            }
        }
    }

    // Remove the last \n of the list, for compatibility with some file managers (e.g. nautilus, nemo)
    clipboard.erase(clipboard.length()-1);

    // Acquire the clipboard
    FXDragType types[4];
    types[0] = xfelistType;
    types[1] = kdelistType;
    types[2] = urilistType;
    types[3] = utf8Type;
    if (acquireClipboard(types, 4))
    {
        return(0);
    }

    return(1);
}


// Paste file(s) from clipboard
long FilePanel::onCmdPaste(FXObject*, FXSelector sel, void*)
{
    FXuchar* data;
    FXuint   len;
    int      beg, end, pos;
    FXString chaine, url, param;
    int      num = 0;
    FXbool   from_kde = false;

    // If source is xfelistType (Gnome, XFCE, or Xfe app)
    if (getDNDData(FROM_CLIPBOARD, xfelistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';

        clipboard = (char*)data;

        // Loop over clipboard items
        for (beg = 0; beg < clipboard.length(); beg = end+1)
        {
            if ((end = clipboard.find("\n", beg)) < 0)
            {
                end = clipboard.length();
            }

            // Obtain item url
            url = clipboard.mid(beg, end-beg);

            // Eventually remove the trailing '\r' if any
            if ((pos = url.rfind('\r')) > 0)
            {
                url.erase(pos);
            }

            // Process first item
            if (num == 0)
            {
                // First item should be "copy" or "cut"
                if (url == "copy")
                {
                    clipboard_type = COPY_CLIPBOARD;
                    num++;
                }
                else if (url == "cut")
                {
                    clipboard_type = CUT_CLIPBOARD;
                    num++;
                }

                // If first item is not "copy" nor "cut", process it as a normal url
                // and use default clipboard type
                else
                {
                    // Update the param string
                    param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";

                    // Add one more because the first line "copy" or "cut" was not present
                    num += 2;
                }
            }

            // Process other items
            else
            {
                // Update the param string
                param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";
                num++;
            }
        }

        // Construct the final param string passed to the file management routine
        param = current->list->getDirectory()+"\n" + FXStringVal(num-1) + "\n" + param;

        // Copy or cut operation depending on the clipboard type
        switch (clipboard_type)
        {
        case COPY_CLIPBOARD:
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_COPY);
            break;

        case CUT_CLIPBOARD:
            clipboard.clear();
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_CUT);
            break;
        }
        fromPaste = true;
        handle(this, sel, (void*)param.text());

        // Free data pointer
        FXFREE(&data);

        // Return here because xfelistType is not compatible with other types
        return(1);
    }

    // If source type is kdelistType (KDE)
    if (getDNDData(FROM_CLIPBOARD, kdelistType, data, len))
    {
        from_kde = true;

        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        clipboard = (char*)data;

        // Obtain clipboard type (copy or cut)
        if (clipboard == "1")
        {
            clipboard_type = CUT_CLIPBOARD;
        }
        else
        {
            clipboard_type = COPY_CLIPBOARD;
        }

        FXFREE(&data);
    }


    // If source type is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    if (getDNDData(FROM_CLIPBOARD, urilistType, data, len))
    {
        // For non KDE apps, set action to copy
        if (!from_kde)
        {
            clipboard_type = COPY_CLIPBOARD;
        }

        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        clipboard = (char*)data;

        // Loop over clipboard items
        for (beg = 0; beg < clipboard.length(); beg = end+1)
        {
            if ((end = clipboard.find("\n", beg)) < 0)
            {
                end = clipboard.length();
            }

            // Obtain item url
            url = clipboard.mid(beg, end-beg);

            // Eventually remove the trailing '\r' if any
            if ((pos = url.rfind('\r')) > 0)
            {
                url.erase(pos);
            }

            // Update the param string
            param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";
            num++;
        }

        // Construct the final param string passed to the file management routine
        param = current->list->getDirectory()+"\n" + FXStringVal(num) + "\n" + param;

        // Copy or cut operation depending on the clipboard type
        switch (clipboard_type)
        {
        case COPY_CLIPBOARD:
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_COPY);
            break;

        case CUT_CLIPBOARD:
            clipboard.clear();
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_CUT);
            break;
        }
        fromPaste = true;
        handle(this, sel, (void*)param.text());

        FXFREE(&data);
        return(1);
    }
    return(0);
}


// Execute file with an optional confirm dialog
void FilePanel::execFile(FXString pathname)
{
    int      ret;
    FXString cmd, cmdname;

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // File is executable, but is it a text file?
    FXString str = mimetype(pathname);
    FXbool   isTextFile = true;
    if (strstr(str.text(), "charset=binary"))
    {
        isTextFile = false;
    }

    // With confirmation dialog
    FXbool confirm_execute = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_execute", true);
    if (isTextFile && (confirm_execute == 1))
    {
        FXString msg;
        msg.format(_("File %s is an executable text file, what do you want to do?"), pathname.text());
        ExecuteBox* dlg = new ExecuteBox(this, _("Confirm Execute"), msg);
        FXuint      answer = dlg->execute(PLACEMENT_CURSOR);
        delete dlg;

        // Execute
        if (answer == EXECBOX_CLICKED_EXECUTE)
        {
            cmdname = FXPath::name(pathname);
            cmd = ::quote(pathname);
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // Execute in console mode
        if (answer == EXECBOX_CLICKED_CONSOLE)
        {
            ret = chdir(current->list->getDirectory().text());
            if (ret < 0)
            {
                int errcode = errno;
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
                }
            }

            cmdname = FXPath::name(pathname);
            cmd = ::quote(pathname);

            // Make and show command window
            // The CommandWindow object will delete itself when closed!
            CommandWindow* cmdwin = new CommandWindow(getApp(), _("Command log"), cmd, 30, 80);
            cmdwin->create();
            cmdwin->setIcon(runicon);

            ret = chdir(startlocation.text());
            if (ret < 0)
            {
                int errcode = errno;
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
                }
            }
        }

        // Edit
        if (answer == EXECBOX_CLICKED_EDIT)
        {
            FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
            cmd = txteditor;
            cmdname = cmd;

            // If command exists, run it
            if (::existCommand(cmdname))
            {
                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
            }

            // If command does not exist, call the "Open with..." dialog
            else
            {
                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
            }
        }
    }

    // Without confirmation dialog
    else
    {
        cmdname = FXPath::name(pathname);
        cmd = ::quote(pathname);
#ifdef STARTUP_NOTIFICATION
        runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
        runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
    }
}


// Double Click on File Item
long FilePanel::onCmdItemDoubleClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    FXString cmd, cmdname, filename, pathname;

    // Wait cursor
    getApp()->beginWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);

    // At most one item selected
    if (current->list->getNumSelectedItems() <= 1)
    {
        FXlong item = (FXlong)ptr;
        if (item > -1)
        {
#ifdef STARTUP_NOTIFICATION
            // Startup notification option and exceptions (if any)
            FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
            FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

            // Default programs
            FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
            FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
            FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
            FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
            FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
            FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
            FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
            FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

            // File name and path
            filename = list->getItemFilename(item);
            pathname = list->getItemPathname(item);

            // If directory, open the directory
            if (list->isItemDirectory(item))
            {
                // Does not have access
                if (!::isReadExecutable(pathname))
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _(" Permission to: %s denied."), pathname.text());
                    getApp()->endWaitCursor();
		    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                    return(0);
                }
                if (filename == "..")
                {
                    list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
                    //list->hide();
                }
                else
                {
                    list->setDirectory(pathname);
                }

                // Change directory in tree list
                dirpanel->setDirectory(pathname, true);
                current->updatePath();

                // Update location history
                updateLocation();
            }
            else if (list->isItemFile(item))
            {
                // Update associations dictionary
                FileDict*  assocdict = new FileDict(getApp());
                FileAssoc* association = assocdict->findFileBinding(pathname.text());

                // If there is an association
                if (association)
                {
                    // Use it to open the file
                    if (association->command.section(',', 0) != "")
                    {
                        cmdname = association->command.section(',', 0);

                        // Use a default program if possible
                        switch (progs[cmdname])
                        {
                        case TXTVIEWER:
                            cmdname = txtviewer;
                            break;

                        case TXTEDITOR:
                            cmdname = txteditor;
                            break;

                        case IMGVIEWER:
                            cmdname = imgviewer;
                            break;

                        case IMGEDITOR:
                            cmdname = imgeditor;
                            break;

                        case PDFVIEWER:
                            cmdname = pdfviewer;
                            break;

                        case AUDIOPLAYER:
                            cmdname = audioplayer;
                            break;

                        case VIDEOPLAYER:
                            cmdname = videoplayer;
                            break;

                        case ARCHIVER:
                            cmdname = archiver;
                            break;

                        case NONE: // No program found
                            ;
                            break;
                        }

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
			    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // Or execute the file
                    else if (list->isItemExecutable(item))
                    {
                        execFile(pathname);
                    }

                    // Or call the "Open with..." dialog
                    else
                    {
                        getApp()->endWaitCursor();
			mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }

                // If no association but executable
                else if (list->isItemExecutable(item))
                {
                    execFile(pathname);
                }

                // Other cases
                else
                {
                    getApp()->endWaitCursor();
		    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                    current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                }
            }
        }
    }

    // More than one selected files
    else
    {
        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN), NULL);
    }

    getApp()->endWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);

    return(1);
}


// Single click on File Item
long FilePanel::onCmdItemClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    // Make panel active
    setActive();

    if (single_click != SINGLE_CLICK_NONE)
    {
        // Default programs
        FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
        FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
        FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
        FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
        FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
        FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
        FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
        FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

        // In detailed mode, avoid single click when mouse cursor is not over the first column
        int    x, y;
        FXuint state;
        getCursorPosition(x, y, state);
        FXbool allow = true;
        if (!(list->getListStyle()&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS)) && ((x-list->getXPosition()) > list->getHeaderSize(0)))
        {
            allow = false;
        }

        // Single click with control or shift
        if (state&(CONTROLMASK|SHIFTMASK))
        {
            return(1);
        }

        // Single click without control or shift
        else
        {
            FXString cmd, cmdname, filename, pathname;

            // Wait cursor
            getApp()->beginWaitCursor();

#ifdef STARTUP_NOTIFICATION
            // Startup notification option and exceptions (if any)
            FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
            FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

            FXlong item = (FXlong)ptr;
            if (item > -1)
            {
                // File name and path
                filename = list->getItemFilename(item);
                pathname = list->getItemPathname(item);

                // If directory, open the directory
                if ((single_click != SINGLE_CLICK_NONE) && list->isItemDirectory(item) && allow)
                {
                    // Does not have access
                    if (!::isReadExecutable(pathname))
                    {
                        MessageBox::error(this, BOX_OK_SU, _("Error"), _(" Permission to: %s denied."), pathname.text());
                        getApp()->endWaitCursor();
                        return(0);
                    }
                    if (filename == "..")
                    {
                        list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
                    }
                    else
                    {
                        list->setDirectory(pathname);
                    }

                    // Change directory in tree list
                    dirpanel->setDirectory(pathname, true);
                    current->updatePath();

                    // Update location history
                    updateLocation();
                }

                // If file, use the association if any
                else if ((single_click == SINGLE_CLICK_DIR_FILE) && list->isItemFile(item) && allow)
                {
                    // Update associations dictionary
                    FileDict*  assocdict = new FileDict(getApp());
                    FileAssoc* association = assocdict->findFileBinding(pathname.text());

                    // If there is an association
                    if (association)
                    {
                        // Use it to open the file
                        if (association->command.section(',', 0) != "")
                        {
                            cmdname = association->command.section(',', 0);

                            // Use a default program if possible
                            switch (progs[cmdname])
                            {
                            case TXTVIEWER:
                                cmdname = txtviewer;
                                break;

                            case TXTEDITOR:
                                cmdname = txteditor;
                                break;

                            case IMGVIEWER:
                                cmdname = imgviewer;
                                break;

                            case IMGEDITOR:
                                cmdname = imgeditor;
                                break;

                            case PDFVIEWER:
                                cmdname = pdfviewer;
                                break;

                            case AUDIOPLAYER:
                                cmdname = audioplayer;
                                break;

                            case VIDEOPLAYER:
                                cmdname = videoplayer;
                                break;

                            case ARCHIVER:
                                cmdname = archiver;
                                break;

                            case NONE: // No program found
                                ;
                                break;
                            }

                            // If command exists, run it
                            if (::existCommand(cmdname))
                            {
                                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                            }

                            // If command does not exist, call the "Open with..." dialog
                            else
                            {
                                getApp()->endWaitCursor();
                                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                            }
                        }

                        // Or execute the file
                        else if (list->isItemExecutable(item))
                        {
                            execFile(pathname);
                        }

                        // Or call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // If no association but executable
                    else if (list->isItemExecutable(item))
                    {
                        execFile(pathname);
                    }

                    // Other cases
                    else
                    {
                        getApp()->endWaitCursor();
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }
            }
            getApp()->endWaitCursor();
        }
    }
    return(1);
}


// Go to parent directory
long FilePanel::onCmdDirectoryUp(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
    current->list->setFocus();
    dirpanel->setDirectory(current->list->getDirectory(), true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Go to home directory
long FilePanel::onCmdGoHome(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setDirectory(homedir);
    current->list->setFocus();
    dirpanel->setDirectory(homedir, true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Go to trash directory
long FilePanel::onCmdGoTrash(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setDirectory(trashfileslocation);
    current->list->setFocus();
    dirpanel->setDirectory(trashfileslocation, true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Set the flag that allows to stop the file list refresh
long FilePanel::onCmdStopListRefreshTimer(FXObject*, FXSelector, void*)
{
    stopListRefresh = true;

    return(0);
}


// Copy/Move/Rename/Symlink file(s)
long FilePanel::onCmdFileMan(FXObject* sender, FXSelector sel, void* ptr)
{
    int      num;
    FXString src, targetdir, target, name, source;
    int      firstitem = 0, lastitem = 0;

    // Focus on this panel list
    current->list->setFocus();

    // Confirmation dialog?
    FXbool ask_before_copy = getApp()->reg().readUnsignedEntry("OPTIONS", "ask_before_copy", true);

    // If we are we called from the paste command, get the parameters from the pointer
    if (fromPaste)
    {
        // Reset the flag
        fromPaste = false;

        // Get the parameters
        FXString str = (char*)ptr;
        targetdir = str.section('\n', 0);
        num = FXUIntVal(str.section('\n', 1));
        src = str.after('\n', 2);

        // If no item in clipboard, return
        if (num <= 0)
        {
            return(0);
        }

        // If there is a selected directory in file panel, use it as target directory
        if (current->list->getNumSelectedItems() == 1)
        {
            int item = current->list->getCurrentItem();
            if (current->list->isItemDirectory(item))
            {
                targetdir = list->getItemPathname(item);
            }
        }
    }

    // Obtain the parameters from the file panel
    else
    {
        // Current directory
        FXString curdir = current->list->getDirectory();

        // Number of selected items
        num = current->list->getNumSelectedItems();

        // If no item, return
        if (num <= 0)
        {
            return(0);
        }

        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        // Obtain the list of source files and the target directory
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                if (firstitem == 0)
                {
                    firstitem = u;
                }
                lastitem = u;
                name = current->list->getItemText(u).text();
                name = name.section('\t', 0);
                src += curdir+PATHSEPSTRING+name+"\n";
            }
        }
        targetdir = current->next->list->getDirectory();

        if (!current->next->shown() || (FXSELID(sel) == ID_FILE_RENAME))
        {
            targetdir = current->list->getDirectory();
        }
    }

    // Number of items in the FileList
    int numitems = current->list->getNumItems();

    // Name and directory of the first source file
    source = src.section('\n', 0);
    name = FXPath::name(source);
    FXString dir = FXPath::directory(source);

    // Initialize target name
    if (targetdir != ROOTDIR)
    {
        target = targetdir+PATHSEPSTRING;
    }
    else
    {
        target = targetdir;
    }

    // Configure the command, title, message, etc.
    FXIcon*  icon = NULL;
    FXString command, title, message;
    if (FXSELID(sel) == ID_FILE_COPY)
    {
        command = "copy";
        title = _("Copy");
        icon = copy_bigicon;
        if (num == 1)
        {
            message = _("Copy ");
            message += source;
            if (::isFile(source))
            {
                target += name;
            }

            // Source and target are identical => add a suffix to the name
            FXString tgt = ::cleanPath(target); // Remove trailing / if any
            if ((::identical(source, tgt) && (tgt != current->list->getDirectory())) || // Check we are not within target
                (::isDirectory(source) && (source == tgt+PATHSEPSTRING+FXPath::name(source))))
            {
                target = ::buildCopyName(source);
            }
        }
        else
        {
            message.format(_("Copy %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_RENAME)
    {
        command = "rename";
        title = _("Rename");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Rename ");
            message += name;
            target = name;
            title = _("Rename");
        }
        else
        {
            return(0);
        }
    }
    if (FXSELID(sel) == ID_FILE_COPYTO)
    {
        command = "copy";
        title = _("Copy");
        icon = copy_bigicon;
        if (num == 1)
        {
            message = _("Copy ");
            message += source;
        }
        else
        {
            message.format(_("Copy %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_MOVETO)
    {
        command = "move";
        title = _("Move");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Move ");
            message += source;
            title = _("Move");
        }
        else
        {
            message.format(_("Move %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_CUT)
    {
        command = "move";
        title = _("Move");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Move ");
            message += source;
            if (::isFile(source))
            {
                target += name;
            }
            title = _("Move");
        }
        else
        {
            message.format(_("Move %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_SYMLINK)
    {
        command = "symlink";
        title = _("Symlink");
        icon = link_bigicon;
        if (num == 1)
        {
            message = _("Symlink ");
            message += source;
            target += name;
        }
        else
        {
            message.format(_("Symlink %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }

    // File operation dialog, if needed
    if (ask_before_copy || (source == target) || (FXSELID(sel) == ID_FILE_COPYTO) || (FXSELID(sel) == ID_FILE_MOVETO) || (FXSELID(sel) == ID_FILE_RENAME) || (FXSELID(sel) == ID_FILE_SYMLINK))
    {
        if (num == 1)
        {
            if (FXSELID(sel) == ID_FILE_RENAME)
            {
                if (operationdialogrename == NULL)
                {
                    operationdialogrename = new InputDialog(this, "", "", title, _("To:"), icon);
                }
                operationdialogrename->setTitle(title);
                operationdialogrename->setIcon(icon);
				operationdialogrename->setMessage(message);
                operationdialogrename->setText(target);

                if (::isDirectory(source))  // directory
                {
                    operationdialogrename->selectAll();
                }
                else
                {
                    int pos = target.rfind('.');
                    if (pos <= 0)
                    {
                        operationdialogrename->selectAll(); // no extension or dot file
                    }
                    else
                    {
                        operationdialogrename->setSelection(0, pos);
                    }
                }

                int rc = 1;
                rc = operationdialogrename->execute(PLACEMENT_CURSOR);
                target = operationdialogrename->getText();
                
                // Target name contains '/'
                if (target.contains(PATHSEPCHAR))
                {
					MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in file or folder names, operation cancelled"));
					return(0);
				}

                if (!rc)
                {
                    return(0);
                }
            }
            else
            {
                if (operationdialogsingle == NULL)
                {
                    operationdialogsingle = new BrowseInputDialog(this, "", "", title, _("To:"), icon, BROWSE_INPUT_MIXED);
                }
                operationdialogsingle->setTitle(title);
                operationdialogsingle->setIcon(icon);
                operationdialogsingle->setMessage(message);
                operationdialogsingle->setText(target);

                // Select file name without path
                if (FXSELID(sel) == ID_FILE_SYMLINK)
                {
                    int pos = target.rfind(PATHSEPSTRING);
                    if (pos >= 0)
                    {
                        operationdialogsingle->setSelection(pos+1, target.length());
                    }
                }

                operationdialogsingle->setDirectory(targetdir);
                int rc = 1;
                rc = operationdialogsingle->execute(PLACEMENT_CURSOR);
                target = operationdialogsingle->getText();
                if (!rc)
                {
                    return(0);
                }
            }
        }
        else
        {
            if (operationdialogmultiple == NULL)
            {
                operationdialogmultiple = new BrowseInputDialog(this, "", "", title, _("To folder:"), icon, BROWSE_INPUT_FOLDER);
            }
            operationdialogmultiple->setTitle(title);
            operationdialogmultiple->setIcon(icon);
            operationdialogmultiple->setMessage(message);
            operationdialogmultiple->setText(target);
            operationdialogmultiple->CursorEnd();
            operationdialogmultiple->setDirectory(targetdir);
            int rc = 1;
            rc = operationdialogmultiple->execute(PLACEMENT_CURSOR);
            target = operationdialogmultiple->getText();
            if (!rc)
            {
                return(0);
            }
        }
    }

    // Nothing entered
    if (target == "")
    {
        MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
        return(0);
    }

    // Update target and target parent directory
	target = ::filePath(target,current->list->getDirectory());
	if (::isDirectory(target))
	{
		targetdir = target;
	}
	else
	{
		targetdir = FXPath::directory(target);
	}

    // Target parent directory doesn't exist
    if (!::exists(targetdir))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), targetdir.text());
        return(0);
    }

    // Target parent directory not writable
    if (!::isWritable(targetdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetdir.text());
        return(0);
    }

    // Target parent directory is not a directory
    if (!::isDirectory(targetdir))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("%s is not a folder"), targetdir.text());
        return(0);
    }

    // Multiple sources and non existent destination
    if ((num > 1) && !::exists(target))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), target.text());
        return(0);
    }

    // Multiple sources and target is a file
    if ((num > 1) && ::isFile(target))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("%s is not a folder"), target.text());
        return(0);
    }

    // Target is a directory and is not writable
    if (::isDirectory(target) && !::isWritable(target))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), target.text());
        return(0);
    }

    // Target is a file and its parent directory is not writable
    if (::isFile(target) && !::isWritable(targetdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetdir.text());
        return(0);
    }

    // One source
    File* f = NULL;
    int   ret;
    if (num == 1)
    {
        // An empty source file name corresponds to the ".." file
        // Don't perform any file operation on it!
        if (source == "")
        {
            return(0);
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        if (command == "copy")
        {
            f = new File(this, _("File copy"), COPY, num);
            f->create();

            // If target file is located at trash location, also create the corresponding trashinfo file
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && (target == trashfileslocation))
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(source, trashfileslocation);

                // Adjust target name to get the _N suffix if any
                FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                // Create trashinfo file
                createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                // Copy source to trash target
                ret = f->copy(source, trashtarget);
            }

            // Copy source to target
            else
            {
                ret = f->copy(source, target);
            }

            // An unknown error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
            }
        }
        else if (command == "rename")
        {
            f = new File(this, _("File rename"), RENAME, num);
            f->create();
            ret = f->rename(source, target);

            // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
            {
                FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                ::unlink(trashinfopathname.text());
            }
        }
        else if (command == "move")
        {
            f = new File(this, _("File move"), MOVE, num);
            f->create();

            // If target file is located at trash location, also create the corresponding trashinfo file
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && (target == trashfileslocation))
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(source, trashfileslocation);

                // Adjust target name to get the _N suffix if any
                FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                // Create trashinfo file
                createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                // Move source to trash target
                ret = f->move(source, trashtarget);
            }

            // Move source to target
            else
            {
                ret = f->move(source, target);
            }

            // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
            // Do it silently and don't report any error if it fails
            if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
            {
                FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                ::unlink(trashinfopathname.text());
            }

            // An unknown error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
            }
        }
        else if (command == "symlink")
        {
            f = new File(this, _("Symlink"), SYMLINK, num);
            f->create();
            f->symlink(source, target);
        }
        // Shouldn't happen
        else
        {
            exit(EXIT_FAILURE);
        }

        getApp()->endWaitCursor();
        delete f;
    }

    // Multiple sources
    // Note : rename cannot be used in this case!
    else if (num > 1)
    {
        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        if (command == "copy")
        {
            f = new File(this, _("File copy"), COPY, num);
        }
        else if (command == "move")
        {
            f = new File(this, _("File move"), MOVE, num);
        }
        else if (command == "symlink")
        {
            f = new File(this, _("Symlink"), SYMLINK, num);
        }
        // Shouldn't happen
        else
        {
            exit(EXIT_FAILURE);
        }
        f->create();

        // Initialize file list stop refresh timer and flag
        stopListRefresh = false;
        getApp()->addTimeout(this, ID_STOP_LIST_REFRESH_TIMER, STOP_LIST_REFRESH_INTERVAL);

        // Loop on the multiple files
        for (int i = 0; i < num; i++)
        {
            // Stop refreshing the file list if file operation is long and has many files
            // This avoids flickering and speeds up things a bit
            if (stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
            {
                // Force a last refresh if current panel is destination
                if (current->getDirectory() == targetdir)
                {
                    current->list->onCmdRefresh(0, 0, 0);
                }

                // Force a last refresh if next panel is destination
                if (next->getDirectory() == targetdir)
                {
                    next->list->onCmdRefresh(0, 0, 0);
                }

                // Tell the dir and file list to not refresh anymore
                setAllowRefresh(false);
                next->setAllowRefresh(false);
                dirpanel->setAllowDirsizeRefresh(false);

                // Don't need to stop again
                stopListRefresh = false;
            }

            // Individual source file
            source = src.section('\n', i);

            // File could have already been moved above in the tree
            if (!::exists(source))
            {
                continue;
            }

            // An empty file name corresponds to the ".." file (why?)
            // Don't perform any file operation on it!
            if (source != "")
            {
                if (command == "copy")
                {
                    // If target file is located at trash location, also create the corresponding trashinfo file
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (target == trashfileslocation))
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(source, trashfileslocation);

                        // Adjust target name to get the _N suffix if any
                        FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                        // Create trashinfo file
                        createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                        // Copy source to trash target
                        ret = f->copy(source, trashtarget);
                    }

                    // Copy source to target
                    else
                    {
                        ret = f->copy(source, target);
                    }

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
                        break;
                    }
                }
                else if (command == "move")
                {
                    // If target file is located at trash location, also create the corresponding trashinfo file
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (target == trashfileslocation))
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(source, trashfileslocation);

                        // Adjust target name to get the _N suffix if any
                        FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                        // Create trashinfo file
                        createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                        // Move source to trash target
                        ret = f->move(source, trashtarget);
                    }

                    // Move source to target
                    else
                    {
                        ret = f->move(source, target);
                    }

                    // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
                    // Do it silently and don't report any error if it fails
                    if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
                    {
                        FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                        ::unlink(trashinfopathname.text());
                    }

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
                        break;
                    }
                }
                else if (command == "symlink")
                {
                    ret = f->symlink(source, target);

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the symlink operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Symlink operation cancelled!"));
                        break;
                    }
                }
                // Shouldn't happen
                else
                {
                    exit(EXIT_FAILURE);
                }
            }
        }

        // Reinit timer and refresh flags
        getApp()->removeTimeout(this, ID_STOP_LIST_REFRESH_TIMER);
        current->setAllowRefresh(true);
        next->setAllowRefresh(true);
        dirpanel->setAllowDirsizeRefresh(true);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panels refresh
    next->onCmdRefresh(0, 0, 0);
    current->onCmdRefresh(0, 0, 0);

    // Enable previous or last selected item for keyboard navigation
    if (((FXSELID(sel) == ID_FILE_MOVETO) || (FXSELID(sel) == ID_FILE_RENAME)) && (current->list->getNumItems() < numitems))
    {
        firstitem = (firstitem < 1) ? 0 : firstitem-1;
        current->list->enableItem(firstitem);
        current->list->setCurrentItem(firstitem);
    }
    else
    {
        current->list->enableItem(lastitem);
        current->list->setCurrentItem(lastitem);
    }

    return(1);
}


// Trash files from the file list or the tree list
long FilePanel::onCmdFileTrash(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();

    FXbool confirm_trash = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_trash", true);

    // If we don't have permission to write to the parent directory
    if (!::isWritable(dir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
        return(0);
    }

    // If we don't have permission to write to the trash directory
    if (!::isWritable(trashfileslocation))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to trash location %s: Permission denied"), trashfileslocation.text());
        return(0);
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        if (confirm_trash)
        {
            FXString message;
	    int funnydelete = 0;
            if (funnydelete == 1)
            {
                    message.format("");

//                  message.format(" ");
            } else {
            if (num == 1)
            {
                FXString pathname;
                for (int u = 0; u < current->list->getNumItems(); u++)
                {
                    if (current->list->isItemSelected(u))
                    {
                        pathname = current->list->getItemPathname(u);
                    }
                }
                if (::isDirectory(pathname))
                {
                    message.format(_("Move folder %s to trash can?"), pathname.text());
                }
                else
                {
                    message.format(_("Move file %s to trash can?"), pathname.text());
                }
            }
            else
            {
                message.format(_("Move %s selected object(s) to trash can?"), FXStringVal(num).text());
            }
            }
            MessageBox box(this, _("Confirm Trash"), message, delete_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
            if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
            {
                return(0);
            }
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Move to trash"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Overwrite initialisations
        FXbool overwrite = false;
        FXbool overwrite_all = false;
        FXbool skip_all = false;

        // Delete selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // If we don't have permission to write to the file
                if (!::isWritable(pathname))
                {
                    // Overwrite dialog if necessary
                    if (!(overwrite_all | skip_all))
                    {
                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("File %s is write-protected, move it anyway to trash can?"), pathname.text());
                        
                        if (num ==1)
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Trash"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;	
							if (answer == 1)
							{
								overwrite = true;
							}
							else
							{
								goto end;
							}
						}  
                        else
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Trash"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Overwrite
							case 1:
								overwrite = true;
								break;

							// Overwrite all
							case 2:
								overwrite_all = true;
								break;

							// Skip
							case 3:
								overwrite = false;
								break;

							// Skip all
							case 4:
								skip_all = true;
								break;
							}
							
						}
                    }
                    if ((overwrite | overwrite_all) & !skip_all)
                    {
                        // Caution!! Don't delete parent directory!!
                        if (filename != "..")
                        {
                            // Trash files path name
                            FXString trashpathname = createTrashpathname(pathname, trashfileslocation);

                            // Create trashinfo file
                            createTrashinfo(pathname, trashpathname, trashfileslocation, trashinfolocation);

                            // Move file to trash files location
                            int ret = f->move(pathname, trashpathname);

                            // An error has occurred
                            if ((ret == 0) && !f->isCancelled())
                            {
                                f->hideProgressDialog();
                                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move to trash operation!"));
                                break;
                            }
                        }
                    }
                    f->showProgressDialog();
                }

                // If we have permission to write
                else
                {
                    // Caution!! Don't delete parent directory!!
                    if (filename != "..")
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(pathname, trashfileslocation);

                        // Create trashinfo file
                        createTrashinfo(pathname, trashpathname, trashfileslocation, trashinfolocation);

                        // Move file to trash files location
                        int ret = f->move(pathname, trashpathname);

                        // An error has occurred
                        if ((ret == 0) && !f->isCancelled())
                        {
                            f->hideProgressDialog();
                            MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move to trash operation!"));
                            break;
                        }
                    }
                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Move to trash file operation cancelled!"));
                        break;
                    }
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// Restore files from trash can
long FilePanel::onCmdFileRestore(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();
    FXbool   confirm_trash = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_trash", true);

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Restore from trash"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Restore (i.e. move to their original location) selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // Don't restore '..' directory
                if (filename != "..")
                {
                    // Obtain trash base name and sub path
                    FXString subpath = pathname;
                    subpath.erase(0, trashfileslocation.length()+1);
                    FXString trashbasename = subpath.before('/');
                    if (trashbasename == "")
                    {
                        trashbasename = name;
                    }
                    subpath.erase(0, trashbasename.length());

                    // Read the .trashinfo file
                    FILE*    fp;
                    char     line[1024];
                    FXbool   success = true;
                    FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+trashbasename+".trashinfo";
                    FXString origpathname = "";

                    if ((fp = fopen(trashinfopathname.text(), "r")) != NULL)
                    {
                        // Read the first two lines and get the strings
                        if (fgets(line, sizeof(line), fp) == NULL)
                        {
                            success = false;
                        }
                        if (fgets(line, sizeof(line), fp) == NULL)
                        {
                            success = false;
                        }
                        if (success)
                        {
                            origpathname = line;
                            origpathname = origpathname.after('=');
                            origpathname = origpathname.before('\n');
                        }
                        fclose(fp);
                        origpathname = origpathname+subpath;
                    }

                    // Confirm restore dialog
                    if (confirm_trash && (u == firstitem))
                    {
                        FXString message;
                        if (num == 1)
                        {
                            if (::isDirectory(pathname))
                            {
                                message.format(_("Restore folder %s to its original location %s ?"), filename.text(), origpathname.text());
                            }
                            else
                            {
                                message.format(_("Restore file %s to its original location %s ?"), filename.text(), origpathname.text());
                            }
                        }
                        else
                        {
                            message.format(_("Restore %s selected object(s) to their original locations?"), FXStringVal(num).text());
                        }
                        f->hideProgressDialog();
                        MessageBox box(this, _("Confirm Restore"), message, restore_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
                        if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
                        {
                            getApp()->endWaitCursor();
                            delete f;
                            return(0);
                        }
                        f->showProgressDialog();
                    }

                    if (origpathname == "")
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("Restore information not available for %s"), pathname.text());
                        goto end;
                    }

                    // If parent dir of the original location does not exist
                    FXString origparentdir = FXPath::directory(origpathname);
                    if (!::exists(origparentdir))
                    {
                        // Ask the user if he wants to create it
                        f->hideProgressDialog();
                        FXString message;
                        message.format(_("Parent folder %s does not exist, do you want to create it?"), origparentdir.text());
                        MessageBox box(this, _("Confirm Restore"), message, restore_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
                        if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
                        {
                            goto end;
                        }
                        else
                        {
                            errno = 0;
                            int ret = mkpath(origparentdir.text(), 0755);
                            int errcode = errno;
                            if (ret == -1)
                            {
                                f->hideProgressDialog();
                                if (errcode)
                                {
                                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't create folder %s: %s"), origparentdir.text(), strerror(errcode));
                                }
                                else
                                {
                                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't create folder %s"), origparentdir.text());
                                }
                                goto end;
                            }
                            f->showProgressDialog();
                        }
                    }

                    // Move file to original location (with restore option)
                    int ret = f->move(pathname, origpathname, true);

                    // An error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the restore from trash operation!"));
                        goto end;
                    }

                    // Silently remove trashinfo file
                    FXString trashfilespathname = trashfileslocation+PATHSEPSTRING+trashbasename;
                    if ((pathname == trashfilespathname) && !::exists(trashfilespathname))
                    {
                        ::unlink(trashinfopathname.text());
                    }
                }
                // If action is cancelled in progress dialog
                if (f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Warning"), _("Restore from trash file operation cancelled!"));
                    goto end;
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// Definitively delete files from the file list or the tree list (no trash can)
long FilePanel::onCmdFileDelete(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();

    FXbool confirm_del = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete", true);
    FXbool confirm_del_emptydir = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete_emptydir", true);

    // If we don't have permission to write to the parent directory
    if (!::isWritable(dir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
        return(0);
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        if (confirm_del)
        {
            FXString message;
            if (num == 1)
            {
                FXString pathname;
                for (int u = 0; u < current->list->getNumItems(); u++)
                {
                    if (current->list->isItemSelected(u))
                    {
                        pathname = current->list->getItemPathname(u);
                    }
                }
                if (::isDirectory(pathname))
                {
                    message.format(_("Definitively delete folder %s ?"), pathname.text());
                }
                else
                {
                    message.format(_("Definitively delete file %s ?"), pathname.text());
                }
            }
            else
            {
                message.format(_("Definitively delete %s selected object(s)?"), FXStringVal(num).text());
            }
            MessageBox box(this, _("Confirm Delete"), message, delete_big_permicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
            if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
            {
                return(0);
            }
        }
        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("File delete"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Overwrite initialisations
        FXbool overwrite = false;
        FXbool overwrite_all = false;
        FXbool skip_all = false;
        FXbool ask_del_empty = true;
        FXbool skip_all_del_emptydir = false;

        // Delete selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // Confirm empty directory deletion
                if (confirm_del & confirm_del_emptydir & ask_del_empty)
                {
                    if ((::isEmptyDir(pathname) == 0) && !::isLink(pathname))
                    {
                        if (skip_all_del_emptydir)
                        {
                            continue;
                        }

                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("Folder %s is not empty, delete it anyway?"), pathname.text());

                        if (num ==1)
                        {
                        	OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							
							if (answer == 0)
							{
								goto end;
							}
						}
                        
                        else
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Yes
							case 1:
								break;

							// Yes for all
							case 2:
								ask_del_empty = false;
								break;

							// Skip
							case 3:
								continue;
								break;

							// Skip all
							case 4:
								skip_all_del_emptydir = true;
								continue;
								break;
							}
						}
						f->showProgressDialog();
                    }
                }

                // If we don't have permission to write to the file
                if (!::isWritable(pathname))
                {
                    // Overwrite dialog if necessary
                    if (!(overwrite_all | skip_all))
                    {
                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("File %s is write-protected, delete it anyway?"), pathname.text());
  
  						if (num == 1)
  						{
                        	OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							if (answer == 1)
							{
								overwrite = true;
							}
							else
							{
								goto end;
							}							
						}
  
 						else
 						{
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Yes
							case 1:
								overwrite = true;
								break;

							// Yes for all
							case 2:
								overwrite_all = true;
								break;

							// Skip
							case 3:
								overwrite = false;
								break;

							// Skip all
							case 4:
								skip_all = true;
								break;
							}
						} 
                    }
                    if ((overwrite | overwrite_all) & !skip_all)
                    {
                        // Caution!! Don't delete parent directory!!
                        if (filename != "..")
                        {
                            // Definitively remove file or folder
                            f->remove(pathname);
                        }
                    }
                    f->showProgressDialog();
                }

                // If we have permission to write
                else
                {
                    // Caution!! Don't delete parent directory!!
                    if (filename != "..")
                    {
                        // Definitively remove file or folder
                        f->remove(pathname);

                        // If is located at trash location, try to also remove the corresponding trashinfo file if it exists
                        // Do it silently and don't report any error if it fails
                        FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                        if (use_trash_can && (pathname.left(trashfileslocation.length()) == trashfileslocation))
                        {
                            FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+filename+".trashinfo";
                            ::unlink(trashinfopathname.text());
                        }
                    }
                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Delete file operation cancelled!"));
                        break;
                    }
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// View/Edit files
long FilePanel::onCmdEdit(FXObject*, FXSelector s, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString   pathname, samecmd, cmd, cmdname, itemslist = " ";
    FileAssoc* association;
    FXbool     same = true;
    FXbool     first = true;

    current->list->setFocus();

    if (current->list->getNumSelectedItems() == 0)
    {
        getApp()->endWaitCursor();
        return(0);
    }

    FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
    FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
    FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
    FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
    FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
    FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
    FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
    FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

    // Update associations dictionary
    FileDict* assocdict = new FileDict(getApp());

    // Check if all files have the same association
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            // Increment number of selected items
            pathname = current->list->getItemPathname(u);
            association = assocdict->findFileBinding(pathname.text());

            // If there is an association
            if (association)
            {
                // Use it to edit/view the files
                if (FXSELID(s) == ID_EDIT) // Edit
                {
                    cmd = association->command.section(',', 2);

                    // Use a default editor if possible
                    switch (progs[cmd])
                    {
                    case TXTEDITOR:
                        cmd = txteditor;
                        break;

                    case IMGEDITOR:
                        cmd = imgeditor;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No default editor found
                        ;
                        break;
                    }

                    if (cmd.length() == 0)
                    {
                        cmd = txteditor;
                    }
                }
                else // Any other is View
                {
                    cmd = association->command.section(',', 1);

                    // Use a default viewer if possible
                    switch (progs[cmd])
                    {
                    case TXTVIEWER:
                        cmd = txtviewer;
                        break;

                    case IMGVIEWER:
                        cmd = imgviewer;
                        break;

                    case PDFVIEWER:
                        cmd = pdfviewer;
                        break;

                    case AUDIOPLAYER:
                        cmd = audioplayer;
                        break;

                    case VIDEOPLAYER:
                        cmd = videoplayer;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No default viewer found
                        ;
                        break;
                    }

                    if (cmd.length() == 0)
                    {
                        cmd = txtviewer;
                    }
                }
                if (cmd.text() != NULL)
                {
                    // First selected item
                    if (first)
                    {
                        samecmd = cmd;
                        first = false;
                    }

                    if (samecmd != cmd)
                    {
                        same = false;
                        break;
                    }

                    // List of selected items
                    itemslist += ::quote(pathname) + " ";
                }
                else
                {
                    same = false;
                    break;
                }
            }

            // No association
            else
            {
                same = false;
                break;
            }
        }
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // Same association for all files : execute the associated or default editor or viewer
    if (same)
    {
        cmdname = samecmd;

        // If command exists, run it
        if (::existCommand(cmdname))
        {
            cmd = cmdname+itemslist;
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
        }
    }

    // Files have different associations : handle them separately
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);

                // Only View / Edit regular files (not directories)
                if (::isFile(pathname))
                {
                    association = assocdict->findFileBinding(pathname.text());

                    // If there is an association
                    if (association)
                    {
                        // Use it to edit/view the file
                        if (FXSELID(s) == ID_EDIT) // Edit
                        {
                            cmd = association->command.section(',', 2);

                            // Use a default editor if possible
                            switch (progs[cmd])
                            {
                            case TXTEDITOR:
                                cmd = txteditor;
                                break;

                            case IMGEDITOR:
                                cmd = imgeditor;
                                break;

                            case ARCHIVER:
                                cmd = archiver;
                                break;
                            }

                            if (cmd.length() == 0)
                            {
                                cmd = txteditor;
                            }
                        }
                        else // Any other is View
                        {
                            cmd = association->command.section(',', 1);

                            // Use a default viewer if possible
                            switch (progs[cmd])
                            {
                            case TXTVIEWER:
                                cmd = txtviewer;
                                break;

                            case IMGVIEWER:
                                cmd = imgviewer;
                                break;

                            case PDFVIEWER:
                                cmd = pdfviewer;
                                break;

                            case AUDIOPLAYER:
                                cmd = audioplayer;
                                break;

                            case VIDEOPLAYER:
                                cmd = videoplayer;
                                break;

                            case ARCHIVER:
                                cmd = archiver;
                                break;

                            case NONE: // No default viewer found
                                ;
                                break;
                            }

                            if (cmd.length() == 0)
                            {
                                cmd = txtviewer;
                            }
                        }

                        if (cmd.text() != NULL)
                        {
                            cmdname = cmd;

                            // If command exists, run it
                            if (::existCommand(cmdname))
                            {
                                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                            }

                            // If command does not exist, call the "Open with..." dialog
                            else
                            {
                                getApp()->endWaitCursor();
                                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                            }
                        }
                    }

                    // No association
                    else
                    {
                        if (FXSELID(s) == ID_EDIT)
                        {
                            cmd = txteditor;
                        }
                        else
                        {
                            cmd = txtviewer;
                        }

                        cmdname = cmd;

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }
                }
            }
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Compare two files
long FilePanel::onCmdCompare(FXObject*, FXSelector s, void*)
{
    current->list->setFocus();
    int num = current->list->getNumSelectedItems();

    // Only one or two selected items can be handled
    if ((num != 1) && (num != 2))
    {
        getApp()->endWaitCursor();
        return(0);
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    FXString filecomparator = getApp()->reg().readStringEntry("PROGS", "filecomparator", DEFAULT_FILECOMPARATOR);
    FXString pathname, cmd, cmdname, itemslist = " ";

    // One selected item
    if (num == 1)
    {
        // Get the selected item
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                itemslist += ::quote(pathname) + " ";
            }
        }

        // Open a dialog to select the other item to be compared
        if (comparedialog == NULL)
        {
            comparedialog = new BrowseInputDialog(this, "", "", _("Compare"), _("With:"), bigcompareicon, BROWSE_INPUT_FILE);
        }
        comparedialog->setIcon(bigcompareicon);
        comparedialog->setMessage(pathname);
        comparedialog->setText("");
        int rc = 1;
        rc = comparedialog->execute(PLACEMENT_CURSOR);

        // Get item path and add it to the list
        FXString str = comparedialog->getText();
        itemslist += ::quote(str);
        if (!rc || (str == ""))
        {
            return(0);
        }
    }

    // Two selected items
    else if (num == 2)
    {
        // Get the two selected items
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                itemslist += ::quote(pathname) + " ";
            }
        }
    }

    // Wait cursor
    getApp()->beginWaitCursor();

    // If command exists, run it
    cmdname = filecomparator;
    if (::existCommand(cmdname))
    {
        cmd = cmdname+itemslist;
#ifdef STARTUP_NOTIFICATION
        runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
        runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
    }

    // If command does not exist, issue an error message
    else
    {
        getApp()->endWaitCursor();
        MessageBox::error(this, BOX_OK, _("Error"), _("Program %s not found. Please define a file comparator program in the Preferences dialog!"), cmdname.text());
    }

    getApp()->endWaitCursor();

    return(1);
}


// File or directory properties
long FilePanel::onCmdProperties(FXObject* sender, FXSelector, void*)
{
    int ret;
    int num, itm;

    current->list->setFocus();

    // If no selected files in the file list, use the selected folder from the tree list (if any)
    num = current->list->getNumSelectedItems(&itm);
    if (num == 0)
    {
		return(0);
    }

    // There is one selected file in the file list
    else if (num == 1)
    {
        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        FXString path = current->list->getDirectory();
        FXString filename = current->list->getItemText(itm);
        filename = filename.section('\t', 0);
        PropertiesBox* attrdlg = new PropertiesBox(this, filename, path);
        attrdlg->create();
        attrdlg->show(PLACEMENT_OWNER);
    }

    // There are multiple selected files in the file list
    else if (num > 1)
    {
        ret = chdir(current->list->getDirectory().text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
            }

            return(0);
        }

        FXString  path = current->list->getDirectory();
        FXString* files = new FXString[num];
        FXString* paths = new FXString[num];

        // Eventually deselect the '..' directory
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        int i = 0;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                files[i] = current->list->getItemText(u).section('\t', 0);
                paths[i] = path;
                i++;
            }
        }

        PropertiesBox* attrdlg = new PropertiesBox(this, files, num, paths);
        attrdlg->create();
        attrdlg->show(PLACEMENT_OWNER);
        
        ret = chdir(startlocation.text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
            }

            return(0);
        }
    }

    // Force panel refresh
    return(1);
}


// Create new directory
long FilePanel::onCmdNewDir(FXObject*, FXSelector, void*)
{
    FXString dirname = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString dirpath = current->list->getDirectory();
    if (dirpath != ROOTDIR)
    {
        dirpath += PATHSEPSTRING;
    }

    if (newdirdialog == NULL)
    {
        newdirdialog = new InputDialog(this, "", _("Create new folder:"), _("New Folder"),"",bignewfoldericon);
    }
    newdirdialog->setText("");

    // Accept was pressed
    if (newdirdialog->execute(PLACEMENT_CURSOR))
    {
        if (newdirdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("Folder name is empty, operation cancelled"));
            return(0);
        }

		// Directory name contains '/'
		if (newdirdialog->getText().contains(PATHSEPCHAR))
		{
			MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in folder names, operation cancelled"));
			return(0);
		}

        dirname = dirpath+newdirdialog->getText();
        if (dirname != dirpath)
        {
            // Create the new dir according to the current umask
            int mask;
            mask = umask(0);
            umask(mask);

            // Note that the umask value is in decimal (511 means octal 0777)
            errno = 0;
            int ret = ::mkdir(dirname.text(), 511 & ~mask);
            int errcode = errno;
            if (ret == -1)
            {
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s: %s"), dirname.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s"), dirname.text());
                }
                return(0);
            }
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == dirname)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Create new file
long FilePanel::onCmdNewFile(FXObject*, FXSelector, void*)
{
    FXString filename = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString pathname = current->list->getDirectory();
    if (pathname != ROOTDIR)
    {
        pathname += PATHSEPSTRING;
    }

    if (newfiledialog == NULL)
    {
        newfiledialog = new InputDialog(this, "", _("Create new file:"), _("New File"), "", bignewfileicon, false);
    }
    newfiledialog->setText("");

    // Accept was pressed
    if (newfiledialog->execute(PLACEMENT_CURSOR))
    {
        if (newfiledialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

		// File name contains '/'
		if (newfiledialog->getText().contains(PATHSEPCHAR))
		{
			MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in file names, operation cancelled"));
			return(0);
		}

        filename = pathname+newfiledialog->getText();
        FILE* file;
        if (filename != pathname)
        {
            // Test some error conditions
            if (::exists(filename))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("File or folder %s already exists"), filename.text());
                return(0);
            }
            // Create the new file
            errno = 0;
            if (!(file = fopen(filename.text(), "w+")) || fclose(file))
            {
                if (errno)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create file %s: %s"), filename.text(), strerror(errno));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create file %s"), filename.text());
                }
                return(0);
            }
            // Change the file permissions according to the current umask
            int mask;
            mask = umask(0);
            umask(mask);
            errno = 0;
            int rc = chmod(filename.text(), 438 & ~mask);
            int errcode = errno;
            if (rc)
            {
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't set permissions in %s: %s"), filename.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't set permissions in %s"), filename.text());
                }
            }
            FXLabel* addressicon = ((XFileExplorer*)mainWindow)->getAddressIcon();
            addressicon->setIcon(minifolderopenicon);
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == filename)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Create new symbolic link
long FilePanel::onCmdNewSymlink(FXObject*, FXSelector, void*)
{
    FXString linkname = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString linkpath = current->list->getDirectory();
    if (linkpath != ROOTDIR)
    {
        linkpath += PATHSEPSTRING;
    }

    if (newlinkdialog == NULL)
    {
        newlinkdialog = new InputDialog(this, "", _("Create new symbolic link:"), _("New Symlink"), "", bignewlinkicon, false);
    }
    newlinkdialog->setText("");

    // Accept was pressed
    if (newlinkdialog->execute(PLACEMENT_CURSOR))
    {
        if (newlinkdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }
        linkname = linkpath+newlinkdialog->getText();
        File* f;
        if (linkname != linkpath)
        {
            // Test some error conditions
            if (::exists(linkname))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("File or folder %s already exists"), linkname.text());
                return(0);
            }

            // Select target
            FileDialog browse(this, _("Select the symlink refered file or folder"));
            browse.setDirectory(linkpath);
            browse.setSelectMode(SELECT_FILE_MIXED);
            if (browse.execute())
            {
                FXString linksource = browse.getFilename();

                // Source does not exist
                if (!::exists(linksource))
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Symlink source %s does not exist"), linksource.text());
                    return(0);
                }

                f = new File(this, _("Symlink"), SYMLINK);
                f->create();
                f->symlink(linksource, linkname);
                delete f;
            }
            //else
            //return 0;
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == linkname)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Open single or multiple files
long FilePanel::onCmdOpen(FXObject*, FXSelector, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString   pathname, samecmd, cmd, cmdname, itemslist = " ";
    FileAssoc* association;
    FXbool     same = true;
    FXbool     first = true;

    current->list->setFocus();
    if (current->list->getNumSelectedItems() == 0)
    {
        getApp()->endWaitCursor();
        return(0);
    }

    // Default programs
    FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
    FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
    FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
    FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
    FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
    FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
    FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
    FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

    // Update associations dictionary
    FileDict* assocdict = new FileDict(getApp());

    // Check if all files have the same association
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            // Increment number of selected items
            pathname = current->list->getItemPathname(u);

            // If directory, skip it
            if (::isDirectory(pathname))
            {
                continue;
            }

            // If association found
            association = assocdict->findFileBinding(pathname.text());
            if (association)
            {
                cmd = association->command.section(',', 0);

                // Use a default program if possible
                switch (progs[cmd])
                {
                case TXTVIEWER:
                    cmd = txtviewer;
                    break;

                case TXTEDITOR:
                    cmd = txteditor;
                    break;

                case IMGVIEWER:
                    cmd = imgviewer;
                    break;

                case IMGEDITOR:
                    cmd = imgeditor;
                    break;

                case PDFVIEWER:
                    cmd = pdfviewer;
                    break;

                case AUDIOPLAYER:
                    cmd = audioplayer;
                    break;

                case VIDEOPLAYER:
                    cmd = videoplayer;
                    break;

                case ARCHIVER:
                    cmd = archiver;
                    break;

                case NONE: // No program found
                    ;
                    break;
                }

                if (cmd != "")
                {
                    // First selected item
                    if (first)
                    {
                        samecmd = cmd;
                        first = false;
                    }

                    if (samecmd != cmd)
                    {
                        same = false;
                        break;
                    }

                    // List of selected items
                    itemslist += ::quote(pathname) + " ";
                }
                else
                {
                    same = false;
                    break;
                }
            }
            else
            {
                same = false;
                break;
            }
        }
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // Same command for all files : open them
    if (same && (itemslist != " "))
    {
        cmdname = samecmd;

        // If command exists, run it
        if (::existCommand(cmdname))
        {
            cmd = samecmd+itemslist;
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
        }
    }

    // Files have different commands : handle them separately
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);

                // If directory, skip it
                if (::isDirectory(pathname))
                {
                    continue;
                }

                association = assocdict->findFileBinding(pathname.text());
                if (association)
                {
                    // Use association to open the file
                    cmd = association->command.section(',', 0);

                    // Use a default program if possible
                    switch (progs[cmd])
                    {
                    case TXTVIEWER:
                        cmd = txtviewer;
                        break;

                    case TXTEDITOR:
                        cmd = txteditor;
                        break;

                    case IMGVIEWER:
                        cmd = imgviewer;
                        break;

                    case IMGEDITOR:
                        cmd = imgeditor;
                        break;

                    case PDFVIEWER:
                        cmd = pdfviewer;
                        break;

                    case AUDIOPLAYER:
                        cmd = audioplayer;
                        break;

                    case VIDEOPLAYER:
                        cmd = videoplayer;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No program found
                        ;
                        break;
                    }

                    if (cmd != "")
                    {
                        cmdname = cmd;

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // Or execute the file
                    else if (current->list->isItemExecutable(u))
                    {
                        execFile(pathname);
                    }

                    // Or call the "Open with..." dialog
                    else
                    {
                        getApp()->endWaitCursor();
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }

                // If no association but executable
                else if (current->list->isItemExecutable(u))
                {
                    execFile(pathname);
                }

                // Other cases
                else
                {
                    getApp()->endWaitCursor();
                    current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                }
            }
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Open with
long FilePanel::onCmdOpenWith(FXObject*, FXSelector, void*)
{
    char** str = NULL;

    current->list->setFocus();

    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    FXString cmd = "", cmdname;
    if (opendialog == NULL)
    {
        opendialog = new HistInputDialog(this, "", _("Open selected file(s) with:"), _("Open With"), "", bigfileopenicon, HIST_INPUT_EXECUTABLE_FILE, true, _("A&ssociate"));
    }
    opendialog->setText(cmd);

    // Dialog with history list and associate checkbox
    opendialog->CursorEnd();
    opendialog->selectAll();
    opendialog->clearItems();
    for (int i = 0; i < OpenNum; i++)
    {
        opendialog->appendItem(OpenHistory[i]);
    }
    opendialog->setDirectory(ROOTDIR);
    opendialog->sortItems();
    if (opendialog->execute())
    {
        cmd = opendialog->getText();
        if (cmd == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Handles "associate" checkbox for "open with..." dialog
                if (opendialog->getOption())
                {
                    FXString filename = current->list->getItemFilename(u);
                    FXString ext = filename.rafter('.', 2).lower();

                    if ((ext == "tar.gz") || (ext == "tar.bz2") || (ext == "tar.xz") || (ext == "tar.z")) // Special cases
                    {
                    }
                    else
                    {
                        ext = FXPath::extension(filename).lower();
                    }

                    if (ext == "")
                    {
                        ext = FXPath::name(filename);
                    }

                    FileAssoc* association = current->list->getItemAssoc(u);

                    if (association)
                    {
                        // Update existing association
                        FXString oldfileassoc = getApp()->reg().readStringEntry("FILETYPES", ext.text(), "");
                        oldfileassoc.erase(0, oldfileassoc.section(';', 0).section(',', 0).length());
                        oldfileassoc.prepend(opendialog->getText());
                        getApp()->reg().writeStringEntry("FILETYPES", ext.text(), oldfileassoc.text());

                        // Handle file association
                        str = new char* [2];
                        str[0] = new char[strlen(ext.text())+1];
                        str[1] = new char[strlen(oldfileassoc.text())+1];
                        strlcpy(str[0], ext.text(), ext.length()+1);
                        strlcpy(str[1], oldfileassoc.text(), oldfileassoc.length()+1);
                        mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ASSOC), str);
                    }
                    else
                    {
                        // New association
                        FXString newcmd = opendialog->getText().append(";Document;;;;");
                        getApp()->reg().writeStringEntry("FILETYPES", ext.text(), newcmd.text());

                        // Handle file association
                        str = new char* [2];
                        str[0] = new char[strlen(ext.text())+1];
                        str[1] = new char[strlen(newcmd.text())+1];
                        strlcpy(str[0], ext.text(), ext.length()+1);
                        strlcpy(str[1], newcmd.text(), newcmd.length()+1);
                        mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ASSOC), str);
                    }
                }
                // End

                FXString pathname = current->list->getItemPathname(u);
                cmdname = cmd;
                cmd += " ";
                cmd = cmd+::quote(pathname);
            }
        }

        // Run command if it exists
        getApp()->beginWaitCursor();

#ifdef STARTUP_NOTIFICATION
        // Startup notification option and exceptions (if any)
        FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
        FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

        // If command exists, run it
        if (::existCommand(cmdname))
#ifdef STARTUP_NOTIFICATION
        {
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
        }
#else
        {
            runcmd(cmd, current->list->getDirectory(), startlocation);
        }
#endif
        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
            return(1);
        }

        // Update history list
        OpenNum = opendialog->getHistorySize();
        cmd = opendialog->getText();

        // Check if cmd is a new string, i.e. is not already in history
        FXbool newstr = true;
        for (int i = 0; i < OpenNum-1; i++)
        {
            if (streq(OpenHistory[i], cmd.text()))
            {
                newstr = false;
                break;
            }
        }

        // History limit reached
        if (OpenNum > OPEN_HIST_SIZE)
        {
            OpenNum--;
        }

        // Restore original history order
        opendialog->clearItems();
        for (int i = 0; i < OpenNum; i++)
        {
            opendialog->appendItem(OpenHistory[i]);
		}

        // New string
        if (newstr)
        {
            // FIFO
            strlcpy(OpenHistory[0], cmd.text(), cmd.length()+1);
            for (int i = 1; i < OpenNum; i++)
            {
                strlcpy(OpenHistory[i], opendialog->getHistoryItem(i-1).text(), opendialog->getHistoryItem(i-1).length()+1);
            }
        }

        getApp()->endWaitCursor();
    }

    return(1);
}


long FilePanel::onCmdItemFilter(FXObject* o, FXSelector sel, void*)
{
    if (FilterNum == 0)
    {
        strlcpy(FilterHistory[FilterNum], "*", 2);
        FilterNum++;
    }

    int      i;
    FXString pat = list->getPattern();
    if (filterdialog == NULL)
    {
        filterdialog = new HistInputDialog(this, pat, _("Show files:"), _("Filter"), "", bigfiltericon, HIST_INPUT_FILE);
    }
    filterdialog->CursorEnd();
    filterdialog->selectAll();
    filterdialog->clearItems();
    for (int i = 0; i < FilterNum; i++)
    {
        filterdialog->appendItem(FilterHistory[i]);
    }
    filterdialog->sortItems();

    if (filterdialog->execute() && ((pat = filterdialog->getText()) != ""))
    {
        // Change file list patten
        if (FXSELID(sel) == ID_FILTER_CURRENT)
        {
            current->list->setPattern(pat);
        }
        else
        {
            list->setPattern(pat);
        }

        FXbool newstr = true;
        for (i = 0; i < FilterNum; i++)
        {
            if (streq(FilterHistory[i], pat.text()))
            {
                newstr = false;
                break;
            }
        }
        // Append new string to the list bottom
        if (newstr && (FilterNum < FILTER_HIST_SIZE))
        {
            strlcpy(FilterHistory[FilterNum], pat.text(), pat.length()+1);
            FilterNum++;
        }
    }

    list->setFocus();
    return(1);
}


// Panel context menu
long FilePanel::onCmdPopupMenu(FXObject* o, FXSelector s, void* p)
{
    // Make panel active
    setActive();

    // Check if control key or Shift-F10 or menu was pressed
    if (p != NULL)
    {
        FXEvent* event = (FXEvent*)p;
        if (event->state&CONTROLMASK)
        {
            ctrl = true;
        }
        if ((event->state&SHIFTMASK && event->code == KEY_F10) || event->code == KEY_Menu)
        {
            shiftf10 = true;
        }
    }

    // Use to select the item under cursor when right clicking
    // Only when Shift-F10 was not pressed
    if (!shiftf10 && (list->getNumSelectedItems() <= 1))
    {
        int    x, y;
        FXuint state;
        list->getCursorPosition(x, y, state);

        int item = list->getItemAt(x, y);

        if (list->getCurrentItem() >= 0)
        {
            list->deselectItem(list->getCurrentItem());
        }
        if (item >= 0)
        {
            list->setCurrentItem(item);
            list->selectItem(item);
        }
    }

    // If first item (i.e. the '..' item)
    if ((list->getNumSelectedItems() == 1) && list->isItemSelected(0))
    {
        ctrl = true;
    }

    // If control flag is set, deselect all items
    if (ctrl)
    {
        list->handle(o, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), p);
    }

    // Popup menu pane
    FXMenuPane* menu = new FXMenuPane(this);
    int         x, y;
    FXuint      state;
    getRoot()->getCursorPosition(x, y, state);

    int num, itm;
    num = current->list->getNumSelectedItems(&itm);

    // No selection or control flag set
    if ((num == 0) || current->ctrl)
    {
        // Menu items
        new FXMenuCommand(menu, _("New& file..."), NULL, current, FilePanel::ID_NEW_FILE);
        new FXMenuCommand(menu, _("New f&older..."), NULL, current, FilePanel::ID_NEW_DIR);
        new FXMenuCommand(menu, _("New s&ymlink..."), NULL, current, FilePanel::ID_NEW_SYMLINK);
        new FXMenuCommand(menu, _("Fi&lter..."), NULL, current, FilePanel::ID_FILTER);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(menu);
        new FXMenuCheck(menu, _("&Hidden files"), current->list, FileList::ID_TOGGLE_HIDDEN);
        new FXMenuCheck(menu, _("Thum&bnails"), current->list, FileList::ID_TOGGLE_THUMBNAILS);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("B&ig icons"), current->list, IconList::ID_SHOW_BIG_ICONS);
        new FXMenuRadio(menu, _("&Small icons"), current->list, IconList::ID_SHOW_MINI_ICONS);
        new FXMenuRadio(menu, _("&Full file list"), current->list, IconList::ID_SHOW_DETAILS);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("&Rows"), current->list, FileList::ID_ARRANGE_BY_ROWS);
        new FXMenuRadio(menu, _("&Columns"), current->list, FileList::ID_ARRANGE_BY_COLUMNS);
        new FXMenuCheck(menu, _("Autosize"), current->list, FileList::ID_AUTOSIZE);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("&Name"), current->list, FileList::ID_SORT_BY_NAME);
        new FXMenuRadio(menu, _("Si&ze"), current->list, FileList::ID_SORT_BY_SIZE);
        new FXMenuRadio(menu, _("&Type"), current->list, FileList::ID_SORT_BY_TYPE);
        new FXMenuRadio(menu, _("E&xtension"), current->list, FileList::ID_SORT_BY_EXT);
        new FXMenuRadio(menu, _("&Date"), current->list, FileList::ID_SORT_BY_TIME);
        new FXMenuRadio(menu, _("&User"), current->list, FileList::ID_SORT_BY_USER);
        new FXMenuRadio(menu, _("&Group"), current->list, FileList::ID_SORT_BY_GROUP);
        new FXMenuRadio(menu, _("Per&missions"), current->list, FileList::ID_SORT_BY_PERM);
        new FXMenuRadio(menu, _("Deletion date"), current->list, FileList::ID_SORT_BY_DELTIME);
        new FXMenuSeparator(menu);
        new FXMenuCheck(menu, _("Ignore c&ase"), current->list, FileList::ID_SORT_CASE);
        new FXMenuCheck(menu, _("Fold&ers first"), current->list, FileList::ID_DIRS_FIRST);
        new FXMenuCheck(menu, _("Re&verse order"), current->list, FileList::ID_SORT_REVERSE);
    }
    // Non empty selection
    else
    {
        // Deselect the '..' item
        if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        }

        // Panel submenu items
        FXMenuPane* submenu = new FXMenuPane(this);
        new FXMenuCommand(submenu, _("Ne&w file..."), NULL, current, FilePanel::ID_NEW_FILE);
        new FXMenuCommand(submenu, _("New f&older..."), NULL, current, FilePanel::ID_NEW_DIR);
        new FXMenuCommand(submenu, _("New s&ymlink..."), NULL, current, FilePanel::ID_NEW_SYMLINK);
        new FXMenuCommand(submenu, _("Fi&lter..."), NULL, current, FilePanel::ID_FILTER);
        new FXMenuSeparator(submenu);
        new FXMenuCommand(submenu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(submenu);
        new FXMenuCheck(submenu, _("&Hidden files"), current->list, FileList::ID_TOGGLE_HIDDEN);
        new FXMenuCheck(submenu, _("Thum&bnails"), current->list, FileList::ID_TOGGLE_THUMBNAILS);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("B&ig icons"), current->list, IconList::ID_SHOW_BIG_ICONS);
        new FXMenuRadio(submenu, _("&Small icons"), current->list, IconList::ID_SHOW_MINI_ICONS);
        new FXMenuRadio(submenu, _("&Full file list"), current->list, IconList::ID_SHOW_DETAILS);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("&Rows"), current->list, FileList::ID_ARRANGE_BY_ROWS);
        new FXMenuRadio(submenu, _("&Columns"), current->list, FileList::ID_ARRANGE_BY_COLUMNS);
        new FXMenuCheck(submenu, _("Autosize"), current->list, FileList::ID_AUTOSIZE);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("&Name"), current->list, FileList::ID_SORT_BY_NAME);
        new FXMenuRadio(submenu, _("Si&ze"), current->list, FileList::ID_SORT_BY_SIZE);
        new FXMenuRadio(submenu, _("&Type"), current->list, FileList::ID_SORT_BY_TYPE);
        new FXMenuRadio(submenu, _("E&xtension"), current->list, FileList::ID_SORT_BY_EXT);
        new FXMenuRadio(submenu, _("&Date"), current->list, FileList::ID_SORT_BY_TIME);
        new FXMenuRadio(submenu, _("&User"), current->list, FileList::ID_SORT_BY_USER);
        new FXMenuRadio(submenu, _("&Group"), current->list, FileList::ID_SORT_BY_GROUP);
        new FXMenuRadio(submenu, _("Per&missions"), current->list, FileList::ID_SORT_BY_PERM);
        new FXMenuRadio(submenu, _("Deletion date"), current->list, FileList::ID_SORT_BY_DELTIME);
        new FXMenuSeparator(submenu);
        new FXMenuCheck(submenu, _("Ignore c&ase"), current->list, FileList::ID_SORT_CASE);
        new FXMenuCheck(submenu, _("Fold&ers first"), current->list, FileList::ID_DIRS_FIRST);
        new FXMenuCheck(submenu, _("Re&verse order"), current->list, FileList::ID_SORT_REVERSE);
        new FXMenuCascade(menu, _("Pane&l"), NULL, submenu);
        new FXMenuSeparator(menu);

#if defined(linux)
        FXString name = current->list->getItemPathname(itm);
        if ((num == 1) && (fsdevices->find(name.text()) || mtdevices->find(name.text())))
        {
            new FXMenuCommand(menu, _("&Mount"), NULL, current, FilePanel::ID_MOUNT);
            new FXMenuCommand(menu, _("Unmount"), NULL, current, FilePanel::ID_UMOUNT);
            new FXMenuSeparator(menu);
        }
#endif

        FXbool ar = false;
        if (current->list->getItem(itm) && current->list->isItemFile(itm))
        {
            new FXMenuCommand(menu, _("Open &with..."), NULL, current, FilePanel::ID_OPEN_WITH);
            new FXMenuCommand(menu, _("&Open"), NULL, current, FilePanel::ID_OPEN);
            FXString name = current->list->getItemText(itm).section('\t', 0);

            // Last and before last file extensions
            FXString ext1 = name.rafter('.', 1).lower();
            FXString ext2 = name.rafter('.', 2).lower();

            // Destination folder name
            FXString extract_to_folder;
            if ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z"))
            {
                extract_to_folder = _("Extr&act to folder ")+name.section('\t', 0).rbefore('.', 2);
            }
            else
            {
                extract_to_folder = _("Extr&act to folder ")+name.section('\t', 0).rbefore('.', 1);
            }

            // Display the extract and package menus according to the archive extensions
            if ((num == 1) && ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
                new FXMenuCommand(menu, extract_to_folder, NULL, current, FilePanel::ID_EXTRACT_TO_FOLDER);
                new FXMenuCommand(menu, _("E&xtract to..."), NULL, current, FilePanel::ID_EXTRACT);
            }
            else if ((num == 1) && ((ext1 == "gz") || (ext1 == "bz2") || (ext1 == "xz") || (ext1 == "z")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
            }
            else if ((num == 1) && ((ext1 == "tar") || (ext1 == "tgz") || (ext1 == "tbz2") || (ext1 == "tbz") || (ext1 == "taz") || (ext1 == "txz") || (ext1 == "zip") || (ext1 == "7z") || (ext1 == "lzh") || (ext1 == "rar") || (ext1 == "ace") || (ext1 == "arj")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
                new FXMenuCommand(menu, extract_to_folder, NULL, current, FilePanel::ID_EXTRACT_TO_FOLDER);
                new FXMenuCommand(menu, _("E&xtract to..."), NULL, current, FilePanel::ID_EXTRACT);
            }
#if defined(linux)
            else if ((num == 1) && ((ext1 == "rpm") || (ext1 == "deb")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&View"), NULL, current, FilePanel::ID_VIEW);
                new FXMenuCommand(menu, _("Install/Up&grade"), NULL, current, ID_PKG_INSTALL);
                new FXMenuCommand(menu, _("Un&install"), NULL, current, ID_PKG_UNINSTALL);
            }
#endif
            // Not archive nor package
            if (!ar)
            {
                new FXMenuCommand(menu, _("&View"), NULL, current, FilePanel::ID_VIEW);
                new FXMenuCommand(menu, _("&Edit"), NULL, current, FilePanel::ID_EDIT);
                if (num == 1)
                {
                    new FXMenuCommand(menu, _("Com&pare..."), NULL, current, FilePanel::ID_COMPARE);
                }
                else
                {
                    new FXMenuCommand(menu, _("Com&pare"), NULL, current, FilePanel::ID_COMPARE);
                }
            }
        }
        if (!ar)
        {
            new FXMenuCommand(menu, _("&Add to archive..."), NULL, current, FilePanel::ID_ADD_TO_ARCH);
        }
#if defined(linux)
        if ((num == 1) && !ar)
        {
            new FXMenuCommand(menu, _("Packages &query "), NULL, current, FilePanel::ID_PKG_QUERY);
        }
#endif

        // Build scripts menu
        new FXMenuSeparator(menu);
        FXString    scriptpath = homedir + PATHSEPSTRING CONFIGPATH PATHSEPSTRING XFECONFIGPATH PATHSEPSTRING SCRIPTPATH;
        FXMenuPane* scriptsmenu = new FXMenuPane(this);
        new FXMenuCascade(menu, _("Scripts"), NULL, scriptsmenu);
        readScriptDir(scriptsmenu, scriptpath);
        new FXMenuSeparator(scriptsmenu);
        new FXMenuCommand(scriptsmenu, _("&Go to script folder"), NULL, this, FilePanel::ID_GO_SCRIPTDIR);

        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("&Copy"), NULL, current, FilePanel::ID_COPY_CLIPBOARD);
        new FXMenuCommand(menu, _("C&ut"), NULL, current, FilePanel::ID_CUT_CLIPBOARD);
        new FXMenuCommand(menu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("Re&name..."), NULL, current, FilePanel::ID_FILE_RENAME);
        new FXMenuCommand(menu, _("Copy &to..."), NULL, current, FilePanel::ID_FILE_COPYTO);
        new FXMenuCommand(menu, _("&Move to..."), NULL, current, FilePanel::ID_FILE_MOVETO);
        new FXMenuCommand(menu, _("Symlin&k to..."), NULL, current, FilePanel::ID_FILE_SYMLINK);
        new FXMenuCommand(menu, _("M&ove to trash"), NULL, current, FilePanel::ID_FILE_TRASH);
        new FXMenuCommand(menu, _("Restore &from trash"), NULL, current, FilePanel::ID_FILE_RESTORE);
        new FXMenuCommand(menu, _("&Delete"), NULL, current, FilePanel::ID_FILE_DELETE);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("Compare &sizes"), NULL, current, FilePanel::ID_DIR_USAGE);
        new FXMenuCommand(menu, _("P&roperties"), NULL, current, FilePanel::ID_PROPERTIES);
    }
    menu->create();

    // Reset flags
    ctrl = false;
    shiftf10 = false;
    allowPopupScroll = true;  // Allow keyboard scrolling


    menu->popup(NULL, x, y);
    getApp()->runModalWhileShown(menu);
    allowPopupScroll = false;

    return(1);
}


// Read all executable file names that are located into the script directory
// Sort entries alphabetically, directories first
int FilePanel::readScriptDir(FXMenuPane* scriptsmenu, FXString dir)
{
    DIR* dp;
    struct dirent** namelist;

    // Open directory
    if ((dp = opendir(dir.text())) == NULL)
    {
        return(0);
    }

    // Eventually add a / at the end of the directory name
    if (dir[dir.length()-1] != '/')
    {
        dir = dir+"/";
    }

	// First, read only directory entries and sort them alphabetically
    int n;
    n = scandir(dir.text(), &namelist, NULL, alphasort);
    if (n < 0)
    {
        perror("scandir");
    }
    else
    {
        for (int k = 0; k < n; k++)
        {
            // Avoid hidden directories and '.' and '..'
            if (namelist[k]->d_name[0] != '.')
            {
                FXString pathname = dir + namelist[k]->d_name;

                // Recurse if non empty directory
                if (::isDirectory(pathname))
                {
                    if (!::isEmptyDir(pathname))
                    {
                        FXMenuPane* submenu = new FXMenuPane(this);
                        new FXMenuCascade(scriptsmenu, namelist[k]->d_name, NULL, submenu);
                        readScriptDir(submenu, pathname);
                    }
                }
            }
            free(namelist[k]);
        }
        free(namelist);
    }

	// Then, read only executable files and sort them alphabetically
    n = scandir(dir.text(), &namelist, NULL, alphasort);
    if (n < 0)
    {
        perror("scandir");
    }
    else
    {
        for (int k = 0; k < n; k++)
        {
			// Add only executable files to the list
			FXString pathname = dir + namelist[k]->d_name;
			if (!::isDirectory(pathname) && isReadExecutable(pathname))
			{
				new FXMenuCommand(scriptsmenu, namelist[k]->d_name + FXString("\t\t") + pathname, miniexecicon, this, FilePanel::ID_RUN_SCRIPT);
			}
            free(namelist[k]);
        }
        free(namelist);
    }

    // Close directory
    (void)closedir(dp);

    return(1);
}


// Run Terminal in the selected directory
long FilePanel::onCmdXTerm(FXObject*, FXSelector, void*)
{
    int ret;

    getApp()->beginWaitCursor();
    ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
        }

        return(0);
    }

    FXString cmd = getApp()->reg().readStringEntry("PROGS", "xterm", "xterm -sb");
    cmd += " &";
    ret = system(cmd.text());
    if (ret < 0)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Can't execute command %s"), cmd.text());
    }

    current->list->setFocus();
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }

        return(0);
    }

    getApp()->endWaitCursor();
    return(1);
}


// Add files or directory to an archive
long FilePanel::onCmdAddToArch(FXObject* o, FXSelector, void*)
{
    int      ret;
    FXString name, ext1, ext2, cmd, archive = "";
    File*    f;

    ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), list->getDirectory().text());
        }

        return(0);
    }

    // Eventually deselect the '..' directory
    if (current->list->isItemSelected(0))
    {
        current->list->deselectItem(0);
    }

    // Return if nothing is selected
    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    // If only one item is selected, use its name as a starting guess for the archive name
    if (current->list->getNumSelectedItems() == 1)
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                name = current->list->getItemFilename(u);
                break;
            }
        }
        archive = name;
    }

    // Initial archive name with full path and default extension
    FXString archpath = current->list->getDirectory();
    if (archpath == PATHSEPSTRING)
    {
        archive = archpath+archive+".tar.gz";
    }
    else
    {
        archive = archpath+PATHSEPSTRING+archive+".tar.gz";
    }

    // Archive dialog
    if (archdialog == NULL)
    {
        archdialog = new ArchInputDialog(this, "");
    }
    archdialog->setText(archive);
    archdialog->CursorEnd();

    if (archdialog->execute())
    {
        if (archdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

        // Get string and preserve escape characters
        archive = ::quote(archdialog->getText());

        // Get extensions of the archive name
        ext1 = archdialog->getText().rafter('.', 1).lower();
        ext2 = archdialog->getText().rafter('.', 2).lower();

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zcvf "+archive+" ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jcvf "+archive+" ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jcvf "+archive+" ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zcvf "+archive+" ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -cvf "+archive+" ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zcvf "+archive+" ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zcvf "+archive+" ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "xz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jcvf "+archive+" ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jcvf "+archive+" ";
        }
        else if (ext1 == "z")
        {
            cmd = "compress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "zip -r "+archive+" ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z a "+archive+" ";
        }

        // Default archive format
        else
        {
            archive += ".tar.gz";
            cmd = "tar -zcvf "+archive+" ";
        }

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Don't include '..' in the list
                name = current->list->getItemFilename(u);
                if (name != "..")
                {
                    cmd += " ";
                    cmd = cmd+::quote(name);
                    cmd += " ";
                }
            }
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Create archive"), ARCHIVE);
        f->create();

        // Create archive
        f->archive(archive, cmd);
        ret = chdir(startlocation.text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
            }

            return(0);
        }

        getApp()->endWaitCursor();
        delete f;

        // Force panel refresh
        onCmdRefresh(0, 0, 0);
    }
    return(1);
}


// Extract archive
long FilePanel::onCmdExtract(FXObject*, FXSelector, void*)
{
    FXString name, ext1, ext2, cmd, dir, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    // File selection dialog
    FileDialog  browse(this, _("Select a destination folder"));
    const char* patterns[] =
    {
        _("All Files"), "*", NULL
    };
    browse.setDirectory(homedir);
    browse.setPatternList(patterns);
    browse.setSelectMode(SELECT_FILE_DIRECTORY);

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        // Archive name and extensions
        name = current->list->getItemText(item).text();

        ext1 = name.section('\t', 0).rafter('.', 1).lower();
        ext2 = name.section('\t', 0).rafter('.', 2).lower();
        name = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jxvf ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -xvf ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gunzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bunzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "unxz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jxvf ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext1 == "z")
        {
            cmd = "uncompress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "unzip -o ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z x -y ";
        }
        else if (ext1 == "rar")
        {
            cmd = "unrar x -o+ ";
        }
        else if (ext1 == "lzh")
        {
            cmd = "lha -xf ";
        }
        else if (ext1 == "ace")
        {
            cmd = "unace x ";
        }
        else if (ext1 == "arj")
        {
            cmd = "arj x -y ";
        }
        else
        {
            cmd = "tar -zxvf ";
        }

        // Final extract command
        cmd += name+" ";


        // Extract archive
        if (browse.execute())
        {
            dir = browse.getFilename();

            if (isWritable(dir))
            {
                // Wait cursor
                getApp()->beginWaitCursor();

                // File object
                f = new File(this, _("Extract archive"), EXTRACT);
                f->create();

                // Extract archive
                f->extract(name, dir, cmd);

                getApp()->endWaitCursor();
                delete f;
            }
            else
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
            }
        }
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Extract archive to a folder name based on the archive name
long FilePanel::onCmdExtractToFolder(FXObject*, FXSelector, void*)
{
    FXString name, pathname, ext1, ext2, cmd, dirname, dirpath, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        // Archive name and extensions
        name = current->list->getItemText(item).text();
        ext1 = name.section('\t', 0).rafter('.', 1).lower();
        ext2 = name.section('\t', 0).rafter('.', 2).lower();

        // Destination folder name
        if ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z"))
        {
            dirname = name.section('\t', 0).rbefore('.', 2);
        }
        else
        {
            dirname = name.section('\t', 0).rbefore('.', 1);
        }

        // Create the new dir according to the current umask
        // Don't complain if directory already exists
        int mask = umask(0);
        umask(mask);
        dirpath = cdir + PATHSEPSTRING + dirname;
        errno = 0;
        int ret = ::mkdir(dirpath.text(), 511 & ~mask);
        int errcode = errno;
        if ((ret == -1) && (errcode != EEXIST))
        {
            if (errcode)
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s: %s"), dirpath.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s"), dirpath.text());
            }
            return(0);
        }

        // Archive pathname
        pathname = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jxvf ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -xvf ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gunzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bunzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "unxz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jxvf ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext1 == "z")
        {
            cmd = "uncompress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "unzip -o ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z x -y ";
        }
        else if (ext1 == "rar")
        {
            cmd = "unrar x -o+ ";
        }
        else if (ext1 == "lzh")
        {
            cmd = "lha -xf ";
        }
        else if (ext1 == "ace")
        {
            cmd = "unace x ";
        }
        else if (ext1 == "arj")
        {
            cmd = "arj x -y ";
        }
        else
        {
            cmd = "tar -zxvf ";
        }

        // Final extract command
        cmd += pathname+" ";

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Extract archive"), EXTRACT);
        f->create();

        // Extract archive
        f->extract(pathname, dirpath, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Extract archive in the current directory
long FilePanel::onCmdExtractHere(FXObject*, FXSelector, void*)
{
    FXString name, ext1, ext2, cmd, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        if (isWritable(cdir))
        {
            // Archive name and extensions
            name = current->list->getItemText(item).text();
            ext1 = name.section('\t', 0).rafter('.', 1);
            lower();
            ext2 = name.section('\t', 0).rafter('.', 2).lower();
            name = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

            // Handle different archive formats
            if (ext2 == "tar.gz")
            {
                cmd = "tar -zxvf ";
            }
            else if (ext2 == "tar.bz2")
            {
                cmd = "tar -jxvf ";
            }
            else if (ext2 == "tar.xz")
            {
                cmd = "tar -Jxvf ";
            }
            else if (ext2 == "tar.z")
            {
                cmd = "tar -Zxvf ";
            }
            else if (ext1 == "tar")
            {
                cmd = "tar -xvf ";
            }
            else if (ext1 == "gz")
            {
                cmd = "gunzip -v ";
            }
            else if (ext1 == "tgz")
            {
                cmd = "tar -zxvf ";
            }
            else if (ext1 == "taz")
            {
                cmd = "tar -Zxvf ";
            }
            else if (ext1 == "bz2")
            {
                cmd = "bunzip2 -v ";
            }
            else if (ext1 == "xz")
            {
                cmd = "unxz -v ";
            }
            else if ((ext1 == "tbz2") || (ext1 == "tbz"))
            {
                cmd = "tar -jxvf ";
            }
            else if (ext1 == "txz")
            {
                cmd = "tar -Jxvf ";
            }
            else if (ext1 == "z")
            {
                cmd = "uncompress -v ";
            }
            else if (ext1 == "zip")
            {
                cmd = "unzip -o ";
            }
            else if (ext1 == "7z")
            {
                cmd = "7z x -y ";
            }
            else if (ext1 == "rar")
            {
                cmd = "unrar x -o+ ";
            }
            else if (ext1 == "lzh")
            {
                cmd = "lha -xf ";
            }
            else if (ext1 == "ace")
            {
                cmd = "unace x ";
            }
            else if (ext1 == "arj")
            {
                cmd = "arj x -y ";
            }
            else
            {
                cmd = "tar -zxvf ";
            }

            // Final extract command
            cmd += name+" ";

            // Wait cursor
            getApp()->beginWaitCursor();

            // File object
            f = new File(this, _("Extract archive"), EXTRACT);
            f->create();

            // Extract archive
            f->extract(name, cdir, cmd);

            getApp()->endWaitCursor();
            delete f;
        }
        else
        {
            MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), cdir.text());
        }
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


#if defined(linux)
// Install/Upgrade package
long FilePanel::onCmdPkgInstall(FXObject*, FXSelector, void*)
{
    FXString name, path, cmd, dir, cdir;
    File*    f;

    cdir = current->list->getDirectory();

    int itm;
    current->list->getNumSelectedItems(&itm);
    if (current->list->getItem(itm))
    {
        name = current->list->getItemText(itm).text();
        name = name.section('\t', 0);
        path = ::quote(cdir + PATHSEPSTRING + name);

        // Command to perform
        FXString ext = FXPath::extension(name);
        if (comparecase(ext, "rpm") == 0)
        {
            cmd = "rpm -Uvh " + path;
        }
        else if (comparecase(ext, "deb") == 0)
        {
            cmd = "dpkg -i "+ path;
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Package Install/Upgrade"), PKG_INSTALL);
        f->create();

        // Install/Upgrade package
        f->pkgInstall(name, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Uninstall package based on its name (package version is ignored)
long FilePanel::onCmdPkgUninstall(FXObject*, FXSelector, void*)
{
    FXString name, cmd, dir, cdir;
    File*    f;

    cdir = current->list->getDirectory();

    int itm;
    current->list->getNumSelectedItems(&itm);
    if (current->list->getItem(itm))
    {
        name = current->list->getItemText(itm).text();
        name = name.section('\t', 0);

        // Command to perform
        FXString ext = FXPath::extension(name);
        if (comparecase(ext, "rpm") == 0)
        {
            name = name.section('-', 0);
            cmd = "rpm -e " + name;
        }
        else if (comparecase(ext, "deb") == 0)
        {
            name = name.section('_', 0);
            cmd = "dpkg -r "+ name;
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Package Uninstall"), PKG_UNINSTALL);
        f->create();

        // Uninstall package
        f->pkgUninstall(name, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


#endif


// Force FilePanel and DirPanel refresh
long FilePanel::onCmdRefresh(FXObject*, FXSelector, void*)
{
    // Refresh panel
    FXString dir = list->getDirectory();
    list->setDirectory(ROOTDIR, false);
    list->setDirectory(dir, false);
    updatePath();
	
	// Focus on current panel
	current-> list->setFocus();

    return(1);
}


// Handle item selection
long FilePanel::onCmdSelect(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setFocus();
    switch (FXSELID(sel))
    {
    case ID_SELECT_ALL:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SELECT_ALL), ptr);
        return(1);

    case ID_DESELECT_ALL:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), ptr);
        return(1);

    case ID_SELECT_INVERSE:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SELECT_INVERSE), ptr);
        return(1);
    }
    return(1);
}


// Handle show commands
long FilePanel::onCmdShow(FXObject* sender, FXSelector sel, void* ptr)
{
    switch (FXSELID(sel))
    {
    case ID_SHOW_BIG_ICONS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_BIG_ICONS), ptr);
        break;

    case ID_SHOW_MINI_ICONS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_MINI_ICONS), ptr);
        break;

    case ID_SHOW_DETAILS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_DETAILS), ptr);
        break;
    }

    // Set focus on current panel list
    current->list->setFocus();

    return(1);
}


// Update show commands
long FilePanel::onUpdShow(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXuint style = current->list->getListStyle();

    switch (FXSELID(sel))
    {
    case ID_SHOW_BIG_ICONS:
        if (style & _ICONLIST_BIG_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_MINI_ICONS:
        if (style & _ICONLIST_MINI_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_DETAILS:
        if (!(style & (_ICONLIST_MINI_ICONS | _ICONLIST_BIG_ICONS)))
        {
            msg = FXWindow::ID_CHECK;
        }
        break;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);

    return(1);
}


// Handle toggle hidden command
long FilePanel::onCmdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_HIDDEN), ptr);
    return(1);
}


// Update toggle hidden command
long FilePanel::onUpdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXbool hidden = current->list->shownHiddenFiles();

    if (hidden == false)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);
    return(1);
}


// Handle toggle thumbnails command
inline long FilePanel::onCmdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_THUMBNAILS), ptr);
    return(1);
}


// Update toggle hidden command
inline long FilePanel::onUpdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXbool showthumb = current->list->shownThumbnails();

    if (showthumb == false)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);
    return(1);
}


// Run script
long FilePanel::onCmdRunScript(FXObject* o, FXSelector sel, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString pathname, cmd, itemslist = " ";
    FXString scriptpath = dynamic_cast<FXMenuCommand*>(o)->getHelpText();

    // Construct selected files list
    current->list->setFocus();
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            pathname = current->list->getItemPathname(u);

            // List of selected items
            itemslist += ::quote(pathname) + " ";
        }
    }

    // Construct command line
    cmd = ::quote(scriptpath) + itemslist + " &";

    // Go to the current directory
    int ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
        }
    }

    // Execute command
    static pid_t child_pid = 0;
    switch ((child_pid = fork()))
    {
    case -1:
        fprintf(stderr, _("Error: Fork failed: %s\n"), strerror(errno));
        break;

    case 0:
        execl("/bin/sh", "sh", "-c", cmd.text(), (char*)NULL);
        _exit(EXIT_SUCCESS);
        break;
    }

    // Return to the starting directory
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Go to scripts directory
long FilePanel::onCmdGoScriptDir(FXObject* o, FXSelector sel, void*)
{
    FXString scriptpath = homedir + PATHSEPSTRING CONFIGPATH PATHSEPSTRING XFECONFIGPATH PATHSEPSTRING SCRIPTPATH;

    if (!::exists(scriptpath))
    {
        // Create the script directory according to the umask
        int mask = umask(0);
        umask(mask);
        errno = 0;
        int ret = mkpath(scriptpath.text(), 511 & ~mask);
        int errcode = errno;
        if (ret == -1)
        {
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create script folder %s: %s"), scriptpath.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create script folder %s"), scriptpath.text());
            }

            return(0);
        }
    }

    // Go to scripts directory
    current->list->setDirectory(scriptpath);
    current->list->setFocus();
    dirpanel->setDirectory(scriptpath, true);
    current->updatePath();
    updateLocation();

    return(1);
}


#if defined(linux)
// Mount/Unmount file systems
long FilePanel::onCmdMount(FXObject*, FXSelector sel, void*)
{
    int      ret;
    FXString cmd, msg, text;
    FXuint   op;
    File*    f;
    FXString dir;

    current->list->setFocus();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (current->list->getNumSelectedItems() == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    // If symbolic link, read the linked directory
    if (::isLink(dir))
    {
        dir = ::readLink(dir);
    }

    if (FXSELID(sel) == ID_MOUNT)
    {
        op = MOUNT;
        msg = _("Mount");
		cmd = getApp()->reg().readStringEntry("PROGS", "mount", DEFAULT_MOUNTCMD) + FXString(" ");
    }
    else
    {
        op = UNMOUNT;
        msg = _("Unmount");
	    cmd = getApp()->reg().readStringEntry("PROGS", "unmount", DEFAULT_UMOUNTCMD) + FXString(" ");
    }
    cmd += ::quote(dir);
    cmd += " 2>&1";
    ret = chdir(ROOTDIR);
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), ROOTDIR, strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), ROOTDIR);
        }

        return(0);
    }

    // Wait cursor
    getApp()->beginWaitCursor();

    // File object
    text = msg + _(" file system...");
    f = new File(this, text.text(), op);
    f->create();

    // Mount/unmount file system
    text = msg + _(" the folder:");
    f->mount(dir, text, cmd, op);
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }

        return(0);
    }

    // If action is cancelled in progress dialog
    if (f->isCancelled())
    {
        f->hide();
        text = msg + _(" operation cancelled!");
        MessageBox::error(this, BOX_OK, _("Warning"), "%s", text.text());
        delete f;
        return(0);
    }

    getApp()->endWaitCursor();
    delete f;

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Update the Mount button
long FilePanel::onUpdMount(FXObject* o, FXSelector sel, void*)
{
    FXString dir;

    int num = current->list->getNumSelectedItems();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (num == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    if (fsdevices->find(dir.text()) && !mtdevices->find(dir.text()) && current->list->getNumItems() && !current->list->isItemSelected(0))
    //if (fsdevices->find(dir.text()) && !mtdevices->find(dir.text()) && current->list->getNumItems())
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update the Unmount button
long FilePanel::onUpdUnmount(FXObject* o, FXSelector sel, void*)
{
    FXString dir;

    int num = current->list->getNumSelectedItems();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (num == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    if ((fsdevices->find(dir.text()) || mtdevices->find(dir.text())) && current->list->getNumItems() && !current->list->isItemSelected(0))
    //if ((fsdevices->find(dir.text()) || mtdevices->find(dir.text())) && current->list->getNumItems())
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Query packages data base
long FilePanel::onCmdPkgQuery(FXObject* o, FXSelector sel, void*)
{
    FXString cmd;

    // Name of the current selected file
    FXString file = current->list->getCurrentFile();

    // Command to perform
    if (pkg_format == DEB_PKG)
    {
        cmd = "dpkg -S " + ::quote(file);
    }
    else if (pkg_format == RPM_PKG)
    {
        cmd = "rpm -qf " + ::quote(file);
    }
    else
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("No compatible package manager (rpm or dpkg) found!"));
        return(0);
    }

    // Query command
    cmd += " 2>&1";

    // Wait cursor
    getApp()->beginWaitCursor();

    // Perform the command
    FILE* pcmd = popen(cmd.text(), "r");
    if (!pcmd)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Failed command: %s"), cmd.text());
        return(0);
    }

    // Get command output
    char     text[10000] = { 0 };
    FXString buf;
    while (fgets(text, sizeof(text), pcmd))
    {
        buf += text;
    }
    snprintf(text, sizeof(text)-1, "%s", buf.text());

    // Close the stream and display error message if any
    if ((pclose(pcmd) == -1) && (errno != ECHILD))   // ECHILD can be set if the child was caught by sigHarvest
    {
        getApp()->endWaitCursor();
        MessageBox::error(this, BOX_OK, _("Error"), "%s", text);
        return(0);
    }
    getApp()->endWaitCursor();

    // Get package name, or detect when the file isn't in a package
    FXString str = text;
    if (pkg_format == DEB_PKG)  // DEB based distribution
    {
        int idx = str.find(" ");               // Split output at first whitespace
        FXString pkgname = str.left(idx-1);    // Remove trailing colon
        FXString fname = str.right(str.length()-idx);
        fname.trim();                          // Remove leading space and trailing newline
        if (streq(fname.text(), file.text()))  // No other word than the file name
        {
            str = pkgname.text();
        }
        else
        {
            str = "";
        }
    }
    if (pkg_format == RPM_PKG)   // RPM based distribution
    {
        if (str.find(' ') != -1) // Space character exists in the string
        {
            str = "";
        }
    }

    // Display the related output message
    FXString message;
    if (str == "")
    {
        message.format(_("File %s does not belong to any package."), file.text());
        MessageBox::information(this, BOX_OK, _("Information"), "%s", message.text());
    }
    else
    {
        message.format(_("File %s belongs to the package: %s"), file.text(), str.text());
        MessageBox::information(this, BOX_OK, _("Information"), "%s", message.text());
    }

    return(1);
}


// Update the package query menu
long FilePanel::onUpdPkgQuery(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing is selected or multiple selection
    // or when unique selection and the selected item is a directory

    int num;

    num = current->list->getNumSelectedItems();

    if ((num == 0) || (num > 1))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else // num=1
    {
        int item = current->list->getCurrentItem();
        if ((item >= 0) && current->list->isItemDirectory(item))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }

    return(1);
}


#endif // End #if defined(linux)


// Directory usage on file selection
long FilePanel::onCmdDirUsage(FXObject* o, FXSelector, void*)
{
	FXString name, command, itemslist = " ";
	FXString cmd1 = "/usr/bin/du --apparent-size -k -s ";
	FXString cmd2 = " 2> /dev/null | /usr/bin/sort -rn | /usr/bin/cut -f2 | /usr/bin/xargs -d '\n' /usr/bin/du --apparent-size --total --si -s 2> /dev/null";

    // Enter current directory
    int ret=chdir(current->getDirectory().text());
    if (ret < 0)
    {
        int errcode=errno;
        if (errcode)
        {
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s: %s"),current->getDirectory().text(),strerror(errcode));
		}
        else
        {
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s"),current->getDirectory().text());
		}

        return 0;
    }

    // Eventually deselect the '..' directory
    if (current->list->isItemSelected(0))
    {
        current->list->deselectItem(0);
    }

    // Return if nothing is selected
    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    // Construct selected files list
    current->list->setFocus();
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
 			name = current->list->getItemFilename(u);

            // List of selected items
            itemslist += ::quote(name) + " ";
        }
    }

	// Command to be executed
	command = cmd1 + itemslist + cmd2;

	// Make and show command window
	CommandWindow* cmdwin=new CommandWindow(getApp(),_("Sizes of Selected Object(s)"),command,25,50);
	cmdwin->create();
	cmdwin->setIcon(charticon);

	// The CommandWindow object will delete itself when closed!

	// Return to start location
	ret = chdir(startlocation.text());
	if (ret < 0)
	{
		int errcode = errno;
		if (errcode)
		{
			MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
		}
		else
		{
			MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
		}
	}

    return(1);
}


// Update the status bar and the path linker
long FilePanel::onUpdStatus(FXObject* sender, FXSelector, void*)
{
    // Update the status bar
    int      item = -1;
    FXString str, linkto;
    char     usize[64];
    FXulong  size = 0;
    //FXString hsize = _("0 bytes");
    FXString hsize = _(" ");

    FXString path = list->getDirectory();

    int num = list->getNumSelectedItems();

    // To handle the update rename (ugly, I know)
    if (current == this)
    {
        if (num <= 1)
        {
            selmult = false;
        }
        else if (num > 1)
        {
            selmult = true;
        }
    }

    item = list->getCurrentItem();

    if (num > 1)
    {
		int nbdirs = 0;
        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u) && !list->isItemDirectory(u))
            {
                size += list->getItemFileSize(u);
#if __WORDSIZE == 64
                snprintf(usize, sizeof(usize)-1, "%lu", size);
#else
                snprintf(usize, sizeof(usize)-1, "%llu", size);
#endif
                hsize = ::hSize(usize);
            }
            
            if (list->isItemDirectory(u))
            {
				nbdirs++;
			}
        }
        
        // Don't count the '..' directory
        if (nbdirs >= 1)
        {
			nbdirs--;
		}
		
		int nbfiles = num - nbdirs;
        if (nbdirs <= 1 && nbfiles <= 1)
        {
	        // str.format(_("%s in %s selected object(s) (%s folder, %s file)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
	        str.format(_("%s object(s) selected (%s folder, %s file)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
                sizestatusct->setText(hsize.text());
		}
        else if (nbdirs <=1 && nbfiles > 1)
        {
	        //str.format(_("%s in %s selected object(s) (%s folder, %s files)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
	        str.format(_("%s object(s) selected (%s folder, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
                sizestatusct->setText(hsize.text());
		}
        else if (nbdirs > 1 && nbfiles <= 1)
        {
	        //str.format(_("%s in %s selected object(s) (%s folders, %s file)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
	        str.format(_("%s object(s) selected (%s folders, %s file)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
                sizestatusct->setText(hsize.text());
		}
		else
		{
	        //str.format(_("%s in %s selected object(s) (%s folders, %s files)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
	        str.format(_("%s object(s) selected (%s folders, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
                sizestatusct->setText(hsize.text());
		}
    }
    else
    {
        // Nothing selected
        if ((num == 0) || (item < 0))
        {
            num = list->getNumItems();
            if (num == 1)
            {
                str = _("1 object(s) (1 folder)");
                sizestatusct->setText(" ");
            }
            else
            {
				int nbdirs = 0;
				for (int u = 0; u < num; u++)
				{
					if (list->isItemDirectory(u))
					{
						nbdirs++;
					}
				}       

				int nbfiles = num - nbdirs;
		        str.format(_("%s object(s) (%s folders, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());
                        sizestatusct->setText(" ");
				if (nbdirs <= 1 && nbfiles <= 1)
				{
					str.format(_("%s object(s) (%s folder, %s file)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
                                        sizestatusct->setText(" ");
				}
				else if (nbdirs <=1 && nbfiles > 1)
				{
					str.format(_("%s object(s) (%s folder, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
                                        sizestatusct->setText(" ");
				}
				else if (nbdirs > 1 && nbfiles <= 1)
				{
					str.format(_("%s object(s) (%s folders, %s file)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
                                        sizestatusct->setText(" ");
				}
				else
				{
					str.format(_("%s object(s) (%s folders, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
                                        sizestatusct->setText(" ");
				}
            }
        }
        else
        {
            FXString string = list->getItemText(item);
            FXString name = string.section('\t', 0);
            FXString type = string.section('\t', 2);

            FXString date = string.section('\t', 4);
            FXString usr = string.section('\t', 5);
            FXString grp = string.section('\t', 6);
            FXString perm = string.section('\t', 7);

            if (type.contains(_("Broken link")))
            {
                linkto = ::readLink(path+PATHSEPSTRING+name);
                //str = name + "->" + linkto.text() + " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
                str = name + "->" + linkto.text() + "; Type: " + type + ";  Date Modified: " + date + "; Size: " + hsize;
                sizestatusct->setText(" ");
            }
            else if (type.contains(_("Link")))
            {
                linkto = ::readLink(path+PATHSEPSTRING+name);
                //str = name + "->" + linkto.text() + " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
                str = name + "->" + linkto.text() + "; Type: " + type + ";  Date Modified: " + date + "; Size: " + hsize;
                sizestatusct->setText(" ");
            }
            else
            {
                for (int u = 0; u < list->getNumItems(); u++)
                {
                    if (list->isItemSelected(u) && !list->isItemDirectory(u))
                    {
                        size = list->getItemFileSize(u);
#if __WORDSIZE == 64
                        snprintf(usize, sizeof(usize)-1, "%lu", size);
#else
                        snprintf(usize, sizeof(usize)-1, "%llu", size);
#endif
                        hsize = ::hSize(usize);
                        break;
                    }
                }
                //str = hsize+ " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
                str = "Type: " + type + "; Date Modified: " + date + "; Size: " + hsize;
                sizestatusct->setText(hsize.text());
            }
        }
    }

    statuslabel->setText(str);

    // Add the filter pattern if any
    if ((list->getPattern() != "*") && (list->getPattern() != "*.*"))
    {
        str.format(_(" - Filter: %s"), list->getPattern().text());
        filterlabel->show();
        filterlabel->setText(str);
        filterlabel->setTextColor(attenclr);
    }
    else
    {
        filterlabel->hide();
        filterlabel->setText("");
    }

    return(1);
}


// Update the path text and the path link
void FilePanel::updatePath()
{
    pathlink->setPath(list->getDirectory());
    pathtext->setText(list->getDirectory());
}


// Update the go to parent directory command
long FilePanel::onUpdUp(FXObject* o, FXSelector, void*)
{
    FXButton* button = (FXButton*)o;
    int       style = button->getButtonStyle();

    if (style & TOGGLEBUTTON_TOOLBAR)
    {
        if (current->list->getDirectory() != ROOTDIR)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update the paste button
long FilePanel::onUpdPaste(FXObject* o, FXSelector, void*)
{
    FXuchar* data;
    FXuint   len;
    FXString buf;
    FXbool   clipboard_empty = true;

    // Lock clipboard to prevent changes in method onCmdRequestClipboard()
    clipboard_locked = true;

    // If source is xfelistType (Gnome, XFCE, or Xfe app)
    if (getDNDData(FROM_CLIPBOARD, xfelistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        buf = (char*)data;

        // Check if valid clipboard
        if (buf.find("file:/") >= 0)
        {
            clipboard_empty = false;
        }

        // Free data pointer
        FXFREE(&data);
    }

    // If source type is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    else if (getDNDData(FROM_CLIPBOARD, urilistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        buf = (char*)data;

        // Check if valid clipboard
        if (buf.find("file:/") >= 0)
        {
            clipboard_empty = false;
        }

        // Free data pointer
        FXFREE(&data);
    }

    // Gray out the paste button, if necessary
    if (clipboard_empty)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }

    // Unlock clipboard
    clipboard_locked = false;

    return(1);
}


// Update menu items and toolbar buttons that are related to file operations
long FilePanel::onUpdMenu(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing or only ".." is selected
    int num;

    num = current->list->getNumSelectedItems();
    DirItem* item = (DirItem*)dirpanel->getCurrentItem();

    if ((dirpanel->shown() && item))
    {
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        //else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        //else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }

    return(1);
}


// Update file delete menu item and toolbar button
long FilePanel::onUpdFileDelete(FXObject* o, FXSelector sel, void*)
{
    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    FXbool use_trash_bypass = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_bypass", false);

    if ( (!use_trash_can) | use_trash_bypass)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        //else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update move to trash menu item and toolbar button
long FilePanel::onUpdFileTrash(FXObject* o, FXSelector sel, void*)
{
    // Disable move to trash menu if we are in trash can
    // or if the trash can directory is selected

    FXbool   trashenable = true;
    FXString trashparentdir = trashlocation.rbefore('/');
    FXString curdir = current->list->getDirectory();

    if (curdir.left(trashlocation.length()) == trashlocation)
    {
        trashenable = false;
    }

    if (curdir == trashparentdir)
    {
        FXString pathname;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                if (pathname == trashlocation)
                {
                    trashenable = false;
                }
            }
        }
    }

    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    if (use_trash_can && trashenable)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        //else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update restore from trash menu item and toolbar button
long FilePanel::onUpdFileRestore(FXObject* o, FXSelector sel, void*)
{
    // Enable restore from trash menu if we are in trash can

    FXbool   restoreenable = false;
    FXString curdir = current->list->getDirectory();

    if (curdir.left(trashfileslocation.length()) == trashfileslocation)
    {
        restoreenable = true;
    }

    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    if (use_trash_can && restoreenable)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else if ((num == 1) && current->list->isItemSelected(0))
        //else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update go trash menu item and toolbar button
inline long FilePanel::onUpdGoTrash(FXObject* o, FXSelector sel, void*)
{
    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);

    if (use_trash_can)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update file open menu
long FilePanel::onUpdOpen(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or a directory (including "..") is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);

    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        if (current->list->getItem(item) && current->list->isItemFile(item))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
    }
    return(1);
}


// Update the status of the menu items that should be disabled when selecting multiple files
long FilePanel::onUpdSelMult(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing is selected or multiple selection or ".." is only selected
    int num;

    num = current->list->getNumSelectedItems();
    DirItem* item = (DirItem*)dirpanel->getCurrentItem();

    if (num == 0)
    {
        if (!item || !dirpanel->shown())
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else if (current->selmult || ((num == 1) && current->list->isItemSelected(0)))
    //else if (current->selmult || (num == 1))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }

    return(1);
}


// Update the file compare menu item
long FilePanel::onUpdCompare(FXObject* o, FXSelector sel, void*)
{
    // Menu item is enabled only when two files are selected
    int num;

    num = current->list->getNumSelectedItems();

    if ((num == 1) || (num == 2))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update Add to archive menu
long FilePanel::onUpdAddToArch(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or ".." is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else if ((num == 1) && current->list->isItemSelected(0))
    //else if ((num == 1))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update scripts menu item
long FilePanel::onUpdRunScript(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or ".." is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update directory usage menu item
inline long FilePanel::onUpdDirUsage(FXObject* o, FXSelector, void*)
{
    // Menu item is enabled only when at least two items are selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num > 1)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    return(1);
}
#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/time.h>

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "startupnotification.h"
#include "FileDialog.h"
#include "FileList.h"
#include "Properties.h"
#include "XFileExplorer.h"
#include "InputDialog.h"
#include "BrowseInputDialog.h"
#include "ArchInputDialog.h"
#include "HistInputDialog.h"
#include "File.h"
#include "MessageBox.h"
#include "OverwriteBox.h"
#include "CommandWindow.h"
#include "ExecuteBox.h"
#include "PathLinker.h"
#include "FilePanel.h"
#include <string>
#include <iostream>

// Duration (in ms) before we can stop refreshing the file list
// Used for file operations on a large list of files
#define STOP_LIST_REFRESH_INTERVAL    5000

// Number of files before stopping the file list refresh
#define STOP_LIST_REFRESH_NBMAX       100


// Clipboard notes :
// The uri-list type used for Xfe is the same as the Gnome uri-list type
// The standard uri-list type is used for KDE and non Gnome / XFCE file managers
// A special uri-list type that containd only "0" (for copy) or "1" (for cut) is used for KDE compatibility


// Global Variables
extern FXMainWindow* mainWindow;
extern FXString      homedir;
extern FXString      xdgdatahome;

// Clipboard
extern FXString clipboard;
FXuint          clipboard_type = 0;


extern char OpenHistory[OPEN_HIST_SIZE][MAX_COMMAND_SIZE];
extern int  OpenNum;
extern char FilterHistory[FILTER_HIST_SIZE][MAX_PATTERN_SIZE];
extern int  FilterNum;
#if defined(linux)
extern FXStringDict* fsdevices;
extern FXStringDict* mtdevices;
extern FXbool        pkg_format;
#endif

extern FXbool allowPopupScroll;
extern FXuint single_click;


// Map
FXDEFMAP(FilePanel) FilePanelMap[] =
{
    FXMAPFUNC(SEL_CLIPBOARD_LOST, 0, FilePanel::onClipboardLost),
    FXMAPFUNC(SEL_CLIPBOARD_GAINED, 0, FilePanel::onClipboardGained),
    FXMAPFUNC(SEL_CLIPBOARD_REQUEST, 0, FilePanel::onClipboardRequest),
    FXMAPFUNC(SEL_TIMEOUT, FilePanel::ID_STOP_LIST_REFRESH_TIMER, FilePanel::onCmdStopListRefreshTimer),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DIRECTORY_UP, FilePanel::onCmdDirectoryUp),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILTER, FilePanel::onCmdItemFilter),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILTER_CURRENT, FilePanel::onCmdItemFilter),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_HOME, FilePanel::onCmdGoHome),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_TRASH, FilePanel::onCmdGoTrash),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_VIEW, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_MIDDLEBUTTONPRESS, FilePanel::ID_FILELIST, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EDIT, FilePanel::onCmdEdit),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_COMPARE, FilePanel::onCmdCompare),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PROPERTIES, FilePanel::onCmdProperties),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_XTERM, FilePanel::onCmdXTerm),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_DIR, FilePanel::onCmdNewDir),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_FILE, FilePanel::onCmdNewFile),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_NEW_SYMLINK, FilePanel::onCmdNewSymlink),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_COPY, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_CUT, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_COPYTO, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_MOVETO, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_RENAME, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_SYMLINK, FilePanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_COPY_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_CUT_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADDCOPY_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADDCUT_CLIPBOARD, FilePanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PASTE_CLIPBOARD, FilePanel::onCmdPaste),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_TRASH, FilePanel::onCmdFileTrash),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_RESTORE, FilePanel::onCmdFileRestore),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_FILE_DELETE, FilePanel::onCmdFileDelete),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_OPEN_WITH, FilePanel::onCmdOpenWith),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_OPEN, FilePanel::onCmdOpen),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_REFRESH, FilePanel::onCmdRefresh),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_BIG_ICONS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_MINI_ICONS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SHOW_DETAILS, FilePanel::onCmdShow),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_TOGGLE_HIDDEN, FilePanel::onCmdToggleHidden),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_TOGGLE_THUMBNAILS, FilePanel::onCmdToggleThumbnails),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SELECT_ALL, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DESELECT_ALL, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_SELECT_INVERSE, FilePanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_ADD_TO_ARCH, FilePanel::onCmdAddToArch),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT, FilePanel::onCmdExtract),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT_TO_FOLDER, FilePanel::onCmdExtractToFolder),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_EXTRACT_HERE, FilePanel::onCmdExtractHere),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_RUN_SCRIPT, FilePanel::onCmdRunScript),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_RUN_SCRIPT, FilePanel::onUpdRunScript),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_GO_SCRIPTDIR, FilePanel::onCmdGoScriptDir),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_DIR_USAGE, FilePanel::onCmdDirUsage),
    FXMAPFUNC(SEL_RIGHTBUTTONRELEASE, FilePanel::ID_FILELIST, FilePanel::onCmdPopupMenu),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_POPUP_MENU, FilePanel::onCmdPopupMenu),
    FXMAPFUNC(SEL_DOUBLECLICKED, FilePanel::ID_FILELIST, FilePanel::onCmdItemDoubleClicked),
    FXMAPFUNC(SEL_CLICKED, FilePanel::ID_FILELIST, FilePanel::onCmdItemClicked),
    FXMAPFUNC(SEL_FOCUSIN, FilePanel::ID_FILELIST, FilePanel::onCmdFocus),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_STATUS, FilePanel::onUpdStatus),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_DIRECTORY_UP, FilePanel::onUpdUp),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_COPY_CLIPBOARD, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_CUT_CLIPBOARD, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PASTE_CLIPBOARD, FilePanel::onUpdPaste),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PROPERTIES, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_TRASH, FilePanel::onUpdFileTrash),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_RESTORE, FilePanel::onUpdFileRestore),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_GO_TRASH, FilePanel::onUpdGoTrash),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_DELETE, FilePanel::onUpdFileDelete),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_MOVETO, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_COPYTO, FilePanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_FILE_RENAME, FilePanel::onUpdSelMult),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_COMPARE, FilePanel::onUpdCompare),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_EDIT, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_VIEW, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_OPEN, FilePanel::onUpdOpen),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_ADD_TO_ARCH, FilePanel::onUpdAddToArch),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_BIG_ICONS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_MINI_ICONS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_SHOW_DETAILS, FilePanel::onUpdShow),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_TOGGLE_HIDDEN, FilePanel::onUpdToggleHidden),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_TOGGLE_THUMBNAILS, FilePanel::onUpdToggleThumbnails),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_DIR_USAGE, FilePanel::onUpdDirUsage),
#if defined(linux)
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_MOUNT, FilePanel::onCmdMount),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_UMOUNT, FilePanel::onCmdMount),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_MOUNT, FilePanel::onUpdMount),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_UMOUNT, FilePanel::onUpdUnmount),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_QUERY, FilePanel::onCmdPkgQuery),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_INSTALL, FilePanel::onCmdPkgInstall),
    FXMAPFUNC(SEL_COMMAND, FilePanel::ID_PKG_UNINSTALL, FilePanel::onCmdPkgUninstall),
    FXMAPFUNC(SEL_UPDATE, FilePanel::ID_PKG_QUERY, FilePanel::onUpdPkgQuery),
#endif
};

// Object implementation
FXIMPLEMENT(FilePanel, FXVerticalFrame, FilePanelMap, ARRAYNUMBER(FilePanelMap))

// Construct File Panel
FilePanel::FilePanel(FXWindow* owner, const char* nm, FXComposite* p, DirPanel* dp, FXuint name_size, FXuint size_size, FXuint type_size, FXuint ext_size,
                     FXuint modd_size, FXuint user_size, FXuint grou_size, FXuint attr_size, FXuint deldate_size, FXuint origpath_size, FXbool showthumbs, FXColor listbackcolor, FXColor listforecolor,
                     FXColor attentioncolor, FXbool smoothscroll, FXuint opts, int x, int y, int w, int h) :
    FXVerticalFrame(p, opts, x, y, w, h, 0, 0, 0, 0)
{
    name = nm;
    dirpanel = dp;
    attenclr = attentioncolor;

    // Global container
    FXVerticalFrame* cont = new FXVerticalFrame(this, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // Container for the path linker
    FXHorizontalFrame* pathframe = new FXHorizontalFrame(cont, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0);

    // File list

    // Smooth scrolling
    FXuint options;
    if (smoothscroll)
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS;
    }
    else
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS|SCROLLERS_DONT_TRACK;
    }

    FXHorizontalFrame* cont2 = new FXHorizontalFrame(cont, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_SUNKEN|FRAME_THICK, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    /*FXVerticalFrame* webview = new FXVerticalFrame(cont2, LAYOUT_FIX_WIDTH|LAYOUT_FILL_Y, 0, 0, 200, 0, 0, 0, 0, 0);
    webview->setBackColor(getApp()->getBackColor());

    FXLabel* webviewbg = new FXLabel(webview, "", webviewbgicon, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    webviewbg->setBackColor(getApp()->getBackColor());

    webviewtext = new FXLabel(webview, "Folder", 0, 0, 10, 100, 0, 0, 10, 10, 0, 0);
    webviewtext->setBackColor(getApp()->getBackColor());

    std::cout << webviewtext;
    std::cout << "\n";


    FXHorizontalFrame* webviewsep = new FXHorizontalFrame(webview, LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, 184, 2);
    webviewsep->setBackColor(FXRGB(102,153,204));

    //std::string iconbg = "test";
    //std::string* ptr = &iconbg;

    //FXEvent *ev=(FXEvent*)ptr;
    //FXDCWindow dc(webviewbg,ev);
    //dc.drawIcon(webviewbgicon,10,10);

    FXLabel* webviewicon = new FXLabel(webview, "", bigfoldericon, LAYOUT_FIX_X|LAYOUT_FIX_Y, 16, 16, 0, 0, 0, 0, 0, 0);
    webviewicon->setBackColor(FXRGBA(255,255,255,0));*/

    list = new FileList(owner, cont2, this, ID_FILELIST, showthumbs, options);
    list->setHeaderSize(0, name_size);
    list->setHeaderSize(1, size_size);
    list->setHeaderSize(2, type_size);
    list->setHeaderSize(3, ext_size);
    list->setHeaderSize(4, modd_size);
    list->setHeaderSize(5, user_size);
    list->setHeaderSize(6, grou_size);
    list->setHeaderSize(7, attr_size);
    list->setHeaderSize(8, deldate_size);
    list->setHeaderSize(9, origpath_size);
    list->setTextColor(listforecolor);
    list->setBackColor(listbackcolor);

    // Path text
    pathtext = new TextLabel(pathframe, 0, this, ID_FILELIST, LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0);
    pathtext->setBackColor(getApp()->getBaseColor());

    // Hide path frame if path link/breadcrums are disabled
    show_pathlink = getApp()->reg().readUnsignedEntry("SETTINGS", "show_pathlinker", true);

    if (show_pathlink == false)
    {
         pathframe->hide();
    }



    // Path linker
    pathlink = new PathLinker(pathframe, list, dirpanel->getList(), JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X);
    //FXButton* dummyicon = new FXButton(pathframe, "", minifoldericon, this, 2, BUTTON_TOOLBAR|JUSTIFY_LEFT|LAYOUT_LEFT);


    // Visually indicate if the panel is active
    activeicon = new FXButton(pathframe, "", minifoldericon, this, FilePanel::ID_FILELIST, BUTTON_TOOLBAR|JUSTIFY_LEFT|LAYOUT_LEFT);



    // Status bar
    statusbar = new FXHorizontalFrame(cont, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|LAYOUT_BOTTOM, 0, 0, 0, 0, 0, 0, 0, 0);

    statusbar->setTarget(this);
    statusbar->setSelector(FXSEL(SEL_UPDATE, FilePanel::ID_STATUS));

    FXString key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "filter", "Ctrl-D");

    FXHorizontalFrame* hframe = new FXHorizontalFrame(statusbar, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0);
    statuslabel = new FXLabel(hframe, _("Status"), NULL, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X|FRAME_SUNKEN);
    filterlabel = new FXLabel(hframe, "", NULL, JUSTIFY_LEFT|LAYOUT_LEFT);

    corner = new FXDragCorner(statusbar);

    // Panel separator
    panelsep = new FXHorizontalSeparator(cont, SEPARATOR_GROOVE|LAYOUT_FILL_X);

    // Initializations
    selmult = false;
    current = NULL;

    // Single click navigation
    single_click = getApp()->reg().readUnsignedEntry("SETTINGS", "single_click", SINGLE_CLICK_NONE);
    if (single_click == SINGLE_CLICK_DIR_FILE)
    {
        list->setDefaultCursor(getApp()->getDefaultCursor(DEF_HAND_CURSOR));
    }

    // Dialogs
    operationdialogsingle = NULL;
    operationdialogrename = NULL;
    operationdialogmultiple = NULL;
    newdirdialog = NULL;
    newfiledialog = NULL;
    newlinkdialog = NULL;
    opendialog = NULL;
    archdialog = NULL;
    filterdialog = NULL;
    comparedialog = NULL;

    // Home and trahscan locations
    trashlocation = xdgdatahome+PATHSEPSTRING TRASHPATH;
    trashfileslocation = xdgdatahome + PATHSEPSTRING TRASHFILESPATH;
    trashinfolocation = xdgdatahome + PATHSEPSTRING TRASHINFOPATH;

    // Start location (we return to the start location after each chdir)
    startlocation = FXSystem::getCurrentDirectory();

    // Initialize clipboard flags
    clipboard_locked = false;
    fromPaste = false;

    // Initialize control flag for right click popup menu
    ctrl = false;

    // Initialize the Shift-F10 flag
    shiftf10 = false;

    // Initialize the active panel flag
    isactive = false;

    // Default programs identifiers
    progs["<txtviewer>"] = TXTVIEWER;
    progs["<txteditor>"] = TXTEDITOR;
    progs["<imgviewer>"] = IMGVIEWER;
    progs["<imgeditor>"] = IMGEDITOR;
    progs["<pdfviewer>"] = PDFVIEWER;
    progs["<audioplayer>"] = AUDIOPLAYER;
    progs["<videoplayer>"] = VIDEOPLAYER;
    progs["<archiver>"] = ARCHIVER;
}


// Create X window
void FilePanel::create()
{
    // Register standard uri-list type
    urilistType = getApp()->registerDragType("text/uri-list");

    // Register special uri-list type used for Gnome, XFCE and Xfe
    xfelistType = getApp()->registerDragType("x-special/gnome-copied-files");

    // Register special uri-list type used for KDE
    kdelistType = getApp()->registerDragType("application/x-kde-cutselection");

    // Register standard UTF-8 text type used for file dialogs
    utf8Type = getApp()->registerDragType("UTF8_STRING");

    // Display or hide path linker
    FXbool show_pathlink = getApp()->reg().readUnsignedEntry("SETTINGS", "show_pathlinker", true);
    if (show_pathlink)
    {
        pathtext->hide();
        pathlink->show();
    }
    else
    {
        pathtext->show();
        pathlink->hide();
    }

    FXVerticalFrame::create();
}


// Destructor
FilePanel::~FilePanel()
{
    delete list;
    delete current;
    delete next;
    delete statuslabel;
    delete filterlabel;
    delete statusbar;
    delete panelsep;
    delete pathlink;
    delete newfiledialog;
    delete newlinkdialog;
    delete newdirdialog;
    delete opendialog;
    delete archdialog;
    delete filterdialog;
    delete comparedialog;
    delete operationdialogsingle;
    delete operationdialogrename;
    delete operationdialogmultiple;
    delete pathtext;
}


// Make panel active
void FilePanel::setActive()
{
    // Set active icon
    // activeicon->setIcon(greenbuttonicon);
    activeicon->setIcon(NULL);
    activeicon->setTipText(_("Panel is active"));

    pathlink->focus();
    current = this;

    // Make dirpanel point on the current directory,
    // but only if Filepanel and Dirpanel directories are different
    if (dirpanel->getDirectory() != current->list->getDirectory())
    {
        dirpanel->setDirectory(current->list->getDirectory(), true);
    }

    // Make dirpanel inactive
    dirpanel->setInactive();

    next->setInactive();
    list->setFocus();

    isactive = true;
}


// Make panel inactive
void FilePanel::setInactive(FXbool force)
{
    // Set active icon
    // activeicon->setIcon(graybuttonicon);
    activeicon->setIcon(NULL);
    activeicon->setTipText(_("Activate panel"));

    // By default we set the panel inactive
    if (force)
    {
        current = next;
        list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), NULL);

        isactive = false;
    }
}


// Make panel focus (i.e. active) when clicked
long FilePanel::onCmdFocus(FXObject* sender, FXSelector sel, void* ptr)
{
    setActive();
    return(1);
}


// Set Pointer to Another FilePanel
void FilePanel::Next(FilePanel* nxt)
{
    next = nxt;
}


// Show or hide drag corner
void FilePanel::showCorner(FXbool show)
{
    if (show)
    {
        corner->show();
    }
    else
    {
        corner->hide();
    }
}


// Show or hide active icon
void FilePanel::showActiveIcon(FXbool show)
{
    if (show)
    {
        activeicon->show();
    }
    else
    {
        activeicon->hide();
    }
}


// Update location history when changing directory (home, up or double click)
void FilePanel::updateLocation()
{
    FXString    item;
    int         i = 0;
    FXComboBox* address = ((XFileExplorer*)mainWindow)->getAddressBox();

    address->setNumVisible(5);
    int      count = address->getNumItems();
    FXString p = list->getDirectory();

    // Remember latest directory in the location address
    if (!count)
    {
        count++;
        address->insertItem(0, address->getText());
    }
    while (i < count)
    {
        item = address->getItem(i++);
        if (streq((const char*)&p[0], (const char*)&item[0]))
        {
            i--;
            break;
        }
    }
    if (i == count)
    {
        address->insertItem(0, list->getDirectory());
        //webviewtext->setText(list->getDirectory());
        //webviewtext->setTextColor(FXRGB(255,255,255));
        //std::cout << webviewtext;
    }

    // Make current directory visible to avoid scrolling again
    list->makeItemVisible(list->getCurrentItem());
}


// We now really do have the clipboard, keep clipboard content
long FilePanel::onClipboardGained(FXObject* sender, FXSelector sel, void* ptr)
{
    FXVerticalFrame::onClipboardGained(sender, sel, ptr);
    return(1);
}


// We lost the clipboard
long FilePanel::onClipboardLost(FXObject* sender, FXSelector sel, void* ptr)
{
    FXVerticalFrame::onClipboardLost(sender, sel, ptr);
    return(1);
}


// Somebody wants our clipboard content
long FilePanel::onClipboardRequest(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    FXuchar* data;
    FXuint   len;

    // Perhaps the target wants to supply its own data for the clipboard
    if (FXVerticalFrame::onClipboardRequest(sender, sel, ptr))
    {
        return(1);
    }

    // Clipboard target is xfelistType (Xfe, Gnome or XFCE)
    if (event->target == xfelistType)
    {
        // Don't modify the clipboard if we are called from updPaste()
        if (!clipboard_locked)
        {
            // Prepend "copy" or "cut" as in the Gnome way and avoid duplicating these strings
            if ((clipboard.find("copy\n") < 0) && (clipboard.find("cut\n") < 0))
            {
                if (clipboard_type == CUT_CLIPBOARD)
                {
                    clipboard = "cut\n" + clipboard;
                }
                else
                {
                    clipboard = "copy\n" + clipboard;
                }
            }
        }

        // Return clipboard content
        if (event->target == xfelistType)
        {
            if (!clipboard.empty())
            {
                len = clipboard.length();
                FXMEMDUP(&data, clipboard.text(), FXuchar, len);
                setDNDData(FROM_CLIPBOARD, event->target, data, len);

                // Return because xfelistType is not compatible with other types
                return(1);
            }
        }
    }

    // Clipboard target is kdelisType (KDE)
    if (event->target == kdelistType)
    {
        // The only data to be passed in this case is "0" for copy and "1" for cut
        // The uri data are passed using the standard uri-list type
        FXString flag;
        if (clipboard_type == CUT_CLIPBOARD)
        {
            flag = "1";
        }
        else
        {
            flag = "0";
        }

        // Return clipboard content
        if (event->target == kdelistType)
        {
            FXMEMDUP(&data, flag.text(), FXuchar, 1);
            setDNDData(FROM_CLIPBOARD, event->target, data, 1);
        }
    }

    // Clipboard target is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    if (event->target == urilistType)
    {
        if (!clipboard.empty())
        {
            len = clipboard.length();
            FXMEMDUP(&data, clipboard.text(), FXuchar, len);
            setDNDData(FROM_CLIPBOARD, event->target, data, len);

            return(1);
        }
    }

    // Clipboard target is utf8Type (to paste file pathes as text to other applications)
    if (event->target == utf8Type)
    {
        if (!clipboard.empty())
        {
            int      beg = 0, end = 0;
            FXString str = "";
            FXString pathname, url;

            // Clipboard don't contain 'copy\n' or 'cut\n' as first line
            if ((clipboard.find("copy\n") < 0) && (clipboard.find("cut\n") < 0))
            {
                // Remove the 'file:' prefix for each file path
                while (1)
                {
                    end = clipboard.find('\n', end);
                    if (end < 0) // Last line
                    {
                        end = clipboard.length();
                        url = clipboard.mid(beg, end-beg+1);
                        pathname = FXURL::decode(FXURL::fileFromURL(url));
                        str += pathname;
                        break;
                    }
                    url = clipboard.mid(beg, end-beg+1);
                    pathname = FXURL::decode(FXURL::fileFromURL(url));
                    str += pathname;
                    end++;
                    beg = end;
                }
                end = str.length();
            }

            // Clipboard contains 'copy\n' or 'cut\n' as first line, thus skip it
            else
            {
                // Start after the 'copy\n' or 'cut\n' prefix
                end = clipboard.find('\n', 0);
                end++;
                beg = end;

                // Remove the 'file:' prefix for each file path
                while (1)
                {
                    end = clipboard.find('\n', end);
                    if (end < 0) // Last line
                    {
                        end = clipboard.length();
                        url = clipboard.mid(beg, end-beg+1);
                        pathname = FXURL::decode(FXURL::fileFromURL(url));
                        str += pathname;
                        break;
                    }
                    url = clipboard.mid(beg, end-beg+1);
                    pathname = FXURL::decode(FXURL::fileFromURL(url));
                    str += pathname;
                    end++;
                    beg = end;
                }
                end = str.length();
            }

            if (!str.empty())
            {
                len = str.length();
                FXMEMDUP(&data, str.text(), FXuchar, len);
                setDNDData(FROM_CLIPBOARD, event->target, data, len);

                return(1);
            }
        }
    }
    return(0);
}


// Copy or cut to clipboard (and add copy / add cut)
long FilePanel::onCmdCopyCut(FXObject*, FXSelector sel, void*)
{
    FXString name, curdir;

    // Clear clipboard if normal copy or cut
    if ((FXSELID(sel) == ID_COPY_CLIPBOARD) || (FXSELID(sel) == ID_CUT_CLIPBOARD))
    {
        clipboard.clear();
    }

    // Add an '\n' at the end if addcopy or addcut
    else
    {
        clipboard += '\n';
    }

    // Clipboard type
    if ((FXSELID(sel) == ID_CUT_CLIPBOARD) || (FXSELID(sel) == ID_ADDCUT_CLIPBOARD))
    {
        clipboard_type = CUT_CLIPBOARD;
    }
    else
    {
        clipboard_type = COPY_CLIPBOARD;
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        /* if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        } */

        // Construct the uri list of files and fill the clipboard with it
        curdir = current->list->getDirectory();

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                name = current->list->getItemText(u).text();
                name = name.section('\t', 0);
                if (curdir == ROOTDIR)
                {
                    clipboard += FXURL::encode(::fileToURI(curdir+name))+"\n";
                }
                else
                {
                    clipboard += FXURL::encode(::fileToURI(curdir+PATHSEPSTRING+name))+"\n";
                }
            }
        }
    }

    // Remove the last \n of the list, for compatibility with some file managers (e.g. nautilus, nemo)
    clipboard.erase(clipboard.length()-1);

    // Acquire the clipboard
    FXDragType types[4];
    types[0] = xfelistType;
    types[1] = kdelistType;
    types[2] = urilistType;
    types[3] = utf8Type;
    if (acquireClipboard(types, 4))
    {
        return(0);
    }

    return(1);
}


// Paste file(s) from clipboard
long FilePanel::onCmdPaste(FXObject*, FXSelector sel, void*)
{
    FXuchar* data;
    FXuint   len;
    int      beg, end, pos;
    FXString chaine, url, param;
    int      num = 0;
    FXbool   from_kde = false;

    // If source is xfelistType (Gnome, XFCE, or Xfe app)
    if (getDNDData(FROM_CLIPBOARD, xfelistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';

        clipboard = (char*)data;

        // Loop over clipboard items
        for (beg = 0; beg < clipboard.length(); beg = end+1)
        {
            if ((end = clipboard.find("\n", beg)) < 0)
            {
                end = clipboard.length();
            }

            // Obtain item url
            url = clipboard.mid(beg, end-beg);

            // Eventually remove the trailing '\r' if any
            if ((pos = url.rfind('\r')) > 0)
            {
                url.erase(pos);
            }

            // Process first item
            if (num == 0)
            {
                // First item should be "copy" or "cut"
                if (url == "copy")
                {
                    clipboard_type = COPY_CLIPBOARD;
                    num++;
                }
                else if (url == "cut")
                {
                    clipboard_type = CUT_CLIPBOARD;
                    num++;
                }

                // If first item is not "copy" nor "cut", process it as a normal url
                // and use default clipboard type
                else
                {
                    // Update the param string
                    param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";

                    // Add one more because the first line "copy" or "cut" was not present
                    num += 2;
                }
            }

            // Process other items
            else
            {
                // Update the param string
                param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";
                num++;
            }
        }

        // Construct the final param string passed to the file management routine
        param = current->list->getDirectory()+"\n" + FXStringVal(num-1) + "\n" + param;

        // Copy or cut operation depending on the clipboard type
        switch (clipboard_type)
        {
        case COPY_CLIPBOARD:
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_COPY);
            break;

        case CUT_CLIPBOARD:
            clipboard.clear();
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_CUT);
            break;
        }
        fromPaste = true;
        handle(this, sel, (void*)param.text());

        // Free data pointer
        FXFREE(&data);

        // Return here because xfelistType is not compatible with other types
        return(1);
    }

    // If source type is kdelistType (KDE)
    if (getDNDData(FROM_CLIPBOARD, kdelistType, data, len))
    {
        from_kde = true;

        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        clipboard = (char*)data;

        // Obtain clipboard type (copy or cut)
        if (clipboard == "1")
        {
            clipboard_type = CUT_CLIPBOARD;
        }
        else
        {
            clipboard_type = COPY_CLIPBOARD;
        }

        FXFREE(&data);
    }


    // If source type is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    if (getDNDData(FROM_CLIPBOARD, urilistType, data, len))
    {
        // For non KDE apps, set action to copy
        if (!from_kde)
        {
            clipboard_type = COPY_CLIPBOARD;
        }

        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        clipboard = (char*)data;

        // Loop over clipboard items
        for (beg = 0; beg < clipboard.length(); beg = end+1)
        {
            if ((end = clipboard.find("\n", beg)) < 0)
            {
                end = clipboard.length();
            }

            // Obtain item url
            url = clipboard.mid(beg, end-beg);

            // Eventually remove the trailing '\r' if any
            if ((pos = url.rfind('\r')) > 0)
            {
                url.erase(pos);
            }

            // Update the param string
            param += FXURL::decode(FXURL::fileFromURL(url)) + "\n";
            num++;
        }

        // Construct the final param string passed to the file management routine
        param = current->list->getDirectory()+"\n" + FXStringVal(num) + "\n" + param;

        // Copy or cut operation depending on the clipboard type
        switch (clipboard_type)
        {
        case COPY_CLIPBOARD:
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_COPY);
            break;

        case CUT_CLIPBOARD:
            clipboard.clear();
            sel = FXSEL(SEL_COMMAND, FilePanel::ID_FILE_CUT);
            break;
        }
        fromPaste = true;
        handle(this, sel, (void*)param.text());

        FXFREE(&data);
        return(1);
    }
    return(0);
}


// Execute file with an optional confirm dialog
void FilePanel::execFile(FXString pathname)
{
    int      ret;
    FXString cmd, cmdname;

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // File is executable, but is it a text file?
    FXString str = mimetype(pathname);
    FXbool   isTextFile = true;
    if (strstr(str.text(), "charset=binary"))
    {
        isTextFile = false;
    }

    // With confirmation dialog
    FXbool confirm_execute = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_execute", true);
    if (isTextFile && (confirm_execute == 1))
    {
        FXString msg;
        msg.format(_("File %s is an executable text file, what do you want to do?"), pathname.text());
        ExecuteBox* dlg = new ExecuteBox(this, _("Confirm Execute"), msg);
        FXuint      answer = dlg->execute(PLACEMENT_CURSOR);
        delete dlg;

        // Execute
        if (answer == EXECBOX_CLICKED_EXECUTE)
        {
            cmdname = FXPath::name(pathname);
            cmd = ::quote(pathname);
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // Execute in console mode
        if (answer == EXECBOX_CLICKED_CONSOLE)
        {
            ret = chdir(current->list->getDirectory().text());
            if (ret < 0)
            {
                int errcode = errno;
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
                }
            }

            cmdname = FXPath::name(pathname);
            cmd = ::quote(pathname);

            // Make and show command window
            // The CommandWindow object will delete itself when closed!
            CommandWindow* cmdwin = new CommandWindow(getApp(), _("Command log"), cmd, 30, 80);
            cmdwin->create();
            cmdwin->setIcon(runicon);

            ret = chdir(startlocation.text());
            if (ret < 0)
            {
                int errcode = errno;
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
                }
            }
        }

        // Edit
        if (answer == EXECBOX_CLICKED_EDIT)
        {
            FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
            cmd = txteditor;
            cmdname = cmd;

            // If command exists, run it
            if (::existCommand(cmdname))
            {
                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
            }

            // If command does not exist, call the "Open with..." dialog
            else
            {
                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
            }
        }
    }

    // Without confirmation dialog
    else
    {
        cmdname = FXPath::name(pathname);
        cmd = ::quote(pathname);
#ifdef STARTUP_NOTIFICATION
        runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
        runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
    }
}


// Double Click on File Item
long FilePanel::onCmdItemDoubleClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    FXString cmd, cmdname, filename, pathname;

    // Wait cursor
    getApp()->beginWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);

    // At most one item selected
    if (current->list->getNumSelectedItems() <= 1)
    {
        FXlong item = (FXlong)ptr;
        if (item > -1)
        {
#ifdef STARTUP_NOTIFICATION
            // Startup notification option and exceptions (if any)
            FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
            FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

            // Default programs
            FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
            FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
            FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
            FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
            FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
            FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
            FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
            FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

            // File name and path
            filename = list->getItemFilename(item);
            pathname = list->getItemPathname(item);

            // If directory, open the directory
            if (list->isItemDirectory(item))
            {
                // Does not have access
                if (!::isReadExecutable(pathname))
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _(" Permission to: %s denied."), pathname.text());
                    getApp()->endWaitCursor();
		    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                    return(0);
                }
                if (filename == "..")
                {
                    list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
                    //list->hide();
                }
                else
                {
                    list->setDirectory(pathname);
                }

                // Change directory in tree list
                dirpanel->setDirectory(pathname, true);
                current->updatePath();

                // Update location history
                updateLocation();
            }
            else if (list->isItemFile(item))
            {
                // Update associations dictionary
                FileDict*  assocdict = new FileDict(getApp());
                FileAssoc* association = assocdict->findFileBinding(pathname.text());

                // If there is an association
                if (association)
                {
                    // Use it to open the file
                    if (association->command.section(',', 0) != "")
                    {
                        cmdname = association->command.section(',', 0);

                        // Use a default program if possible
                        switch (progs[cmdname])
                        {
                        case TXTVIEWER:
                            cmdname = txtviewer;
                            break;

                        case TXTEDITOR:
                            cmdname = txteditor;
                            break;

                        case IMGVIEWER:
                            cmdname = imgviewer;
                            break;

                        case IMGEDITOR:
                            cmdname = imgeditor;
                            break;

                        case PDFVIEWER:
                            cmdname = pdfviewer;
                            break;

                        case AUDIOPLAYER:
                            cmdname = audioplayer;
                            break;

                        case VIDEOPLAYER:
                            cmdname = videoplayer;
                            break;

                        case ARCHIVER:
                            cmdname = archiver;
                            break;

                        case NONE: // No program found
                            ;
                            break;
                        }

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
			    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // Or execute the file
                    else if (list->isItemExecutable(item))
                    {
                        execFile(pathname);
                    }

                    // Or call the "Open with..." dialog
                    else
                    {
                        getApp()->endWaitCursor();
			mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }

                // If no association but executable
                else if (list->isItemExecutable(item))
                {
                    execFile(pathname);
                }

                // Other cases
                else
                {
                    getApp()->endWaitCursor();
		    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                    current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                }
            }
        }
    }

    // More than one selected files
    else
    {
        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN), NULL);
    }

    getApp()->endWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);

    return(1);
}


// Single click on File Item
long FilePanel::onCmdItemClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    // Make panel active
    setActive();

    if (single_click != SINGLE_CLICK_NONE)
    {
        // Default programs
        FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
        FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
        FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
        FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
        FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
        FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
        FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
        FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

        // In detailed mode, avoid single click when mouse cursor is not over the first column
        int    x, y;
        FXuint state;
        getCursorPosition(x, y, state);
        FXbool allow = true;
        if (!(list->getListStyle()&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS)) && ((x-list->getXPosition()) > list->getHeaderSize(0)))
        {
            allow = false;
        }

        // Single click with control or shift
        if (state&(CONTROLMASK|SHIFTMASK))
        {
            return(1);
        }

        // Single click without control or shift
        else
        {
            FXString cmd, cmdname, filename, pathname;

            // Wait cursor
            getApp()->beginWaitCursor();

#ifdef STARTUP_NOTIFICATION
            // Startup notification option and exceptions (if any)
            FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
            FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

            FXlong item = (FXlong)ptr;
            if (item > -1)
            {
                // File name and path
                filename = list->getItemFilename(item);
                pathname = list->getItemPathname(item);

                // If directory, open the directory
                if ((single_click != SINGLE_CLICK_NONE) && list->isItemDirectory(item) && allow)
                {
                    // Does not have access
                    if (!::isReadExecutable(pathname))
                    {
                        MessageBox::error(this, BOX_OK_SU, _("Error"), _(" Permission to: %s denied."), pathname.text());
                        getApp()->endWaitCursor();
                        return(0);
                    }
                    if (filename == "..")
                    {
                        list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
                    }
                    else
                    {
                        list->setDirectory(pathname);
                    }

                    // Change directory in tree list
                    dirpanel->setDirectory(pathname, true);
                    current->updatePath();

                    // Update location history
                    updateLocation();
                }

                // If file, use the association if any
                else if ((single_click == SINGLE_CLICK_DIR_FILE) && list->isItemFile(item) && allow)
                {
                    // Update associations dictionary
                    FileDict*  assocdict = new FileDict(getApp());
                    FileAssoc* association = assocdict->findFileBinding(pathname.text());

                    // If there is an association
                    if (association)
                    {
                        // Use it to open the file
                        if (association->command.section(',', 0) != "")
                        {
                            cmdname = association->command.section(',', 0);

                            // Use a default program if possible
                            switch (progs[cmdname])
                            {
                            case TXTVIEWER:
                                cmdname = txtviewer;
                                break;

                            case TXTEDITOR:
                                cmdname = txteditor;
                                break;

                            case IMGVIEWER:
                                cmdname = imgviewer;
                                break;

                            case IMGEDITOR:
                                cmdname = imgeditor;
                                break;

                            case PDFVIEWER:
                                cmdname = pdfviewer;
                                break;

                            case AUDIOPLAYER:
                                cmdname = audioplayer;
                                break;

                            case VIDEOPLAYER:
                                cmdname = videoplayer;
                                break;

                            case ARCHIVER:
                                cmdname = archiver;
                                break;

                            case NONE: // No program found
                                ;
                                break;
                            }

                            // If command exists, run it
                            if (::existCommand(cmdname))
                            {
                                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                            }

                            // If command does not exist, call the "Open with..." dialog
                            else
                            {
                                getApp()->endWaitCursor();
                                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                            }
                        }

                        // Or execute the file
                        else if (list->isItemExecutable(item))
                        {
                            execFile(pathname);
                        }

                        // Or call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // If no association but executable
                    else if (list->isItemExecutable(item))
                    {
                        execFile(pathname);
                    }

                    // Other cases
                    else
                    {
                        getApp()->endWaitCursor();
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }
            }
            getApp()->endWaitCursor();
        }
    }
    return(1);
}


// Go to parent directory
long FilePanel::onCmdDirectoryUp(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(this, FXSEL(SEL_COMMAND, FileList::ID_DIRECTORY_UP), NULL);
    current->list->setFocus();
    dirpanel->setDirectory(current->list->getDirectory(), true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Go to home directory
long FilePanel::onCmdGoHome(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setDirectory(homedir);
    current->list->setFocus();
    dirpanel->setDirectory(homedir, true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Go to trash directory
long FilePanel::onCmdGoTrash(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setDirectory(trashfileslocation);
    current->list->setFocus();
    dirpanel->setDirectory(trashfileslocation, true);
    current->updatePath();
    updateLocation();
    return(1);
}


// Set the flag that allows to stop the file list refresh
long FilePanel::onCmdStopListRefreshTimer(FXObject*, FXSelector, void*)
{
    stopListRefresh = true;

    return(0);
}


// Copy/Move/Rename/Symlink file(s)
long FilePanel::onCmdFileMan(FXObject* sender, FXSelector sel, void* ptr)
{
    int      num;
    FXString src, targetdir, target, name, source;
    int      firstitem = 0, lastitem = 0;

    // Focus on this panel list
    current->list->setFocus();

    // Confirmation dialog?
    FXbool ask_before_copy = getApp()->reg().readUnsignedEntry("OPTIONS", "ask_before_copy", true);

    // If we are we called from the paste command, get the parameters from the pointer
    if (fromPaste)
    {
        // Reset the flag
        fromPaste = false;

        // Get the parameters
        FXString str = (char*)ptr;
        targetdir = str.section('\n', 0);
        num = FXUIntVal(str.section('\n', 1));
        src = str.after('\n', 2);

        // If no item in clipboard, return
        if (num <= 0)
        {
            return(0);
        }

        // If there is a selected directory in file panel, use it as target directory
        if (current->list->getNumSelectedItems() == 1)
        {
            int item = current->list->getCurrentItem();
            if (current->list->isItemDirectory(item))
            {
                targetdir = list->getItemPathname(item);
            }
        }
    }

    // Obtain the parameters from the file panel
    else
    {
        // Current directory
        FXString curdir = current->list->getDirectory();

        // Number of selected items
        num = current->list->getNumSelectedItems();

        // If no item, return
        if (num <= 0)
        {
            return(0);
        }

        // Eventually deselect the '..' directory
        /* if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        } */

        // Obtain the list of source files and the target directory
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                if (firstitem == 0)
                {
                    firstitem = u;
                }
                lastitem = u;
                name = current->list->getItemText(u).text();
                name = name.section('\t', 0);
                src += curdir+PATHSEPSTRING+name+"\n";
            }
        }
        targetdir = current->next->list->getDirectory();

        if (!current->next->shown() || (FXSELID(sel) == ID_FILE_RENAME))
        {
            targetdir = current->list->getDirectory();
        }
    }

    // Number of items in the FileList
    int numitems = current->list->getNumItems();

    // Name and directory of the first source file
    source = src.section('\n', 0);
    name = FXPath::name(source);
    FXString dir = FXPath::directory(source);

    // Initialize target name
    if (targetdir != ROOTDIR)
    {
        target = targetdir+PATHSEPSTRING;
    }
    else
    {
        target = targetdir;
    }

    // Configure the command, title, message, etc.
    FXIcon*  icon = NULL;
    FXString command, title, message;
    if (FXSELID(sel) == ID_FILE_COPY)
    {
        command = "copy";
        title = _("Copy");
        icon = copy_bigicon;
        if (num == 1)
        {
            message = _("Copy ");
            message += source;
            if (::isFile(source))
            {
                target += name;
            }

            // Source and target are identical => add a suffix to the name
            FXString tgt = ::cleanPath(target); // Remove trailing / if any
            if ((::identical(source, tgt) && (tgt != current->list->getDirectory())) || // Check we are not within target
                (::isDirectory(source) && (source == tgt+PATHSEPSTRING+FXPath::name(source))))
            {
                target = ::buildCopyName(source);
            }
        }
        else
        {
            message.format(_("Copy %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_RENAME)
    {
        command = "rename";
        title = _("Rename");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Rename ");
            message += name;
            target = name;
            title = _("Rename");
        }
        else
        {
            return(0);
        }
    }
    if (FXSELID(sel) == ID_FILE_COPYTO)
    {
        command = "copy";
        title = _("Copy");
        icon = copy_bigicon;
        if (num == 1)
        {
            message = _("Copy ");
            message += source;
        }
        else
        {
            message.format(_("Copy %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_MOVETO)
    {
        command = "move";
        title = _("Move");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Move ");
            message += source;
            title = _("Move");
        }
        else
        {
            message.format(_("Move %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_CUT)
    {
        command = "move";
        title = _("Move");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Move ");
            message += source;
            if (::isFile(source))
            {
                target += name;
            }
            title = _("Move");
        }
        else
        {
            message.format(_("Move %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }
    if (FXSELID(sel) == ID_FILE_SYMLINK)
    {
        command = "symlink";
        title = _("Symlink");
        icon = link_bigicon;
        if (num == 1)
        {
            message = _("Symlink ");
            message += source;
            target += name;
        }
        else
        {
            message.format(_("Symlink %s items from: %s"), FXStringVal(num).text(), dir.text());
        }
    }

    // File operation dialog, if needed
    if (ask_before_copy || (source == target) || (FXSELID(sel) == ID_FILE_COPYTO) || (FXSELID(sel) == ID_FILE_MOVETO) || (FXSELID(sel) == ID_FILE_RENAME) || (FXSELID(sel) == ID_FILE_SYMLINK))
    {
        if (num == 1)
        {
            if (FXSELID(sel) == ID_FILE_RENAME)
            {
                if (operationdialogrename == NULL)
                {
                    operationdialogrename = new InputDialog(this, "", "", title, _("To:"), icon);
                }
                operationdialogrename->setTitle(title);
                operationdialogrename->setIcon(icon);
				operationdialogrename->setMessage(message);
                operationdialogrename->setText(target);

                if (::isDirectory(source))  // directory
                {
                    operationdialogrename->selectAll();
                }
                else
                {
                    int pos = target.rfind('.');
                    if (pos <= 0)
                    {
                        operationdialogrename->selectAll(); // no extension or dot file
                    }
                    else
                    {
                        operationdialogrename->setSelection(0, pos);
                    }
                }

                int rc = 1;
                rc = operationdialogrename->execute(PLACEMENT_CURSOR);
                target = operationdialogrename->getText();
                
                // Target name contains '/'
                if (target.contains(PATHSEPCHAR))
                {
					MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in file or folder names, operation cancelled"));
					return(0);
				}

                if (!rc)
                {
                    return(0);
                }
            }
            else
            {
                if (operationdialogsingle == NULL)
                {
                    operationdialogsingle = new BrowseInputDialog(this, "", "", title, _("To:"), icon, BROWSE_INPUT_MIXED);
                }
                operationdialogsingle->setTitle(title);
                operationdialogsingle->setIcon(icon);
                operationdialogsingle->setMessage(message);
                operationdialogsingle->setText(target);

                // Select file name without path
                if (FXSELID(sel) == ID_FILE_SYMLINK)
                {
                    int pos = target.rfind(PATHSEPSTRING);
                    if (pos >= 0)
                    {
                        operationdialogsingle->setSelection(pos+1, target.length());
                    }
                }

                operationdialogsingle->setDirectory(targetdir);
                int rc = 1;
                rc = operationdialogsingle->execute(PLACEMENT_CURSOR);
                target = operationdialogsingle->getText();
                if (!rc)
                {
                    return(0);
                }
            }
        }
        else
        {
            if (operationdialogmultiple == NULL)
            {
                operationdialogmultiple = new BrowseInputDialog(this, "", "", title, _("To folder:"), icon, BROWSE_INPUT_FOLDER);
            }
            operationdialogmultiple->setTitle(title);
            operationdialogmultiple->setIcon(icon);
            operationdialogmultiple->setMessage(message);
            operationdialogmultiple->setText(target);
            operationdialogmultiple->CursorEnd();
            operationdialogmultiple->setDirectory(targetdir);
            int rc = 1;
            rc = operationdialogmultiple->execute(PLACEMENT_CURSOR);
            target = operationdialogmultiple->getText();
            if (!rc)
            {
                return(0);
            }
        }
    }

    // Nothing entered
    if (target == "")
    {
        MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
        return(0);
    }

    // Update target and target parent directory
	target = ::filePath(target,current->list->getDirectory());
	if (::isDirectory(target))
	{
		targetdir = target;
	}
	else
	{
		targetdir = FXPath::directory(target);
	}

    // Target parent directory doesn't exist
    if (!::exists(targetdir))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), targetdir.text());
        return(0);
    }

    // Target parent directory not writable
    if (!::isWritable(targetdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetdir.text());
        return(0);
    }

    // Target parent directory is not a directory
    if (!::isDirectory(targetdir))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("%s is not a folder"), targetdir.text());
        return(0);
    }

    // Multiple sources and non existent destination
    if ((num > 1) && !::exists(target))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), target.text());
        return(0);
    }

    // Multiple sources and target is a file
    if ((num > 1) && ::isFile(target))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("%s is not a folder"), target.text());
        return(0);
    }

    // Target is a directory and is not writable
    if (::isDirectory(target) && !::isWritable(target))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), target.text());
        return(0);
    }

    // Target is a file and its parent directory is not writable
    if (::isFile(target) && !::isWritable(targetdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetdir.text());
        return(0);
    }

    // One source
    File* f = NULL;
    int   ret;
    if (num == 1)
    {
        // An empty source file name corresponds to the ".." file
        // Don't perform any file operation on it!
        if (source == "")
        {
            return(0);
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        if (command == "copy")
        {
            f = new File(this, _("File copy"), COPY, num);
            f->create();

            // If target file is located at trash location, also create the corresponding trashinfo file
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && (target == trashfileslocation))
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(source, trashfileslocation);

                // Adjust target name to get the _N suffix if any
                FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                // Create trashinfo file
                createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                // Copy source to trash target
                ret = f->copy(source, trashtarget);
            }

            // Copy source to target
            else
            {
                ret = f->copy(source, target);
            }

            // An unknown error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
            }
        }
        else if (command == "rename")
        {
            f = new File(this, _("File rename"), RENAME, num);
            f->create();
            ret = f->rename(source, target);

            // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
            {
                FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                ::unlink(trashinfopathname.text());
            }
        }
        else if (command == "move")
        {
            f = new File(this, _("File move"), MOVE, num);
            f->create();

            // If target file is located at trash location, also create the corresponding trashinfo file
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && (target == trashfileslocation))
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(source, trashfileslocation);

                // Adjust target name to get the _N suffix if any
                FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                // Create trashinfo file
                createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                // Move source to trash target
                ret = f->move(source, trashtarget);
            }

            // Move source to target
            else
            {
                ret = f->move(source, target);
            }

            // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
            // Do it silently and don't report any error if it fails
            if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
            {
                FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                ::unlink(trashinfopathname.text());
            }

            // An unknown error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
            }
        }
        else if (command == "symlink")
        {
            f = new File(this, _("Symlink"), SYMLINK, num);
            f->create();
            f->symlink(source, target);
        }
        // Shouldn't happen
        else
        {
            exit(EXIT_FAILURE);
        }

        getApp()->endWaitCursor();
        delete f;
    }

    // Multiple sources
    // Note : rename cannot be used in this case!
    else if (num > 1)
    {
        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        if (command == "copy")
        {
            f = new File(this, _("File copy"), COPY, num);
        }
        else if (command == "move")
        {
            f = new File(this, _("File move"), MOVE, num);
        }
        else if (command == "symlink")
        {
            f = new File(this, _("Symlink"), SYMLINK, num);
        }
        // Shouldn't happen
        else
        {
            exit(EXIT_FAILURE);
        }
        f->create();

        // Initialize file list stop refresh timer and flag
        stopListRefresh = false;
        getApp()->addTimeout(this, ID_STOP_LIST_REFRESH_TIMER, STOP_LIST_REFRESH_INTERVAL);

        // Loop on the multiple files
        for (int i = 0; i < num; i++)
        {
            // Stop refreshing the file list if file operation is long and has many files
            // This avoids flickering and speeds up things a bit
            if (stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
            {
                // Force a last refresh if current panel is destination
                if (current->getDirectory() == targetdir)
                {
                    current->list->onCmdRefresh(0, 0, 0);
                }

                // Force a last refresh if next panel is destination
                if (next->getDirectory() == targetdir)
                {
                    next->list->onCmdRefresh(0, 0, 0);
                }

                // Tell the dir and file list to not refresh anymore
                setAllowRefresh(false);
                next->setAllowRefresh(false);
                dirpanel->setAllowDirsizeRefresh(false);

                // Don't need to stop again
                stopListRefresh = false;
            }

            // Individual source file
            source = src.section('\n', i);

            // File could have already been moved above in the tree
            if (!::exists(source))
            {
                continue;
            }

            // An empty file name corresponds to the ".." file (why?)
            // Don't perform any file operation on it!
            if (source != "")
            {
                if (command == "copy")
                {
                    // If target file is located at trash location, also create the corresponding trashinfo file
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (target == trashfileslocation))
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(source, trashfileslocation);

                        // Adjust target name to get the _N suffix if any
                        FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                        // Create trashinfo file
                        createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                        // Copy source to trash target
                        ret = f->copy(source, trashtarget);
                    }

                    // Copy source to target
                    else
                    {
                        ret = f->copy(source, target);
                    }

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
                        break;
                    }
                }
                else if (command == "move")
                {
                    // If target file is located at trash location, also create the corresponding trashinfo file
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (target == trashfileslocation))
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(source, trashfileslocation);

                        // Adjust target name to get the _N suffix if any
                        FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                        // Create trashinfo file
                        createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                        // Move source to trash target
                        ret = f->move(source, trashtarget);
                    }

                    // Move source to target
                    else
                    {
                        ret = f->move(source, target);
                    }

                    // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
                    // Do it silently and don't report any error if it fails
                    if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
                    {
                        FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                        ::unlink(trashinfopathname.text());
                    }

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
                        break;
                    }
                }
                else if (command == "symlink")
                {
                    ret = f->symlink(source, target);

                    // An known error has occurred
                    if (ret == -1)
                    {
                        f->hideProgressDialog();
                        break;
                    }

                    // An unknown error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the symlink operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Symlink operation cancelled!"));
                        break;
                    }
                }
                // Shouldn't happen
                else
                {
                    exit(EXIT_FAILURE);
                }
            }
        }

        // Reinit timer and refresh flags
        getApp()->removeTimeout(this, ID_STOP_LIST_REFRESH_TIMER);
        current->setAllowRefresh(true);
        next->setAllowRefresh(true);
        dirpanel->setAllowDirsizeRefresh(true);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panels refresh
    next->onCmdRefresh(0, 0, 0);
    current->onCmdRefresh(0, 0, 0);

    // Enable previous or last selected item for keyboard navigation
    if (((FXSELID(sel) == ID_FILE_MOVETO) || (FXSELID(sel) == ID_FILE_RENAME)) && (current->list->getNumItems() < numitems))
    {
        firstitem = (firstitem < 1) ? 0 : firstitem-1;
        current->list->enableItem(firstitem);
        current->list->setCurrentItem(firstitem);
    }
    else
    {
        current->list->enableItem(lastitem);
        current->list->setCurrentItem(lastitem);
    }

    return(1);
}


// Trash files from the file list or the tree list
long FilePanel::onCmdFileTrash(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();

    FXbool confirm_trash = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_trash", true);

    // If we don't have permission to write to the parent directory
    if (!::isWritable(dir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
        return(0);
    }

    // If we don't have permission to write to the trash directory
    if (!::isWritable(trashfileslocation))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to trash location %s: Permission denied"), trashfileslocation.text());
        return(0);
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        /* if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        } */

        if (confirm_trash)
        {
            FXString message;
            if (num == 1)
            {
                FXString pathname;
                for (int u = 0; u < current->list->getNumItems(); u++)
                {
                    if (current->list->isItemSelected(u))
                    {
                        pathname = current->list->getItemPathname(u);
                    }
                }
                if (::isDirectory(pathname))
                {
                    message.format(_("Move folder %s to trash can?"), pathname.text());
                }
                else
                {
                    message.format(_("Move file %s to trash can?"), pathname.text());
                }
            }
            else
            {
                message.format(_("Move %s selected object(s) to trash can?"), FXStringVal(num).text());
            }

            MessageBox box(this, _("Confirm Trash"), message, delete_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
            if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
            {
                return(0);
            }
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Move to trash"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Overwrite initialisations
        FXbool overwrite = false;
        FXbool overwrite_all = false;
        FXbool skip_all = false;

        // Delete selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // If we don't have permission to write to the file
                if (!::isWritable(pathname))
                {
                    // Overwrite dialog if necessary
                    if (!(overwrite_all | skip_all))
                    {
                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("File %s is write-protected, move it anyway to trash can?"), pathname.text());
                        
                        if (num ==1)
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Trash"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;	
							if (answer == 1)
							{
								overwrite = true;
							}
							else
							{
								goto end;
							}
						}  
                        else
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Trash"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Overwrite
							case 1:
								overwrite = true;
								break;

							// Overwrite all
							case 2:
								overwrite_all = true;
								break;

							// Skip
							case 3:
								overwrite = false;
								break;

							// Skip all
							case 4:
								skip_all = true;
								break;
							}
							
						}
                    }
                    if ((overwrite | overwrite_all) & !skip_all)
                    {
                        // Caution!! Don't delete parent directory!!
                        if (filename != "..")
                        {
                            // Trash files path name
                            FXString trashpathname = createTrashpathname(pathname, trashfileslocation);

                            // Create trashinfo file
                            createTrashinfo(pathname, trashpathname, trashfileslocation, trashinfolocation);

                            // Move file to trash files location
                            int ret = f->move(pathname, trashpathname);

                            // An error has occurred
                            if ((ret == 0) && !f->isCancelled())
                            {
                                f->hideProgressDialog();
                                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move to trash operation!"));
                                break;
                            }
                        }
                    }
                    f->showProgressDialog();
                }

                // If we have permission to write
                else
                {
                    // Caution!! Don't delete parent directory!!
                    if (filename != "..")
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(pathname, trashfileslocation);

                        // Create trashinfo file
                        createTrashinfo(pathname, trashpathname, trashfileslocation, trashinfolocation);

                        // Move file to trash files location
                        int ret = f->move(pathname, trashpathname);

                        // An error has occurred
                        if ((ret == 0) && !f->isCancelled())
                        {
                            f->hideProgressDialog();
                            MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move to trash operation!"));
                            break;
                        }
                    }
                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Move to trash file operation cancelled!"));
                        break;
                    }
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// Restore files from trash can
long FilePanel::onCmdFileRestore(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();
    FXbool   confirm_trash = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_trash", true);

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        /* if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        } */

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Restore from trash"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Restore (i.e. move to their original location) selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // Don't restore '..' directory
                if (filename != "..")
                {
                    // Obtain trash base name and sub path
                    FXString subpath = pathname;
                    subpath.erase(0, trashfileslocation.length()+1);
                    FXString trashbasename = subpath.before('/');
                    if (trashbasename == "")
                    {
                        trashbasename = name;
                    }
                    subpath.erase(0, trashbasename.length());

                    // Read the .trashinfo file
                    FILE*    fp;
                    char     line[1024];
                    FXbool   success = true;
                    FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+trashbasename+".trashinfo";
                    FXString origpathname = "";

                    if ((fp = fopen(trashinfopathname.text(), "r")) != NULL)
                    {
                        // Read the first two lines and get the strings
                        if (fgets(line, sizeof(line), fp) == NULL)
                        {
                            success = false;
                        }
                        if (fgets(line, sizeof(line), fp) == NULL)
                        {
                            success = false;
                        }
                        if (success)
                        {
                            origpathname = line;
                            origpathname = origpathname.after('=');
                            origpathname = origpathname.before('\n');
                        }
                        fclose(fp);
                        origpathname = origpathname+subpath;
                    }

                    // Confirm restore dialog
                    if (confirm_trash && (u == firstitem))
                    {
                        FXString message;
                        if (num == 1)
                        {
                            if (::isDirectory(pathname))
                            {
                                message.format(_("Restore folder %s to its original location %s ?"), filename.text(), origpathname.text());
                            }
                            else
                            {
                                message.format(_("Restore file %s to its original location %s ?"), filename.text(), origpathname.text());
                            }
                        }
                        else
                        {
                            message.format(_("Restore %s selected object(s) to their original locations?"), FXStringVal(num).text());
                        }
                        f->hideProgressDialog();
                        MessageBox box(this, _("Confirm Restore"), message, restore_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
                        if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
                        {
                            getApp()->endWaitCursor();
                            delete f;
                            return(0);
                        }
                        f->showProgressDialog();
                    }

                    if (origpathname == "")
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("Restore information not available for %s"), pathname.text());
                        goto end;
                    }

                    // If parent dir of the original location does not exist
                    FXString origparentdir = FXPath::directory(origpathname);
                    if (!::exists(origparentdir))
                    {
                        // Ask the user if he wants to create it
                        f->hideProgressDialog();
                        FXString message;
                        message.format(_("Parent folder %s does not exist, do you want to create it?"), origparentdir.text());
                        MessageBox box(this, _("Confirm Restore"), message, restore_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
                        if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
                        {
                            goto end;
                        }
                        else
                        {
                            errno = 0;
                            int ret = mkpath(origparentdir.text(), 0755);
                            int errcode = errno;
                            if (ret == -1)
                            {
                                f->hideProgressDialog();
                                if (errcode)
                                {
                                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't create folder %s: %s"), origparentdir.text(), strerror(errcode));
                                }
                                else
                                {
                                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't create folder %s"), origparentdir.text());
                                }
                                goto end;
                            }
                            f->showProgressDialog();
                        }
                    }

                    // Move file to original location (with restore option)
                    int ret = f->move(pathname, origpathname, true);

                    // An error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the restore from trash operation!"));
                        goto end;
                    }

                    // Silently remove trashinfo file
                    FXString trashfilespathname = trashfileslocation+PATHSEPSTRING+trashbasename;
                    if ((pathname == trashfilespathname) && !::exists(trashfilespathname))
                    {
                        ::unlink(trashinfopathname.text());
                    }
                }
                // If action is cancelled in progress dialog
                if (f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Warning"), _("Restore from trash file operation cancelled!"));
                    goto end;
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// Definitively delete files from the file list or the tree list (no trash can)
long FilePanel::onCmdFileDelete(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    current->list->setFocus();
    FXString dir = current->list->getDirectory();

    FXbool confirm_del = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete", true);
    FXbool confirm_del_emptydir = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete_emptydir", true);

    // If we don't have permission to write to the parent directory
    if (!::isWritable(dir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
        return(0);
    }

    // Items number in the file list
    int num = current->list->getNumSelectedItems();

    // If nothing selected, return
    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    else if (num >= 1)
    {
        // Eventually deselect the '..' directory
        /* if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        } */

        if (confirm_del)
        {
            FXString message;
            if (num == 1)
            {
                FXString pathname;
                for (int u = 0; u < current->list->getNumItems(); u++)
                {
                    if (current->list->isItemSelected(u))
                    {
                        pathname = current->list->getItemPathname(u);
                    }
                }
                if (::isDirectory(pathname))
                {
                    message.format(_("Definitively delete folder %s ?"), pathname.text());
                }
                else
                {
                    message.format(_("Definitively delete file %s ?"), pathname.text());
                }
            }
            else
            {
                message.format(_("Definitively delete %s selected object(s)?"), FXStringVal(num).text());
            }
            MessageBox box(this, _("Confirm Delete"), message, delete_big_permicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
            if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
            {
                return(0);
            }
        }
        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("File delete"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Overwrite initialisations
        FXbool overwrite = false;
        FXbool overwrite_all = false;
        FXbool skip_all = false;
        FXbool ask_del_empty = true;
        FXbool skip_all_del_emptydir = false;

        // Delete selected files
        FXString filename, pathname;
        int      i = 0;
        stopListRefresh = false;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Stop refreshing the dirsize in dirpanel
                // when there are many files to delete
                i++;
                if (!stopListRefresh && (i > STOP_LIST_REFRESH_NBMAX))
                {
                    dirpanel->setAllowDirsizeRefresh(false);
                    stopListRefresh = true;
                }

                // Get file name and path
                filename = current->list->getItemFilename(u);
                pathname = current->list->getItemPathname(u);

                // Confirm empty directory deletion
                if (confirm_del & confirm_del_emptydir & ask_del_empty)
                {
                    if ((::isEmptyDir(pathname) == 0) && !::isLink(pathname))
                    {
                        if (skip_all_del_emptydir)
                        {
                            continue;
                        }

                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("Folder %s is not empty, delete it anyway?"), pathname.text());

                        if (num ==1)
                        {
                        	OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							
							if (answer == 0)
							{
								goto end;
							}
						}
                        
                        else
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Yes
							case 1:
								break;

							// Yes for all
							case 2:
								ask_del_empty = false;
								break;

							// Skip
							case 3:
								continue;
								break;

							// Skip all
							case 4:
								skip_all_del_emptydir = true;
								continue;
								break;
							}
						}
						f->showProgressDialog();
                    }
                }

                // If we don't have permission to write to the file
                if (!::isWritable(pathname))
                {
                    // Overwrite dialog if necessary
                    if (!(overwrite_all | skip_all))
                    {
                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("File %s is write-protected, delete it anyway?"), pathname.text());
  
  						if (num == 1)
  						{
                        	OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							if (answer == 1)
							{
								overwrite = true;
							}
							else
							{
								goto end;
							}							
						}
  
 						else
 						{
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Yes
							case 1:
								overwrite = true;
								break;

							// Yes for all
							case 2:
								overwrite_all = true;
								break;

							// Skip
							case 3:
								overwrite = false;
								break;

							// Skip all
							case 4:
								skip_all = true;
								break;
							}
						} 
                    }
                    if ((overwrite | overwrite_all) & !skip_all)
                    {
                        // Caution!! Don't delete parent directory!!
                        if (filename != "..")
                        {
                            // Definitively remove file or folder
                            f->remove(pathname);
                        }
                    }
                    f->showProgressDialog();
                }

                // If we have permission to write
                else
                {
                    // Caution!! Don't delete parent directory!!
                    if (filename != "..")
                    {
                        // Definitively remove file or folder
                        f->remove(pathname);

                        // If is located at trash location, try to also remove the corresponding trashinfo file if it exists
                        // Do it silently and don't report any error if it fails
                        FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                        if (use_trash_can && (pathname.left(trashfileslocation.length()) == trashfileslocation))
                        {
                            FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+filename+".trashinfo";
                            ::unlink(trashinfopathname.text());
                        }
                    }
                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Delete file operation cancelled!"));
                        break;
                    }
                }
            }
        }
end:
        getApp()->endWaitCursor();
        delete f;
    }
    // Force FilePanel and DirPanel refresh
    list->setAllowRefresh(true);
    stopListRefresh = false;
    dirpanel->setAllowDirsizeRefresh(true);
    onCmdRefresh(0, 0, 0);

    // Enable last item before the first selected item (for keyboard navigation)
    firstitem = (firstitem < 1) ? 0 : firstitem-1;
    current->list->enableItem(firstitem);
    current->list->setCurrentItem(firstitem);

    return(1);
}


// View/Edit files
long FilePanel::onCmdEdit(FXObject*, FXSelector s, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString   pathname, samecmd, cmd, cmdname, itemslist = " ";
    FileAssoc* association;
    FXbool     same = true;
    FXbool     first = true;

    current->list->setFocus();

    if (current->list->getNumSelectedItems() == 0)
    {
        getApp()->endWaitCursor();
        return(0);
    }

    FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
    FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
    FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
    FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
    FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
    FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
    FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
    FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

    // Update associations dictionary
    FileDict* assocdict = new FileDict(getApp());

    // Check if all files have the same association
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            // Increment number of selected items
            pathname = current->list->getItemPathname(u);
            association = assocdict->findFileBinding(pathname.text());

            // If there is an association
            if (association)
            {
                // Use it to edit/view the files
                if (FXSELID(s) == ID_EDIT) // Edit
                {
                    cmd = association->command.section(',', 2);

                    // Use a default editor if possible
                    switch (progs[cmd])
                    {
                    case TXTEDITOR:
                        cmd = txteditor;
                        break;

                    case IMGEDITOR:
                        cmd = imgeditor;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No default editor found
                        ;
                        break;
                    }

                    if (cmd.length() == 0)
                    {
                        cmd = txteditor;
                    }
                }
                else // Any other is View
                {
                    cmd = association->command.section(',', 1);

                    // Use a default viewer if possible
                    switch (progs[cmd])
                    {
                    case TXTVIEWER:
                        cmd = txtviewer;
                        break;

                    case IMGVIEWER:
                        cmd = imgviewer;
                        break;

                    case PDFVIEWER:
                        cmd = pdfviewer;
                        break;

                    case AUDIOPLAYER:
                        cmd = audioplayer;
                        break;

                    case VIDEOPLAYER:
                        cmd = videoplayer;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No default viewer found
                        ;
                        break;
                    }

                    if (cmd.length() == 0)
                    {
                        cmd = txtviewer;
                    }
                }
                if (cmd.text() != NULL)
                {
                    // First selected item
                    if (first)
                    {
                        samecmd = cmd;
                        first = false;
                    }

                    if (samecmd != cmd)
                    {
                        same = false;
                        break;
                    }

                    // List of selected items
                    itemslist += ::quote(pathname) + " ";
                }
                else
                {
                    same = false;
                    break;
                }
            }

            // No association
            else
            {
                same = false;
                break;
            }
        }
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // Same association for all files : execute the associated or default editor or viewer
    if (same)
    {
        cmdname = samecmd;

        // If command exists, run it
        if (::existCommand(cmdname))
        {
            cmd = cmdname+itemslist;
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
        }
    }

    // Files have different associations : handle them separately
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);

                // Only View / Edit regular files (not directories)
                if (::isFile(pathname))
                {
                    association = assocdict->findFileBinding(pathname.text());

                    // If there is an association
                    if (association)
                    {
                        // Use it to edit/view the file
                        if (FXSELID(s) == ID_EDIT) // Edit
                        {
                            cmd = association->command.section(',', 2);

                            // Use a default editor if possible
                            switch (progs[cmd])
                            {
                            case TXTEDITOR:
                                cmd = txteditor;
                                break;

                            case IMGEDITOR:
                                cmd = imgeditor;
                                break;

                            case ARCHIVER:
                                cmd = archiver;
                                break;
                            }

                            if (cmd.length() == 0)
                            {
                                cmd = txteditor;
                            }
                        }
                        else // Any other is View
                        {
                            cmd = association->command.section(',', 1);

                            // Use a default viewer if possible
                            switch (progs[cmd])
                            {
                            case TXTVIEWER:
                                cmd = txtviewer;
                                break;

                            case IMGVIEWER:
                                cmd = imgviewer;
                                break;

                            case PDFVIEWER:
                                cmd = pdfviewer;
                                break;

                            case AUDIOPLAYER:
                                cmd = audioplayer;
                                break;

                            case VIDEOPLAYER:
                                cmd = videoplayer;
                                break;

                            case ARCHIVER:
                                cmd = archiver;
                                break;

                            case NONE: // No default viewer found
                                ;
                                break;
                            }

                            if (cmd.length() == 0)
                            {
                                cmd = txtviewer;
                            }
                        }

                        if (cmd.text() != NULL)
                        {
                            cmdname = cmd;

                            // If command exists, run it
                            if (::existCommand(cmdname))
                            {
                                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                                runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                                runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                            }

                            // If command does not exist, call the "Open with..." dialog
                            else
                            {
                                getApp()->endWaitCursor();
                                current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                            }
                        }
                    }

                    // No association
                    else
                    {
                        if (FXSELID(s) == ID_EDIT)
                        {
                            cmd = txteditor;
                        }
                        else
                        {
                            cmd = txtviewer;
                        }

                        cmdname = cmd;

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }
                }
            }
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Compare two files
long FilePanel::onCmdCompare(FXObject*, FXSelector s, void*)
{
    current->list->setFocus();
    int num = current->list->getNumSelectedItems();

    // Only one or two selected items can be handled
    if ((num != 1) && (num != 2))
    {
        getApp()->endWaitCursor();
        return(0);
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    FXString filecomparator = getApp()->reg().readStringEntry("PROGS", "filecomparator", DEFAULT_FILECOMPARATOR);
    FXString pathname, cmd, cmdname, itemslist = " ";

    // One selected item
    if (num == 1)
    {
        // Get the selected item
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                itemslist += ::quote(pathname) + " ";
            }
        }

        // Open a dialog to select the other item to be compared
        if (comparedialog == NULL)
        {
            comparedialog = new BrowseInputDialog(this, "", "", _("Compare"), _("With:"), bigcompareicon, BROWSE_INPUT_FILE);
        }
        comparedialog->setIcon(bigcompareicon);
        comparedialog->setMessage(pathname);
        comparedialog->setText("");
        int rc = 1;
        rc = comparedialog->execute(PLACEMENT_CURSOR);

        // Get item path and add it to the list
        FXString str = comparedialog->getText();
        itemslist += ::quote(str);
        if (!rc || (str == ""))
        {
            return(0);
        }
    }

    // Two selected items
    else if (num == 2)
    {
        // Get the two selected items
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                itemslist += ::quote(pathname) + " ";
            }
        }
    }

    // Wait cursor
    getApp()->beginWaitCursor();

    // If command exists, run it
    cmdname = filecomparator;
    if (::existCommand(cmdname))
    {
        cmd = cmdname+itemslist;
#ifdef STARTUP_NOTIFICATION
        runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
        runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
    }

    // If command does not exist, issue an error message
    else
    {
        getApp()->endWaitCursor();
        MessageBox::error(this, BOX_OK, _("Error"), _("Program %s not found. Please define a file comparator program in the Preferences dialog!"), cmdname.text());
    }

    getApp()->endWaitCursor();

    return(1);
}


// File or directory properties
long FilePanel::onCmdProperties(FXObject* sender, FXSelector, void*)
{
    int ret;
    int num, itm;

    current->list->setFocus();

    // If no selected files in the file list, use the selected folder from the tree list (if any)
    num = current->list->getNumSelectedItems(&itm);
    if (num == 0)
    {
		return(0);
    }

    // There is one selected file in the file list
    else if (num == 1)
    {
        // Eventually deselect the '..' directory
        /* if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        } */

        FXString path = current->list->getDirectory();
        FXString filename = current->list->getItemText(itm);
        filename = filename.section('\t', 0);
        PropertiesBox* attrdlg = new PropertiesBox(this, filename, path);
        attrdlg->create();
        attrdlg->show(PLACEMENT_OWNER);
    }

    // There are multiple selected files in the file list
    else if (num > 1)
    {
        ret = chdir(current->list->getDirectory().text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
            }

            return(0);
        }

        FXString  path = current->list->getDirectory();
        FXString* files = new FXString[num];
        FXString* paths = new FXString[num];

        // Eventually deselect the '..' directory
        /* if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        } */

        int i = 0;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                files[i] = current->list->getItemText(u).section('\t', 0);
                paths[i] = path;
                i++;
            }
        }

        PropertiesBox* attrdlg = new PropertiesBox(this, files, num, paths);
        attrdlg->create();
        attrdlg->show(PLACEMENT_OWNER);
        
        ret = chdir(startlocation.text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
            }

            return(0);
        }
    }

    // Force panel refresh
    return(1);
}


// Create new directory
long FilePanel::onCmdNewDir(FXObject*, FXSelector, void*)
{
    FXString dirname = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString dirpath = current->list->getDirectory();
    if (dirpath != ROOTDIR)
    {
        dirpath += PATHSEPSTRING;
    }

    if (newdirdialog == NULL)
    {
        newdirdialog = new InputDialog(this, "", _("Create new folder:"), _("New Folder"),"",bignewfoldericon);
    }
    newdirdialog->setText("");

    // Accept was pressed
    if (newdirdialog->execute(PLACEMENT_CURSOR))
    {
        if (newdirdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("Folder name is empty, operation cancelled"));
            return(0);
        }

		// Directory name contains '/'
		if (newdirdialog->getText().contains(PATHSEPCHAR))
		{
			MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in folder names, operation cancelled"));
			return(0);
		}

        dirname = dirpath+newdirdialog->getText();
        if (dirname != dirpath)
        {
            // Create the new dir according to the current umask
            int mask;
            mask = umask(0);
            umask(mask);

            // Note that the umask value is in decimal (511 means octal 0777)
            errno = 0;
            int ret = ::mkdir(dirname.text(), 511 & ~mask);
            int errcode = errno;
            if (ret == -1)
            {
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s: %s"), dirname.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s"), dirname.text());
                }
                return(0);
            }
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == dirname)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Create new file
long FilePanel::onCmdNewFile(FXObject*, FXSelector, void*)
{
    FXString filename = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString pathname = current->list->getDirectory();
    if (pathname != ROOTDIR)
    {
        pathname += PATHSEPSTRING;
    }

    if (newfiledialog == NULL)
    {
        newfiledialog = new InputDialog(this, "", _("Create new file:"), _("New File"), "", bignewfileicon, false);
    }
    newfiledialog->setText("");

    // Accept was pressed
    if (newfiledialog->execute(PLACEMENT_CURSOR))
    {
        if (newfiledialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

		// File name contains '/'
		if (newfiledialog->getText().contains(PATHSEPCHAR))
		{
			MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in file names, operation cancelled"));
			return(0);
		}

        filename = pathname+newfiledialog->getText();
        FILE* file;
        if (filename != pathname)
        {
            // Test some error conditions
            if (::exists(filename))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("File or folder %s already exists"), filename.text());
                return(0);
            }
            // Create the new file
            errno = 0;
            if (!(file = fopen(filename.text(), "w+")) || fclose(file))
            {
                if (errno)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create file %s: %s"), filename.text(), strerror(errno));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create file %s"), filename.text());
                }
                return(0);
            }
            // Change the file permissions according to the current umask
            int mask;
            mask = umask(0);
            umask(mask);
            errno = 0;
            int rc = chmod(filename.text(), 438 & ~mask);
            int errcode = errno;
            if (rc)
            {
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't set permissions in %s: %s"), filename.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't set permissions in %s"), filename.text());
                }
            }
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == filename)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Create new symbolic link
long FilePanel::onCmdNewSymlink(FXObject*, FXSelector, void*)
{
    FXString linkname = "";

    // Focus on current panel list
    current->list->setFocus();

    FXString linkpath = current->list->getDirectory();
    if (linkpath != ROOTDIR)
    {
        linkpath += PATHSEPSTRING;
    }

    if (newlinkdialog == NULL)
    {
        newlinkdialog = new InputDialog(this, "", _("Create new symbolic link:"), _("New Symlink"), "", bignewlinkicon, false);
    }
    newlinkdialog->setText("");

    // Accept was pressed
    if (newlinkdialog->execute(PLACEMENT_CURSOR))
    {
        if (newlinkdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }
        linkname = linkpath+newlinkdialog->getText();
        File* f;
        if (linkname != linkpath)
        {
            // Test some error conditions
            if (::exists(linkname))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("File or folder %s already exists"), linkname.text());
                return(0);
            }

            // Select target
            FileDialog browse(this, _("Select the symlink refered file or folder"));
            browse.setDirectory(linkpath);
            browse.setSelectMode(SELECT_FILE_MIXED);
            if (browse.execute())
            {
                FXString linksource = browse.getFilename();

                // Source does not exist
                if (!::exists(linksource))
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Symlink source %s does not exist"), linksource.text());
                    return(0);
                }

                f = new File(this, _("Symlink"), SYMLINK);
                f->create();
                f->symlink(linksource, linkname);
                delete f;
            }
            //else
            //return 0;
        }
    }

    // Cancel was pressed
    else
    {
        return(0);
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    // Enable created item, if any (for keyboard navigation)
    FXString name;
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        name = current->list->getItemPathname(u);
        if (name == linkname)
        {
            current->list->enableItem(u);
            current->list->setCurrentItem(u);
            break;
        }
    }

    return(1);
}


// Open single or multiple files
long FilePanel::onCmdOpen(FXObject*, FXSelector, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString   pathname, samecmd, cmd, cmdname, itemslist = " ";
    FileAssoc* association;
    FXbool     same = true;
    FXbool     first = true;

    current->list->setFocus();
    if (current->list->getNumSelectedItems() == 0)
    {
        getApp()->endWaitCursor();
        return(0);
    }

    // Default programs
    FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
    FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
    FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
    FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
    FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
    FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
    FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
    FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

    // Update associations dictionary
    FileDict* assocdict = new FileDict(getApp());

    // Check if all files have the same association
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            // Increment number of selected items
            pathname = current->list->getItemPathname(u);

            // If directory, skip it
            if (::isDirectory(pathname))
            {
                continue;
            }

            // If association found
            association = assocdict->findFileBinding(pathname.text());
            if (association)
            {
                cmd = association->command.section(',', 0);

                // Use a default program if possible
                switch (progs[cmd])
                {
                case TXTVIEWER:
                    cmd = txtviewer;
                    break;

                case TXTEDITOR:
                    cmd = txteditor;
                    break;

                case IMGVIEWER:
                    cmd = imgviewer;
                    break;

                case IMGEDITOR:
                    cmd = imgeditor;
                    break;

                case PDFVIEWER:
                    cmd = pdfviewer;
                    break;

                case AUDIOPLAYER:
                    cmd = audioplayer;
                    break;

                case VIDEOPLAYER:
                    cmd = videoplayer;
                    break;

                case ARCHIVER:
                    cmd = archiver;
                    break;

                case NONE: // No program found
                    ;
                    break;
                }

                if (cmd != "")
                {
                    // First selected item
                    if (first)
                    {
                        samecmd = cmd;
                        first = false;
                    }

                    if (samecmd != cmd)
                    {
                        same = false;
                        break;
                    }

                    // List of selected items
                    itemslist += ::quote(pathname) + " ";
                }
                else
                {
                    same = false;
                    break;
                }
            }
            else
            {
                same = false;
                break;
            }
        }
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // Same command for all files : open them
    if (same && (itemslist != " "))
    {
        cmdname = samecmd;

        // If command exists, run it
        if (::existCommand(cmdname))
        {
            cmd = samecmd+itemslist;
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
        }

        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
        }
    }

    // Files have different commands : handle them separately
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);

                // If directory, skip it
                if (::isDirectory(pathname))
                {
                    continue;
                }

                association = assocdict->findFileBinding(pathname.text());
                if (association)
                {
                    // Use association to open the file
                    cmd = association->command.section(',', 0);

                    // Use a default program if possible
                    switch (progs[cmd])
                    {
                    case TXTVIEWER:
                        cmd = txtviewer;
                        break;

                    case TXTEDITOR:
                        cmd = txteditor;
                        break;

                    case IMGVIEWER:
                        cmd = imgviewer;
                        break;

                    case IMGEDITOR:
                        cmd = imgeditor;
                        break;

                    case PDFVIEWER:
                        cmd = pdfviewer;
                        break;

                    case AUDIOPLAYER:
                        cmd = audioplayer;
                        break;

                    case VIDEOPLAYER:
                        cmd = videoplayer;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No program found
                        ;
                        break;
                    }

                    if (cmd != "")
                    {
                        cmdname = cmd;

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
#else
                            runcmd(cmd, current->list->getDirectory(), startlocation);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
                            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // Or execute the file
                    else if (current->list->isItemExecutable(u))
                    {
                        execFile(pathname);
                    }

                    // Or call the "Open with..." dialog
                    else
                    {
                        getApp()->endWaitCursor();
                        current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }

                // If no association but executable
                else if (current->list->isItemExecutable(u))
                {
                    execFile(pathname);
                }

                // Other cases
                else
                {
                    getApp()->endWaitCursor();
                    current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                }
            }
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Open with
long FilePanel::onCmdOpenWith(FXObject*, FXSelector, void*)
{
    char** str = NULL;

    current->list->setFocus();

    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    FXString cmd = "", cmdname;
    if (opendialog == NULL)
    {
        opendialog = new HistInputDialog(this, "", _("Open selected file(s) with:"), _("Open With"), "", bigfileopenicon, HIST_INPUT_EXECUTABLE_FILE, true, _("A&ssociate"));
    }
    opendialog->setText(cmd);

    // Dialog with history list and associate checkbox
    opendialog->CursorEnd();
    opendialog->selectAll();
    opendialog->clearItems();
    for (int i = 0; i < OpenNum; i++)
    {
        opendialog->appendItem(OpenHistory[i]);
    }
    opendialog->setDirectory(ROOTDIR);
    opendialog->sortItems();
    if (opendialog->execute())
    {
        cmd = opendialog->getText();
        if (cmd == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Handles "associate" checkbox for "open with..." dialog
                if (opendialog->getOption())
                {
                    FXString filename = current->list->getItemFilename(u);
                    FXString ext = filename.rafter('.', 2).lower();

                    if ((ext == "tar.gz") || (ext == "tar.bz2") || (ext == "tar.xz") || (ext == "tar.z")) // Special cases
                    {
                    }
                    else
                    {
                        ext = FXPath::extension(filename).lower();
                    }

                    if (ext == "")
                    {
                        ext = FXPath::name(filename);
                    }

                    FileAssoc* association = current->list->getItemAssoc(u);

                    if (association)
                    {
                        // Update existing association
                        FXString oldfileassoc = getApp()->reg().readStringEntry("FILETYPES", ext.text(), "");
                        oldfileassoc.erase(0, oldfileassoc.section(';', 0).section(',', 0).length());
                        oldfileassoc.prepend(opendialog->getText());
                        getApp()->reg().writeStringEntry("FILETYPES", ext.text(), oldfileassoc.text());

                        // Handle file association
                        str = new char* [2];
                        str[0] = new char[strlen(ext.text())+1];
                        str[1] = new char[strlen(oldfileassoc.text())+1];
                        strlcpy(str[0], ext.text(), ext.length()+1);
                        strlcpy(str[1], oldfileassoc.text(), oldfileassoc.length()+1);
                        mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ASSOC), str);
                    }
                    else
                    {
                        // New association
                        FXString newcmd = opendialog->getText().append(";Document;;;;");
                        getApp()->reg().writeStringEntry("FILETYPES", ext.text(), newcmd.text());

                        // Handle file association
                        str = new char* [2];
                        str[0] = new char[strlen(ext.text())+1];
                        str[1] = new char[strlen(newcmd.text())+1];
                        strlcpy(str[0], ext.text(), ext.length()+1);
                        strlcpy(str[1], newcmd.text(), newcmd.length()+1);
                        mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ASSOC), str);
                    }
                }
                // End

                FXString pathname = current->list->getItemPathname(u);
                cmdname = cmd;
                cmd += " ";
                cmd = cmd+::quote(pathname);
            }
        }

        // Run command if it exists
        getApp()->beginWaitCursor();

#ifdef STARTUP_NOTIFICATION
        // Startup notification option and exceptions (if any)
        FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
        FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

        // If command exists, run it
        if (::existCommand(cmdname))
#ifdef STARTUP_NOTIFICATION
        {
            runcmd(cmd, cmdname, current->list->getDirectory(), startlocation, usesn, snexcepts);
        }
#else
        {
            runcmd(cmd, current->list->getDirectory(), startlocation);
        }
#endif
        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            current->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
            return(1);
        }

        // Update history list
        OpenNum = opendialog->getHistorySize();
        cmd = opendialog->getText();

        // Check if cmd is a new string, i.e. is not already in history
        FXbool newstr = true;
        for (int i = 0; i < OpenNum-1; i++)
        {
            if (streq(OpenHistory[i], cmd.text()))
            {
                newstr = false;
                break;
            }
        }

        // History limit reached
        if (OpenNum > OPEN_HIST_SIZE)
        {
            OpenNum--;
        }

        // Restore original history order
        opendialog->clearItems();
        for (int i = 0; i < OpenNum; i++)
        {
            opendialog->appendItem(OpenHistory[i]);
		}

        // New string
        if (newstr)
        {
            // FIFO
            strlcpy(OpenHistory[0], cmd.text(), cmd.length()+1);
            for (int i = 1; i < OpenNum; i++)
            {
                strlcpy(OpenHistory[i], opendialog->getHistoryItem(i-1).text(), opendialog->getHistoryItem(i-1).length()+1);
            }
        }

        getApp()->endWaitCursor();
    }

    return(1);
}


long FilePanel::onCmdItemFilter(FXObject* o, FXSelector sel, void*)
{
    if (FilterNum == 0)
    {
        strlcpy(FilterHistory[FilterNum], "*", 2);
        FilterNum++;
    }

    int      i;
    FXString pat = list->getPattern();
    if (filterdialog == NULL)
    {
        filterdialog = new HistInputDialog(this, pat, _("Show files:"), _("Filter"), "", bigfiltericon, HIST_INPUT_FILE);
    }
    filterdialog->CursorEnd();
    filterdialog->selectAll();
    filterdialog->clearItems();
    for (int i = 0; i < FilterNum; i++)
    {
        filterdialog->appendItem(FilterHistory[i]);
    }
    filterdialog->sortItems();

    if (filterdialog->execute() && ((pat = filterdialog->getText()) != ""))
    {
        // Change file list patten
        if (FXSELID(sel) == ID_FILTER_CURRENT)
        {
            current->list->setPattern(pat);
        }
        else
        {
            list->setPattern(pat);
        }

        FXbool newstr = true;
        for (i = 0; i < FilterNum; i++)
        {
            if (streq(FilterHistory[i], pat.text()))
            {
                newstr = false;
                break;
            }
        }
        // Append new string to the list bottom
        if (newstr && (FilterNum < FILTER_HIST_SIZE))
        {
            strlcpy(FilterHistory[FilterNum], pat.text(), pat.length()+1);
            FilterNum++;
        }
    }

    list->setFocus();
    return(1);
}


// Panel context menu
long FilePanel::onCmdPopupMenu(FXObject* o, FXSelector s, void* p)
{
    // Make panel active
    setActive();

    // Check if control key or Shift-F10 or menu was pressed
    if (p != NULL)
    {
        FXEvent* event = (FXEvent*)p;
        if (event->state&CONTROLMASK)
        {
            ctrl = true;
        }
        if ((event->state&SHIFTMASK && event->code == KEY_F10) || event->code == KEY_Menu)
        {
            shiftf10 = true;
        }
    }

    // Use to select the item under cursor when right clicking
    // Only when Shift-F10 was not pressed
    if (!shiftf10 && (list->getNumSelectedItems() <= 1))
    {
        int    x, y;
        FXuint state;
        list->getCursorPosition(x, y, state);

        int item = list->getItemAt(x, y);

        if (list->getCurrentItem() >= 0)
        {
            list->deselectItem(list->getCurrentItem());
        }
        if (item >= 0)
        {
            list->setCurrentItem(item);
            list->selectItem(item);
        }
    }

    // If first item (i.e. the '..' item)
    //if ((list->getNumSelectedItems() == 1) && list->isItemSelected(0))
    //{
    //    ctrl = true;
    //}

    // If control flag is set, deselect all items
    if (ctrl)
    {
        list->handle(o, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), p);
    }

    // Popup menu pane
    FXMenuPane* menu = new FXMenuPane(this);
    int         x, y;
    FXuint      state;
    getRoot()->getCursorPosition(x, y, state);

    int num, itm;
    num = current->list->getNumSelectedItems(&itm);

    // No selection or control flag set
    if ((num == 0) || current->ctrl)
    {
        // Menu items
        new FXMenuCommand(menu, _("New& file..."), NULL, current, FilePanel::ID_NEW_FILE);
        new FXMenuCommand(menu, _("New f&older..."), NULL, current, FilePanel::ID_NEW_DIR);
        new FXMenuCommand(menu, _("New s&ymlink..."), NULL, current, FilePanel::ID_NEW_SYMLINK);
        new FXMenuCommand(menu, _("Fi&lter..."), NULL, current, FilePanel::ID_FILTER);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(menu);
        new FXMenuCheck(menu, _("&Hidden files"), current->list, FileList::ID_TOGGLE_HIDDEN);
        new FXMenuCheck(menu, _("Thum&bnails"), current->list, FileList::ID_TOGGLE_THUMBNAILS);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("B&ig icons"), current->list, IconList::ID_SHOW_BIG_ICONS);
        new FXMenuRadio(menu, _("&Small icons"), current->list, IconList::ID_SHOW_MINI_ICONS);
        new FXMenuRadio(menu, _("&Full file list"), current->list, IconList::ID_SHOW_DETAILS);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("&Rows"), current->list, FileList::ID_ARRANGE_BY_ROWS);
        new FXMenuRadio(menu, _("&Columns"), current->list, FileList::ID_ARRANGE_BY_COLUMNS);
        new FXMenuCheck(menu, _("Autosize"), current->list, FileList::ID_AUTOSIZE);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("&Name"), current->list, FileList::ID_SORT_BY_NAME);
        new FXMenuRadio(menu, _("Si&ze"), current->list, FileList::ID_SORT_BY_SIZE);
        new FXMenuRadio(menu, _("&Type"), current->list, FileList::ID_SORT_BY_TYPE);
        new FXMenuRadio(menu, _("E&xtension"), current->list, FileList::ID_SORT_BY_EXT);
        new FXMenuRadio(menu, _("&Date"), current->list, FileList::ID_SORT_BY_TIME);
        new FXMenuRadio(menu, _("&User"), current->list, FileList::ID_SORT_BY_USER);
        new FXMenuRadio(menu, _("&Group"), current->list, FileList::ID_SORT_BY_GROUP);
        new FXMenuRadio(menu, _("Per&missions"), current->list, FileList::ID_SORT_BY_PERM);
        new FXMenuRadio(menu, _("Deletion date"), current->list, FileList::ID_SORT_BY_DELTIME);
        new FXMenuSeparator(menu);
        new FXMenuCheck(menu, _("Ignore c&ase"), current->list, FileList::ID_SORT_CASE);
        new FXMenuCheck(menu, _("Fold&ers first"), current->list, FileList::ID_DIRS_FIRST);
        new FXMenuCheck(menu, _("Re&verse order"), current->list, FileList::ID_SORT_REVERSE);
    }
    // Non empty selection
    else
    {
        // Deselect the '..' item
        /* if (current->list->isItemSelected(0))
        {
            current->list->deselectItem(0);
        } */

        // Panel submenu items
        FXMenuPane* submenu = new FXMenuPane(this);
        new FXMenuCommand(submenu, _("Ne&w file..."), NULL, current, FilePanel::ID_NEW_FILE);
        new FXMenuCommand(submenu, _("New f&older..."), NULL, current, FilePanel::ID_NEW_DIR);
        new FXMenuCommand(submenu, _("New s&ymlink..."), NULL, current, FilePanel::ID_NEW_SYMLINK);
        new FXMenuCommand(submenu, _("Fi&lter..."), NULL, current, FilePanel::ID_FILTER);
        new FXMenuSeparator(submenu);
        new FXMenuCommand(submenu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(submenu);
        new FXMenuCheck(submenu, _("&Hidden files"), current->list, FileList::ID_TOGGLE_HIDDEN);
        new FXMenuCheck(submenu, _("Thum&bnails"), current->list, FileList::ID_TOGGLE_THUMBNAILS);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("B&ig icons"), current->list, IconList::ID_SHOW_BIG_ICONS);
        new FXMenuRadio(submenu, _("&Small icons"), current->list, IconList::ID_SHOW_MINI_ICONS);
        new FXMenuRadio(submenu, _("&Full file list"), current->list, IconList::ID_SHOW_DETAILS);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("&Rows"), current->list, FileList::ID_ARRANGE_BY_ROWS);
        new FXMenuRadio(submenu, _("&Columns"), current->list, FileList::ID_ARRANGE_BY_COLUMNS);
        new FXMenuCheck(submenu, _("Autosize"), current->list, FileList::ID_AUTOSIZE);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("&Name"), current->list, FileList::ID_SORT_BY_NAME);
        new FXMenuRadio(submenu, _("Si&ze"), current->list, FileList::ID_SORT_BY_SIZE);
        new FXMenuRadio(submenu, _("&Type"), current->list, FileList::ID_SORT_BY_TYPE);
        new FXMenuRadio(submenu, _("E&xtension"), current->list, FileList::ID_SORT_BY_EXT);
        new FXMenuRadio(submenu, _("&Date"), current->list, FileList::ID_SORT_BY_TIME);
        new FXMenuRadio(submenu, _("&User"), current->list, FileList::ID_SORT_BY_USER);
        new FXMenuRadio(submenu, _("&Group"), current->list, FileList::ID_SORT_BY_GROUP);
        new FXMenuRadio(submenu, _("Per&missions"), current->list, FileList::ID_SORT_BY_PERM);
        new FXMenuRadio(submenu, _("Deletion date"), current->list, FileList::ID_SORT_BY_DELTIME);
        new FXMenuSeparator(submenu);
        new FXMenuCheck(submenu, _("Ignore c&ase"), current->list, FileList::ID_SORT_CASE);
        new FXMenuCheck(submenu, _("Fold&ers first"), current->list, FileList::ID_DIRS_FIRST);
        new FXMenuCheck(submenu, _("Re&verse order"), current->list, FileList::ID_SORT_REVERSE);
        new FXMenuCascade(menu, _("Pane&l"), NULL, submenu);
        new FXMenuSeparator(menu);

#if defined(linux)
        FXString name = current->list->getItemPathname(itm);
        if ((num == 1) && (fsdevices->find(name.text()) || mtdevices->find(name.text())))
        {
            new FXMenuCommand(menu, _("&Mount"), NULL, current, FilePanel::ID_MOUNT);
            new FXMenuCommand(menu, _("Unmount"), NULL, current, FilePanel::ID_UMOUNT);
            new FXMenuSeparator(menu);
        }
#endif

        FXbool ar = false;
        if (current->list->getItem(itm) && current->list->isItemFile(itm))
        {
            new FXMenuCommand(menu, _("Open &with..."), NULL, current, FilePanel::ID_OPEN_WITH);
            new FXMenuCommand(menu, _("&Open"), NULL, current, FilePanel::ID_OPEN);
            FXString name = current->list->getItemText(itm).section('\t', 0);

            // Last and before last file extensions
            FXString ext1 = name.rafter('.', 1).lower();
            FXString ext2 = name.rafter('.', 2).lower();

            // Destination folder name
            FXString extract_to_folder;
            if ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z"))
            {
                extract_to_folder = _("Extr&act to folder ")+name.section('\t', 0).rbefore('.', 2);
            }
            else
            {
                extract_to_folder = _("Extr&act to folder ")+name.section('\t', 0).rbefore('.', 1);
            }

            // Display the extract and package menus according to the archive extensions
            if ((num == 1) && ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
                new FXMenuCommand(menu, extract_to_folder, NULL, current, FilePanel::ID_EXTRACT_TO_FOLDER);
                new FXMenuCommand(menu, _("E&xtract to..."), NULL, current, FilePanel::ID_EXTRACT);
            }
            else if ((num == 1) && ((ext1 == "gz") || (ext1 == "bz2") || (ext1 == "xz") || (ext1 == "z")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
            }
            else if ((num == 1) && ((ext1 == "tar") || (ext1 == "tgz") || (ext1 == "tbz2") || (ext1 == "tbz") || (ext1 == "taz") || (ext1 == "txz") || (ext1 == "zip") || (ext1 == "7z") || (ext1 == "lzh") || (ext1 == "rar") || (ext1 == "ace") || (ext1 == "arj")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), NULL, current, FilePanel::ID_EXTRACT_HERE);
                new FXMenuCommand(menu, extract_to_folder, NULL, current, FilePanel::ID_EXTRACT_TO_FOLDER);
                new FXMenuCommand(menu, _("E&xtract to..."), NULL, current, FilePanel::ID_EXTRACT);
            }
#if defined(linux)
            else if ((num == 1) && ((ext1 == "rpm") || (ext1 == "deb")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&View"), NULL, current, FilePanel::ID_VIEW);
                new FXMenuCommand(menu, _("Install/Up&grade"), NULL, current, ID_PKG_INSTALL);
                new FXMenuCommand(menu, _("Un&install"), NULL, current, ID_PKG_UNINSTALL);
            }
#endif
            // Not archive nor package
            if (!ar)
            {
                new FXMenuCommand(menu, _("&View"), NULL, current, FilePanel::ID_VIEW);
                new FXMenuCommand(menu, _("&Edit"), NULL, current, FilePanel::ID_EDIT);
                if (num == 1)
                {
                    new FXMenuCommand(menu, _("Com&pare..."), NULL, current, FilePanel::ID_COMPARE);
                }
                else
                {
                    new FXMenuCommand(menu, _("Com&pare"), NULL, current, FilePanel::ID_COMPARE);
                }
            }
        }
        if (!ar)
        {
            new FXMenuCommand(menu, _("&Add to archive..."), NULL, current, FilePanel::ID_ADD_TO_ARCH);
        }
#if defined(linux)
        if ((num == 1) && !ar)
        {
            new FXMenuCommand(menu, _("Packages &query "), NULL, current, FilePanel::ID_PKG_QUERY);
        }
#endif

        // Build scripts menu
        new FXMenuSeparator(menu);
        FXString    scriptpath = homedir + PATHSEPSTRING CONFIGPATH PATHSEPSTRING XFECONFIGPATH PATHSEPSTRING SCRIPTPATH;
        FXMenuPane* scriptsmenu = new FXMenuPane(this);
        new FXMenuCascade(menu, _("Scripts"), NULL, scriptsmenu);
        readScriptDir(scriptsmenu, scriptpath);
        new FXMenuSeparator(scriptsmenu);
        new FXMenuCommand(scriptsmenu, _("&Go to script folder"), NULL, this, FilePanel::ID_GO_SCRIPTDIR);

        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("&Copy"), NULL, current, FilePanel::ID_COPY_CLIPBOARD);
        new FXMenuCommand(menu, _("C&ut"), NULL, current, FilePanel::ID_CUT_CLIPBOARD);
        new FXMenuCommand(menu, _("&Paste"), NULL, current, FilePanel::ID_PASTE_CLIPBOARD);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("Re&name..."), NULL, current, FilePanel::ID_FILE_RENAME);
        new FXMenuCommand(menu, _("Copy &to..."), NULL, current, FilePanel::ID_FILE_COPYTO);
        new FXMenuCommand(menu, _("&Move to..."), NULL, current, FilePanel::ID_FILE_MOVETO);
        new FXMenuCommand(menu, _("Symlin&k to..."), NULL, current, FilePanel::ID_FILE_SYMLINK);
        new FXMenuCommand(menu, _("M&ove to trash"), NULL, current, FilePanel::ID_FILE_TRASH);
        new FXMenuCommand(menu, _("Restore &from trash"), NULL, current, FilePanel::ID_FILE_RESTORE);
        new FXMenuCommand(menu, _("&Delete"), NULL, current, FilePanel::ID_FILE_DELETE);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("Compare &sizes"), NULL, current, FilePanel::ID_DIR_USAGE);
        new FXMenuCommand(menu, _("P&roperties"), NULL, current, FilePanel::ID_PROPERTIES);
    }
    menu->create();

    // Reset flags
    ctrl = false;
    shiftf10 = false;
    allowPopupScroll = true;  // Allow keyboard scrolling


    menu->popup(NULL, x, y);
    getApp()->runModalWhileShown(menu);
    allowPopupScroll = false;

    return(1);
}


// Read all executable file names that are located into the script directory
// Sort entries alphabetically, directories first
int FilePanel::readScriptDir(FXMenuPane* scriptsmenu, FXString dir)
{
    DIR* dp;
    struct dirent** namelist;

    // Open directory
    if ((dp = opendir(dir.text())) == NULL)
    {
        return(0);
    }

    // Eventually add a / at the end of the directory name
    if (dir[dir.length()-1] != '/')
    {
        dir = dir+"/";
    }

	// First, read only directory entries and sort them alphabetically
    int n;
    n = scandir(dir.text(), &namelist, NULL, alphasort);
    if (n < 0)
    {
        perror("scandir");
    }
    else
    {
        for (int k = 0; k < n; k++)
        {
            // Avoid hidden directories and '.' and '..'
            if (namelist[k]->d_name[0] != '.')
            {
                FXString pathname = dir + namelist[k]->d_name;

                // Recurse if non empty directory
                if (::isDirectory(pathname))
                {
                    if (!::isEmptyDir(pathname))
                    {
                        FXMenuPane* submenu = new FXMenuPane(this);
                        new FXMenuCascade(scriptsmenu, namelist[k]->d_name, NULL, submenu);
                        readScriptDir(submenu, pathname);
                    }
                }
            }
            free(namelist[k]);
        }
        free(namelist);
    }

	// Then, read only executable files and sort them alphabetically
    n = scandir(dir.text(), &namelist, NULL, alphasort);
    if (n < 0)
    {
        perror("scandir");
    }
    else
    {
        for (int k = 0; k < n; k++)
        {
			// Add only executable files to the list
			FXString pathname = dir + namelist[k]->d_name;
			if (!::isDirectory(pathname) && isReadExecutable(pathname))
			{
				new FXMenuCommand(scriptsmenu, namelist[k]->d_name + FXString("\t\t") + pathname, miniexecicon, this, FilePanel::ID_RUN_SCRIPT);
			}
            free(namelist[k]);
        }
        free(namelist);
    }

    // Close directory
    (void)closedir(dp);

    return(1);
}


// Run Terminal in the selected directory
long FilePanel::onCmdXTerm(FXObject*, FXSelector, void*)
{
    int ret;

    getApp()->beginWaitCursor();
    ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
        }

        return(0);
    }

    FXString cmd = getApp()->reg().readStringEntry("PROGS", "xterm", "xterm -sb");
    cmd += " &";
    ret = system(cmd.text());
    if (ret < 0)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Can't execute command %s"), cmd.text());
    }

    current->list->setFocus();
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }

        return(0);
    }

    getApp()->endWaitCursor();
    return(1);
}


// Add files or directory to an archive
long FilePanel::onCmdAddToArch(FXObject* o, FXSelector, void*)
{
    int      ret;
    FXString name, ext1, ext2, cmd, archive = "";
    File*    f;

    ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), list->getDirectory().text());
        }

        return(0);
    }

    // Eventually deselect the '..' directory
    /* if (current->list->isItemSelected(0))
    {
        current->list->deselectItem(0);
    } */

    // Return if nothing is selected
    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    // If only one item is selected, use its name as a starting guess for the archive name
    if (current->list->getNumSelectedItems() == 1)
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                name = current->list->getItemFilename(u);
                break;
            }
        }
        archive = name;
    }

    // Initial archive name with full path and default extension
    FXString archpath = current->list->getDirectory();
    if (archpath == PATHSEPSTRING)
    {
        archive = archpath+archive+".tar.gz";
    }
    else
    {
        archive = archpath+PATHSEPSTRING+archive+".tar.gz";
    }

    // Archive dialog
    if (archdialog == NULL)
    {
        archdialog = new ArchInputDialog(this, "");
    }
    archdialog->setText(archive);
    archdialog->CursorEnd();

    if (archdialog->execute())
    {
        if (archdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

        // Get string and preserve escape characters
        archive = ::quote(archdialog->getText());

        // Get extensions of the archive name
        ext1 = archdialog->getText().rafter('.', 1).lower();
        ext2 = archdialog->getText().rafter('.', 2).lower();

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zcvf "+archive+" ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jcvf "+archive+" ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jcvf "+archive+" ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zcvf "+archive+" ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -cvf "+archive+" ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zcvf "+archive+" ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zcvf "+archive+" ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "xz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jcvf "+archive+" ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jcvf "+archive+" ";
        }
        else if (ext1 == "z")
        {
            cmd = "compress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "zip -r "+archive+" ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z a "+archive+" ";
        }

        // Default archive format
        else
        {
            archive += ".tar.gz";
            cmd = "tar -zcvf "+archive+" ";
        }

        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                // Don't include '..' in the list
                name = current->list->getItemFilename(u);
                if (name != "..")
                {
                    cmd += " ";
                    cmd = cmd+::quote(name);
                    cmd += " ";
                }
            }
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Create archive"), ARCHIVE);
        f->create();

        // Create archive
        f->archive(archive, cmd);
        ret = chdir(startlocation.text());
        if (ret < 0)
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
            }

            return(0);
        }

        getApp()->endWaitCursor();
        delete f;

        // Force panel refresh
        onCmdRefresh(0, 0, 0);
    }
    return(1);
}


// Extract archive
long FilePanel::onCmdExtract(FXObject*, FXSelector, void*)
{
    FXString name, ext1, ext2, cmd, dir, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    // File selection dialog
    FileDialog  browse(this, _("Select a destination folder"));
    const char* patterns[] =
    {
        _("All Files"), "*", NULL
    };
    browse.setDirectory(homedir);
    browse.setPatternList(patterns);
    browse.setSelectMode(SELECT_FILE_DIRECTORY);

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        // Archive name and extensions
        name = current->list->getItemText(item).text();

        ext1 = name.section('\t', 0).rafter('.', 1).lower();
        ext2 = name.section('\t', 0).rafter('.', 2).lower();
        name = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jxvf ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -xvf ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gunzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bunzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "unxz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jxvf ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext1 == "z")
        {
            cmd = "uncompress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "unzip -o ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z x -y ";
        }
        else if (ext1 == "rar")
        {
            cmd = "unrar x -o+ ";
        }
        else if (ext1 == "lzh")
        {
            cmd = "lha -xf ";
        }
        else if (ext1 == "ace")
        {
            cmd = "unace x ";
        }
        else if (ext1 == "arj")
        {
            cmd = "arj x -y ";
        }
        else
        {
            cmd = "tar -zxvf ";
        }

        // Final extract command
        cmd += name+" ";


        // Extract archive
        if (browse.execute())
        {
            dir = browse.getFilename();

            if (isWritable(dir))
            {
                // Wait cursor
                getApp()->beginWaitCursor();

                // File object
                f = new File(this, _("Extract archive"), EXTRACT);
                f->create();

                // Extract archive
                f->extract(name, dir, cmd);

                getApp()->endWaitCursor();
                delete f;
            }
            else
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
            }
        }
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Extract archive to a folder name based on the archive name
long FilePanel::onCmdExtractToFolder(FXObject*, FXSelector, void*)
{
    FXString name, pathname, ext1, ext2, cmd, dirname, dirpath, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        // Archive name and extensions
        name = current->list->getItemText(item).text();
        ext1 = name.section('\t', 0).rafter('.', 1).lower();
        ext2 = name.section('\t', 0).rafter('.', 2).lower();

        // Destination folder name
        if ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z"))
        {
            dirname = name.section('\t', 0).rbefore('.', 2);
        }
        else
        {
            dirname = name.section('\t', 0).rbefore('.', 1);
        }

        // Create the new dir according to the current umask
        // Don't complain if directory already exists
        int mask = umask(0);
        umask(mask);
        dirpath = cdir + PATHSEPSTRING + dirname;
        errno = 0;
        int ret = ::mkdir(dirpath.text(), 511 & ~mask);
        int errcode = errno;
        if ((ret == -1) && (errcode != EEXIST))
        {
            if (errcode)
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s: %s"), dirpath.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't create folder %s"), dirpath.text());
            }
            return(0);
        }

        // Archive pathname
        pathname = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jxvf ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -xvf ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gunzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bunzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "unxz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jxvf ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext1 == "z")
        {
            cmd = "uncompress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "unzip -o ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z x -y ";
        }
        else if (ext1 == "rar")
        {
            cmd = "unrar x -o+ ";
        }
        else if (ext1 == "lzh")
        {
            cmd = "lha -xf ";
        }
        else if (ext1 == "ace")
        {
            cmd = "unace x ";
        }
        else if (ext1 == "arj")
        {
            cmd = "arj x -y ";
        }
        else
        {
            cmd = "tar -zxvf ";
        }

        // Final extract command
        cmd += pathname+" ";

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Extract archive"), EXTRACT);
        f->create();

        // Extract archive
        f->extract(pathname, dirpath, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Extract archive in the current directory
long FilePanel::onCmdExtractHere(FXObject*, FXSelector, void*)
{
    FXString name, ext1, ext2, cmd, cdir;
    File*    f;

    // Current directory
    cdir = current->list->getDirectory();

    int item;
    current->list->getNumSelectedItems(&item);
    if (current->list->getItem(item))
    {
        if (isWritable(cdir))
        {
            // Archive name and extensions
            name = current->list->getItemText(item).text();
            ext1 = name.section('\t', 0).rafter('.', 1);
            lower();
            ext2 = name.section('\t', 0).rafter('.', 2).lower();
            name = ::quote(cdir + PATHSEPSTRING + name.section('\t', 0));

            // Handle different archive formats
            if (ext2 == "tar.gz")
            {
                cmd = "tar -zxvf ";
            }
            else if (ext2 == "tar.bz2")
            {
                cmd = "tar -jxvf ";
            }
            else if (ext2 == "tar.xz")
            {
                cmd = "tar -Jxvf ";
            }
            else if (ext2 == "tar.z")
            {
                cmd = "tar -Zxvf ";
            }
            else if (ext1 == "tar")
            {
                cmd = "tar -xvf ";
            }
            else if (ext1 == "gz")
            {
                cmd = "gunzip -v ";
            }
            else if (ext1 == "tgz")
            {
                cmd = "tar -zxvf ";
            }
            else if (ext1 == "taz")
            {
                cmd = "tar -Zxvf ";
            }
            else if (ext1 == "bz2")
            {
                cmd = "bunzip2 -v ";
            }
            else if (ext1 == "xz")
            {
                cmd = "unxz -v ";
            }
            else if ((ext1 == "tbz2") || (ext1 == "tbz"))
            {
                cmd = "tar -jxvf ";
            }
            else if (ext1 == "txz")
            {
                cmd = "tar -Jxvf ";
            }
            else if (ext1 == "z")
            {
                cmd = "uncompress -v ";
            }
            else if (ext1 == "zip")
            {
                cmd = "unzip -o ";
            }
            else if (ext1 == "7z")
            {
                cmd = "7z x -y ";
            }
            else if (ext1 == "rar")
            {
                cmd = "unrar x -o+ ";
            }
            else if (ext1 == "lzh")
            {
                cmd = "lha -xf ";
            }
            else if (ext1 == "ace")
            {
                cmd = "unace x ";
            }
            else if (ext1 == "arj")
            {
                cmd = "arj x -y ";
            }
            else
            {
                cmd = "tar -zxvf ";
            }

            // Final extract command
            cmd += name+" ";

            // Wait cursor
            getApp()->beginWaitCursor();

            // File object
            f = new File(this, _("Extract archive"), EXTRACT);
            f->create();

            // Extract archive
            f->extract(name, cdir, cmd);

            getApp()->endWaitCursor();
            delete f;
        }
        else
        {
            MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), cdir.text());
        }
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


#if defined(linux)
// Install/Upgrade package
long FilePanel::onCmdPkgInstall(FXObject*, FXSelector, void*)
{
    FXString name, path, cmd, dir, cdir;
    File*    f;

    cdir = current->list->getDirectory();

    int itm;
    current->list->getNumSelectedItems(&itm);
    if (current->list->getItem(itm))
    {
        name = current->list->getItemText(itm).text();
        name = name.section('\t', 0);
        path = ::quote(cdir + PATHSEPSTRING + name);

        // Command to perform
        FXString ext = FXPath::extension(name);
        if (comparecase(ext, "rpm") == 0)
        {
            cmd = "rpm -Uvh " + path;
        }
        else if (comparecase(ext, "deb") == 0)
        {
            cmd = "dpkg -i "+ path;
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Package Install/Upgrade"), PKG_INSTALL);
        f->create();

        // Install/Upgrade package
        f->pkgInstall(name, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Uninstall package based on its name (package version is ignored)
long FilePanel::onCmdPkgUninstall(FXObject*, FXSelector, void*)
{
    FXString name, cmd, dir, cdir;
    File*    f;

    cdir = current->list->getDirectory();

    int itm;
    current->list->getNumSelectedItems(&itm);
    if (current->list->getItem(itm))
    {
        name = current->list->getItemText(itm).text();
        name = name.section('\t', 0);

        // Command to perform
        FXString ext = FXPath::extension(name);
        if (comparecase(ext, "rpm") == 0)
        {
            name = name.section('-', 0);
            cmd = "rpm -e " + name;
        }
        else if (comparecase(ext, "deb") == 0)
        {
            name = name.section('_', 0);
            cmd = "dpkg -r "+ name;
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Package Uninstall"), PKG_UNINSTALL);
        f->create();

        // Uninstall package
        f->pkgUninstall(name, cmd);

        getApp()->endWaitCursor();
        delete f;
    }

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


#endif


// Force FilePanel and DirPanel refresh
long FilePanel::onCmdRefresh(FXObject*, FXSelector, void*)
{
    // Refresh panel
    FXString dir = list->getDirectory();
    list->setDirectory(ROOTDIR, false);
    list->setDirectory(dir, false);
    updatePath();
	
	// Focus on current panel
	current-> list->setFocus();

    return(1);
}


// Handle item selection
long FilePanel::onCmdSelect(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->setFocus();
    switch (FXSELID(sel))
    {
    case ID_SELECT_ALL:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SELECT_ALL), ptr);
        return(1);

    case ID_DESELECT_ALL:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), ptr);
        return(1);

    case ID_SELECT_INVERSE:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SELECT_INVERSE), ptr);
        return(1);
    }
    return(1);
}


// Handle show commands
long FilePanel::onCmdShow(FXObject* sender, FXSelector sel, void* ptr)
{
    switch (FXSELID(sel))
    {
    case ID_SHOW_BIG_ICONS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_BIG_ICONS), ptr);
        break;

    case ID_SHOW_MINI_ICONS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_MINI_ICONS), ptr);
        break;

    case ID_SHOW_DETAILS:
        current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SHOW_DETAILS), ptr);
        break;
    }

    // Set focus on current panel list
    current->list->setFocus();

    return(1);
}


// Update show commands
long FilePanel::onUpdShow(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXuint style = current->list->getListStyle();

    switch (FXSELID(sel))
    {
    case ID_SHOW_BIG_ICONS:
        if (style & _ICONLIST_BIG_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_MINI_ICONS:
        if (style & _ICONLIST_MINI_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_DETAILS:
        if (!(style & (_ICONLIST_MINI_ICONS | _ICONLIST_BIG_ICONS)))
        {
            msg = FXWindow::ID_CHECK;
        }
        break;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);

    return(1);
}


// Handle toggle hidden command
long FilePanel::onCmdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_HIDDEN), ptr);
    return(1);
}


// Update toggle hidden command
long FilePanel::onUpdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXbool hidden = current->list->shownHiddenFiles();

    if (hidden == false)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);
    return(1);
}


// Handle toggle thumbnails command
long FilePanel::onCmdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    current->list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_THUMBNAILS), ptr);
    return(1);
}


// Update toggle hidden command
long FilePanel::onUpdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;
    FXbool showthumb = current->list->shownThumbnails();

    if (showthumb == false)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);
    return(1);
}


// Run script
long FilePanel::onCmdRunScript(FXObject* o, FXSelector sel, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    FXString pathname, cmd, itemslist = " ";
    FXString scriptpath = dynamic_cast<FXMenuCommand*>(o)->getHelpText();

    // Construct selected files list
    current->list->setFocus();
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
            pathname = current->list->getItemPathname(u);

            // List of selected items
            itemslist += ::quote(pathname) + " ";
        }
    }

    // Construct command line
    cmd = ::quote(scriptpath) + itemslist + " &";

    // Go to the current directory
    int ret = chdir(current->list->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), current->list->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), current->list->getDirectory().text());
        }
    }

    // Execute command
    static pid_t child_pid = 0;
    switch ((child_pid = fork()))
    {
    case -1:
        fprintf(stderr, _("Error: Fork failed: %s\n"), strerror(errno));
        break;

    case 0:
        execl("/bin/sh", "sh", "-c", cmd.text(), (char*)NULL);
        _exit(EXIT_SUCCESS);
        break;
    }

    // Return to the starting directory
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }
    }

    getApp()->endWaitCursor();

    return(1);
}


// Go to scripts directory
long FilePanel::onCmdGoScriptDir(FXObject* o, FXSelector sel, void*)
{
    FXString scriptpath = homedir + PATHSEPSTRING CONFIGPATH PATHSEPSTRING XFECONFIGPATH PATHSEPSTRING SCRIPTPATH;

    if (!::exists(scriptpath))
    {
        // Create the script directory according to the umask
        int mask = umask(0);
        umask(mask);
        errno = 0;
        int ret = mkpath(scriptpath.text(), 511 & ~mask);
        int errcode = errno;
        if (ret == -1)
        {
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create script folder %s: %s"), scriptpath.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create script folder %s"), scriptpath.text());
            }

            return(0);
        }
    }

    // Go to scripts directory
    current->list->setDirectory(scriptpath);
    current->list->setFocus();
    dirpanel->setDirectory(scriptpath, true);
    current->updatePath();
    updateLocation();

    return(1);
}


#if defined(linux)
// Mount/Unmount file systems
long FilePanel::onCmdMount(FXObject*, FXSelector sel, void*)
{
    int      ret;
    FXString cmd, msg, text;
    FXuint   op;
    File*    f;
    FXString dir;

    current->list->setFocus();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (current->list->getNumSelectedItems() == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    // If symbolic link, read the linked directory
    if (::isLink(dir))
    {
        dir = ::readLink(dir);
    }

    if (FXSELID(sel) == ID_MOUNT)
    {
        op = MOUNT;
        msg = _("Mount");
		cmd = getApp()->reg().readStringEntry("PROGS", "mount", DEFAULT_MOUNTCMD) + FXString(" ");
    }
    else
    {
        op = UNMOUNT;
        msg = _("Unmount");
	    cmd = getApp()->reg().readStringEntry("PROGS", "unmount", DEFAULT_UMOUNTCMD) + FXString(" ");
    }
    cmd += ::quote(dir);
    cmd += " 2>&1";
    ret = chdir(ROOTDIR);
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), ROOTDIR, strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), ROOTDIR);
        }

        return(0);
    }

    // Wait cursor
    getApp()->beginWaitCursor();

    // File object
    text = msg + _(" file system...");
    f = new File(this, text.text(), op);
    f->create();

    // Mount/unmount file system
    text = msg + _(" the folder:");
    f->mount(dir, text, cmd, op);
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }

        return(0);
    }

    // If action is cancelled in progress dialog
    if (f->isCancelled())
    {
        f->hide();
        text = msg + _(" operation cancelled!");
        MessageBox::error(this, BOX_OK, _("Warning"), "%s", text.text());
        delete f;
        return(0);
    }

    getApp()->endWaitCursor();
    delete f;

    // Force panel refresh
    onCmdRefresh(0, 0, 0);

    return(1);
}


// Update the Mount button
long FilePanel::onUpdMount(FXObject* o, FXSelector sel, void*)
{
    FXString dir;

    int num = current->list->getNumSelectedItems();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (num == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    //if (fsdevices->find(dir.text()) && !mtdevices->find(dir.text()) && current->list->getNumItems() && !current->list->isItemSelected(0))
    if (fsdevices->find(dir.text()) && !mtdevices->find(dir.text()) && current->list->getNumItems())
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update the Unmount button
long FilePanel::onUpdUnmount(FXObject* o, FXSelector sel, void*)
{
    FXString dir;

    int num = current->list->getNumSelectedItems();

    // Use the selected directory in FilePanel if any
    // or use the selected directory in DirPanel
    if (num == 0)
    {
        dir = current->list->getDirectory();
    }
    else
    {
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                dir = current->list->getItemPathname(u);
            }
        }
    }

    //if ((fsdevices->find(dir.text()) || mtdevices->find(dir.text())) && current->list->getNumItems() && !current->list->isItemSelected(0))
    if ((fsdevices->find(dir.text()) || mtdevices->find(dir.text())) && current->list->getNumItems())
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Query packages data base
long FilePanel::onCmdPkgQuery(FXObject* o, FXSelector sel, void*)
{
    FXString cmd;

    // Name of the current selected file
    FXString file = current->list->getCurrentFile();

    // Command to perform
    if (pkg_format == DEB_PKG)
    {
        cmd = "dpkg -S " + ::quote(file);
    }
    else if (pkg_format == RPM_PKG)
    {
        cmd = "rpm -qf " + ::quote(file);
    }
    else
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("No compatible package manager (rpm or dpkg) found!"));
        return(0);
    }

    // Query command
    cmd += " 2>&1";

    // Wait cursor
    getApp()->beginWaitCursor();

    // Perform the command
    FILE* pcmd = popen(cmd.text(), "r");
    if (!pcmd)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Failed command: %s"), cmd.text());
        return(0);
    }

    // Get command output
    char     text[10000] = { 0 };
    FXString buf;
    while (fgets(text, sizeof(text), pcmd))
    {
        buf += text;
    }
    snprintf(text, sizeof(text)-1, "%s", buf.text());

    // Close the stream and display error message if any
    if ((pclose(pcmd) == -1) && (errno != ECHILD))   // ECHILD can be set if the child was caught by sigHarvest
    {
        getApp()->endWaitCursor();
        MessageBox::error(this, BOX_OK, _("Error"), "%s", text);
        return(0);
    }
    getApp()->endWaitCursor();

    // Get package name, or detect when the file isn't in a package
    FXString str = text;
    if (pkg_format == DEB_PKG)  // DEB based distribution
    {
        int idx = str.find(" ");               // Split output at first whitespace
        FXString pkgname = str.left(idx-1);    // Remove trailing colon
        FXString fname = str.right(str.length()-idx);
        fname.trim();                          // Remove leading space and trailing newline
        if (streq(fname.text(), file.text()))  // No other word than the file name
        {
            str = pkgname.text();
        }
        else
        {
            str = "";
        }
    }
    if (pkg_format == RPM_PKG)   // RPM based distribution
    {
        if (str.find(' ') != -1) // Space character exists in the string
        {
            str = "";
        }
    }

    // Display the related output message
    FXString message;
    if (str == "")
    {
        message.format(_("File %s does not belong to any package."), file.text());
        MessageBox::information(this, BOX_OK, _("Information"), "%s", message.text());
    }
    else
    {
        message.format(_("File %s belongs to the package: %s"), file.text(), str.text());
        MessageBox::information(this, BOX_OK, _("Information"), "%s", message.text());
    }

    return(1);
}


// Update the package query menu
long FilePanel::onUpdPkgQuery(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing is selected or multiple selection
    // or when unique selection and the selected item is a directory

    int num;

    num = current->list->getNumSelectedItems();

    if ((num == 0) || (num > 1))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else // num=1
    {
        int item = current->list->getCurrentItem();
        if ((item >= 0) && current->list->isItemDirectory(item))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }

    return(1);
}


#endif // End #if defined(linux)


// Directory usage on file selection
long FilePanel::onCmdDirUsage(FXObject* o, FXSelector, void*)
{
	FXString name, command, itemslist = " ";
	FXString cmd1 = "/usr/bin/du --apparent-size -k -s ";
	FXString cmd2 = " 2> /dev/null | /usr/bin/sort -rn | /usr/bin/cut -f2 | /usr/bin/xargs -d '\n' /usr/bin/du --apparent-size --total --si -s 2> /dev/null";

    // Enter current directory
    int ret=chdir(current->getDirectory().text());
    if (ret < 0)
    {
        int errcode=errno;
        if (errcode)
        {
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s: %s"),current->getDirectory().text(),strerror(errcode));
		}
        else
        {
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s"),current->getDirectory().text());
		}

        return 0;
    }

    // Eventually deselect the '..' directory
    /* if (current->list->isItemSelected(0))
    {
        current->list->deselectItem(0);
    } */

    // Return if nothing is selected
    if (current->list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    // Construct selected files list
    current->list->setFocus();
    for (int u = 0; u < current->list->getNumItems(); u++)
    {
        if (current->list->isItemSelected(u))
        {
 			name = current->list->getItemFilename(u);

            // List of selected items
            itemslist += ::quote(name) + " ";
        }
    }

	// Command to be executed
	command = cmd1 + itemslist + cmd2;

	// Make and show command window
	CommandWindow* cmdwin=new CommandWindow(getApp(),_("Sizes of Selected Object(s)"),command,25,50);
	cmdwin->create();
	cmdwin->setIcon(charticon);

	// The CommandWindow object will delete itself when closed!

	// Return to start location
	ret = chdir(startlocation.text());
	if (ret < 0)
	{
		int errcode = errno;
		if (errcode)
		{
			MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
		}
		else
		{
			MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
		}
	}

    return(1);
}


// Update the status bar and the path linker
long FilePanel::onUpdStatus(FXObject* sender, FXSelector, void*)
{
    // Update the status bar
    int      item = -1;
    FXString str, linkto;
    char     usize[64];
    FXulong  size = 0;
    FXString hsize = _("0 bytes");

    FXString path = list->getDirectory();

    int num = list->getNumSelectedItems();

    // To handle the update rename (ugly, I know)
    if (current == this)
    {
        if (num <= 1)
        {
            selmult = false;
        }
        else if (num > 1)
        {
            selmult = true;
        }
    }

    item = list->getCurrentItem();

    if (num > 1)
    {
		int nbdirs = 0;
        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u) && !list->isItemDirectory(u))
            {
                size += list->getItemFileSize(u);
#if __WORDSIZE == 64
                snprintf(usize, sizeof(usize)-1, "%lu", size);
#else
                snprintf(usize, sizeof(usize)-1, "%llu", size);
#endif
                hsize = ::hSize(usize);
            }
            
            if (list->isItemDirectory(u))
            {
				nbdirs++;
			}
        }
        
        // Don't count the '..' directory
        if (nbdirs >= 1)
        {
			nbdirs--;
		}
		
		int nbfiles = num - nbdirs;
        if (nbdirs <= 1 && nbfiles <= 1)
        {
	        str.format(_("%s in %s selected object(s) (%s folder, %s file)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
        else if (nbdirs <=1 && nbfiles > 1)
        {
	        str.format(_("%s in %s selected object(s) (%s folder, %s files)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
        else if (nbdirs > 1 && nbfiles <= 1)
        {
	        str.format(_("%s in %s selected object(s) (%s folders, %s file)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
		else
		{
	        str.format(_("%s in %s selected object(s) (%s folders, %s files)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
    }
    else
    {
        // Nothing selected
        if ((num == 0) || (item < 0))
        {
            num = list->getNumItems();
            if (num == 1)
            {
                str = _("1 object(s) (1 folder)");
            }
            else
            {
				int nbdirs = 0;
				for (int u = 0; u < num; u++)
				{
					if (list->isItemDirectory(u))
					{
						nbdirs++;
					}
				}       

				int nbfiles = num - nbdirs;
		        str.format(_("%s object(s) (%s folders, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());
				if (nbdirs <= 1 && nbfiles <= 1)
				{
					str.format(_("%s object(s) (%s folder, %s file)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else if (nbdirs <=1 && nbfiles > 1)
				{
					str.format(_("%s object(s) (%s folder, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else if (nbdirs > 1 && nbfiles <= 1)
				{
					str.format(_("%s object(s) (%s folders, %s file)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else
				{
					str.format(_("%s object(s) (%s folders, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
            }
        }
        else
        {
            FXString string = list->getItemText(item);
            FXString name = string.section('\t', 0);
            FXString type = string.section('\t', 2);

            FXString date = string.section('\t', 4);
            FXString usr = string.section('\t', 5);
            FXString grp = string.section('\t', 6);
            FXString perm = string.section('\t', 7);

            if (type.contains(_("Broken link")))
            {
                linkto = ::readLink(path+PATHSEPSTRING+name);
                str = name + "->" + linkto.text() + " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
            else if (type.contains(_("Link")))
            {
                linkto = ::readLink(path+PATHSEPSTRING+name);
                str = name + "->" + linkto.text() + " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
            else
            {
                for (int u = 0; u < list->getNumItems(); u++)
                {
                    if (list->isItemSelected(u) && !list->isItemDirectory(u))
                    {
                        size = list->getItemFileSize(u);
#if __WORDSIZE == 64
                        snprintf(usize, sizeof(usize)-1, "%lu", size);
#else
                        snprintf(usize, sizeof(usize)-1, "%llu", size);
#endif
                        hsize = ::hSize(usize);
                        break;
                    }
                }
                str = hsize+ " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
        }
    }

    statuslabel->setText(str);

    // Add the filter pattern if any
    if ((list->getPattern() != "*") && (list->getPattern() != "*.*"))
    {
        str.format(_(" - Filter: %s"), list->getPattern().text());
        filterlabel->setText(str);
        filterlabel->setTextColor(attenclr);
    }
    else
    {
        filterlabel->setText("");
    }

    return(1);
}


// Update the path text and the path link
void FilePanel::updatePath()
{
    pathlink->setPath(list->getDirectory());
    pathtext->setText(list->getDirectory());
}


// Update the go to parent directory command
long FilePanel::onUpdUp(FXObject* o, FXSelector, void*)
{
    FXButton* button = (FXButton*)o;
    int       style = button->getButtonStyle();

    if (style & TOGGLEBUTTON_TOOLBAR)
    {
        if (current->list->getDirectory() != ROOTDIR)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update the paste button
long FilePanel::onUpdPaste(FXObject* o, FXSelector, void*)
{
    FXuchar* data;
    FXuint   len;
    FXString buf;
    FXbool   clipboard_empty = true;

    // Lock clipboard to prevent changes in method onCmdRequestClipboard()
    clipboard_locked = true;

    // If source is xfelistType (Gnome, XFCE, or Xfe app)
    if (getDNDData(FROM_CLIPBOARD, xfelistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        buf = (char*)data;

        // Check if valid clipboard
        if (buf.find("file:/") >= 0)
        {
            clipboard_empty = false;
        }

        // Free data pointer
        FXFREE(&data);
    }

    // If source type is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    else if (getDNDData(FROM_CLIPBOARD, urilistType, data, len))
    {
        FXRESIZE(&data, FXuchar, len+1);
        data[len] = '\0';
        buf = (char*)data;

        // Check if valid clipboard
        if (buf.find("file:/") >= 0)
        {
            clipboard_empty = false;
        }

        // Free data pointer
        FXFREE(&data);
    }

    // Gray out the paste button, if necessary
    if (clipboard_empty)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }

    // Unlock clipboard
    clipboard_locked = false;

    return(1);
}


// Update menu items and toolbar buttons that are related to file operations
long FilePanel::onUpdMenu(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing or only ".." is selected
    int num;

    num = current->list->getNumSelectedItems();
    DirItem* item = (DirItem*)dirpanel->getCurrentItem();

    if ((dirpanel->shown() && item))
    {
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        //else if ((num == 1) && current->list->isItemSelected(0))
        else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        //else if ((num == 1) && current->list->isItemSelected(0))
        else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }

    return(1);
}


// Update file delete menu item and toolbar button
long FilePanel::onUpdFileDelete(FXObject* o, FXSelector sel, void*)
{
    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    FXbool use_trash_bypass = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_bypass", false);

    if ( (!use_trash_can) | use_trash_bypass)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        //else if ((num == 1) && current->list->isItemSelected(0))
        else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update move to trash menu item and toolbar button
long FilePanel::onUpdFileTrash(FXObject* o, FXSelector sel, void*)
{
    // Disable move to trash menu if we are in trash can
    // or if the trash can directory is selected

    FXbool   trashenable = true;
    FXString trashparentdir = trashlocation.rbefore('/');
    FXString curdir = current->list->getDirectory();

    if (curdir.left(trashlocation.length()) == trashlocation)
    {
        trashenable = false;
    }

    if (curdir == trashparentdir)
    {
        FXString pathname;
        for (int u = 0; u < current->list->getNumItems(); u++)
        {
            if (current->list->isItemSelected(u))
            {
                pathname = current->list->getItemPathname(u);
                if (pathname == trashlocation)
                {
                    trashenable = false;
                }
            }
        }
    }

    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    if (use_trash_can && trashenable)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        //else if ((num == 1) && current->list->isItemSelected(0))
        else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update restore from trash menu item and toolbar button
long FilePanel::onUpdFileRestore(FXObject* o, FXSelector sel, void*)
{
    // Enable restore from trash menu if we are in trash can

    FXbool   restoreenable = false;
    FXString curdir = current->list->getDirectory();

    if (curdir.left(trashfileslocation.length()) == trashfileslocation)
    {
        restoreenable = true;
    }

    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    if (use_trash_can && restoreenable)
    {
        int num = current->list->getNumSelectedItems();
        if (num == 0)
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        //else if ((num == 1) && current->list->isItemSelected(0))
        else if ((num == 1))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update go trash menu item and toolbar button
long FilePanel::onUpdGoTrash(FXObject* o, FXSelector sel, void*)
{
    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);

    if (use_trash_can)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update file open menu
long FilePanel::onUpdOpen(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or a directory (including "..") is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);

    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        if (current->list->getItem(item) && current->list->isItemFile(item))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
    }
    return(1);
}


// Update the status of the menu items that should be disabled when selecting multiple files
long FilePanel::onUpdSelMult(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing is selected or multiple selection or ".." is only selected
    int num;

    num = current->list->getNumSelectedItems();
    DirItem* item = (DirItem*)dirpanel->getCurrentItem();

    if (num == 0)
    {
        if (!item || !dirpanel->shown())
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }
    //else if (current->selmult || ((num == 1) && current->list->isItemSelected(0)))
    else if (current->selmult || (num == 1))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }

    return(1);
}


// Update the file compare menu item
long FilePanel::onUpdCompare(FXObject* o, FXSelector sel, void*)
{
    // Menu item is enabled only when two files are selected
    int num;

    num = current->list->getNumSelectedItems();

    if ((num == 1) || (num == 2))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update Add to archive menu
long FilePanel::onUpdAddToArch(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or ".." is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    //else if ((num == 1) && current->list->isItemSelected(0))
    else if ((num == 1))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update scripts menu item
long FilePanel::onUpdRunScript(FXObject* o, FXSelector, void*)
{
    // Menu item is disabled when nothing or ".." is selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    return(1);
}


// Update directory usage menu item
long FilePanel::onUpdDirUsage(FXObject* o, FXSelector, void*)
{
    // Menu item is enabled only when at least two items are selected
    int num, item;

    num = current->list->getNumSelectedItems(&item);
    if (num > 1)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    return(1);
}
// Font dialog. Taken from the FOX library and only modified for translation purpose

#include "config.h"
#include "i18n.h"

#include <fx.h>

#include "xfedefs.h"
#include "xfeutils.h"
#include "FontDialog.h"

// Map
FXDEFMAP(FontSelector) FontSelectorMap[] =
{
    FXMAPFUNC(SEL_COMMAND, FontSelector::ID_FAMILY, FontSelector::onCmdFamily),
    FXMAPFUNC(SEL_COMMAND, FontSelector::ID_WEIGHT, FontSelector::onCmdWeight),
    FXMAPFUNC(SEL_COMMAND, FontSelector::ID_SIZE, FontSelector::onCmdSize),
    FXMAPFUNC(SEL_COMMAND, FontSelector::ID_SIZE_TEXT, FontSelector::onCmdSizeText),
    FXMAPFUNC(SEL_COMMAND, FontSelector::ID_STYLE, FontSelector::onCmdStyle),
    FXMAPFUNC(SEL_COMMAND, FontSelector::ID_STYLE_TEXT, FontSelector::onCmdStyleText),
    FXMAPFUNC(SEL_COMMAND, FontSelector::ID_CHARSET, FontSelector::onCmdCharset),
    FXMAPFUNC(SEL_UPDATE, FontSelector::ID_CHARSET, FontSelector::onUpdCharset),
    FXMAPFUNC(SEL_COMMAND, FontSelector::ID_SETWIDTH, FontSelector::onCmdSetWidth),
    FXMAPFUNC(SEL_UPDATE, FontSelector::ID_SETWIDTH, FontSelector::onUpdSetWidth),
    FXMAPFUNC(SEL_COMMAND, FontSelector::ID_PITCH, FontSelector::onCmdPitch),
    FXMAPFUNC(SEL_UPDATE, FontSelector::ID_PITCH, FontSelector::onUpdPitch),
    FXMAPFUNC(SEL_UPDATE, FontSelector::ID_SCALABLE, FontSelector::onUpdScalable),
    FXMAPFUNC(SEL_COMMAND, FontSelector::ID_SCALABLE, FontSelector::onCmdScalable),
    FXMAPFUNC(SEL_UPDATE, FontSelector::ID_ALLFONTS, FontSelector::onUpdAllFonts),
    FXMAPFUNC(SEL_COMMAND, FontSelector::ID_ALLFONTS, FontSelector::onCmdAllFonts),
};


// Implementation
FXIMPLEMENT(FontSelector, FXPacker, FontSelectorMap, ARRAYNUMBER(FontSelectorMap))


FontSelector::FontSelector(FXComposite* p, FXObject* tgt, FXSelector sel, FXuint opts, int x, int y, int w, int h) :
    FXPacker(p, opts, x, y, w, h)
{
    target = tgt;
    message = sel;

    // Bottom side
    FXHorizontalFrame* buttons = new FXHorizontalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X);
    accept = new FXButton(buttons, _("&Accept"), NULL, NULL, 0, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT, 0, 0, 0, 0, 20, 20);
    cancel = new FXButton(buttons, _("&Cancel"), NULL, NULL, 0, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT, 0, 0, 0, 0, 20, 20);

    // Left side
    FXMatrix* controls = new FXMatrix(this, 3, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FIX_HEIGHT, 0, 0, 0, 160, DEFAULT_SPACING, DEFAULT_SPACING, DEFAULT_SPACING, DEFAULT_SPACING, DEFAULT_SPACING, 0);

    // Font families, to be filled later
    new FXLabel(controls, _("&Font:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_COLUMN);
    family = new FXTextField(controls, 10, NULL, 0, TEXTFIELD_READONLY|FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_X|LAYOUT_FILL_COLUMN);
    FXHorizontalFrame* familyframe = new FXHorizontalFrame(controls, FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_Y|LAYOUT_FILL_X|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW, 0, 0, 0, 0, 0, 0, 0, 0);
    familylist = new FXList(familyframe, this, ID_FAMILY, LIST_BROWSESELECT|LAYOUT_FILL_Y|LAYOUT_FILL_X|HSCROLLER_NEVER|VSCROLLER_ALWAYS);

    // Initial focus on list
    familylist->setFocus();

    // Font weights
    new FXLabel(controls, _("&Weight:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_COLUMN);
    weight = new FXTextField(controls, 4, NULL, 0, TEXTFIELD_READONLY|FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_X|LAYOUT_FILL_COLUMN);
    FXHorizontalFrame* weightframe = new FXHorizontalFrame(controls, FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_Y|LAYOUT_FILL_X|LAYOUT_FILL_ROW|LAYOUT_FILL_COLUMN, 0, 0, 0, 0, 0, 0, 0, 0);
    weightlist = new FXList(weightframe, this, ID_WEIGHT, LIST_BROWSESELECT|LAYOUT_FILL_Y|LAYOUT_FILL_X|HSCROLLER_NEVER|VSCROLLER_ALWAYS);

    // Font styles
    new FXLabel(controls, _("Font St&yle:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_COLUMN);
    style = new FXTextField(controls, 6, NULL, 0, TEXTFIELD_READONLY|FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_X|LAYOUT_FILL_COLUMN);
    FXHorizontalFrame* styleframe = new FXHorizontalFrame(controls, FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_Y|LAYOUT_FILL_X|LAYOUT_FILL_ROW|LAYOUT_FILL_COLUMN, 0, 0, 0, 0, 0, 0, 0, 0);
    stylelist = new FXList(styleframe, this, ID_STYLE, LIST_BROWSESELECT|LAYOUT_FILL_Y|LAYOUT_FILL_X|HSCROLLER_NEVER|VSCROLLER_ALWAYS);

    // Font sizes, to be filled later
    new FXLabel(controls, _("&Size:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_COLUMN);
    size = new FXTextField(controls, 2, this, ID_SIZE_TEXT, FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_X|LAYOUT_FILL_COLUMN);
    FXHorizontalFrame* sizeframe = new FXHorizontalFrame(controls, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_Y|LAYOUT_FILL_X|LAYOUT_FILL_ROW|LAYOUT_FILL_COLUMN, 0, 0, 0, 0, 0, 0, 0, 0);
    sizelist = new FXList(sizeframe, this, ID_SIZE, LIST_BROWSESELECT|LAYOUT_FILL_Y|LAYOUT_FILL_X|HSCROLLER_NEVER|VSCROLLER_ALWAYS);

    FXMatrix* attributes = new FXMatrix(this, 2, LAYOUT_SIDE_TOP|LAYOUT_FILL_X, 0, 0, 0, 0, DEFAULT_SPACING, DEFAULT_SPACING, DEFAULT_SPACING, DEFAULT_SPACING, DEFAULT_SPACING, 0);

    // Character set choice
    new FXLabel(attributes, _("Scr&ipt:"), NULL, LAYOUT_CENTER_Y|LAYOUT_FILL_COLUMN);
    charset = new FXComboBox(attributes, 8, this, ID_CHARSET, COMBOBOX_STATIC|LAYOUT_CENTER_Y|LAYOUT_FILL_COLUMN);
    charset->setNumVisible(10);
    charset->appendItem(_("Any"), (void*)0);
    charset->appendItem(_("West European"), (void*)FONTENCODING_WESTEUROPE);
    charset->appendItem(_("East European"), (void*)FONTENCODING_EASTEUROPE);
    charset->appendItem(_("South European"), (void*)FONTENCODING_SOUTHEUROPE);
    charset->appendItem(_("North European"), (void*)FONTENCODING_NORTHEUROPE);
    charset->appendItem(_("Cyrillic"), (void*)FONTENCODING_CYRILLIC);
    charset->appendItem(_("Arabic"), (void*)FONTENCODING_ARABIC);
    charset->appendItem(_("Greek"), (void*)FONTENCODING_GREEK);
    charset->appendItem(_("Hebrew"), (void*)FONTENCODING_HEBREW);
    charset->appendItem(_("Turkish"), (void*)FONTENCODING_TURKISH);
    charset->appendItem(_("Nordic"), (void*)FONTENCODING_NORDIC);
    charset->appendItem(_("Thai"), (void*)FONTENCODING_THAI);
    charset->appendItem(_("Baltic"), (void*)FONTENCODING_BALTIC);
    charset->appendItem(_("Celtic"), (void*)FONTENCODING_CELTIC);
    charset->appendItem(_("Russian"), (void*)FONTENCODING_KOI8);
    charset->appendItem(_("Central European (cp1250)"), (void*)FONTENCODING_CP1250);
    charset->appendItem(_("Russian (cp1251)"), (void*)FONTENCODING_CP1251);
    charset->appendItem(_("Latin1 (cp1252)"), (void*)FONTENCODING_CP1252);
    charset->appendItem(_("Greek (cp1253)"), (void*)FONTENCODING_CP1253);
    charset->appendItem(_("Turkish (cp1254)"), (void*)FONTENCODING_CP1254);
    charset->appendItem(_("Hebrew (cp1255)"), (void*)FONTENCODING_CP1255);
    charset->appendItem(_("Arabic (cp1256)"), (void*)FONTENCODING_CP1256);
    charset->appendItem(_("Baltic (cp1257)"), (void*)FONTENCODING_CP1257);
    charset->appendItem(_("Vietnam (cp1258)"), (void*)FONTENCODING_CP1258);
    charset->appendItem(_("Thai (cp874)"), (void*)FONTENCODING_CP874);
    charset->appendItem(_("UNICODE"), (void*)FONTENCODING_UNICODE);
    charset->setCurrentItem(0);

    // Set width
    new FXLabel(attributes, _("Set Width:"), NULL, LAYOUT_CENTER_Y|LAYOUT_FILL_COLUMN);
    setwidth = new FXComboBox(attributes, 9, this, ID_SETWIDTH, COMBOBOX_STATIC|LAYOUT_CENTER_Y|LAYOUT_FILL_COLUMN);
    setwidth->setNumVisible(10);
    setwidth->appendItem(_("Any"), (void*)0);
    setwidth->appendItem(_("Ultra condensed"), (void*)FXFont::UltraCondensed);
    setwidth->appendItem(_("Extra condensed"), (void*)FXFont::ExtraCondensed);
    setwidth->appendItem(_("Condensed"), (void*)FXFont::Condensed);
    setwidth->appendItem(_("Semi condensed"), (void*)FXFont::SemiCondensed);
    setwidth->appendItem(_("Normal"), (void*)FXFont::NonExpanded);
    setwidth->appendItem(_("Semi expanded"), (void*)FXFont::SemiExpanded);
    setwidth->appendItem(_("Expanded"), (void*)FXFont::Expanded);
    setwidth->appendItem(_("Extra expanded"), (void*)FXFont::ExtraExpanded);
    setwidth->appendItem(_("Ultra expanded"), (void*)FXFont::UltraExpanded);
    setwidth->setCurrentItem(0);

    // Pitch
    new FXLabel(attributes, _("Pitch:"), NULL, LAYOUT_CENTER_Y|LAYOUT_FILL_COLUMN);
    pitch = new FXComboBox(attributes, 5, this, ID_PITCH, COMBOBOX_STATIC|LAYOUT_CENTER_Y|LAYOUT_FILL_COLUMN);
    pitch->setNumVisible(3);
    pitch->appendItem(_("Any"), (void*)0);
    pitch->appendItem(_("Fixed"), (void*)FXFont::Fixed);
    pitch->appendItem(_("Variable"), (void*)FXFont::Variable);
    pitch->setCurrentItem(0);

    // Check for scalable
    new FXFrame(attributes, FRAME_NONE|LAYOUT_FILL_COLUMN);
    scalable = new FXCheckButton(attributes, _("Scalable:"), this, ID_SCALABLE, JUSTIFY_NORMAL|TEXT_BEFORE_ICON|LAYOUT_CENTER_Y|LAYOUT_FILL_COLUMN);

    // Check for all (X11) fonts
    new FXFrame(attributes, FRAME_NONE|LAYOUT_FILL_COLUMN);
    allfonts = new FXCheckButton(attributes, _("All Fonts:"), this, ID_ALLFONTS, JUSTIFY_NORMAL|TEXT_BEFORE_ICON|LAYOUT_CENTER_Y|LAYOUT_FILL_COLUMN);

    // Preview
    FXVerticalFrame* bottom = new FXVerticalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, DEFAULT_SPACING, DEFAULT_SPACING, DEFAULT_SPACING, DEFAULT_SPACING, 0, 0);
    new FXLabel(bottom, _("Preview:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_X);
    FXHorizontalFrame* box = new FXHorizontalFrame(bottom, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_THICK, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    FXScrollWindow*    scroll = new FXScrollWindow(box, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    preview = new FXLabel(scroll, "ABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz\n0123456789", NULL, JUSTIFY_CENTER_X|JUSTIFY_CENTER_Y);
    preview->setBackColor(getApp()->getBackColor());

	FXString fontname = FXString(DEFAULT_NORMAL_FONT);
    strlcpy(selected.face, fontname.before(',').text(), sizeof(selected.face)+1);
    selected.size = 90;
    selected.weight = FXFont::Bold;
    selected.slant = 0;
    selected.encoding = FONTENCODING_USASCII;
    selected.setwidth = 0;
    selected.flags = 0;
    previewfont = NULL;
}


// List the fonts when created
void FontSelector::create()
{
    FXPacker::create();
    listFontFaces();
    listWeights();
    listSlants();
    listFontSizes();
}


// Fill the list with face names
void FontSelector::listFontFaces()
{
    FXFontDesc* fonts;
    FXuint      numfonts, f;
    int         selindex = -1;

    familylist->clearItems();
    family->setText("");
    if (FXFont::listFonts(fonts, numfonts, FXString::null, 0, 0, selected.setwidth, selected.encoding, selected.flags))
    {
        FXASSERT(0 < numfonts);
        for (f = 0; f < numfonts; f++)
        {
            familylist->appendItem(fonts[f].face, NULL, (void*)(FXuval)fonts[f].flags);
            if (strcmp(selected.face, fonts[f].face) == 0)
            {
                selindex = f;
            }
        }
        if (selindex == -1)
        {
            selindex = 0;
        }
        if (0 < familylist->getNumItems())
        {
            familylist->setCurrentItem(selindex);
            familylist->makeItemVisible(selindex);
            family->setText(familylist->getItemText(selindex));
            strlcpy(selected.face, familylist->getItemText(selindex).text(), sizeof(selected.face)+1);
        }
        FXFREE(&fonts);
    }
}


// Fill the list with font weights
void FontSelector::listWeights()
{
    FXFontDesc* fonts;
    FXuint      numfonts, f, ww, lastww;
    const char* wgt;
    int         selindex = -1;

    weightlist->clearItems();
    weight->setText("");
    if (FXFont::listFonts(fonts, numfonts, selected.face, 0, 0, selected.setwidth, selected.encoding, selected.flags))
    {
        FXASSERT(0 < numfonts);
        lastww = 0;
        for (f = 0; f < numfonts; f++)
        {
            ww = fonts[f].weight;
            if (ww != lastww)
            {
                // Get text for the weight
                switch (ww)
                {
                case FXFont::Thin:
                    wgt = "thin";
                    break;

                case FXFont::ExtraLight:
                    wgt = "extra light";
                    break;

                case FXFont::Light:
                    wgt = "light";
                    break;

                case FXFont::Normal:
                    wgt = "normal";
                    break;

                case FXFont::Medium:
                    wgt = "medium";
                    break;

                case FXFont::DemiBold:
                    wgt = "demibold";
                    break;

                case FXFont::Bold:
                    wgt = "bold";
                    break;

                case FXFont::ExtraBold:
                    wgt = "extra bold";
                    break;

                case FXFont::Black:
                    wgt = "black";
                    break;

                default:
                    wgt = "normal";
                    break;
                }

                // Add it
                weightlist->appendItem(_(wgt), NULL, (void*)(FXuval)ww);

                // Remember if this was the current selection
                if (selected.weight == ww)
                {
                    selindex = weightlist->getNumItems()-1;
                }
                lastww = ww;
            }
        }
        if (selindex == -1)
        {
            selindex = 0;
        }
        if (0 < weightlist->getNumItems())
        {
            weightlist->setCurrentItem(selindex);
            weightlist->makeItemVisible(selindex);
            weight->setText(weightlist->getItemText(selindex));
            selected.weight = (FXuint)(FXuval)weightlist->getItemData(selindex);
        }
        FXFREE(&fonts);
    }
}


// Fill the list with font slants
void FontSelector::listSlants()
{
    FXFontDesc* fonts;
    FXuint      numfonts, f, s, lasts;
    const char* slt;
    int         selindex = -1;

    stylelist->clearItems();
    style->setText("");
    if (FXFont::listFonts(fonts, numfonts, selected.face, selected.weight, 0, selected.setwidth, selected.encoding, selected.flags))
    {
        FXASSERT(0 < numfonts);
        lasts = 0;
        for (f = 0; f < numfonts; f++)
        {
            s = fonts[f].slant;
            if (s != lasts)
            {
                // Get text for the weight
                switch (s)
                {
                case FXFont::ReverseOblique:
                    slt = "reverse oblique";
                    break;

                case FXFont::ReverseItalic:
                    slt = "reverse italic";
                    break;

                case FXFont::Straight:
                    slt = "regular";
                    break;

                case FXFont::Italic:
                    slt = "italic";
                    break;

                case FXFont::Oblique:
                    slt = "oblique";
                    break;

                default:
                    slt = "normal";
                    break;
                }

                // Add it
                stylelist->appendItem(_(slt), NULL, (void*)(FXuval)s);

                // Remember if this was the current selection
                if (selected.slant == s)
                {
                    selindex = stylelist->getNumItems()-1;
                }
                lasts = s;
            }
        }
        if (selindex == -1)
        {
            selindex = 0;
        }
        if (0 < stylelist->getNumItems())
        {
            stylelist->setCurrentItem(selindex);
            stylelist->makeItemVisible(selindex);
            style->setText(stylelist->getItemText(selindex));
            selected.slant = (FXuint)(FXuval)stylelist->getItemData(selindex);
        }
        FXFREE(&fonts);
    }
}


// Fill the list with font sizes
void FontSelector::listFontSizes()
{
    const FXuint sizeint[] =
    {
        60, 80, 90, 100, 110, 120, 140, 160, 200, 240, 300, 360, 420, 480, 640
    };
    FXFontDesc* fonts;
    FXuint      numfonts, f, s, lasts;
    int         selindex = -1;

    sizelist->clearItems();
    size->setText("");
    FXString string;
    if (FXFont::listFonts(fonts, numfonts, selected.face, selected.weight, selected.slant, selected.setwidth, selected.encoding, selected.flags))
    {
        FXASSERT(0 < numfonts);
        lasts = 0;
        if (fonts[0].flags&FXFont::Scalable)
        {
            for (f = 0; f < ARRAYNUMBER(sizeint); f++)
            {
                s = sizeint[f];
                string.format("%.1f", 0.1*s);
                sizelist->appendItem(string, NULL, (void*)(FXuval)s);
                if (selected.size == s)
                {
                    selindex = sizelist->getNumItems()-1;
                }
                lasts = s;
            }
        }
        else
        {
            for (f = 0; f < numfonts; f++)
            {
                s = fonts[f].size;
                if (s != lasts)
                {
                    string.format("%.1f", 0.1*s);
                    sizelist->appendItem(string, NULL, (void*)(FXuval)s);
                    if (selected.size == s)
                    {
                        selindex = sizelist->getNumItems()-1;
                    }
                    lasts = s;
                }
            }
        }
        if (selindex == -1)
        {
            selindex = 0;
        }
        if (0 < sizelist->getNumItems())
        {
            sizelist->setCurrentItem(selindex);
            sizelist->makeItemVisible(selindex);
            size->setText(sizelist->getItemText(selindex));
            selected.size = (FXuint)(FXuval)sizelist->getItemData(selindex);
        }
        FXFREE(&fonts);
    }
}


// Preview
void FontSelector::previewFont()
{
    FXFont* old;

    // Save old font
    old = previewfont;

    // Get new font
    previewfont = new FXFont(getApp(), selected);

    // Realize new font
    previewfont->create();

    // Set new font
    preview->setFont(previewfont);

    // Delete old font
    delete old;
}


// Selected font family
long FontSelector::onCmdFamily(FXObject*, FXSelector, void* ptr)
{
    strlcpy(selected.face, familylist->getItemText((int)(FXival)ptr).text(), sizeof(selected.face)+1);
    family->setText(selected.face);
    listWeights();
    listSlants();
    listFontSizes();
    previewFont();
    return(1);
}


// Changed weight setting
long FontSelector::onCmdWeight(FXObject*, FXSelector, void* ptr)
{
    selected.weight = (FXuint)(FXuval)weightlist->getItemData((int)(FXival)ptr);
    weight->setText(weightlist->getItemText((int)(FXival)ptr));
    listSlants();
    listFontSizes();
    previewFont();
    return(1);
}


// User clicked up directory button
long FontSelector::onCmdSize(FXObject*, FXSelector, void* ptr)
{
    selected.size = (FXuint)(FXuval)sizelist->getItemData((int)(FXival)ptr);
    size->setText(sizelist->getItemText((int)(FXival)ptr));
    previewFont();
    return(1);
}


// User clicked up directory button
long FontSelector::onCmdSizeText(FXObject*, FXSelector, void*)
{
    selected.size = (FXuint)(10.0*FXFloatVal(size->getText()));
    if (selected.size < 60)
    {
        selected.size = 60;
    }
    if (selected.size > 2400)
    {
        selected.size = 2400;
    }
    previewFont();
    return(1);
}


// User clicked up directory button
long FontSelector::onCmdStyle(FXObject*, FXSelector, void* ptr)
{
    selected.slant = (FXuint)(FXuval)stylelist->getItemData((int)(FXival)ptr);
    style->setText(stylelist->getItemText((int)(FXival)ptr));
    listFontSizes();
    previewFont();
    return(1);
}


// Style type in
long FontSelector::onCmdStyleText(FXObject*, FXSelector, void*)
{
    return(1);
}


// Character set
long FontSelector::onCmdCharset(FXObject*, FXSelector, void*)
{
    int    index = charset->getCurrentItem();
    FXuint enc = (FXuint)(FXuval)charset->getItemData(index);

    selected.encoding = (FXFontEncoding)enc;
    listFontFaces();
    listWeights();
    listSlants();
    listFontSizes();
    previewFont();
    return(1);
}


// Update character set
long FontSelector::onUpdCharset(FXObject*, FXSelector, void*)
{
    charset->setCurrentItem(charset->findItemByData((void*)(FXuval)selected.encoding));
    return(1);
}


// Changed set width
long FontSelector::onCmdSetWidth(FXObject*, FXSelector, void*)
{
    int index = setwidth->getCurrentItem();

    selected.setwidth = (FXuint)(FXuval)setwidth->getItemData(index);
    listFontFaces();
    listWeights();
    listSlants();
    listFontSizes();
    previewFont();
    return(1);
}


// Update set width
long FontSelector::onUpdSetWidth(FXObject*, FXSelector, void*)
{
    setwidth->setCurrentItem(setwidth->findItemByData((void*)(FXuval)selected.setwidth));
    return(1);
}


// Changed pitch
long FontSelector::onCmdPitch(FXObject*, FXSelector, void*)
{
    int index = pitch->getCurrentItem();

    selected.flags &= ~(FXFont::Fixed|FXFont::Variable);
    selected.flags |= (FXuint)(FXuval)pitch->getItemData(index);
    listFontFaces();
    listWeights();
    listSlants();
    listFontSizes();
    previewFont();
    return(1);
}


// Update pitch
long FontSelector::onUpdPitch(FXObject*, FXSelector, void*)
{
    pitch->setCurrentItem((selected.flags&FXFont::Fixed) ? 1 : (selected.flags&FXFont::Variable) ? 2 : 0);
    return(1);
}


// Scalable toggle
long FontSelector::onCmdScalable(FXObject*, FXSelector, void* ptr)
{
    if (ptr)
    {
        selected.flags |= FXFont::Scalable;
    }
    else
    {
        selected.flags &= ~FXFont::Scalable;
    }
    listFontFaces();
    listWeights();
    listSlants();
    listFontSizes();
    previewFont();
    return(1);
}


// Update scalable toggle
long FontSelector::onUpdScalable(FXObject*, FXSelector, void*)
{
    scalable->setCheck((selected.flags&FXFont::Scalable) != 0);
    return(1);
}


// All fonts toggle
long FontSelector::onCmdAllFonts(FXObject*, FXSelector, void* ptr)
{
    if (ptr)
    {
        selected.flags |= FXFont::X11;
    }
    else
    {
        selected.flags &= ~FXFont::X11;
    }
    listFontFaces();
    listWeights();
    listSlants();
    listFontSizes();
    previewFont();
    return(1);
}


// Update all fonts toggle
long FontSelector::onUpdAllFonts(FXObject*, FXSelector, void*)
{
    allfonts->setCheck((selected.flags&FXFont::X11) != 0);
    return(1);
}


// Change font selection
void FontSelector::setFontSelection(const FXFontDesc& fontdesc)
{
    selected = fontdesc;

    // Validate these numbers
    if (selected.encoding > FONTENCODING_UNICODE)
    {
        selected.encoding = FONTENCODING_UNICODE;
    }
    if (selected.slant > FXFont::ReverseOblique)
    {
        selected.slant = FXFont::ReverseOblique;
    }
    if (selected.weight > FXFont::Black)
    {
        selected.weight = FXFont::Black;
    }
    if (selected.setwidth > FXFont::UltraExpanded)
    {
        selected.setwidth = FXFont::UltraExpanded;
    }
    if (selected.size > 10000)
    {
        selected.size = 10000;
    }

    // Under Windows, this should be OFF
    selected.flags &= ~FXFont::X11;

    // Relist fonts
    listFontFaces();
    listWeights();
    listSlants();
    listFontSizes();

    // Update preview
    previewFont();
}


// Change font selection
void FontSelector::getFontSelection(FXFontDesc& fontdesc) const
{
    fontdesc = selected;
}


// Save data
void FontSelector::save(FXStream& store) const
{
    FXPacker::save(store);
    store << family;
    store << familylist;
    store << weight;
    store << weightlist;
    store << style;
    store << stylelist;
    store << size;
    store << sizelist;
    store << charset;
    store << setwidth;
    store << pitch;
    store << scalable;
    store << allfonts;
    store << accept;
    store << cancel;
    store << preview;
    store << previewfont;
}


// Load data
void FontSelector::load(FXStream& store)
{
    FXPacker::load(store);
    store >> family;
    store >> familylist;
    store >> weight;
    store >> weightlist;
    store >> style;
    store >> stylelist;
    store >> size;
    store >> sizelist;
    store >> charset;
    store >> setwidth;
    store >> pitch;
    store >> scalable;
    store >> allfonts;
    store >> accept;
    store >> cancel;
    store >> preview;
    store >> previewfont;
}


// Cleanup
FontSelector::~FontSelector()
{
    delete previewfont;
    family = (FXTextField*)-1L;
    familylist = (FXList*)-1L;
    weight = (FXTextField*)-1L;
    weightlist = (FXList*)-1L;
    style = (FXTextField*)-1L;
    stylelist = (FXList*)-1L;
    size = (FXTextField*)-1L;
    sizelist = (FXList*)-1L;
    charset = (FXComboBox*)-1L;
    setwidth = (FXComboBox*)-1L;
    pitch = (FXComboBox*)-1L;
    scalable = (FXCheckButton*)-1L;
    allfonts = (FXCheckButton*)-1L;
    preview = (FXLabel*)-1L;
    previewfont = (FXFont*)-1L;
    accept = (FXButton*)-1L;
    cancel = (FXButton*)-1L;
}


// Object implementation
FXIMPLEMENT(FontDialog, DialogBox, NULL, 0)


// Separator item
FontDialog::FontDialog(FXWindow* owner, const FXString& name, FXuint opts, int x, int y, int w, int h) :
    DialogBox(owner, name, opts|DECOR_TITLE|DECOR_BORDER|DECOR_RESIZE|DECOR_MAXIMIZE|DECOR_CLOSE, x, y, w, h, 0, 0, 0, 0, 4, 4)
{
    fontbox = new FontSelector(this, NULL, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    fontbox->acceptButton()->setTarget(this);
    fontbox->acceptButton()->setSelector(DialogBox::ID_ACCEPT);
    fontbox->cancelButton()->setTarget(this);
    fontbox->cancelButton()->setSelector(DialogBox::ID_CANCEL);
}


// Save data
void FontDialog::save(FXStream& store) const
{
    DialogBox::save(store);
    store << fontbox;
}


// Load data
void FontDialog::load(FXStream& store)
{
    DialogBox::load(store);
    store >> fontbox;
}


// Change the selected font
void FontDialog::setFontSelection(const FXFontDesc& fontdesc)
{
    fontbox->setFontSelection(fontdesc);
}


// Return the selected font
void FontDialog::getFontSelection(FXFontDesc& fontdesc) const
{
    fontbox->getFontSelection(fontdesc);
}


// Cleanup
FontDialog::~FontDialog()
{
    fontbox = (FontSelector*)-1L;
}
// Input dialog with history list and an optional check box

#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <fxkeys.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "FileDialog.h"
#include "HistInputDialog.h"

extern FXString homedir;

// Object implementation
FXIMPLEMENT(ComboBox, FXComboBox, NULL, 0)

ComboBox::ComboBox(FXComposite* p, int cols, FXObject* tgt, FXSelector sel, FXuint opts) :
    FXComboBox(p, cols, tgt, sel, opts)
{
}


void ComboBox::create()
{
    FXComboBox::create();
    setFocus();
}


FXDEFMAP(HistInputDialog) HistInputDialogMap[] =
{
    FXMAPFUNC(SEL_KEYPRESS, 0, HistInputDialog::onCmdKeyPress),
    FXMAPFUNC(SEL_COMMAND, HistInputDialog::ID_BROWSE_PATH, HistInputDialog::onCmdBrowsePath),
};


// Object implementation
FXIMPLEMENT(HistInputDialog, DialogBox, HistInputDialogMap, ARRAYNUMBER(HistInputDialogMap))

// Construct a dialog box with an optional check box
HistInputDialog::HistInputDialog(FXWindow* w, FXString inp, FXString message, FXString title, FXString label, FXIcon* ic, FXuint browse, FXbool option, FXString optiontext) :
    DialogBox(w, title, DECOR_TITLE|DECOR_BORDER|DECOR_STRETCHABLE|DECOR_MAXIMIZE|DECOR_CLOSE)
{
    // Browse type flag
    browsetype = browse;

    // Buttons
    buttons = new FXHorizontalFrame(this, PACK_UNIFORM_WIDTH|LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X, 0, 0, 0, 0, 10, 10, 5, 5);

    // Accept
    new FXButton(buttons, _("&Accept"), NULL, this, ID_ACCEPT, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT, 0, 0, 0, 0, 20, 20);

    // Cancel
    new FXButton(buttons, _("&Cancel"), NULL, this, ID_CANCEL, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT, 0, 0, 0, 0, 20, 20);

    // Optional check box
    checkbutton = new FXHorizontalFrame(this, JUSTIFY_RIGHT|LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X, 0, 0, 0, 0, 10, 10, 0, 0);

    if (option)
    {
        new FXCheckButton(checkbutton, optiontext, this, ID_TOGGLE_OPTION);
    }

    // Vertical frame
    FXVerticalFrame* contents = new FXVerticalFrame(this, LAYOUT_SIDE_TOP|FRAME_NONE|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Icon and first line
    FXMatrix* matrix1 = new FXMatrix(contents, 2, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix1, "", ic, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW);
    new FXLabel(matrix1, message, NULL, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW|FRAME_NONE);

    // Label and input field (combo box)
    FXMatrix* matrix2 = new FXMatrix(contents, 3, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix2, label, NULL, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW);
    input = new ComboBox(matrix2, 40, NULL, 0, COMBOBOX_INSERT_LAST|LAYOUT_CENTER_Y|LAYOUT_CENTER_X|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    input->setNumVisible(8);
    input->setText(inp);
    new FXButton(matrix2, _("\tSelect destination..."), filedialogicon, this, ID_BROWSE_PATH, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    if (!isUtf8(message.text(), message.length()))
    {
        new FXLabel(contents, _("=> Warning: file name is not UTF-8 encoded!"), NULL, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW);
    }

    // Initial directory for browsing
    initialdir = homedir;
}


void HistInputDialog::create()
{
    DialogBox::create();
    input->setFocus();
}


void HistInputDialog::CursorEnd()
{
    input->CursorEnd();
    input->setFocus();
}


void HistInputDialog::selectAll()
{
    input->onFwdToText(this, FXSEL(SEL_FOCUSIN, 0), NULL);
    input->onFwdToText(this, FXSEL(SEL_COMMAND, FXTextField::ID_SELECT_ALL), NULL);
}


long HistInputDialog::onCmdKeyPress(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    switch (event->code)
    {
    case KEY_Escape:
        handle(this, FXSEL(SEL_COMMAND, ID_CANCEL), NULL);
        return(1);

    case KEY_KP_Enter:
    case KEY_Return:
        handle(this, FXSEL(SEL_COMMAND, ID_ACCEPT), NULL);
        return(1);

    default:
        FXTopWindow::onKeyPress(sender, sel, ptr);
        return(1);
    }
    return(0);
}


long HistInputDialog::onCmdBrowsePath(FXObject* o, FXSelector s, void* p)
{
    FXString title;

    if (browsetype == HIST_INPUT_FOLDER)
    {
        title = _("Select a destination folder");
    }
    else if (browsetype == HIST_INPUT_FILE)
    {
        title = _("Select a file");
    }
    else if (browsetype == HIST_INPUT_EXECUTABLE_FILE)
    {
        title = _("Select an executable file");
    }
    else
    {
        title = _("Select a file or a destination folder");
    }

    // File dialog
    FileDialog browse(this, title);

    const char* patterns[] =
    {
        _("All Files"), "*", NULL
    };
    browse.setDirectory(initialdir);
    browse.setPatternList(patterns);

    // Browse files in directory, or existing, or mixed mode depending on the flag
    if (browsetype == HIST_INPUT_FOLDER)
    {
        browse.setSelectMode(SELECT_FILE_DIRECTORY);
    }
    else if (browsetype == HIST_INPUT_FILE)
    {
        browse.setSelectMode(SELECT_FILE_EXISTING);
    }
    else if (browsetype == HIST_INPUT_EXECUTABLE_FILE)
    {
        browse.setSelectMode(SELECT_FILE_EXISTING);
    }
    else
    {
        browse.setSelectMode(SELECT_FILE_MIXED);
    }
    if (browse.execute())
    {
        FXString path = browse.getFilename();
        input->setText(path);
    }

    return(1);
}


// Set initial directory
void HistInputDialog::setDirectory(const FXString& path)
{
    initialdir = path;
}
// Icon list. Taken from the FOX library and slightly modified.
#include "config.h"
#include "i18n.h"

#include <ctype.h>
#include <time.h>

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>
#include <FXJPGIcon.h>
#include <FXTIFIcon.h>
#if defined(linux)
#include <mntent.h>
#endif

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "IconList.h"


// Number of columns in detailed view, in the general case
// NB : when the deletion date and original path are displayed, two more columns are added
#define NUM_HEADERS    8



#define SIDE_SPACING           4      // Left or right spacing between items
#define DETAIL_TEXT_SPACING    2      // Spacing between text and icon in detail icon mode
#define MINI_TEXT_SPACING      2      // Spacing between text and icon in mini icon mode
#define BIG_LINE_SPACING       16      // Line spacing in big icon mode
// #define BIG_LINE_SPACING       8      // Line spacing in big icon mode

#define BIG_ICON_TOP       3      // Spacing between text and icon in big icon mode

#define BIG_TEXT_SPACING       2      // Spacing between text and icon in big icon mode
#define ITEM_SPACE             76     // Default space for item name
#define ITEM_HEIGHT            1      // Initial item height
// #define ITEM_HEIGHT            2      // Initial item height
#define ITEM_WIDTH             1      // Initial item width

#define SELECT_MASK            (_ICONLIST_EXTENDEDSELECT|_ICONLIST_SINGLESELECT|_ICONLIST_BROWSESELECT|_ICONLIST_MULTIPLESELECT)
#define ICONLIST_MASK          (SELECT_MASK|_ICONLIST_MINI_ICONS|_ICONLIST_BIG_ICONS|_ICONLIST_COLUMNS|_ICONLIST_AUTOSIZE)

extern FXuint single_click;
extern FXbool file_tooltips;
extern FXbool relative_resize;


// Object implementation
FXIMPLEMENT(IconItem, FXObject, NULL, 0)


// Check if integer is odd (return true) or even (return false)
inline FXbool IconItem::isOdd(int i) const
{
    return((FXbool)(i & 0x1));
}


// Draw item
inline void IconItem::draw(IconList* list, FXDC& dc, int x, int y, int w, int h) const
{
    register FXuint options = list->getListStyle();

    if (options&_ICONLIST_BIG_ICONS)
    {
        drawBigIcon(list, dc, x, y, w, h);
    }
    else if (options&_ICONLIST_MINI_ICONS)
    {
        drawMiniIcon(list, dc, x, y, w, h);
    }
    else
    {
        drawDetails(list, dc, x, y, w, h);
    }
}


// Draw big icon
void IconItem::drawBigIcon(const IconList* list, FXDC& dc, int x, int y, int w, int h) const
{
    register int     len, dw, s, space, xt, yt, xi, yi;
    register FXFont* font = list->getFont();
    register int     iw = 0, ih = 0, tw = 0, th = 0, ss = 0;

    space = w-SIDE_SPACING;

    if (!label.empty())
    {
        for (len = 0; len < label.length() && label[len] != '\t'; len++)
        {
        }
        tw = 4+font->getTextWidth(label.text(), len);
        th = 4+font->getFontHeight();
        yt = y+h-th-BIG_LINE_SPACING/2;
        dw = 0;
        if (tw > space)
        {
            dw = font->getTextWidth("...", 3);
            s = space-dw;
            while ((tw = 4+font->getTextWidth(label.text(), len)) > s && len > 1)
            {
                len = label.dec(len);
            }
            if (tw > s)
            {
                dw = 0;
           }
        }
        if (tw <= space)         // FIXME as below in drawDetails
        {
            xt = x+(w-tw-dw)/2;
            if (isSelected())
            {
                dc.setForeground(list->getSelBackColor());
                dc.fillRectangle(xt , yt - BIG_ICON_TOP + 2, tw+dw , th-3);
            }
            if (!isEnabled())
            {
                dc.setForeground(makeShadowColor(list->getBackColor()));
            }
            else if (isSelected())
            {
                dc.setForeground(list->getSelTextColor());
            }
            else
            {
                dc.setForeground(list->getTextColor());
            }
            dc.drawText(xt+2, yt+font->getFontAscent()+2-BIG_ICON_TOP, label.text(), len);
            if (dw)
            {
                dc.drawText(xt+tw-2, yt+font->getFontAscent()+2-BIG_ICON_TOP, "...", 3);
            }
            if (hasFocus())
            {
                dc.drawFocusRectangle(xt, yt - BIG_ICON_TOP + 2, tw+dw, th - 3);
            }
        }
        ss = BIG_TEXT_SPACING;    // Space between text and icon only added if we have both icon and text
    }
    if (bigIcon)
    {
        iw = bigIcon->getWidth();
        ih = bigIcon->getHeight();
        xi = x+(w-iw)/2;
        yi = y+BIG_LINE_SPACING/2+(h-th-BIG_LINE_SPACING-ss-ih)/2-BIG_ICON_TOP;
        if (isSelected())
        {
            dc.drawIconShaded(bigIcon, xi, yi);
        }
        else
        {
            dc.drawIcon(bigIcon, xi, yi);
        }
    }
}


// Draw mini icon
void IconItem::drawMiniIcon(const IconList* list, FXDC& dc, int x, int y, int w, int h) const
{
    register FXFont* font = list->getFont();
    register int     iw = 0, ih = 0, tw = 0, th = 0;
    register int     len, dw, s, space;

    x += SIDE_SPACING/2;
    space = w-SIDE_SPACING;

    if (miniIcon)
    {
        iw = miniIcon->getWidth();
        ih = miniIcon->getHeight();
        if (isSelected())
        {
            dc.drawIconShaded(miniIcon, x, y+(h-ih)/2);
        }
        else
        {
            dc.drawIcon(miniIcon, x, y+(h-ih)/2);
        }
        x += iw+MINI_TEXT_SPACING;
        space -= iw+MINI_TEXT_SPACING;
    }
    if (!label.empty())
    {
        for (len = 0; len < label.length() && label[len] != '\t'; len++)
        {
        }
        tw = 4+font->getTextWidth(label.text(), len);
        th = 4+font->getFontHeight();
        dw = font->getTextWidth("...", 3);
        y += (h-th)/2;
        dw = 0;
        if (tw > space)                  // FIXME as below in drawDetails
        {
            dw = font->getTextWidth("...", 3);
            s = space-dw;
            while ((tw = 4+font->getTextWidth(label.text(), len)) > s && len > 1)
            {
                len = label.dec(len);
            }
            if (tw > s)
            {
                dw = 0;
            }
        }
        if (tw <= space)
        {
            if (isSelected())
            {
                dc.setForeground(list->getSelBackColor());
                dc.fillRectangle(x, y, tw+dw, th);
            }
            if (!isEnabled())
            {
                dc.setForeground(makeShadowColor(list->getBackColor()));
            }
            else if (isSelected())
            {
                dc.setForeground(list->getSelTextColor());
            }
            else
            {
                dc.setForeground(list->getTextColor());
            }
            dc.drawText(x+2, y+font->getFontAscent()+2, label.text(), len);
            if (dw)
            {
                dc.drawText(x+tw-2, y+font->getFontAscent()+2, "...", 3);
            }
            if (hasFocus())
            {
                dc.drawFocusRectangle(x+1, y+1, tw+dw-2, th-2);
            }
        }
    }
}


void IconItem::drawDetails(IconList* list, FXDC& dc, int x, int y, int, int h) const
{
    register FXHeader* header = list->getHeader();
    register FXFont*   font = list->getFont();
    register int       iw = 0, ih = 0, tw = 0, th = 0, yt, beg, end, hi, drw, space, used, dw, xx, dx = 0;
    register FXbool    highlight;
    register FXuint    options = list->getListStyle();

    if (header->getNumItems() == 0)
    {
        return;
    }

    // Display a colored bar in the Filelist, one line over two
    highlight = IconItem::isOdd(list->getItemAt(x, y));
    if (highlight)
    {
        dc.setForeground(list->getHighlightColor());
        dc.fillRectangle(x, y, header->getTotalSize(), h);
    }
    highlight = !highlight;

    // Darken the sorted column
    for (hi = 0; hi < (int)list->getSortHeader(); hi++)
    {
        dx += header->getItemSize(hi);
    }

    if (highlight)
    {
        dc.setForeground(list->getSortColor());
        dc.fillRectangle(x+dx, y, header->getItemSize(list->getSortHeader()), h);
    }
    else
    {
        dc.setForeground(list->getHighlightSortColor());
        dc.fillRectangle(x+dx, y, header->getItemSize(list->getSortHeader()), h);
    }

    // Color the selected items
    if (isSelected())
    {
        dc.setForeground(list->getSelBackColor());
        dc.fillRectangle(x, y, header->getTotalSize(), h);
    }
    if (hasFocus())
    {
        dc.drawFocusRectangle(x+1, y+1, header->getTotalSize()-2, h-2);
    }
    xx = x+SIDE_SPACING/2;
    if (miniIcon)
    {
        iw = miniIcon->getWidth();
        ih = miniIcon->getHeight();
        dc.setClipRectangle(x, y, header->getItemSize(0), h);
        dc.drawIcon(miniIcon, xx, y+(h-ih)/2);
        dc.clearClipRectangle();
        xx += iw+DETAIL_TEXT_SPACING;
    }
    if (!label.empty())
    {
        th = font->getFontHeight();
        dw = font->getTextWidth("...", 3);
        yt = y+(h-th-4)/2;
        if (!isEnabled())
        {
            dc.setForeground(makeShadowColor(list->getBackColor()));
        }
        else if (isSelected())
        {
            dc.setForeground(list->getSelTextColor());
        }
        else
        {
            dc.setForeground(list->getTextColor());
        }
        used = iw+DETAIL_TEXT_SPACING+SIDE_SPACING/2;

        for (hi = beg = 0; beg < label.length() && hi < header->getNumItems(); hi++, beg = end+1)
        {
            space = header->getItemSize(hi)-used;
            for (end = beg; end < label.length() && label[end] != '\t'; end++)
            {
            }
            if (end > beg)
            {
                drw = end-beg;
                tw = font->getTextWidth(&label[beg], drw);

                // Right justify the file size column (second one in file list mode or third one in search list mode)
                if (!(options&_ICONLIST_STANDARD) && ((!(options&_ICONLIST_SEARCH) && (hi == 1)) || (options&_ICONLIST_SEARCH && (hi == 2))))
                {
                    if (tw > space-20)
                    {
                        while ((tw = font->getTextWidth(&label[beg], drw))+dw > space-4 && drw > 1)
                        {
                            drw--;
                        }
                        dc.setClipRectangle(xx, y, space, h);
                        dc.drawText(xx+2, yt+font->getFontAscent()+2, &label[beg], drw);
                        dc.drawText(xx+tw+2, yt+font->getFontAscent()+2, "...", 3);
                        dc.clearClipRectangle();
                    }
                    else
                    {
                        dc.drawText(xx+space-tw-20, yt+font->getFontAscent()+2, &label[beg], drw);
                    }
                }
                else
                {
                    if (tw > space-4)
                    {
                        while ((tw = font->getTextWidth(&label[beg], drw))+dw > space-4 && drw > 1)
                        {
                            drw--;
                        }
                        dc.setClipRectangle(xx, y, space, h);
                        dc.drawText(xx+2, yt+font->getFontAscent()+2, &label[beg], drw);
                        dc.drawText(xx+tw+2, yt+font->getFontAscent()+2, "...", 3);
                        dc.clearClipRectangle();
                    }
                    else
                    {
                        dc.drawText(xx+2, yt+font->getFontAscent()+2, &label[beg], drw);
                    }
                }
            }
            xx += space;
            used = 0;
        }
    }
}


// See if item got hit and where: 0 is outside, 1 is icon, 2 is text
int IconItem::hitItem(const IconList* list, int rx, int ry, int rw, int rh) const
{
    register int     iw = 0, tw = 0, ih = 0, th = 0, ss = 0, ix, iy, tx, ty, w, h, sp, tlen;
    register FXuint  options = list->getListStyle();
    register FXFont* font = list->getFont();

    for (tlen = 0; tlen < label.length() && label[tlen] != '\t'; tlen++)
    {
    }
    if (options&_ICONLIST_BIG_ICONS)
    {
        w = list->getItemSpace();
        h = list->getItemHeight();
        sp = w-SIDE_SPACING;
        if (!label.empty())
        {
            tw = 4+font->getTextWidth(label.text(), tlen);
            th = BIG_ICON_TOP+4+font->getFontHeight();
            if (tw > sp)
            {
                tw = sp;
            }
            if (bigIcon)
            {
                ss = BIG_TEXT_SPACING;
            }
        }
        if (bigIcon)
        {
            iw = bigIcon->getWidth();
            ih = bigIcon->getHeight();
        }
        ty = h-th-BIG_LINE_SPACING/2 - BIG_ICON_TOP;
        iy = BIG_LINE_SPACING/2+(h-th-BIG_LINE_SPACING-ss-ih)/2-BIG_ICON_TOP;
        ix = (w-iw)/2;
        tx = (w-tw)/2;
    }
    else if (options&_ICONLIST_MINI_ICONS)
    {
        sp = list->getItemSpace()-SIDE_SPACING;
        ix = SIDE_SPACING/2;
        tx = SIDE_SPACING/2;
        if (miniIcon)
        {
            iw = miniIcon->getWidth();
            ih = miniIcon->getHeight();
            tx += iw+MINI_TEXT_SPACING;
            sp = sp-iw-MINI_TEXT_SPACING;
        }
        if (!label.empty())
        {
            tw = 4+font->getTextWidth(label.text(), tlen);
            th = 4+font->getFontHeight();
            if (tw > sp)
            {
                tw = sp;
            }
        }
        h = list->getItemHeight();
        iy = (h-ih)/2;
        ty = (h-th)/2;
    }
    else
    {
        ix = SIDE_SPACING/2;
        tx = SIDE_SPACING/2;
        if (miniIcon)
        {
            iw = miniIcon->getWidth();
            ih = miniIcon->getHeight();
            tx += iw+DETAIL_TEXT_SPACING;
        }
        if (!label.empty())
        {
            tw = 10000000;
            th = 4+font->getFontHeight();
        }
        h = list->getItemHeight();
        iy = (h-ih)/2;
        ty = (h-th)/2;
    }

    // In icon?
    if ((ix <= rx+rw) && (iy <= ry+rh) && (rx < ix+iw) && (ry < iy+ih))
    {
        return(1);
    }

    // In text?
    if ((tx <= rx+rw) && (ty <= ry+rh) && (rx < tx+tw) && (ry < ty+th))
    {
        return(2);
    }

    // Outside
    return(0);
}


// Set or kill focus
inline void IconItem::setFocus(FXbool focus)
{
    if (focus)
    {
        state |= FOCUS;
    }
    else
    {
        state &= ~FOCUS;
    }
}


// Select or deselect item
inline void IconItem::setSelected(FXbool selected)
{
    if (selected)
    {
        state |= SELECTED;
    }
    else
    {
        state &= ~SELECTED;
    }
}


// Enable or disable the item
inline void IconItem::setEnabled(FXbool enabled)
{
    if (enabled)
    {
        state &= ~DISABLED;
    }
    else
    {
        state |= DISABLED;
    }
}


// Icon is draggable
inline void IconItem::setDraggable(FXbool draggable)
{
    if (draggable)
    {
        state |= DRAGGABLE;
    }
    else
    {
        state &= ~DRAGGABLE;
    }
}


// Change item's text label
inline void IconItem::setText(const FXString& txt)
{
    label = txt;
}


// Change item's big icon
inline void IconItem::setBigIcon(FXIcon* icn, FXbool owned)
{
    if (bigIcon && (state&BIGICONOWNED))
    {
        if (bigIcon != icn)
        {
            delete bigIcon;
        }
        state &= ~BIGICONOWNED;
    }
    bigIcon = icn;
    if (bigIcon && owned)
    {
        state |= BIGICONOWNED;
    }
}


// Change item's mini icon
inline void IconItem::setMiniIcon(FXIcon* icn, FXbool owned)
{
    if (miniIcon && (state&MINIICONOWNED))
    {
        if (miniIcon != icn)
        {
            delete miniIcon;
        }
        state &= ~MINIICONOWNED;
    }
    miniIcon = icn;
    if (miniIcon && owned)
    {
        state |= MINIICONOWNED;
    }
}


// Create icon
inline void IconItem::create()
{
    if (bigIcon)
    {
        bigIcon->create();
    }
    if (miniIcon)
    {
        miniIcon->create();
    }
}


// Destroy icon
inline void IconItem::destroy()
{
    if ((state&BIGICONOWNED) && bigIcon)
    {
        bigIcon->destroy();
    }
    if ((state&MINIICONOWNED) && miniIcon)
    {
        miniIcon->destroy();
    }
}


// Detach from icon resource
inline void IconItem::detach()
{
    if (bigIcon)
    {
        bigIcon->detach();
    }
    if (miniIcon)
    {
        miniIcon->detach();
    }
}


// Get item width
int IconItem::getWidth(const IconList* list) const
{
    register FXuint  options = list->getListStyle();
    register FXFont* font = list->getFont();
    register int     iw = 0, tw = 0, w = 0, tlen;

    for (tlen = 0; tlen < label.length() && label[tlen] != '\t'; tlen++)
    {
    }
    if (options&_ICONLIST_BIG_ICONS)
    {
        if (bigIcon)
        {
            iw = bigIcon->getWidth();
        }
        if (!label.empty())
        {
            tw = 4+font->getTextWidth(label.text(), tlen);
        }
        w = SIDE_SPACING+FXMAX(tw, iw);
    }
    else if (options&_ICONLIST_MINI_ICONS)
    {
        if (miniIcon)
        {
            iw = miniIcon->getWidth();
        }
        if (!label.empty())
        {
            tw = 4+font->getTextWidth(label.text(), tlen);
        }
        if (iw && tw)
        {
            iw += MINI_TEXT_SPACING;
        }
        w = SIDE_SPACING+iw+tw;
    }
    else
    {
        w = SIDE_SPACING;
    }
    return(w);
}


// Get item height
int IconItem::getHeight(const IconList* list) const
{
    register FXuint options = list->getListStyle();
    register int    ih = 0, th = 0, h = 0;

    if (options&_ICONLIST_BIG_ICONS)
    {
        if (bigIcon)
        {
            ih = bigIcon->getHeight();
        }
        if (!label.empty())
        {
            th = 4+list->getFont()->getFontHeight();
        }
        if (ih && th)
        {
            ih += BIG_TEXT_SPACING;
        }
        h = BIG_LINE_SPACING+ih+th;
    }
    else if (options&_ICONLIST_MINI_ICONS)
    {
        if (miniIcon)
        {
            ih = miniIcon->getHeight();
        }
        if (!label.empty())
        {
            th = 4+list->getFont()->getFontHeight();
        }
        h = FXMAX(ih, th);
    }
    else
    {
        if (miniIcon)
        {
            ih = miniIcon->getHeight();
        }
        if (!label.empty())
        {
            th = 4+list->getFont()->getFontHeight();
        }
        h = FXMAX(ih, th);
    }
    return(h);
}


// Save data
inline void IconItem::save(FXStream& store) const
{
    FXObject::save(store);
    store << label;
    store << bigIcon;
    store << miniIcon;
    store << state;
}


// Load data
inline void IconItem::load(FXStream& store)
{
    FXObject::load(store);
    store >> label;
    store >> bigIcon;
    store >> miniIcon;
    store >> state;
}


// Delete icons if owned
IconItem::~IconItem()
{
    if (state&BIGICONOWNED)
    {
        delete bigIcon;
    }
    if (state&MINIICONOWNED)
    {
        delete miniIcon;
    }
    bigIcon = (FXIcon*)-1L;
    miniIcon = (FXIcon*)-1L;
}


// Map
FXDEFMAP(IconList) IconListMap[] =
{
    FXMAPFUNC(SEL_PAINT, 0, IconList::onPaint),
    FXMAPFUNC(SEL_MOTION, 0, IconList::onMotion),
    FXMAPFUNC(SEL_CONFIGURE, 0, IconList::onConfigure),
    FXMAPFUNC(SEL_LEFTBUTTONPRESS, 0, IconList::onLeftBtnPress),
    FXMAPFUNC(SEL_LEFTBUTTONRELEASE, 0, IconList::onLeftBtnRelease),
    FXMAPFUNC(SEL_RIGHTBUTTONPRESS, 0, IconList::onRightBtnPress),
    FXMAPFUNC(SEL_RIGHTBUTTONRELEASE, 0, IconList::onRightBtnRelease),
    FXMAPFUNC(SEL_TIMEOUT, FXWindow::ID_AUTOSCROLL, IconList::onAutoScroll),
    FXMAPFUNC(SEL_TIMEOUT, IconList::ID_TIPTIMER, IconList::onTipTimer),
    FXMAPFUNC(SEL_TIMEOUT, IconList::ID_LOOKUPTIMER, IconList::onLookupTimer),
    FXMAPFUNC(SEL_UNGRABBED, 0, IconList::onUngrabbed),
    FXMAPFUNC(SEL_KEYPRESS, 0, IconList::onKeyPress),
    FXMAPFUNC(SEL_KEYRELEASE, 0, IconList::onKeyRelease),
    FXMAPFUNC(SEL_ENTER, 0, IconList::onEnter),
    FXMAPFUNC(SEL_LEAVE, 0, IconList::onLeave),
    FXMAPFUNC(SEL_FOCUSIN, 0, IconList::onFocusIn),
    FXMAPFUNC(SEL_FOCUSOUT, 0, IconList::onFocusOut),
    FXMAPFUNC(SEL_CLICKED, 0, IconList::onClicked),
    FXMAPFUNC(SEL_DOUBLECLICKED, 0, IconList::onDoubleClicked),
    FXMAPFUNC(SEL_TRIPLECLICKED, 0, IconList::onTripleClicked),
    FXMAPFUNC(SEL_QUERY_TIP, 0, IconList::onQueryTip),
    FXMAPFUNC(SEL_QUERY_HELP, 0, IconList::onQueryHelp),
    FXMAPFUNC(SEL_CHANGED, IconList::ID_HEADER_CHANGE, IconList::onHeaderChanged),
    FXMAPFUNC(SEL_CLICKED, IconList::ID_HEADER_CHANGE, IconList::onHeaderResize),
    FXMAPFUNC(SEL_UPDATE, IconList::ID_SHOW_DETAILS, IconList::onUpdShowDetails),
    FXMAPFUNC(SEL_UPDATE, IconList::ID_SHOW_MINI_ICONS, IconList::onUpdShowMiniIcons),
    FXMAPFUNC(SEL_UPDATE, IconList::ID_SHOW_BIG_ICONS, IconList::onUpdShowBigIcons),
    FXMAPFUNC(SEL_UPDATE, IconList::ID_ARRANGE_BY_ROWS, IconList::onUpdArrangeByRows),
    FXMAPFUNC(SEL_UPDATE, IconList::ID_ARRANGE_BY_COLUMNS, IconList::onUpdArrangeByColumns),
    FXMAPFUNC(SEL_COMMAND, IconList::ID_SHOW_DETAILS, IconList::onCmdShowDetails),
    FXMAPFUNC(SEL_COMMAND, IconList::ID_SHOW_MINI_ICONS, IconList::onCmdShowMiniIcons),
    FXMAPFUNC(SEL_COMMAND, IconList::ID_SHOW_BIG_ICONS, IconList::onCmdShowBigIcons),
    FXMAPFUNC(SEL_COMMAND, IconList::ID_ARRANGE_BY_ROWS, IconList::onCmdArrangeByRows),
    FXMAPFUNC(SEL_COMMAND, IconList::ID_ARRANGE_BY_COLUMNS, IconList::onCmdArrangeByColumns),
    FXMAPFUNC(SEL_COMMAND, IconList::ID_SELECT_ALL, IconList::onCmdselectAll),
    FXMAPFUNC(SEL_COMMAND, IconList::ID_DESELECT_ALL, IconList::onCmdDeselectAll),
    FXMAPFUNC(SEL_COMMAND, IconList::ID_SELECT_INVERSE, IconList::onCmdSelectInverse),
    FXMAPFUNC(SEL_COMMAND, FXWindow::ID_SETVALUE, IconList::onCmdSetValue),
    FXMAPFUNC(SEL_COMMAND, FXWindow::ID_SETINTVALUE, IconList::onCmdSetIntValue),
    FXMAPFUNC(SEL_COMMAND, FXWindow::ID_GETINTVALUE, IconList::onCmdGetIntValue),
    FXMAPFUNC(SEL_COMMAND, IconList::ID_AUTOSIZE, IconList::onCmdToggleAutosize),
    FXMAPFUNC(SEL_UPDATE, IconList::ID_AUTOSIZE, IconList::onUpdToggleAutosize),
    FXMAPFUNC(SEL_COMMAND, IconList::ID_HEADER_CHANGE, IconList::onCmdHeaderClicked),
};


// Object implementation
FXIMPLEMENT(IconList, FXScrollArea, IconListMap, ARRAYNUMBER(IconListMap))



// Icon List
IconList::IconList(FXComposite* p, FXObject* tgt, FXSelector sel, FXuint opts, int x, int y, int w, int h) :
    FXScrollArea(p, opts, x, y, w, h)
{
    flags |= FLAG_ENABLED;

    // Headers look slightly different depending on the control theme
    FXbool use_clearlooks = getApp()->reg().readUnsignedEntry("SETTINGS", "use_clearlooks", true);
    if (use_clearlooks)
    {
        header = new FXHeader(this, this, IconList::ID_HEADER_CHANGE, HEADER_TRACKING|HEADER_BUTTON|HEADER_RESIZE|FRAME_RAISED);
    }
    else
    {
        header = new FXHeader(this, this, IconList::ID_HEADER_CHANGE, HEADER_TRACKING|HEADER_BUTTON|HEADER_RESIZE|FRAME_RAISED|FRAME_THICK);
    }

    target = tgt;
    message = sel;
    nrows = 1;
    ncols = 1;
    anchor = -1;
    current = -1;
    extent = -1;
    cursor = -1;
    viewable = -1;
    font = getApp()->getNormalFont();
    sortfunc = NULL;
    textColor = getApp()->getForeColor();
    selbackColor = getApp()->getSelbackColor();
    seltextColor = getApp()->getSelforeColor();
    highlightColor = getApp()->reg().readColorEntry("SETTINGS", "highlightcolor", FXRGB(238, 238, 238));

    // Sort colors for detailed mode
    FXColor listbackColor = getApp()->reg().readColorEntry("SETTINGS", "listbackcolor", FXRGB(255, 255, 255));
    FXuint  R, G, B;
    R = (FXuint)(DARKEN_SORT*FXREDVAL(listbackColor));
    G = (FXuint)(DARKEN_SORT*FXGREENVAL(listbackColor));
    B = (FXuint)(DARKEN_SORT*FXBLUEVAL(listbackColor));
    sortColor = FXRGB(R, G, B);
    R = (FXuint)(DARKEN_SORT*FXREDVAL(highlightColor));
    G = (FXuint)(DARKEN_SORT*FXGREENVAL(highlightColor));
    B = (FXuint)(DARKEN_SORT*FXBLUEVAL(highlightColor));
    highlightSortColor = FXRGB(R, G, B);

    itemSpace = ITEM_SPACE;
    itemWidth = ITEM_WIDTH;
    itemHeight = ITEM_HEIGHT;
    anchorx = 0;
    anchory = 0;
    currentx = 0;
    currenty = 0;
    grabx = 0;
    graby = 0;
    state = false;
    numsortheader = 0;
    count = 0;
    ignorecase = true;
    initheaderpct = true;
    allowTooltip = true;
}


// Used to resize the headers relatively to the list width
long IconList::onConfigure(FXObject*, FXSelector, void*)
{
    // Obtain the main window width
    int width = (this->getShell())->getWidth();

    // Initialize the relative sizes, skipping the first call
    if (count == 1)
    {
        // Initialize the relative header sizes
        for (int hi = 0; hi < getNumHeaders(); hi++)
        {
            headerpct[hi] = (double)getHeaderSize(hi)/(double)width;
        }
    }

    // Update the relative header sizes
    if (relative_resize && (count >= 1))
    {
        // Initialize the extra header pcts if necessary
        if (initheaderpct && (getNumHeaders() == 9))  // Search list, is it really necessary???
        {
            headerpct[8] = (double)getHeaderSize(8)/(double)width;
            initheaderpct = false;
        }
        if (initheaderpct && (getNumHeaders() == 10))
        {
            headerpct[8] = (double)getHeaderSize(8)/(double)width;
            headerpct[9] = (double)getHeaderSize(9)/(double)width;
            initheaderpct = false;
        }
        int newhsize;
        for (int hi = 0; hi < getNumHeaders(); hi++)
        {
            newhsize = (int)round(headerpct[hi]*width);
            setHeaderSize(hi, newhsize);
        }
    }

    // Update the counter
    if (count <= 2)
    {
        count++;
    }

    return(1);
}


// Create window
inline void IconList::create()
{
    register int i;

    FXScrollArea::create();
    for (i = 0; i < items.no(); i++)
    {
        items[i]->create();
    }
    font->create();
}


// Detach window
inline void IconList::detach()
{
    register int i;

    FXScrollArea::detach();
    for (i = 0; i < items.no(); i++)
    {
        items[i]->detach();
    }
    font->detach();
}


// If window can have focus
inline bool IconList::canFocus() const
{
    return(true);
}


// Into focus chain
inline void IconList::setFocus()
{
    FXScrollArea::setFocus();
    setDefault(true);
}


// Out of focus chain
inline void IconList::killFocus()
{
    FXScrollArea::killFocus();
    setDefault(MAYBE);
}


// Move content
void IconList::moveContents(int x, int y)
{
    int dx = x-pos_x;
    int dy = y-pos_y;
    int top = 0;

    pos_x = x;
    pos_y = y;
    if (!(options&(_ICONLIST_MINI_ICONS|_ICONLIST_BIG_ICONS)))
    {
        top = header->getDefaultHeight();
        header->setPosition(x);
    }
    scroll(0, top, viewport_w, viewport_h, dx, dy);
}


// Propagate size change
inline void IconList::recalc()
{
    FXScrollArea::recalc();
    flags |= FLAG_RECALC;
    cursor = -1;
}


// Recompute interior
void IconList::recompute()
{
    register int w, h, i;

    itemWidth = ITEM_WIDTH;
    itemHeight = ITEM_HEIGHT;

    // Measure the items
    for (i = 0; i < items.no(); i++)
    {
        w = items[i]->getWidth(this);
        h = items[i]->getHeight(this);
        if (w > itemWidth)
        {
            itemWidth = w;
        }
        if (h > itemHeight)
        {
            itemHeight = h;
        }
    }

    // Automatically size item spacing
    if (options&_ICONLIST_AUTOSIZE)
    {
        itemSpace = FXMAX(itemWidth, 1);
    }
    else
    {
        itemSpace = ITEM_SPACE;
    }

    // Adjust for detail mode
    if (!(options&(_ICONLIST_MINI_ICONS|_ICONLIST_BIG_ICONS)))
    {
        itemWidth = header->getDefaultWidth();
    }

    // Get number of rows or columns
    getrowscols(nrows, ncols, width, height);

    // Done
    flags &= ~FLAG_RECALC;
}


// Determine number of columns and number of rows
void IconList::getrowscols(int& nr, int& nc, int w, int h) const
{
    if (options&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS))
    {
        if (options&_ICONLIST_COLUMNS)
        {
            nc = w/itemSpace;
            if (nc < 1)
            {
                nc = 1;
            }
            nr = (items.no()+nc-1)/nc;
            if (nr*itemHeight > h)
            {
                nc = (w-vertical->getDefaultWidth())/itemSpace;
                if (nc < 1)
                {
                    nc = 1;
                }
                nr = (items.no()+nc-1)/nc;
            }
            if (nr < 1)
            {
                nr = 1;
            }
        }
        else
        {
            nr = h/itemHeight;
            if (nr < 1)
            {
                nr = 1;
            }
            nc = (items.no()+nr-1)/nr;
            if (nc*itemSpace > w)
            {
                nr = (h-horizontal->getDefaultHeight())/itemHeight;
                if (nr < 1)
                {
                    nr = 1;
                }
                nc = (items.no()+nr-1)/nr;
            }
            if (nc < 1)
            {
                nc = 1;
            }
        }
    }
    else
    {
        nr = items.no();
        nc = 1;
    }
}


// Size of a possible column caption
inline int IconList::getViewportHeight()
{
    return((options&(_ICONLIST_MINI_ICONS|_ICONLIST_BIG_ICONS)) ? height : height-header->getDefaultHeight());
}


// Determine content width of icon list
int IconList::getContentWidth()
{
    if (flags&FLAG_RECALC)
    {
        recompute();
    }
    if (options&(_ICONLIST_MINI_ICONS|_ICONLIST_BIG_ICONS))
    {
        return(ncols*itemSpace);
    }
    return(header->getDefaultWidth());
}


// Determine content height of icon list
int IconList::getContentHeight()
{
    if (flags&FLAG_RECALC)
    {
        recompute();
    }
    return(nrows*itemHeight);
}


// Recalculate layout
void IconList::layout()
{
    // Update scroll bars
    FXScrollArea::layout();

    // In detail mode
    if (!(options&(_ICONLIST_MINI_ICONS|_ICONLIST_BIG_ICONS)))
    {
        header->position(0, 0, viewport_w, header->getDefaultHeight());
        header->show();
    }
    else
    {
        header->hide();
    }

    // Set line size
    vertical->setLine(itemHeight);
    horizontal->setLine(itemSpace);

    // We were supposed to make this item viewable
    if (0 <= viewable)
    {
        makeItemVisible(viewable);
    }

    // Force repaint
    update();

    flags &= ~FLAG_DIRTY;
}


// Changed size:- this is a bit tricky, because
// we don't want to re-measure the items, but the content
// size has changed because the number of rows/columns has...
void IconList::resize(int w, int h)
{
    int nr = nrows;
    int nc = ncols;

    if ((w != width) || (h != height))
    {
        getrowscols(nrows, ncols, w, h);
        if ((nr != nrows) || (nc != ncols))
        {
            update();
        }
    }
    FXScrollArea::resize(w, h);
}


// Changed size and/or pos:- this is a bit tricky, because
// we don't want to re-measure the items, but the content
// size has changed because the number of rows/columns has...
void IconList::position(int x, int y, int w, int h)
{
    int nr = nrows;
    int nc = ncols;

    if ((w != width) || (h != height))
    {
        getrowscols(nrows, ncols, w, h);
        if ((nr != nrows) || (nc != ncols))
        {
            update();
        }
    }
    FXScrollArea::position(x, y, w, h);
}


// A header button was clicked : pass the message to the target
inline long IconList::onCmdHeaderClicked(FXObject*, FXSelector, void* ptr)
{
    if (target && target->tryHandle(this, FXSEL(SEL_COMMAND, message), ptr))
    {
    }
    return(1);
}


// Header subdivision has changed:- this is a bit tricky,
// we want to update the content size w/o re-measuring the items...
long IconList::onHeaderChanged(FXObject*, FXSelector, void* ptr)
{
    // Obtain the main window width
    int width = (this->getShell())->getWidth();

    // Update the header relative sizes
    for (int hi = 0; hi < getNumHeaders(); hi++)
    {
        headerpct[hi] = (double)getHeaderSize(hi)/(double)width;
    }

    flags &= ~FLAG_RECALC;
    return(1);
}


// Header subdivision resize has been requested;
// we want to set the width of the header column
// to that of the widest item.
long IconList::onHeaderResize(FXObject*, FXSelector, void* ptr)
{
    register int hi = (int)(FXival)ptr;
    register int i, iw, tw, w, nw = 0;
    FXString     text;

    // For detailed icon list
    if (!(options&(_ICONLIST_MINI_ICONS|_ICONLIST_BIG_ICONS)))
    {
        for (i = 0; i < items.no(); i++)
        {
            w = 0;

            // The first header item may have an icon
            if (hi == 0)
            {
                if (items[i]->miniIcon)
                {
                    iw = items[i]->miniIcon->getWidth();
                    w += iw+DETAIL_TEXT_SPACING+SIDE_SPACING/2;
                }
            }

            // Measure section of text
            text = items[i]->label.section('\t', hi);
            if (!text.empty())
            {
                tw = font->getTextWidth(text.text(), text.length());
                w += tw+SIDE_SPACING+2;
            }

            // Keep the max
            if (w > nw)
            {
                nw = w;
            }
        }

        // Set new header width
        if ((nw > 0) && (nw != header->getItemSize(hi)))
        {
            header->setItemSize(hi, nw);
            flags &= ~FLAG_RECALC;
        }
    }
    return(1);
}


// Set headers from array of strings
inline void IconList::setHeaders(const char** strings, int size)
{
    header->clearItems();
    header->fillItems(strings, NULL, size);
}


// Set headers from newline separated strings
inline void IconList::setHeaders(const FXString& strings, int size)
{
    header->clearItems();
    header->fillItems(strings, NULL, size);
}


// Append header caption
void IconList::appendHeader(const FXString& text, FXIcon* icon, int size)
{
    header->appendItem(text, icon, size);
}


// Remove header caption
void IconList::removeHeader(int index)
{
    if ((index < 0) || (header->getNumItems() <= index))
    {
        fprintf(stderr, "%s::removeHeader: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    header->removeItem(index);
}


// Change header caption
void IconList::setHeaderText(int index, const FXString& text)
{
    if ((index < 0) || (header->getNumItems() <= index))
    {
        fprintf(stderr, "%s::setHeaderText: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    header->setItemText(index, text);
}


// Get header caption
FXString IconList::getHeaderText(int index) const
{
    if ((index < 0) || (header->getNumItems() <= index))
    {
        fprintf(stderr, "%s::getHeaderText: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return(header->getItemText(index));
}


// Change header icon
void IconList::setHeaderIcon(int index, FXIcon* icon)
{
    if ((index < 0) || (header->getNumItems() <= index))
    {
        fprintf(stderr, "%s::setHeaderIcon: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    header->setItemIcon(index, icon);
}


// Get header icon
FXIcon* IconList::getHeaderIcon(int index) const
{
    if ((index < 0) || (header->getNumItems() <= index))
    {
        fprintf(stderr, "%s::getHeaderIcon: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return(header->getItemIcon(index));
}


// Change header size
void IconList::setHeaderSize(int index, int size)
{
    if ((index < 0) || (header->getNumItems() <= index))
    {
        fprintf(stderr, "%s::setHeaderSize: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    header->setItemSize(index, size);
}


// Get header size
int IconList::getHeaderSize(int index) const
{
    if ((index < 0) || (header->getNumItems() <= index))
    {
        fprintf(stderr, "%s::getHeaderSize: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return(header->getItemSize(index));
}


// Return number of headers
int IconList::getNumHeaders() const
{
    return(header->getNumItems());
}


// Change item text
void IconList::setItemText(int index, const FXString& text)
{
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::setItemText: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    if (items[index]->getText() != text)
    {
        items[index]->setText(text);
        recalc();
    }
}


// Get item text
FXString IconList::getItemText(int index) const
{
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::getItemText: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return(items[index]->getText());
}


// Set item icon
void IconList::setItemBigIcon(int index, FXIcon* icon, FXbool owned)
{
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::setItemBigIcon: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    if (items[index]->getBigIcon() != icon)
    {
        recalc();
    }
    items[index]->setBigIcon(icon, owned);
}


// Get item icon
FXIcon* IconList::getItemBigIcon(int index) const
{
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::getItemBigIcon: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return(items[index]->getBigIcon());
}


// Set item icon
void IconList::setItemMiniIcon(int index, FXIcon* icon, FXbool owned)
{
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::setItemMiniIcon: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    if (items[index]->getMiniIcon() != icon)
    {
        recalc();
    }
    items[index]->setMiniIcon(icon, owned);
}


// Get item icon
FXIcon* IconList::getItemMiniIcon(int index) const
{
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::getItemMiniIcon: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return(items[index]->getMiniIcon());
}


// Set item data
void IconList::setItemData(int index, void* ptr)
{
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::setItemData: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    items[index]->setData(ptr);
}


// Get item data
void* IconList::getItemData(int index) const
{
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::getItemData: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return(items[index]->getData());
}


// True if item is current
FXbool IconList::isItemCurrent(int index) const
{
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::isItemCurrent: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return(index == current);
}


// True if item is enabled
FXbool IconList::isItemEnabled(int index) const
{
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::isItemEnabled: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return(items[index]->isEnabled());
}


// True if item (partially) visible
FXbool IconList::isItemVisible(int index) const
{
    register FXbool vis = false;
    register int    x, y, hh;

    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::isItemVisible: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    if (options&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS))
    {
        if (options&_ICONLIST_COLUMNS)
        {
            FXASSERT(ncols > 0);
            x = pos_x+itemSpace*(index%ncols);
            y = pos_y+itemHeight*(index/ncols);
        }
        else
        {
            FXASSERT(nrows > 0);
            x = pos_x+itemSpace*(index/nrows);
            y = pos_y+itemHeight*(index%nrows);
        }
        if ((0 < x+itemSpace) && (x < viewport_w) && (0 < y+itemHeight) && (y < viewport_h))
        {
            vis = true;
        }
    }
    else
    {
        hh = header->getDefaultHeight();
        y = pos_y+hh+index*itemHeight;
        if ((hh < y+itemHeight) && (y < viewport_h))
        {
            vis = true;
        }
    }
    return(vis);
}


// Make item fully visible
void IconList::makeItemVisible(int index)
{
    register int x, y, hh, px, py;

    if ((0 <= index) && (index < items.no()))
    {
        // Remember for later
        viewable = index;

        // Was realized
        if (xid)
        {
            // Force layout if dirty
            if (flags&FLAG_RECALC)
            {
                layout();
            }

            px = pos_x;
            py = pos_y;

            // Showing icon view
            if (options&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS))
            {
                if (options&_ICONLIST_COLUMNS)
                {
                    FXASSERT(ncols > 0);
                    x = itemSpace*(index%ncols);
                    y = itemHeight*(index/ncols);
                }
                else
                {
                    FXASSERT(nrows > 0);
                    x = itemSpace*(index/nrows);
                    y = itemHeight*(index%nrows);
                }
                if (px+x+itemSpace >= viewport_w)
                {
                    px = viewport_w-x-itemSpace;
                }
                if (px+x <= 0)
                {
                    px = -x;
                }
                if (py+y+itemHeight >= viewport_h)
                {
                    py = viewport_h-y-itemHeight;
                }
                if (py+y <= 0)
                {
                    py = -y;
                }
            }

            // Showing list view
            else
            {
                hh = header->getDefaultHeight();
                y = hh+index*itemHeight;
                if (py+y+itemHeight >= viewport_h+hh)
                {
                    py = hh+viewport_h-y-itemHeight;
                }
                if (py+y <= hh)
                {
                    py = hh-y;
                }
            }

            // Scroll into view
            setPosition(px, py);

            // Done it
            viewable = -1;
        }
    }
}


// Hack to avoid displaying the allowTooltip in detailed mode when the mouse is not on the first column
// Get item at position x,y
//int IconList::getItemAt(int x,int y) const
int IconList::getItemAt(int x, int y)
{
    register int ix, iy;
    register int r, c, index;

    y -= pos_y;
    x -= pos_x;

    // Update the allowTooltip variable
    allowTooltip = true;
    if (options&_ICONLIST_STANDARD)
    {
        allowTooltip = false;
    }

    if (!(options&_ICONLIST_STANDARD) && (single_click == SINGLE_CLICK_DIR_FILE))
    {
        // Don't change cursor while the wait cursor is displayed
        if (::setWaitCursor(getApp(), QUERY_CURSOR) == 0)
        {
            setDefaultCursor(getApp()->getDefaultCursor(DEF_HAND_CURSOR));
        }
    }

    if (options&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS))
    {
        c = x/itemSpace;
        r = y/itemHeight;

        if ((c < 0) || (c >= ncols) || (r < 0) || (r >= nrows))
        {
            return(-1);
        }

        index = (options&_ICONLIST_COLUMNS) ? ncols*r+c : nrows*c+r;

        if ((index < 0) || (index >= items.no()))
        {
            return(-1);
        }

        ix = itemSpace*c;
        iy = itemHeight*r;

        if (items[index]->hitItem(this, x-ix, y-iy) == 0)
        {
            return(-1);
        }
    }
    else
    {
        // Update the allowTooltip variable
        if ((x == 0) || (x > header->getItemSize(0)))
        {
            allowTooltip = false;

            // Don't change cursor while the wait cursor is displayed
            if (::setWaitCursor(getApp(), QUERY_CURSOR) == 0)
            {
                setDefaultCursor(getApp()->getDefaultCursor(DEF_ARROW_CURSOR));
            }
        }

        y -= header->getDefaultHeight();
        c = 0;
        index = y/itemHeight;


        if ((index < 0) || (index >= items.no()))
        {
            return(-1);
        }
    }
    return(index);
}


// Compare strings up to n
static int comp(const FXString& s1, const FXString& s2, int n)
{
    register const FXuchar* p1 = (const FXuchar*)s1.text();
    register const FXuchar* p2 = (const FXuchar*)s2.text();
    register int            c1, c2;

    if (0 < n)
    {
        do
        {
            c1 = *p1++;
            if (c1 == '\t')
            {
                c1 = 0;
            }
            c2 = *p2++;
            if (c2 == '\t')
            {
                c2 = 0;
            }
        } while (--n && c1 && (c1 == c2));
        return(c1-c2);
    }
    return(0);
}


// Compare strings case insensitive up to n
static int compcase(const FXString& s1, const FXString& s2, int n)
{
    register const FXuchar* p1 = (const FXuchar*)s1.text();
    register const FXuchar* p2 = (const FXuchar*)s2.text();
    register int            c1, c2;

    if (0 < n)
    {
        do
        {
            c1 = Ascii::toLower(*p1++);
            if (c1 == '\t')
            {
                c1 = 0;     // FIXME UTF8 version
            }
            c2 = Ascii::toLower(*p2++);
            if (c2 == '\t')
            {
                c2 = 0;
            }
        } while (--n && c1 && (c1 == c2));
        return(c1-c2);
    }
    return(0);
}


typedef int (*FXCompareFunc)(const FXString&, const FXString&, int);


// Get item by name
int IconList::findItem(const FXString& text, int start, FXuint flgs) const
{
    register FXCompareFunc comparefunc;
    register int           index, len;

    if (0 < items.no())
    {
        comparefunc = (flgs&SEARCH_IGNORECASE) ? (FXCompareFunc)compcase : (FXCompareFunc)comp;
        len = (flgs&SEARCH_PREFIX) ? text.length() : 2147483647;
        if (flgs&SEARCH_BACKWARD)
        {
            if (start < 0)
            {
                start = items.no()-1;
            }
            for (index = start; 0 <= index; index--)
            {
                if ((*comparefunc)(items[index]->getText(), text, len) == 0)
                {
                    return(index);
                }
            }
            if (!(flgs&SEARCH_WRAP))
            {
                return(-1);
            }
            for (index = items.no()-1; start < index; index--)
            {
                if ((*comparefunc)(items[index]->getText(), text, len) == 0)
                {
                    return(index);
                }
            }
        }
        else
        {
            if (start < 0)
            {
                start = 0;
            }
            for (index = start; index < items.no(); index++)
            {
                if ((*comparefunc)(items[index]->getText(), text, len) == 0)
                {
                    return(index);
                }
            }
            if (!(flgs&SEARCH_WRAP))
            {
                return(-1);
            }
            for (index = 0; index < start; index++)
            {
                if ((*comparefunc)(items[index]->getText(), text, len) == 0)
                {
                    return(index);
                }
            }
        }
    }
    return(-1);
}


// Get item by data
int IconList::findItemByData(const void* ptr, int start, FXuint flgs) const
{
    register int index;

    if (0 < items.no())
    {
        if (flgs&SEARCH_BACKWARD)
        {
            if (start < 0)
            {
                start = items.no()-1;
            }
            for (index = start; 0 <= index; index--)
            {
                if (items[index]->getData() == ptr)
                {
                    return(index);
                }
            }
            if (!(flgs&SEARCH_WRAP))
            {
                return(-1);
            }
            for (index = items.no()-1; start < index; index--)
            {
                if (items[index]->getData() == ptr)
                {
                    return(index);
                }
            }
        }
        else
        {
            if (start < 0)
            {
                start = 0;
            }
            for (index = start; index < items.no(); index++)
            {
                if (items[index]->getData() == ptr)
                {
                    return(index);
                }
            }
            if (!(flgs&SEARCH_WRAP))
            {
                return(-1);
            }
            for (index = 0; index < start; index++)
            {
                if (items[index]->getData() == ptr)
                {
                    return(index);
                }
            }
        }
    }
    return(-1);
}


// Did we hit the item, and which part of it did we hit
int IconList::hitItem(int index, int x, int y, int ww, int hh) const
{
    int ix, iy, r, c, hit = 0;

    if ((0 <= index) && (index < items.no()))
    {
        x -= pos_x;
        y -= pos_y;
        if (!(options&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS)))
        {
            y -= header->getDefaultHeight();
        }
        if (options&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS))
        {
            if (options&_ICONLIST_COLUMNS)
            {
                r = index/ncols;
                c = index%ncols;
            }
            else
            {
                c = index/nrows;
                r = index%nrows;
            }
        }
        else
        {
            r = index;
            c = 0;
        }
        ix = itemSpace*c;
        iy = itemHeight*r;
        hit = items[index]->hitItem(this, x-ix, y-iy, ww, hh);
    }
    return(hit);
}


// Repaint
void IconList::updateItem(int index) const
{
    if (xid && (0 <= index) && (index < items.no()))
    {
        if (options&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS))
        {
            if (options&_ICONLIST_COLUMNS)
            {
                FXASSERT(ncols > 0);
                update(pos_x+itemSpace*(index%ncols), pos_y+itemHeight*(index/ncols), itemSpace, itemHeight);
            }
            else
            {
                FXASSERT(nrows > 0);
                update(pos_x+itemSpace*(index/nrows), pos_y+itemHeight*(index%nrows), itemSpace, itemHeight);
            }
        }
        else
        {
            update(0, pos_y+header->getDefaultHeight()+index*itemHeight, width, itemHeight);
        }
    }
}


// Enable one item
FXbool IconList::enableItem(int index)
{
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::enableItem: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    if (!items[index]->isEnabled())
    {
        items[index]->setEnabled(true);
        updateItem(index);
        return(true);
    }
    return(false);
}


// Disable one item
FXbool IconList::disableItem(int index)
{
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::disableItem: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    if (items[index]->isEnabled())
    {
        items[index]->setEnabled(false);
        updateItem(index);
        return(true);
    }
    return(false);
}


// Select one item
FXbool IconList::selectItem(int index, FXbool notify)
{

    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::selectItem: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    if (!items[index]->isSelected())
    {

        switch (options&SELECT_MASK)
        {
        case _ICONLIST_SINGLESELECT:
        case _ICONLIST_BROWSESELECT:
            
           killSelection(notify);

        case _ICONLIST_EXTENDEDSELECT:
        case _ICONLIST_MULTIPLESELECT:
            items[index]->setSelected(true);
            updateItem(index);
            if (notify && target)
            {
                target->tryHandle(this, FXSEL(SEL_SELECTED, message), (void*)(FXival)index);
            }
            break;
        }
        return(true);
    }
    return(false);
}


// Deselect one item
FXbool IconList::deselectItem(int index, FXbool notify)
{
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::deselectItem: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    if (items[index]->isSelected())
    {
        switch (options&SELECT_MASK)
        {
        case _ICONLIST_EXTENDEDSELECT:
        case _ICONLIST_MULTIPLESELECT:
        case _ICONLIST_SINGLESELECT:
            items[index]->setSelected(false);
            updateItem(index);
            if (notify && target)
            {
                target->tryHandle(this, FXSEL(SEL_DESELECTED, message), (void*)(FXival)index);
            }
            break;
        }
        return(true);
    }
    return(false);
}


// Toggle one item
FXbool IconList::toggleItem(int index, FXbool notify)
{
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::toggleItem: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    switch (options&SELECT_MASK)
    {
    case _ICONLIST_BROWSESELECT:
        if (!items[index]->isSelected())
        {
            killSelection(notify);
            items[index]->setSelected(true);
            updateItem(index);
            if (notify && target)
            {
                target->tryHandle(this, FXSEL(SEL_SELECTED, message), (void*)(FXival)index);
            }
        }
        break;

    case _ICONLIST_SINGLESELECT:
        if (!items[index]->isSelected())
        {
            killSelection(notify);
            items[index]->setSelected(true);
            updateItem(index);
            if (notify && target)
            {
                target->tryHandle(this, FXSEL(SEL_SELECTED, message), (void*)(FXival)index);
            }
        }
        else
        {
            items[index]->setSelected(false);
            updateItem(index);
            if (notify && target)
            {
                target->tryHandle(this, FXSEL(SEL_DESELECTED, message), (void*)(FXival)index);
            }
        }
        break;

    case _ICONLIST_EXTENDEDSELECT:
    case _ICONLIST_MULTIPLESELECT:
        if (!items[index]->isSelected())
        {
            items[index]->setSelected(true);
            updateItem(index);
            if (notify && target)
            {
                target->tryHandle(this, FXSEL(SEL_SELECTED, message), (void*)(FXival)index);
            }
        }
        else
        {
            items[index]->setSelected(false);
            updateItem(index);
            if (notify && target)
            {
                target->tryHandle(this, FXSEL(SEL_DESELECTED, message), (void*)(FXival)index);
            }
        }
        break;
    }
    return(true);
}


// Select items in rectangle
FXbool IconList::selectInRectangle(int x, int y, int w, int h, FXbool notify)
{
    register int    r, c, index;
    register FXbool changed = false;

    if (options&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS))
    {
        for (r = 0; r < nrows; r++)
        {
            for (c = 0; c < ncols; c++)
            {
                index = (options&_ICONLIST_COLUMNS) ? ncols*r+c : nrows*c+r;
                if (index < items.no())
                {
                    if (hitItem(index, x, y, w, h))
                    {
                        changed |= selectItem(index, notify);
                    }
                }
            }
        }
    }
    else
    {
        for (index = 0; index < items.no(); index++)
        {
            if (hitItem(index, x, y, w, h))
            {
                changed |= selectItem(index, notify);
            }
        }
    }
    return(changed);
}


// Extend selection
FXbool IconList::extendSelection(int index, FXbool notify)
{
    register FXbool changes = false;
    int             i1, i2, i3, i;

    if ((0 <= index) && (0 <= anchor) && (0 <= extent))
    {
        // Find segments
        i1 = index;
        if (anchor < i1)
        {
            i2 = i1;
            i1 = anchor;
        }
        else
        {
            i2 = anchor;
        }
        if (extent < i1)
        {
            i3 = i2;
            i2 = i1;
            i1 = extent;
        }
        else if (extent < i2)
        {
            i3 = i2;
            i2 = extent;
        }
        else
        {
            i3 = extent;
        }

        // First segment
        for (i = i1; i < i2; i++)
        {
            // item===extent---anchor
            // item===anchor---extent
            if (i1 == index)
            {
                if (!items[i]->isSelected())
                {
                    items[i]->setSelected(true);
                    updateItem(i);
                    changes = true;
                    if (notify && target)
                    {
                        target->tryHandle(this, FXSEL(SEL_SELECTED, message), (void*)(FXival)i);
                    }
                }
            }

            // extent===anchor---item
            // extent===item-----anchor
            else if (i1 == extent)
            {
                if (items[i]->isSelected())
                {
                    items[i]->setSelected(false);
                    updateItem(i);
                    changes = true;
                    if (notify && target)
                    {
                        target->tryHandle(this, FXSEL(SEL_DESELECTED, message), (void*)(FXival)i);
                    }
                }
            }
        }

        // Second segment
        for (i = i2+1; i <= i3; i++)
        {
            // extent---anchor===item
            // anchor---extent===item
            if (i3 == index)
            {
                if (!items[i]->isSelected())
                {
                    items[i]->setSelected(true);
                    updateItem(i);
                    changes = true;
                    if (notify && target)
                    {
                        target->tryHandle(this, FXSEL(SEL_SELECTED, message), (void*)(FXival)i);
                    }
                }
            }

            // item-----anchor===extent
            // anchor---item=====extent
            else if (i3 == extent)
            {
                if (items[i]->isSelected())
                {
                    items[i]->setSelected(false);
                    updateItem(i);
                    changes = true;
                    if (notify && target)
                    {
                        target->tryHandle(this, FXSEL(SEL_DESELECTED, message), (void*)(FXival)i);
                    }
                }
            }
        }
        extent = index;
    }
    return(changes);
}


// Kill selection
FXbool IconList::killSelection(FXbool notify)
{
    register FXbool changes = false;
    register int    i;

    for (i = 0; i < items.no(); i++)
    {
        if (items[i]->isSelected())
        {
            items[i]->setSelected(false);
            updateItem(i);
            changes = true;
            if (notify && target)
            {
                target->tryHandle(this, FXSEL(SEL_DESELECTED, message), (void*)(FXival)i);
            }
        }
    }
    return(changes);
}


// Lasso changed, so select/unselect items based on difference between new and old lasso box
void IconList::lassoChanged(int ox, int oy, int ow, int oh, int nx, int ny, int nw, int nh, FXbool notify)
{
    register int r, c;
    int          ohit, nhit, index;

    if (options&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS))
    {
        for (r = 0; r < nrows; r++)
        {
            for (c = 0; c < ncols; c++)
            {
                index = (options&_ICONLIST_COLUMNS) ? ncols*r+c : nrows*c+r;
                if (index < items.no())
                {
                    ohit = hitItem(index, ox, oy, ow, oh);
                    nhit = hitItem(index, nx, ny, nw, nh);
                    if (ohit && !nhit)      // In old rectangle and not in new rectangle
                    {
                        deselectItem(index, notify);
                    }
                    else if (!ohit && nhit) // Not in old rectangle and in new rectangle
                    {
                        selectItem(index, notify);
                    }
                }
            }
        }
    }
    else
    {
        for (index = 0; index < items.no(); index++)
        {
            ohit = hitItem(index, ox, oy, ow, oh);
            nhit = hitItem(index, nx, ny, nw, nh);
            if (ohit && !nhit)          // Was in old, not in new
            {
                deselectItem(index, notify);
            }
            else if (!ohit && nhit)     // Not in old, but in new
            {
                selectItem(index, notify);
            }
        }
    }
}


// Update value from a message
long IconList::onCmdSetValue(FXObject*, FXSelector, void* ptr)
{
    setCurrentItem((int)(FXival)ptr);
    return(1);
}


// Obtain value from list
long IconList::onCmdGetIntValue(FXObject*, FXSelector, void* ptr)
{
    *((int*)ptr) = getCurrentItem();
    return(1);
}


// Update value from a message
long IconList::onCmdSetIntValue(FXObject*, FXSelector, void* ptr)
{
    setCurrentItem(*((int*)ptr));
    return(1);
}


// Start motion timer while in this window
long IconList::onEnter(FXObject* sender, FXSelector sel, void* ptr)
{
    FXScrollArea::onEnter(sender, sel, ptr);
    getApp()->addTimeout(this, ID_TIPTIMER, getApp()->getMenuPause());
    cursor = -1;
    return(1);
}


// Stop motion timer when leaving window
long IconList::onLeave(FXObject* sender, FXSelector sel, void* ptr)
{
    FXScrollArea::onLeave(sender, sel, ptr);
    getApp()->removeTimeout(this, ID_TIPTIMER);
    cursor = -1;
    return(1);
}


// We timed out, i.e. the user didn't move for a while
long IconList::onTipTimer(FXObject*, FXSelector, void*)
{
    flags |= FLAG_TIP;
    return(1);
}


// Hack to display more informations in the tool tip
long IconList::onQueryTip(FXObject* sender, FXSelector sel, void* ptr)
{
    if (FXWindow::onQueryTip(sender, sel, ptr))
    {
        return(1);
    }

    // File tooltips are optional
    if (file_tooltips)
    {
        // In detailed mode, avoid displaying the tooltip when the mouse is not on the first column
        if (allowTooltip && (flags&FLAG_TIP) && (0 <= cursor))
        {
            FXString string;

            // Get the item text
            FXString str = items[cursor]->getText();

            // Add name, size, type, permissions, etc. to the tool tip
            FXString name = str.section('\t', 0);
            FXString size = str.section('\t', 1);
            FXString type = str.section('\t', 2);
            FXString date = str.section('\t', 4);
            FXString user = str.section('\t', 5);
            FXString group = str.section('\t', 6);
            FXString perms = str.section('\t', 7);
            FXString origpath = str.section('\t', 8);
            FXString deldate = str.section('\t', 9);
            FXString pathname = str.section('\t', 10);

            // Don't display tooltip for the dotdot directory
            if (name == "..")
            {
                string = "";
            }
            else
            {
                // Folder or mount point
                if ((type == _("Folder")) || (type == _("Mount point")))
                {
                    // Compute root file size
                    FXulong dnsize;
                    char    dsize[64];
                    dnsize = ::dirsize(pathname.text());
#if __WORDSIZE == 64
                    snprintf(dsize, sizeof(dsize)-1, "%lu", dnsize);
#else
                    snprintf(dsize, sizeof(dsize)-1, "%llu", dnsize);
#endif
                    size = ::hSize(dsize);

                    if (deldate.empty())
                    {
                        string = _("Name: ")+name+"\n"+_("Size in root: ")+size+"\n"+_("Type: ")+type+"\n"
                                 +_("Modified date: ")+date+"\n"+_("User: ")+user+" - "+_("Group: ")+group+"\n"
                                 +_("Permissions: ")+perms;
                    }
                    else
                    {
                        string = _("Name: ")+name+"\n"+
                                 +_("Original path: ")+origpath+"\n"
                                 +_("Size in root: ")+size+"\n"+_("Type: ")+type+"\n"
                                 +_("Modified date: ")+date+"\n"
                                 +_("Deletion date: ")+deldate+"\n"
                                 +_("User: ")+user+" - "+_("Group: ")+group+"\n"+_("Permissions: ")+perms;
                    }
                }
                // Regular file
                else
                {
                    if (deldate.empty())
                    {
                        string = _("Name: ")+name+"\n"+_("Size: ")+size+"\n"+_("Type: ")+type+"\n"
                                 +_("Modified date: ")+date+"\n"+_("User: ")+user+" - "+_("Group: ")+group
                                 +"\n"+_("Permissions: ")+perms;
                    }
                    else
                    {
                        string = _("Name: ")+name+"\n"+
                                 +_("Original path: ")+origpath+"\n"
                                 +_("Size: ")+size+"\n"+_("Type: ")+type
                                 +"\n"+_("Modified date: ")+date+"\n"
                                 +_("Deletion date: ")+deldate+"\n"
                                 +_("User: ")+user+" - "+_("Group: ")+group+"\n"+_("Permissions: ")+perms;
                    }
                }
            }
            sender->handle(this, FXSEL(SEL_COMMAND, ID_SETSTRINGVALUE), (void*)&string);
            return(1);
        }
        else if (!allowTooltip)
        {
            // Don't change cursor while the wait cursor is displayed
            if (::setWaitCursor(getApp(), QUERY_CURSOR) == 0)
            {
                setDefaultCursor(getApp()->getDefaultCursor(DEF_ARROW_CURSOR));
            }
        }
    }

    return(0);
}


// We were asked about status text
long IconList::onQueryHelp(FXObject* sender, FXSelector sel, void* ptr)
{
    if (FXWindow::onQueryHelp(sender, sel, ptr))
    {
        return(1);
    }
    if ((flags&FLAG_HELP) && !help.empty())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_SETSTRINGVALUE), (void*)&help);
        return(1);
    }
    return(0);
}


// Gained focus
long IconList::onFocusIn(FXObject* sender, FXSelector sel, void* ptr)
{
    FXScrollArea::onFocusIn(sender, sel, ptr);
    if (0 <= current)
    {
        FXASSERT(current < items.no());
        items[current]->setFocus(true);
        updateItem(current);
    }
    return(1);
}


// Lost focus
long IconList::onFocusOut(FXObject* sender, FXSelector sel, void* ptr)
{
    FXScrollArea::onFocusOut(sender, sel, ptr);
    if (0 <= current)
    {
        FXASSERT(current < items.no());
        items[current]->setFocus(false);
        updateItem(current);
    }
    return(1);
}


// Draw item list
long IconList::onPaint(FXObject*, FXSelector, void* ptr)
{	
    register int rlo, rhi, clo, chi, yy, xx;
    register int x, y, r, c, index;
    FXEvent*     event = (FXEvent*)ptr;
    FXDCWindow   dc(this, event);

	// Only draw the rectangle background if item height hasn't been computed yet
	// This avoids an ugly transient drawing on older hardware
	if (itemHeight == ITEM_HEIGHT)
	{
        dc.setForeground(backColor);
        dc.fillRectangle(event->rect.x, event->rect.y, event->rect.w, event->rect.h);

		return (0);
	}

    // Set font
    dc.setFont(font);

    // Icon mode
    if (options&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS))
    {
        // Exposed rows
        rlo = (event->rect.y-pos_y)/itemHeight;
        rhi = (event->rect.y+event->rect.h-pos_y)/itemHeight;
        if (rlo < 0)
        {
            rlo = 0;
        }
        if (rhi >= nrows)
        {
            rhi = nrows-1;
        }

        // Exposed columns
        clo = (event->rect.x-pos_x)/itemSpace;
        chi = (event->rect.x+event->rect.w-pos_x)/itemSpace;
        if (clo < 0)
        {
            clo = 0;
        }
        if (chi >= ncols)
        {
            chi = ncols-1;
        }

        // Big Icons
        if (options&_ICONLIST_BIG_ICONS)
        {
            for (r = rlo; r <= rhi; r++)
            {
                y = pos_y+r*itemHeight;
                for (c = clo; c <= chi; c++)
                {
                    x = pos_x+c*itemSpace;
                    index = (options&_ICONLIST_COLUMNS) ? ncols*r+c : nrows*c+r;
                    dc.setForeground(backColor);
                    dc.fillRectangle(x, y, itemSpace, itemHeight);
                    if (index < items.no())
                    {
                        items[index]->draw(this, dc, x, y, itemSpace, itemHeight);
                    }
                }
            }
        }

        // Mini icons
        else
        {
            for (r = rlo; r <= rhi; r++)
            {
                y = pos_y+r*itemHeight;
                for (c = clo; c <= chi; c++)
                {
                    x = pos_x+c*itemSpace;
                    index = (options&_ICONLIST_COLUMNS) ? ncols*r+c : nrows*c+r;
                    dc.setForeground(backColor);
                    dc.fillRectangle(x, y, itemSpace, itemHeight);
                    if (index < items.no())
                    {
                        items[index]->draw(this, dc, x, y, itemSpace, itemHeight);
                    }
                }
            }
        }

        // Repaint left-over background
        yy = (rhi+1)*itemHeight;
        if (yy < event->rect.y+event->rect.h)
        {
            dc.setForeground(backColor);
            dc.fillRectangle(event->rect.x, yy, event->rect.w, event->rect.y+event->rect.h-yy);
        }
        xx = (chi+1)*itemSpace;
        if (xx < event->rect.x+event->rect.w)
        {
            dc.setForeground(backColor);
            dc.fillRectangle(xx, event->rect.y, event->rect.x+event->rect.w-xx, event->rect.h);
        }
    }

    // Detailed mode
    else
    {
        // Exposed rows
        rlo = (event->rect.y-pos_y-header->getDefaultHeight())/itemHeight;
        rhi = (event->rect.y+event->rect.h-pos_y-header->getDefaultHeight())/itemHeight;
        if (rlo < 0)
        {
            rlo = 0;
        }
        if (rhi >= items.no())
        {
            rhi = items.no()-1;
        }

        // Repaint the items
        y = pos_y+rlo*itemHeight+header->getDefaultHeight();
        for (index = rlo; index <= rhi; index++, y += itemHeight)
        {
            dc.setForeground(backColor);
            dc.fillRectangle(0, y, width, itemHeight);
            items[index]->draw(this, dc, pos_x, y, width, itemHeight);
        }

        // Repaint left-over background
        if (y < event->rect.y+event->rect.h)
        {
            dc.setForeground(backColor);
            dc.fillRectangle(event->rect.x, y, event->rect.w, event->rect.y+event->rect.h-y);
        }
    }

    return(1);
}


// Draw Lasso rectangle
void IconList::drawLasso(int x0, int y0, int x1, int y1)
{
    FXDCWindow dc(this);

    dc.setFunction(BLT_NOT_DST);
    x0 += pos_x;
    x1 += pos_x;
    y0 += pos_y;
    y1 += pos_y;
    dc.drawLine(x0, y0, x1, y0);
    dc.drawLine(x1, y0, x1, y1);
    dc.drawLine(x1, y1, x0, y1);
    dc.drawLine(x0, y1, x0, y0);
}


// Arrange by rows
long IconList::onCmdArrangeByRows(FXObject*, FXSelector, void*)
{
    options &= ~_ICONLIST_COLUMNS;
    recalc();
    return(1);
}


// Update sender
long IconList::onUpdArrangeByRows(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (options&_ICONLIST_COLUMNS) ? FXSEL(SEL_COMMAND, ID_UNCHECK) : FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    sender->handle(this, (options&(_ICONLIST_MINI_ICONS|_ICONLIST_BIG_ICONS)) ? FXSEL(SEL_COMMAND, ID_ENABLE) : FXSEL(SEL_COMMAND, ID_DISABLE), NULL);
    return(1);
}


// Arrange by columns
long IconList::onCmdArrangeByColumns(FXObject*, FXSelector, void*)
{
    options |= _ICONLIST_COLUMNS;
    recalc();
    return(1);
}


// Update sender
long IconList::onUpdArrangeByColumns(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (options&_ICONLIST_COLUMNS) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    sender->handle(this, (options&(_ICONLIST_MINI_ICONS|_ICONLIST_BIG_ICONS)) ? FXSEL(SEL_COMMAND, ID_ENABLE) : FXSEL(SEL_COMMAND, ID_DISABLE), NULL);
    return(1);
}


// Toggle autosize items
long IconList::onCmdToggleAutosize(FXObject*, FXSelector, void*)
{
    if (options&_ICONLIST_AUTOSIZE)
    {
        options &= ~_ICONLIST_AUTOSIZE;
    }
    else
    {
        options |= _ICONLIST_AUTOSIZE;
    }
    recalc();
    return(1);
}


// Update sender
long IconList::onUpdToggleAutosize(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (options&_ICONLIST_AUTOSIZE) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    sender->handle(this, (options&(_ICONLIST_MINI_ICONS|_ICONLIST_BIG_ICONS)) ? FXSEL(SEL_COMMAND, ID_ENABLE) : FXSEL(SEL_COMMAND, ID_DISABLE), NULL);
    return(1);
}


// Show detailed list
long IconList::onCmdShowDetails(FXObject*, FXSelector, void*)
{
    options &= ~_ICONLIST_MINI_ICONS;
    options &= ~_ICONLIST_BIG_ICONS;
    recalc();
    return(1);
}


// Update sender
long IconList::onUpdShowDetails(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (options&(_ICONLIST_MINI_ICONS|_ICONLIST_BIG_ICONS)) ? FXSEL(SEL_COMMAND, ID_UNCHECK) : FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    return(1);
}


// Show big icons
long IconList::onCmdShowBigIcons(FXObject*, FXSelector, void*)
{
    options &= ~_ICONLIST_MINI_ICONS;
    options |= _ICONLIST_BIG_ICONS;
    recalc();
    return(1);
}


// Update sender
long IconList::onUpdShowBigIcons(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (options&_ICONLIST_BIG_ICONS) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    return(1);
}


// Show small icons
long IconList::onCmdShowMiniIcons(FXObject*, FXSelector, void*)
{
    options |= _ICONLIST_MINI_ICONS;
    options &= ~_ICONLIST_BIG_ICONS;
    recalc();
    return(1);
}


// Update sender
long IconList::onUpdShowMiniIcons(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, (options&_ICONLIST_MINI_ICONS) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    return(1);
}


// Select all items
long IconList::onCmdselectAll(FXObject*, FXSelector, void*)
{
    for (int i = 0; i < items.no(); i++)
    {
        selectItem(i, true);
    }
    if (!(options&_ICONLIST_SEARCH) && !(options&_ICONLIST_STANDARD))
    {
        deselectItem(0, true);
    }
    return(1);
}


// Deselect all items
long IconList::onCmdDeselectAll(FXObject*, FXSelector, void*)
{
    for (int i = 0; i < items.no(); i++)
    {
        deselectItem(i, true);
    }
    return(1);
}


// Select inverse of current selection
long IconList::onCmdSelectInverse(FXObject*, FXSelector, void*)
{
    for (int i = 0; i < items.no(); i++)
    {
        toggleItem(i, true);
    }
    if (!(options&_ICONLIST_SEARCH) && !(options&_ICONLIST_STANDARD))
    {
        deselectItem(0, true);
    }
    return(1);
}


// Compare sectioned strings
int IconList::compareSection(const char* p, const char* q, int s)
{
    register int c1, c2, x;

    for (x = s; x && *p; x -= (*p++ == '\t'))
    {
    }
    for (x = s; x && *q; x -= (*q++ == '\t'))
    {
    }
    do
    {
        c1 = (FXuchar)(*p++);
        c2 = (FXuchar)(*q++);
    } while ('\t' < c1 && (c1 == c2));
    return(c1-c2);
}


// Compare sectioned strings, case-insensitive
int IconList::compareSectionCase(const char* p, const char* q, int s)
{
    register int c1, c2, x;

    for (x = s; x && *p; x -= (*p++ == '\t'))
    {
    }
    for (x = s; x && *q; x -= (*q++ == '\t'))
    {
    }
    do
    {
        if ((*p & 0x80) && (*q & 0x80))
        {
            c1 = Unicode::toLower(wc(p));
            p += wclen(p);
            c2 = Unicode::toLower(wc(q));
            q += wclen(q);
        }
        else
        {
            c1 = Ascii::toLower(*p);
            p += 1;
            c2 = Ascii::toLower(*q);
            q += 1;
        }
    } while ('\t' < c1 && (c1 == c2));
    return(c1-c2);
}


// Sort items in ascending order
int IconList::ascending(const IconItem* a, const IconItem* b)
{
    return(compareSection(a->getText().text(), b->getText().text(), 0));
}


// Sort items in descending order
int IconList::descending(const IconItem* a, const IconItem* b)
{
    return(compareSection(b->getText().text(), a->getText().text(), 0));
}


// Sort items in ascending order, case insensitive
int IconList::ascendingCase(const IconItem* a, const IconItem* b)
{
    return(compareSectionCase(a->getText().text(), b->getText().text(), 0));
}


// Sort items in descending order, case insensitive
int IconList::descendingCase(const IconItem* a, const IconItem* b)
{
    return(compareSectionCase(b->getText().text(), a->getText().text(), 0));
}


// Sort the items based on the sort function
void IconList::sortItems()
{
    register IconItem* v, *c = 0;
    register FXbool    exch = false;
    register int       i, j, h;

    if (sortfunc)
    {
        if (0 <= current)
        {
            c = items[current];
        }
        for (h = 1; h <= items.no()/9; h = 3*h+1)
        {
        }
        for ( ; h > 0; h /= 3)
        {
            for (i = h+1; i <= items.no(); i++)
            {
                v = items[i-1];
                j = i;
                while (j > h && sortfunc(items[j-h-1], v) > 0)
                {
                    items[j-1] = items[j-h-1];
                    exch = true;
                    j -= h;
                }
                items[j-1] = v;
            }
        }
        if (0 <= current)
        {
            for (i = 0; i < items.no(); i++)
            {
                if (items[i] == c)
                {
                    current = i;
                    break;
                }
            }
        }
        if (exch)
        {
            recalc();
        }
    }
}


// Set current item
void IconList::setCurrentItem(int index, FXbool notify)
{
    if ((index < -1) || (items.no() <= index))
    {
        fprintf(stderr, "%s::setCurrentItem: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    if (index != current)
    {
        // Deactivate old item
        if (0 <= current)
        {
            // No visible change if it doen't have the focus
            if (hasFocus())
            {
                items[current]->setFocus(false);
                updateItem(current);
            }
        }

        current = index;

        // Activate new item
        if (0 <= current)
        {
            // No visible change if it doen't have the focus
            if (hasFocus())
            {
                items[current]->setFocus(true);
                updateItem(current);
            }
        }

        // Notify item change
        if (notify && target)
        {
            target->tryHandle(this, FXSEL(SEL_CHANGED, message), (void*)(FXival)current);
        }
    }

    // In browse selection mode, select item
    if (((options&SELECT_MASK) == _ICONLIST_BROWSESELECT) && (0 <= current) && items[current]->isEnabled())
    {
        selectItem(current, notify);
    }
}


// Set anchor item
void IconList::setAnchorItem(int index)
{
    if ((index < -1) || (items.no() <= index))
    {
        fprintf(stderr, "%s::setAnchorItem: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    anchor = index;
    extent = index;
}


// Zero out lookup string
long IconList::onLookupTimer(FXObject*, FXSelector, void*)
{
    lookup = FXString::null;
    return(1);
}


long IconList::onKeyPress(FXObject*, FXSelector, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    int      index = current;

    flags &= ~FLAG_TIP;
    if (!isEnabled())
    {
        return(0);
    }
    if (target && target->tryHandle(this, FXSEL(SEL_KEYPRESS, message), ptr))
    {
        return(1);
    }
    switch (event->code)
    {
    case KEY_Control_L:
    case KEY_Control_R:
    case KEY_Shift_L:
    case KEY_Shift_R:
    case KEY_Alt_L:
    case KEY_Alt_R:
        if (flags&FLAG_DODRAG)
        {
            handle(this, FXSEL(SEL_DRAGGED, 0), ptr);
        }
        return(1);

    case KEY_Page_Up:
    case KEY_KP_Page_Up:
        lookup = FXString::null;
        setPosition(pos_x, pos_y+verticalScrollBar()->getPage());
        // To select an item in the current page
        index -= (int)(verticalScrollBar()->getPage()/verticalScrollBar()->getLine());
        goto hop;
        return(1);

    case KEY_Page_Down:
    case KEY_KP_Page_Down:
        lookup = FXString::null;
        setPosition(pos_x, pos_y-verticalScrollBar()->getPage());
        // To select an item in the current page
        index += (int)(verticalScrollBar()->getPage()/verticalScrollBar()->getLine());
        goto hop;
        return(1);

    case KEY_Right:
    case KEY_KP_Right:
        if (!(options&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS)))
        {
            setPosition(pos_x-10, pos_y);
            return(1);
        }
        if (options&_ICONLIST_COLUMNS)
        {
            index += 1;
        }
        else
        {
            index += nrows;
        }
        goto hop;

    case KEY_Left:
    case KEY_KP_Left:
        if (!(options&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS)))
        {
            setPosition(pos_x+10, pos_y);
            return(1);
        }
        if (options&_ICONLIST_COLUMNS)
        {
            index -= 1;
        }
        else
        {
            index -= nrows;
        }
        goto hop;

    case KEY_Up:
    case KEY_KP_Up:
        if (options&_ICONLIST_COLUMNS)
        {
            index -= ncols;
        }
        else
        {
            index -= 1;
        }
        goto hop;

    case KEY_Down:
    case KEY_KP_Down:
        if (options&_ICONLIST_COLUMNS)
        {
            index += ncols;
        }
        else
        {
            index += 1;
        }
        goto hop;

    case KEY_Home:
    case KEY_KP_Home:
        index = 0;
        goto hop;

    case KEY_End:
    case KEY_KP_End:
        index = items.no()-1;
hop:
        lookup = FXString::null;
        if ((0 <= index) && (index < items.no()))
        {
            setCurrentItem(index, true);
            makeItemVisible(index);
            if (items[index]->isEnabled())
            {
                if ((options&SELECT_MASK) == _ICONLIST_EXTENDEDSELECT)
                {
                    if (event->state&SHIFTMASK)
                    {
                        if (0 <= anchor)
                        {
                            selectItem(anchor, true);
                            extendSelection(index, true);
                        }
                        else
                        {
                            selectItem(index, true);
                        }
                    }
                    else if (!(event->state&CONTROLMASK))
                    {
                        killSelection(true);
                        selectItem(index, true);
                        setAnchorItem(index);
                    }
                }
            }
        }

        // Commented out to allow single click navigation in the FileList
        //handle(this,FXSEL(SEL_CLICKED,0),(void*)(FXival)current);

        if ((0 <= current) && items[current]->isEnabled())
        {
            handle(this, FXSEL(SEL_COMMAND, 0), (void*)(FXival)current);
        }
        return(1);

    case KEY_space:
    case KEY_KP_Space:
        lookup = FXString::null;

        if ((0 <= current) && items[current]->isEnabled())
        {
            switch (options&SELECT_MASK)
            {
            case _ICONLIST_EXTENDEDSELECT:
                if (event->state&SHIFTMASK)
                {
                    if (0 <= anchor)
                    {
                        selectItem(anchor, true);
                        extendSelection(current, true);
                    }
                    else
                    {
                        selectItem(current, true);
                    }
                }
                else if (event->state&CONTROLMASK)
                {
                    toggleItem(current, true);
                }
                else
                {
                    killSelection(true);
                    selectItem(current, true);
                }
                break;

            case _ICONLIST_MULTIPLESELECT:
            case _ICONLIST_SINGLESELECT:
                toggleItem(current, true);
                break;
            }
            setAnchorItem(current);
        }
        // Commented out to select the current item with space
        //handle(this,FXSEL(SEL_CLICKED,0),(void*)(FXival)current);
        if ((0 <= current) && items[current]->isEnabled())
        {
            handle(this, FXSEL(SEL_COMMAND, 0), (void*)(FXival)current);
        }
        return(1);

    case KEY_Return:
    case KEY_KP_Enter:
        lookup = FXString::null;
        handle(this, FXSEL(SEL_DOUBLECLICKED, 0), (void*)(FXival)current);
        if ((0 <= current) && items[current]->isEnabled())
        {
            handle(this, FXSEL(SEL_COMMAND, 0), (void*)(FXival)current);
        }
        return(1);

    default:
        if ((FXuchar)event->text[0] < ' ')
        {
            return(0);
        }
        if (event->state&(CONTROLMASK|ALTMASK))
        {
            return(0);
        }
        if (!Ascii::isPrint(event->text[0]))
        {
            return(0);
        }
        lookup.append(event->text);
        getApp()->addTimeout(this, ID_LOOKUPTIMER, getApp()->getTypingSpeed());

        // String lookup can be case insensitive now
        if (ignorecase)
        {
            index = findItem(lookup, current, SEARCH_FORWARD|SEARCH_WRAP|SEARCH_PREFIX|SEARCH_IGNORECASE);
        }
        else
        {
            index = findItem(lookup, current, SEARCH_FORWARD|SEARCH_WRAP|SEARCH_PREFIX);
        }

        if (0 <= index)
        {
            setCurrentItem(index, true);
            makeItemVisible(index);
            if (items[index]->isEnabled())
            {
                if ((options&SELECT_MASK) == _ICONLIST_EXTENDEDSELECT)
                {
                    killSelection(true);
                    selectItem(index, true);
                }
                setAnchorItem(index);
            }
        }
        handle(this, FXSEL(SEL_FOCUSIN, 0), (void*)(FXival)current);
        if ((0 <= current) && items[current]->isEnabled())
        {
            handle(this, FXSEL(SEL_COMMAND, 0), (void*)(FXival)current);
        }
        return(1);
    }
    return(0);
}


// Key Release
long IconList::onKeyRelease(FXObject*, FXSelector, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    if (!isEnabled())
    {
        return(0);
    }
    if (target && target->tryHandle(this, FXSEL(SEL_KEYRELEASE, message), ptr))
    {
        return(1);
    }
    switch (event->code)
    {
    case KEY_Shift_L:
    case KEY_Shift_R:
    case KEY_Control_L:
    case KEY_Control_R:
    case KEY_Alt_L:
    case KEY_Alt_R:
        if (flags&FLAG_DODRAG)
        {
            handle(this, FXSEL(SEL_DRAGGED, 0), ptr);
        }
        return(1);
    }
    return(0);
}


// Autoscrolling timer
long IconList::onAutoScroll(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    int      olx, orx, oty, oby, nlx, nrx, nty, nby;

    // Lasso mode
    if (flags&FLAG_LASSO)
    {
        // Hide the lasso before scrolling
        drawLasso(anchorx, anchory, currentx, currenty);

        // Scroll the content
        FXScrollArea::onAutoScroll(sender, sel, ptr);

        // Select items in lasso
        FXMINMAX(olx, orx, anchorx, currentx);
        FXMINMAX(oty, oby, anchory, currenty);
        currentx = event->win_x-pos_x;
        currenty = event->win_y-pos_y;
        FXMINMAX(nlx, nrx, anchorx, currentx);
        FXMINMAX(nty, nby, anchory, currenty);
        lassoChanged(pos_x+olx, pos_y+oty, orx-olx+1, oby-oty+1, pos_x+nlx, pos_y+nty, nrx-nlx+1, nby-nty+1, true);

        // Force repaint on this window
        repaint();

        // Show lasso again
        drawLasso(anchorx, anchory, currentx, currenty);
        return(1);
    }

    // Scroll the content
    FXScrollArea::onAutoScroll(sender, sel, ptr);

    // Content scrolled, so perhaps something else under cursor
    if (flags&FLAG_DODRAG)
    {
        handle(this, FXSEL(SEL_DRAGGED, 0), ptr);
        return(1);
    }

    return(0);
}


// Mouse moved
long IconList::onMotion(FXObject*, FXSelector, void* ptr)
{
    int      olx, orx, oty, oby, nlx, nrx, nty, nby;
    FXEvent* event = (FXEvent*)ptr;
    int      oldcursor = cursor;
    FXuint   flg = flags;

    // Kill the tip
    flags &= ~FLAG_TIP;

    // Kill the tip timer
    getApp()->removeTimeout(this, ID_TIPTIMER);

    // Right mouse scrolling
    if (flags&FLAG_SCROLLING)
    {
        setPosition(event->win_x-grabx, event->win_y-graby);
        return(1);
    }

    // Lasso selection mode
    if (flags&FLAG_LASSO)
    {
        if (startAutoScroll(event, false))
        {
            return(1);
        }

        // Hide lasso
        drawLasso(anchorx, anchory, currentx, currenty);

        // Select items in lasso
        FXMINMAX(olx, orx, anchorx, currentx);
        FXMINMAX(oty, oby, anchory, currenty);
        currentx = event->win_x-pos_x;
        currenty = event->win_y-pos_y;
        FXMINMAX(nlx, nrx, anchorx, currentx);
        FXMINMAX(nty, nby, anchory, currenty);
        lassoChanged(pos_x+olx, pos_y+oty, orx-olx+1, oby-oty+1, pos_x+nlx, pos_y+nty, nrx-nlx+1, nby-nty+1, true);

        // Force repaint on this window
        repaint();

        // Show lasso again
        drawLasso(anchorx, anchory, currentx, currenty);
        return(1);
    }

    // Drag and drop mode
    if (flags&FLAG_DODRAG)
    {
        if (startAutoScroll(event, true))
        {
            return(1);
        }
        handle(this, FXSEL(SEL_DRAGGED, 0), ptr);
        return(1);
    }

    // Tentative drag and drop
    if (flags&FLAG_TRYDRAG)
    {
        if (event->moved)
        {
            flags &= ~FLAG_TRYDRAG;
            if (handle(this, FXSEL(SEL_BEGINDRAG, 0), ptr))
            {
                flags |= FLAG_DODRAG;
            }
        }
        return(1);
    }

    // Reset tip timer if nothing's going on
    getApp()->addTimeout(this, ID_TIPTIMER, getApp()->getMenuPause());

    // Get item we're over
    cursor = getItemAt(event->win_x, event->win_y);

    // Force GUI update only when needed
    return((cursor != oldcursor) || (flg&FLAG_TIP));
}


// Pressed a button
long IconList::onLeftBtnPress(FXObject*, FXSelector, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    int      index, code;

    flags &= ~FLAG_TIP;
    handle(this, FXSEL(SEL_FOCUS_SELF, 0), ptr);
    if (isEnabled())
    {
        grab();
        flags &= ~FLAG_UPDATE;

        // First change callback
        if (target && target->tryHandle(this, FXSEL(SEL_LEFTBUTTONPRESS, message), ptr))
        {
            return(1);
        }

        // Locate item
        index = getItemAt(event->win_x, event->win_y);

        // No item
        if (index < 0)
        {
            // Start lasso
            if ((options&SELECT_MASK) == _ICONLIST_EXTENDEDSELECT)
            {
                // Kill selection
                if (!(event->state&(SHIFTMASK|CONTROLMASK)))
                {
                    killSelection(true);
                }

                anchorx = currentx = event->win_x-pos_x;
                anchory = currenty = event->win_y-pos_y;
                drawLasso(anchorx, anchory, currentx, currenty);
                flags |= FLAG_LASSO;
            }
            return(1);
        }

        // Find out where hit
        code = hitItem(index, event->win_x, event->win_y);

        // Change current item
        setCurrentItem(index, true);

        // Change item selection
        state = items[index]->isSelected();
        switch (options&SELECT_MASK)
        {
        case _ICONLIST_EXTENDEDSELECT:
            if (event->state&SHIFTMASK)
            {
                if (0 <= anchor)
                {
                    if (items[anchor]->isEnabled())
                    {
                        selectItem(anchor, true);
                    }
                    extendSelection(index, true);
                }
                else
                {
                    if (items[index]->isEnabled())
                    {
                        selectItem(index, true);
                    }
                    setAnchorItem(index);
                }
            }
            else if (event->state&CONTROLMASK)
            {
                if (items[index]->isEnabled() && !state)
                {
                    selectItem(index, true);
                }
                setAnchorItem(index);
            }
            else
            {
                if (items[index]->isEnabled() && !state)
                {
                    killSelection(true);
                    selectItem(index, true);
                }
                setAnchorItem(index);
            }
            break;

        case _ICONLIST_MULTIPLESELECT:
        case _ICONLIST_SINGLESELECT:
            if (items[index]->isEnabled() && !state)
            {
                selectItem(index, true);
            }
            break;
        }

        // Are we dragging?
        if (code && items[index]->isSelected() && items[index]->isDraggable())
        {
            flags |= FLAG_TRYDRAG;
        }

        flags |= FLAG_PRESSED;
        return(1);
    }
    return(0);
}


// Released button
long IconList::onLeftBtnRelease(FXObject*, FXSelector, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    FXuint   flg = flags;

    if (isEnabled())
    {
        ungrab();
        stopAutoScroll();
        flags |= FLAG_UPDATE;
        flags &= ~(FLAG_PRESSED|FLAG_TRYDRAG|FLAG_LASSO|FLAG_DODRAG);

        // First chance callback
        if (target && target->tryHandle(this, FXSEL(SEL_LEFTBUTTONRELEASE, message), ptr))
        {
            return(1);
        }

        // Was lassoing
        if (flg&FLAG_LASSO)
        {
            drawLasso(anchorx, anchory, currentx, currenty);
            return(1);
        }

        // Was dragging
        if (flg&FLAG_DODRAG)
        {
            handle(this, FXSEL(SEL_ENDDRAG, 0), ptr);
            return(1);
        }

        // Must have pressed
        if (flg&FLAG_PRESSED)
        {
            // Selection change
            switch (options&SELECT_MASK)
            {
            case _ICONLIST_EXTENDEDSELECT:
                if ((0 <= current) && items[current]->isEnabled())
                {
                    if (event->state&CONTROLMASK)
                    {
                        if (state)
                        {
                            deselectItem(current, true);
                        }
                    }
                    else if (!(event->state&SHIFTMASK))
                    {
                        if (state)
                        {
                            killSelection(true);
                            selectItem(current, true);
                        }
                    }
                }
                break;

            case _ICONLIST_MULTIPLESELECT:
            case _ICONLIST_SINGLESELECT:
                if ((0 <= current) && items[current]->isEnabled())
                {
                    if (state)
                    {
                        deselectItem(current, true);
                    }
                }
                break;
            }

            // Scroll to make item visible
            makeItemVisible(current);

            // Update anchor
            setAnchorItem(current);

            // Generate clicked callbacks
            if (event->click_count == 1)
            {
                handle(this, FXSEL(SEL_CLICKED, 0), (void*)(FXival)current);
            }
            else if (event->click_count == 2)
            {
                handle(this, FXSEL(SEL_DOUBLECLICKED, 0), (void*)(FXival)current);
            }
            else if (event->click_count == 3)
            {
                handle(this, FXSEL(SEL_TRIPLECLICKED, 0), (void*)(FXival)current);
            }

            // Command callback only when clicked on item
            if ((0 <= current) && items[current]->isEnabled())
            {
                handle(this, FXSEL(SEL_COMMAND, 0), (void*)(FXival)current);
            }
        }
        return(1);
    }
    return(0);
}


// Pressed right button
long IconList::onRightBtnPress(FXObject*, FXSelector, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    flags &= ~FLAG_TIP;
    handle(this, FXSEL(SEL_FOCUS_SELF, 0), ptr);
    if (isEnabled())
    {
        grab();
        flags &= ~FLAG_UPDATE;
        if (target && target->tryHandle(this, FXSEL(SEL_RIGHTBUTTONPRESS, message), ptr))
        {
            return(1);
        }
        flags |= FLAG_SCROLLING;
        grabx = event->win_x-pos_x;
        graby = event->win_y-pos_y;
        return(1);
    }
    return(0);
}


// Released right button
long IconList::onRightBtnRelease(FXObject*, FXSelector, void* ptr)
{
    if (isEnabled())
    {
        ungrab();
        flags &= ~FLAG_SCROLLING;
        flags |= FLAG_UPDATE;
        if (target && target->tryHandle(this, FXSEL(SEL_RIGHTBUTTONRELEASE, message), ptr))
        {
        }
        return(1);
    }
    return(0);
}


// The widget lost the grab for some reason
long IconList::onUngrabbed(FXObject* sender, FXSelector sel, void* ptr)
{
    FXScrollArea::onUngrabbed(sender, sel, ptr);
    flags &= ~(FLAG_DODRAG|FLAG_LASSO|FLAG_TRYDRAG|FLAG_PRESSED|FLAG_CHANGED|FLAG_SCROLLING);
    flags |= FLAG_UPDATE;
    stopAutoScroll();
    return(1);
}


// Command message
long IconList::onCommand(FXObject*, FXSelector, void* ptr)
{
    return(target && target->tryHandle(this, FXSEL(SEL_COMMAND, message), ptr));
}


// Clicked in list
long IconList::onClicked(FXObject*, FXSelector, void* ptr)
{
    return(target && target->tryHandle(this, FXSEL(SEL_CLICKED, message), ptr));
}


// Double Clicked in list; ptr may or may not point to an item
long IconList::onDoubleClicked(FXObject*, FXSelector, void* ptr)
{
    return(target && target->tryHandle(this, FXSEL(SEL_DOUBLECLICKED, message), ptr));
}


// Triple Clicked in list; ptr may or may not point to an item
long IconList::onTripleClicked(FXObject*, FXSelector, void* ptr)
{
    return(target && target->tryHandle(this, FXSEL(SEL_TRIPLECLICKED, message), ptr));
}


// Create custom item
IconItem* IconList::createItem(const FXString& text, FXIcon* big, FXIcon* mini, void* ptr)
{
    return(new IconItem(text, big, mini, ptr));
}


// Retrieve item
IconItem* IconList::getItem(int index) const
{
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::getItem: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    return(items[index]);
}


// Replace item with another
int IconList::setItem(int index, IconItem* item, FXbool notify)
{
    // Must have item
    if (!item)
    {
        fprintf(stderr, "%s::setItem: item is NULL.\n", getClassName());
        exit(EXIT_FAILURE);
    }

    // Must be in range
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::setItem: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }

    // Notify item will be replaced
    if (notify && target)
    {
        target->tryHandle(this, FXSEL(SEL_REPLACED, message), (void*)(FXival)index);
    }

    // Copy the state over
    item->state = items[index]->state;

    // Delete old
    delete items[index];

    // Add new
    items[index] = item;

    // Redo layout
    recalc();
    return(index);
}


// Replace item with another
int IconList::setItem(int index, const FXString& text, FXIcon* big, FXIcon* mini, void* ptr, FXbool notify)
{
    return(setItem(index, createItem(text, big, mini, ptr), notify));
}


// Insert item
int IconList::insertItem(int index, IconItem* item, FXbool notify)
{
    register int old = current;

    // Must have item
    if (!item)
    {
        fprintf(stderr, "%s::insertItem: item is NULL.\n", getClassName());
        exit(EXIT_FAILURE);
    }

    // Must be in range
    if ((index < 0) || (items.no() < index))
    {
        fprintf(stderr, "%s::insertItem: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }

    // Add item to list
    items.insert(index, item);

    // Adjust indices
    if (anchor >= index)
    {
        anchor++;
    }
    if (extent >= index)
    {
        extent++;
    }
    if (current >= index)
    {
        current++;
    }
    if (viewable >= index)
    {
        viewable++;
    }
    if ((current < 0) && (items.no() == 1))
    {
        current = 0;
    }

    // Notify item has been inserted
    if (notify && target)
    {
        target->tryHandle(this, FXSEL(SEL_INSERTED, message), (void*)(FXival)index);
    }

    // Current item may have changed
    if (old != current)
    {
        if (notify && target)
        {
            target->tryHandle(this, FXSEL(SEL_CHANGED, message), (void*)(FXival)current);
        }
    }

    // Was new item
    if ((0 <= current) && (current == index))
    {
        if (hasFocus())
        {
            items[current]->setFocus(true);
        }
        if (((options&SELECT_MASK) == _ICONLIST_BROWSESELECT) && items[current]->isEnabled())
        {
            selectItem(current, notify);
        }
    }

    // Redo layout
    recalc();
    return(index);
}


// Insert item
int IconList::insertItem(int index, const FXString& text, FXIcon* big, FXIcon* mini, void* ptr, FXbool notify)
{
    return(insertItem(index, createItem(text, big, mini, ptr), notify));
}


// Append item
int IconList::appendItem(IconItem* item, FXbool notify)
{
    return(insertItem(items.no(), item, notify));
}


// Append item
int IconList::appendItem(const FXString& text, FXIcon* big, FXIcon* mini, void* ptr, FXbool notify)
{
    return(insertItem(items.no(), createItem(text, big, mini, ptr), notify));
}


// Prepend item
int IconList::prependItem(IconItem* item, FXbool notify)
{
    return(insertItem(0, item, notify));
}


// Prepend item
int IconList::prependItem(const FXString& text, FXIcon* big, FXIcon* mini, void* ptr, FXbool notify)
{
    return(insertItem(0, createItem(text, big, mini, ptr), notify));
}


// Fill list by appending items from array of strings
int IconList::fillItems(const char** strings, FXIcon* big, FXIcon* mini, void* ptr, FXbool notify)
{
    register int n = 0;

    if (strings)
    {
        while (strings[n])
        {
            appendItem(strings[n++], big, mini, ptr, notify);
        }
    }
    return(n);
}


// Fill list by appending items from newline separated strings
int IconList::fillItems(const FXString& strings, FXIcon* big, FXIcon* mini, void* ptr, FXbool notify)
{
    register int n = 0;
    FXString     text;

    while (!(text = strings.section('\n', n)).empty())
    {
        appendItem(text, big, mini, ptr, notify);
        n++;
    }
    return(n);
}


// Move item from oldindex to newindex
int IconList::moveItem(int newindex, int oldindex, FXbool notify)
{
    register int       old = current;
    register IconItem* item;

    // Must be in range
    if ((newindex < 0) || (oldindex < 0) || (items.no() <= newindex) || (items.no() <= oldindex))
    {
        fprintf(stderr, "%s::moveItem: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }

    // Did it change?
    if (oldindex != newindex)
    {
        // Move item
        item = items[oldindex];
        items.erase(oldindex);
        items.insert(newindex, item);

        // Move item down
        if (newindex < oldindex)
        {
            if ((newindex <= anchor) && (anchor < oldindex))
            {
                anchor++;
            }
            if ((newindex <= extent) && (extent < oldindex))
            {
                extent++;
            }
            if ((newindex <= current) && (current < oldindex))
            {
                current++;
            }
            if ((newindex <= viewable) && (viewable < oldindex))
            {
                viewable++;
            }
        }

        // Move item up
        else
        {
            if ((oldindex < anchor) && (anchor <= newindex))
            {
                anchor--;
            }
            if ((oldindex < extent) && (extent <= newindex))
            {
                extent--;
            }
            if ((oldindex < current) && (current <= newindex))
            {
                current--;
            }
            if ((oldindex < viewable) && (viewable <= newindex))
            {
                viewable--;
            }
        }

        // Adjust if it was equal
        if (anchor == oldindex)
        {
            anchor = newindex;
        }
        if (extent == oldindex)
        {
            extent = newindex;
        }
        if (current == oldindex)
        {
            current = newindex;
        }
        if (viewable == oldindex)
        {
            viewable = newindex;
        }

        // Current item may have changed
        if (old != current)
        {
            if (notify && target)
            {
                target->tryHandle(this, FXSEL(SEL_CHANGED, message), (void*)(FXival)current);
            }
        }

        // Redo layout
        recalc();
    }
    return(newindex);
}


// Extract node from list
IconItem* IconList::extractItem(int index, FXbool notify)
{
    register IconItem* result;
    register int       old = current;

    // Must be in range
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::extractItem: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }

    // Notify item will be deleted
    if (notify && target)
    {
        target->tryHandle(this, FXSEL(SEL_DELETED, message), (void*)(FXival)index);
    }

    // Extract item
    result = items[index];

    // Remove from list
    items.erase(index);

    // Adjust indices
    if ((anchor > index) || (anchor >= items.no()))
    {
        anchor--;
    }
    if ((extent > index) || (extent >= items.no()))
    {
        extent--;
    }
    if ((current > index) || (current >= items.no()))
    {
        current--;
    }
    if ((viewable > index) || (viewable >= items.no()))
    {
        viewable--;
    }

    // Current item has changed
    if (index <= old)
    {
        if (notify && target)
        {
            target->tryHandle(this, FXSEL(SEL_CHANGED, message), (void*)(FXival)current);
        }
    }

    // Deleted current item
    if ((0 <= current) && (index == old))
    {
        if (hasFocus())
        {
            items[current]->setFocus(true);
        }
        if (((options&SELECT_MASK) == _ICONLIST_BROWSESELECT) && items[current]->isEnabled())
        {
            selectItem(current, notify);
        }
    }

    // Redo layout
    recalc();

    // Return item
    return(result);
}


// Remove node from list
void IconList::removeItem(int index, FXbool notify)
{
    register int old = current;

    // Must be in range
    if ((index < 0) || (items.no() <= index))
    {
        fprintf(stderr, "%s::removeItem: index out of range.\n", getClassName());
        exit(EXIT_FAILURE);
    }

    // Notify item will be deleted
    if (notify && target)
    {
        target->tryHandle(this, FXSEL(SEL_DELETED, message), (void*)(FXival)index);
    }

    // Delete item
    delete items[index];

    // Remove from list
    items.erase(index);

    // Adjust indices
    if ((anchor > index) || (anchor >= items.no()))
    {
        anchor--;
    }
    if ((extent > index) || (extent >= items.no()))
    {
        extent--;
    }
    if ((current > index) || (current >= items.no()))
    {
        current--;
    }
    if ((viewable > index) || (viewable >= items.no()))
    {
        viewable--;
    }

    // Current item has changed
    if (index <= old)
    {
        if (notify && target)
        {
            target->tryHandle(this, FXSEL(SEL_CHANGED, message), (void*)(FXival)current);
        }
    }

    // Deleted current item
    if ((0 <= current) && (index == old))
    {
        if (hasFocus())
        {
            items[current]->setFocus(true);
        }
        if (((options&SELECT_MASK) == _ICONLIST_BROWSESELECT) && items[current]->isEnabled())
        {
            selectItem(current, notify);
        }
    }

    // Redo layout
    recalc();
}


// Remove all items
void IconList::clearItems(FXbool notify)
{
    register int old = current;

    // Delete items
    for (int index = items.no()-1; 0 <= index; index--)
    {
        if (notify && target)
        {
            target->tryHandle(this, FXSEL(SEL_DELETED, message), (void*)(FXival)index);
        }
        delete items[index];
    }

    // Free array
    items.clear();

    // Adjust indices
    current = -1;
    anchor = -1;
    extent = -1;
    viewable = -1;

    // Current item has changed
    if (old != -1)
    {
        if (notify && target)
        {
            target->tryHandle(this, FXSEL(SEL_CHANGED, message), (void*)(FXival)-1);
        }
    }

    // Redo layout
    recalc();
}


// Change the font
void IconList::setFont(FXFont* fnt)
{
    if (!fnt)
    {
        fprintf(stderr, "%s::setFont: NULL font specified.\n", getClassName());
        exit(EXIT_FAILURE);
    }
    if (font != fnt)
    {
        font = fnt;
        recalc();
        update();
    }
}


// Set text color
void IconList::setTextColor(FXColor clr)
{
    if (clr != textColor)
    {
        textColor = clr;
        update();
    }
}


// Set select background color
void IconList::setSelBackColor(FXColor clr)
{
    if (clr != selbackColor)
    {
        selbackColor = clr;
        update();
    }
}


// Set selected text color
void IconList::setSelTextColor(FXColor clr)
{
    if (clr != seltextColor)
    {
        seltextColor = clr;
        update();
    }
}


// Set text width
void IconList::setItemSpace(int s)
{
    if (s < 1)
    {
        s = 1;
    }
    if (itemSpace != s)
    {
        itemSpace = s;
        recalc();
    }
}


// Change list style
void IconList::setListStyle(FXuint style)
{
    FXuint opts = (options&~ICONLIST_MASK) | (style&ICONLIST_MASK);

    if (options != opts)
    {
        options = opts;
        recalc();
    }
}


// Get list style
FXuint IconList::getListStyle() const
{
    return(options&ICONLIST_MASK);
}


// Change help text
void IconList::setHelpText(const FXString& text)
{
    help = text;
}


// Set ignore case flag
void IconList::setIgnoreCase(FXbool icase)
{
    ignorecase = icase;
}


// Save data
void IconList::save(FXStream& store) const
{
    FXScrollArea::save(store);
    store << header;
    items.save(store);
    store << nrows;
    store << ncols;
    store << anchor;
    store << current;
    store << extent;
    store << font;
    store << textColor;
    store << selbackColor;
    store << seltextColor;
    store << itemSpace;
    store << itemWidth;
    store << itemHeight;
    store << help;
}


// Load data
void IconList::load(FXStream& store)
{
    FXScrollArea::load(store);
    store >> header;
    items.load(store);
    store >> nrows;
    store >> ncols;
    store >> anchor;
    store >> current;
    store >> extent;
    store >> font;
    store >> textColor;
    store >> selbackColor;
    store >> seltextColor;
    store >> itemSpace;
    store >> itemWidth;
    store >> itemHeight;
    store >> help;
}


// Cleanup
IconList::~IconList()
{
    getApp()->removeTimeout(this, ID_TIPTIMER);
    getApp()->removeTimeout(this, ID_LOOKUPTIMER);
    clearItems(false);
    header = (FXHeader*)-1L;
    font = (FXFont*)-1L;
}
// Simple input dialog (without history)

#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <fxkeys.h>

#include "xfeutils.h"
#include "InputDialog.h"



FXDEFMAP(InputDialog) InputDialogMap[] =
{
    FXMAPFUNC(SEL_KEYPRESS, 0, InputDialog::onCmdKeyPress),
};

// Object implementation
FXIMPLEMENT(InputDialog, DialogBox, InputDialogMap, ARRAYNUMBER(InputDialogMap))

// Construct a dialog box
InputDialog::InputDialog(FXWindow* win, FXString inp, FXString message, FXString title, FXString label, FXIcon* icon, FXbool option, FXString optiontext) :
    DialogBox(win, title, DECOR_TITLE|DECOR_BORDER|DECOR_STRETCHABLE|DECOR_MAXIMIZE|DECOR_CLOSE)
{
    // Buttons
    FXHorizontalFrame* buttons = new FXHorizontalFrame(this, PACK_UNIFORM_WIDTH|LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X, 0, 0, 0, 0, 10, 10, 5, 5);

    // Accept
    new FXButton(buttons, _("&Accept"), NULL, this, ID_ACCEPT, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT, 0, 0, 0, 0, 20, 20);

    // Cancel
    new FXButton(buttons, _("&Cancel"), NULL, this, ID_CANCEL, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT, 0, 0, 0, 0, 20, 20);

    // Optional check box
    checkbutton = new FXHorizontalFrame(this, JUSTIFY_RIGHT|LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X, 0, 0, 0, 0, 10, 10, 0, 0);

    if (option)
    {
        new FXCheckButton(checkbutton, optiontext, this, ID_TOGGLE_OPTION);
    }

    // Vertical frame
    FXVerticalFrame* contents = new FXVerticalFrame(this, LAYOUT_SIDE_TOP|FRAME_NONE|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Icon and message line
    FXMatrix* matrix = new FXMatrix(contents, 2, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix, "", icon, LAYOUT_LEFT);
	msg = new FXLabel(matrix,"",NULL,JUSTIFY_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
	msg->setText(message);

    // Label and input field
    new FXLabel(matrix, label, NULL, LAYOUT_RIGHT|LAYOUT_CENTER_Y|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    input = new FXTextField(matrix, 40, 0, 0, LAYOUT_CENTER_Y|LAYOUT_CENTER_X|FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    input->setText(inp);
}


void InputDialog::create()
{
    DialogBox::create();
    input->setFocus();
}


long InputDialog::onCmdKeyPress(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    switch (event->code)
    {
    case KEY_Escape:
        handle(this, FXSEL(SEL_COMMAND, ID_CANCEL), NULL);
        return(1);

    case KEY_KP_Enter:
    case KEY_Return:
        handle(this, FXSEL(SEL_COMMAND, ID_ACCEPT), NULL);
        return(1);

    default:
        FXTopWindow::onKeyPress(sender, sel, ptr);
        return(1);
    }
    return(0);
}
// Dialog used to modify key bindings

#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <fxkeys.h>

#include "icons.h"
#include "xfeutils.h"
#include "InputDialog.h"
#include "MessageBox.h"
#include "KeybindingsDialog.h"
#include "XFileExplorer.h"
#include "Keybindings.h"


// Minimum header size for lists
#ifndef MIN_HEADER_SIZE
#define MIN_HEADER_SIZE    50
#endif

// Main window
extern FXMainWindow* mainWindow;


FXDEFMAP(KeybindingsBox) KeybindingsBoxMap[] =
{
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_ACCEPT, KeybindingsBox::onCmdAccept),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_CANCEL, KeybindingsBox::onCmdCancel),
    FXMAPFUNC(SEL_DOUBLECLICKED, KeybindingsBox::ID_GLB_BINDINGS_LIST, KeybindingsBox::onCmdDefineGlbKeybindings),
    FXMAPFUNC(SEL_DOUBLECLICKED, KeybindingsBox::ID_XFE_BINDINGS_LIST, KeybindingsBox::onCmdDefineXfeKeybindings),
    FXMAPFUNC(SEL_DOUBLECLICKED, KeybindingsBox::ID_XFI_BINDINGS_LIST, KeybindingsBox::onCmdDefineXfiKeybindings),
    FXMAPFUNC(SEL_DOUBLECLICKED, KeybindingsBox::ID_XFW_BINDINGS_LIST, KeybindingsBox::onCmdDefineXfwKeybindings),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_GLB_SORT_BY_ACTIONNAME, KeybindingsBox::onCmdGlbSortByActionName),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_GLB_SORT_BY_REGISTRYKEY, KeybindingsBox::onCmdGlbSortByRegistryKey),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_GLB_SORT_BY_KEYBINDING, KeybindingsBox::onCmdGlbSortByKeyBinding),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_XFE_SORT_BY_ACTIONNAME, KeybindingsBox::onCmdXfeSortByActionName),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_XFE_SORT_BY_REGISTRYKEY, KeybindingsBox::onCmdXfeSortByRegistryKey),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_XFE_SORT_BY_KEYBINDING, KeybindingsBox::onCmdXfeSortByKeyBinding),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_XFI_SORT_BY_ACTIONNAME, KeybindingsBox::onCmdXfiSortByActionName),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_XFI_SORT_BY_REGISTRYKEY, KeybindingsBox::onCmdXfiSortByRegistryKey),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_XFI_SORT_BY_KEYBINDING, KeybindingsBox::onCmdXfiSortByKeyBinding),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_XFW_SORT_BY_ACTIONNAME, KeybindingsBox::onCmdXfwSortByActionName),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_XFW_SORT_BY_REGISTRYKEY, KeybindingsBox::onCmdXfwSortByRegistryKey),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_XFW_SORT_BY_KEYBINDING, KeybindingsBox::onCmdXfwSortByKeyBinding),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_GLB_BINDINGS_LIST, KeybindingsBox::onCmdGlbHeaderClicked),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_XFE_BINDINGS_LIST, KeybindingsBox::onCmdXfeHeaderClicked),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_XFI_BINDINGS_LIST, KeybindingsBox::onCmdXfiHeaderClicked),
    FXMAPFUNC(SEL_COMMAND, KeybindingsBox::ID_XFW_BINDINGS_LIST, KeybindingsBox::onCmdXfwHeaderClicked),
    FXMAPFUNC(SEL_UPDATE, KeybindingsBox::ID_GLB_BINDINGS_LIST, KeybindingsBox::onUpdGlbHeader),
    FXMAPFUNC(SEL_UPDATE, KeybindingsBox::ID_XFE_BINDINGS_LIST, KeybindingsBox::onUpdXfeHeader),
    FXMAPFUNC(SEL_UPDATE, KeybindingsBox::ID_XFI_BINDINGS_LIST, KeybindingsBox::onUpdXfiHeader),
    FXMAPFUNC(SEL_UPDATE, KeybindingsBox::ID_XFW_BINDINGS_LIST, KeybindingsBox::onUpdXfwHeader),
};


// Object implementation
FXIMPLEMENT(KeybindingsBox, DialogBox, KeybindingsBoxMap, ARRAYNUMBER(KeybindingsBoxMap))


KeybindingsBox::KeybindingsBox(FXWindow* win, FXStringDict* glbbindings, FXStringDict* xfebindings, FXStringDict* xfibindings, FXStringDict* xfwbindings) :
    DialogBox(win, _("Key Bindings"), DECOR_TITLE|DECOR_BORDER|DECOR_RESIZE|DECOR_MAXIMIZE|DECOR_CLOSE, 0, 0, 800, 600)
{
    glbBindingsDict = glbbindings;
    xfeBindingsDict = xfebindings;
    xfiBindingsDict = xfibindings;
    xfwBindingsDict = xfwbindings;

    // Buttons
    FXHorizontalFrame* buttons = new FXHorizontalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X, 0, 0, 0, 0, 10, 10, 5, 5);

    // Contents
    FXHorizontalFrame* contents = new FXHorizontalFrame(this, LAYOUT_SIDE_TOP|FRAME_NONE|LAYOUT_FILL_X|LAYOUT_FILL_Y|PACK_UNIFORM_WIDTH);

    // Accept button
    FXButton* ok = new FXButton(buttons, _("&Accept"), NULL, this, KeybindingsBox::ID_ACCEPT, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    ok->addHotKey(KEY_Return);

    // Cancel button
    new FXButton(buttons, _("&Cancel"), NULL, this, KeybindingsBox::ID_CANCEL, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);

    // Tab book
    FXTabBook* tabbook = new FXTabBook(contents, NULL, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y|LAYOUT_RIGHT);

    // First tab is global key bindings
    new FXTabItem(tabbook, _("&Global Key Bindings"), NULL);
    FXVerticalFrame* frame1 = new FXVerticalFrame(tabbook, LAYOUT_SIDE_TOP|FRAME_RAISED|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(frame1, _("These key bindings are common to all Xfe applications.\nDouble click on an item to modify the selected key binding..."), NULL, LAYOUT_LEFT|JUSTIFY_LEFT, 0, 0, 0, 0, 0, 0, 20, 20);
    glbBindingsList = new IconList(frame1, this, ID_GLB_BINDINGS_LIST, _ICONLIST_STANDARD|HSCROLLER_NEVER|ICONLIST_BROWSESELECT|LAYOUT_SIDE_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Second tab is Xfe key bindings
    new FXTabItem(tabbook, _("Xf&e Key Bindings"), NULL);
    FXVerticalFrame* frame2 = new FXVerticalFrame(tabbook, LAYOUT_SIDE_TOP|FRAME_RAISED|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(frame2, _("These key bindings are specific to the X File Explorer application.\nDouble click on an item to modify the selected key binding..."), NULL, LAYOUT_LEFT|JUSTIFY_LEFT, 0, 0, 0, 0, 0, 0, 20, 20);
    xfeBindingsList = new IconList(frame2, this, ID_XFE_BINDINGS_LIST, _ICONLIST_STANDARD|HSCROLLER_NEVER|ICONLIST_BROWSESELECT|LAYOUT_SIDE_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Third tab is Xfi key bindings
    new FXTabItem(tabbook, _("Xf&i Key Bindings"), NULL);
    FXVerticalFrame* frame3 = new FXVerticalFrame(tabbook, LAYOUT_SIDE_TOP|FRAME_RAISED|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(frame3, _("These key bindings are specific to the X File Image application.\nDouble click on an item to modify the selected key binding..."), NULL, LAYOUT_LEFT|JUSTIFY_LEFT, 0, 0, 0, 0, 0, 0, 20, 20);
    xfiBindingsList = new IconList(frame3, this, ID_XFI_BINDINGS_LIST, _ICONLIST_STANDARD|HSCROLLER_NEVER|ICONLIST_BROWSESELECT|LAYOUT_SIDE_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Fourth tab is Xfw key bindings
    new FXTabItem(tabbook, _("Xf&w Key Bindings"), NULL);
    FXVerticalFrame* frame4 = new FXVerticalFrame(tabbook, LAYOUT_SIDE_TOP|FRAME_RAISED|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(frame4, _("These key bindings are specific to the X File Write application.\nDouble click on an item to modify the selected key binding..."), NULL, LAYOUT_LEFT|JUSTIFY_LEFT, 0, 0, 0, 0, 0, 0, 20, 20);
    xfwBindingsList = new IconList(frame4, this, ID_XFW_BINDINGS_LIST, _ICONLIST_STANDARD|HSCROLLER_NEVER|ICONLIST_BROWSESELECT|LAYOUT_SIDE_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Set list headers name and size
    FXuint hsize1 = getWidth()/2-50;
    FXuint hsize2 = getWidth()/4;

    glbBindingsList->appendHeader(_("Action Name"), NULL, hsize1);
    glbBindingsList->appendHeader(_("Registry Key"), NULL, hsize2);
    glbBindingsList->appendHeader(_("Key Binding"), NULL, hsize2);

    xfeBindingsList->appendHeader(_("Action Name"), NULL, hsize1);
    xfeBindingsList->appendHeader(_("Registry Key"), NULL, hsize2);
    xfeBindingsList->appendHeader(_("Key Binding"), NULL, hsize2);

    xfiBindingsList->appendHeader(_("Action Name"), NULL, hsize1);
    xfiBindingsList->appendHeader(_("Registry Key"), NULL, hsize2);
    xfiBindingsList->appendHeader(_("Key Binding"), NULL, hsize2);

    xfwBindingsList->appendHeader(_("Action Name"), NULL, hsize1);
    xfwBindingsList->appendHeader(_("Registry Key"), NULL, hsize2);
    xfwBindingsList->appendHeader(_("Key Binding"), NULL, hsize2);

    // Initialize sort functions
    glbBindingsList->setSortFunc(ascendingActionName);
    xfeBindingsList->setSortFunc(ascendingActionName);
    xfiBindingsList->setSortFunc(ascendingActionName);
    xfwBindingsList->setSortFunc(ascendingActionName);

    // Initialize initial binding dicts
    glbBindingsDict_prev = new FXStringDict();
    xfeBindingsDict_prev = new FXStringDict();
    xfiBindingsDict_prev = new FXStringDict();
    xfwBindingsDict_prev = new FXStringDict();

    // Changed flag
    changed = false;
}


// Create window
void KeybindingsBox::create()
{
    DialogBox::create();

    int      i;
    FXString str, data, action, keybinding;

    // Fullfill the four lists
    glbBindingsList->clearItems();
    for (i = glbBindingsDict->first(); i < glbBindingsDict->size(); i = glbBindingsDict->next(i))
    {
        data = glbBindingsDict->data(i);
        action = data.before('\t');
        keybinding = data.after('\t');
        str = action+TAB+glbBindingsDict->key(i)+TAB+keybinding;
        glbBindingsList->appendItem(str);
    }
    glbBindingsList->sortItems();

    xfeBindingsList->clearItems();
    for (i = xfeBindingsDict->first(); i < xfeBindingsDict->size(); i = xfeBindingsDict->next(i))
    {
        data = xfeBindingsDict->data(i);
        action = data.before('\t');
        keybinding = data.after('\t');
        str = action+TAB+xfeBindingsDict->key(i)+TAB+keybinding;
        xfeBindingsList->appendItem(str);
    }
    xfeBindingsList->sortItems();

    xfiBindingsList->clearItems();
    for (i = xfiBindingsDict->first(); i < xfiBindingsDict->size(); i = xfiBindingsDict->next(i))
    {
        data = xfiBindingsDict->data(i);
        action = data.before('\t');
        keybinding = data.after('\t');
        str = action+TAB+xfiBindingsDict->key(i)+TAB+keybinding;
        xfiBindingsList->appendItem(str);
    }
    xfiBindingsList->sortItems();

    xfwBindingsList->clearItems();
    for (i = xfwBindingsDict->first(); i < xfwBindingsDict->size(); i = xfwBindingsDict->next(i))
    {
        data = xfwBindingsDict->data(i);
        action = data.before('\t');
        keybinding = data.after('\t');
        str = action+TAB+xfwBindingsDict->key(i)+TAB+keybinding;
        xfwBindingsList->appendItem(str);
    }
    xfwBindingsList->sortItems();

    // Deselect all items
    glbBindingsList->killSelection();
    xfeBindingsList->killSelection();
    xfiBindingsList->killSelection();
    xfwBindingsList->killSelection();
}


// Delete objects
KeybindingsBox::~KeybindingsBox()
{
    delete glbBindingsList;
    delete xfeBindingsList;
    delete xfiBindingsList;
    delete xfwBindingsList;
    delete glbBindingsDict_prev;
    delete xfeBindingsDict_prev;
    delete xfiBindingsDict_prev;
    delete xfwBindingsDict_prev;
}


// Changes are accepted
long KeybindingsBox::onCmdAccept(FXObject* o, FXSelector s, void* p)
{
    // If some key binding was modified
    if (changed)
    {
        // Write keybindings to the registry
        FXString data, regkey, keybinding;
        for (int i = glbBindingsDict->first(); i < glbBindingsDict->size(); i = glbBindingsDict->next(i))
        {
            regkey = glbBindingsDict->key(i);
            data = glbBindingsDict->data(i);
            keybinding = data.after('\t');
            getApp()->reg().writeStringEntry("KEYBINDINGS", regkey.text(), keybinding.text());
        }
        for (int i = xfeBindingsDict->first(); i < xfeBindingsDict->size(); i = xfeBindingsDict->next(i))
        {
            regkey = xfeBindingsDict->key(i);
            data = xfeBindingsDict->data(i);
            keybinding = data.after('\t');
            getApp()->reg().writeStringEntry("KEYBINDINGS", regkey.text(), keybinding.text());
        }
        for (int i = xfiBindingsDict->first(); i < xfiBindingsDict->size(); i = xfiBindingsDict->next(i))
        {
            regkey = xfiBindingsDict->key(i);
            data = xfiBindingsDict->data(i);
            keybinding = data.after('\t');
            getApp()->reg().writeStringEntry("KEYBINDINGS", regkey.text(), keybinding.text());
        }
        for (int i = xfwBindingsDict->first(); i < xfwBindingsDict->size(); i = xfwBindingsDict->next(i))
        {
            regkey = xfwBindingsDict->key(i);
            data = xfwBindingsDict->data(i);
            keybinding = data.after('\t');
            getApp()->reg().writeStringEntry("KEYBINDINGS", regkey.text(), keybinding.text());
        }

        // Update the registry
        getApp()->reg().write();

        // Reinit the changed flag
        changed = false;

        // Ask the user if he wants to restart Xfe
        if (BOX_CLICKED_CANCEL != MessageBox::question(this, BOX_OK_CANCEL, _("Restart"), _("Key bindings will be changed after restart.\nRestart X File Explorer now?")))
        {
            mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_RESTART), NULL);
        }
    }
    DialogBox::onCmdAccept(o, s, p);
    return(1);
}


// Changes are cancelled
long KeybindingsBox::onCmdCancel(FXObject* o, FXSelector s, void* p)
{
    // Restore initial (i.e. before modification) binding dicts
    FXString data, regkey;

    for (int i = glbBindingsDict_prev->first(); i < glbBindingsDict_prev->size(); i = glbBindingsDict_prev->next(i))
    {
        regkey = glbBindingsDict_prev->key(i);
        data = glbBindingsDict_prev->data(i);
        glbBindingsDict->replace(regkey.text(), data.text());
    }
    for (int i = xfeBindingsDict_prev->first(); i < xfeBindingsDict_prev->size(); i = xfeBindingsDict_prev->next(i))
    {
        regkey = xfeBindingsDict_prev->key(i);
        data = xfeBindingsDict_prev->data(i);
        xfeBindingsDict->replace(regkey.text(), data.text());
    }
    for (int i = xfiBindingsDict_prev->first(); i < xfiBindingsDict_prev->size(); i = xfiBindingsDict_prev->next(i))
    {
        regkey = xfiBindingsDict_prev->key(i);
        data = xfiBindingsDict_prev->data(i);
        xfiBindingsDict->replace(regkey.text(), data.text());
    }
    for (int i = xfwBindingsDict_prev->first(); i < xfwBindingsDict_prev->size(); i = xfwBindingsDict_prev->next(i))
    {
        regkey = xfwBindingsDict_prev->key(i);
        data = xfwBindingsDict_prev->data(i);
        xfwBindingsDict->replace(regkey.text(), data.text());
    }

    // Reinit the changed flag
    changed = false;

    DialogBox::onCmdCancel(o, s, p);
    return(0);
}


// Compare sectioned strings
int KeybindingsBox::compareSection(const char* p, const char* q, int s)
{
    register int c1, c2, x;

    for (x = s; x && *p; x -= (*p++ == '\t'))
    {
    }
    for (x = s; x && *q; x -= (*q++ == '\t'))
    {
    }
    do
    {
        c1 = (FXuchar)(*p++);
        c2 = (FXuchar)(*q++);
    } while ('\t' < c1 && (c1 == c2));
    return(c1-c2);
}


// Sort functions
int KeybindingsBox::ascendingActionName(const IconItem* a, const IconItem* b)
{
    return(compareSection(a->getText().text(), b->getText().text(), 0));
}


int KeybindingsBox::descendingActionName(const IconItem* a, const IconItem* b)
{
    return(compareSection(b->getText().text(), a->getText().text(), 0));
}


int KeybindingsBox::ascendingRegistryKey(const IconItem* a, const IconItem* b)
{
    return(compareSection(a->getText().text(), b->getText().text(), 1));
}


int KeybindingsBox::descendingRegistryKey(const IconItem* a, const IconItem* b)
{
    return(compareSection(b->getText().text(), a->getText().text(), 1));
}


int KeybindingsBox::ascendingKeybinding(const IconItem* a, const IconItem* b)
{
    return(compareSection(a->getText().text(), b->getText().text(), 2));
}


int KeybindingsBox::descendingKeybinding(const IconItem* a, const IconItem* b)
{
    return(compareSection(b->getText().text(), a->getText().text(), 2));
}


// Sort global list by action name
long KeybindingsBox::onCmdGlbSortByActionName(FXObject*, FXSelector, void*)
{
    glbBindingsList->setSortFunc((glbBindingsList->getSortFunc() == ascendingActionName) ? descendingActionName : ascendingActionName);
    glbBindingsList->setSortHeader(0);
    glbBindingsList->clearItems();
    FXString str, data, action, keybinding;
    for (int i = glbBindingsDict->first(); i < glbBindingsDict->size(); i = glbBindingsDict->next(i))
    {
        data = glbBindingsDict->data(i);
        action = data.before('\t');
        keybinding = data.after('\t');
        str = action+TAB+glbBindingsDict->key(i)+TAB+keybinding;
        glbBindingsList->appendItem(str);
    }
    glbBindingsList->sortItems();

    return(1);
}


// Sort global list by registry key name
long KeybindingsBox::onCmdGlbSortByRegistryKey(FXObject*, FXSelector, void*)
{
    glbBindingsList->setSortFunc((glbBindingsList->getSortFunc() == ascendingRegistryKey) ? descendingRegistryKey : ascendingRegistryKey);
    glbBindingsList->setSortHeader(1);
    glbBindingsList->clearItems();
    FXString str, data, action, keybinding;
    for (int i = glbBindingsDict->first(); i < glbBindingsDict->size(); i = glbBindingsDict->next(i))
    {
        data = glbBindingsDict->data(i);
        action = data.before('\t');
        keybinding = data.after('\t');
        str = action+TAB+glbBindingsDict->key(i)+TAB+keybinding;
        glbBindingsList->appendItem(str);
    }
    glbBindingsList->sortItems();

    return(1);
}


// Sort global list by key binding
long KeybindingsBox::onCmdGlbSortByKeyBinding(FXObject*, FXSelector, void*)
{
    glbBindingsList->setSortFunc((glbBindingsList->getSortFunc() == ascendingKeybinding) ? descendingKeybinding : ascendingKeybinding);
    glbBindingsList->setSortHeader(2);
    glbBindingsList->clearItems();
    FXString str, data, action, keybinding;
    for (int i = glbBindingsDict->first(); i < glbBindingsDict->size(); i = glbBindingsDict->next(i))
    {
        data = glbBindingsDict->data(i);
        action = data.before('\t');
        keybinding = data.after('\t');
        str = action+TAB+glbBindingsDict->key(i)+TAB+keybinding;
        glbBindingsList->appendItem(str);
    }
    glbBindingsList->sortItems();

    return(1);
}


// Sort Xfe list by action name
long KeybindingsBox::onCmdXfeSortByActionName(FXObject*, FXSelector, void*)
{
    xfeBindingsList->setSortFunc((xfeBindingsList->getSortFunc() == ascendingActionName) ? descendingActionName : ascendingActionName);
    xfeBindingsList->setSortHeader(0);
    xfeBindingsList->clearItems();
    FXString str, data, action, keybinding;
    for (int i = xfeBindingsDict->first(); i < xfeBindingsDict->size(); i = xfeBindingsDict->next(i))
    {
        data = xfeBindingsDict->data(i);
        action = data.before('\t');
        keybinding = data.after('\t');
        str = action+TAB+xfeBindingsDict->key(i)+TAB+keybinding;
        xfeBindingsList->appendItem(str);
    }
    xfeBindingsList->sortItems();

    return(1);
}


// Sort Xfe list by registry key name
long KeybindingsBox::onCmdXfeSortByRegistryKey(FXObject*, FXSelector, void*)
{
    xfeBindingsList->setSortFunc((xfeBindingsList->getSortFunc() == ascendingRegistryKey) ? descendingRegistryKey : ascendingRegistryKey);
    xfeBindingsList->setSortHeader(1);
    xfeBindingsList->clearItems();
    FXString str, data, action, keybinding;
    for (int i = xfeBindingsDict->first(); i < xfeBindingsDict->size(); i = xfeBindingsDict->next(i))
    {
        data = xfeBindingsDict->data(i);
        action = data.before('\t');
        keybinding = data.after('\t');
        str = action+TAB+xfeBindingsDict->key(i)+TAB+keybinding;
        xfeBindingsList->appendItem(str);
    }
    xfeBindingsList->sortItems();

    return(1);
}


// Sort Xfe list by key binding
long KeybindingsBox::onCmdXfeSortByKeyBinding(FXObject*, FXSelector, void*)
{
    xfeBindingsList->setSortFunc((xfeBindingsList->getSortFunc() == ascendingKeybinding) ? descendingKeybinding : ascendingKeybinding);
    xfeBindingsList->setSortHeader(2);
    xfeBindingsList->clearItems();
    FXString str, data, action, keybinding;
    for (int i = xfeBindingsDict->first(); i < xfeBindingsDict->size(); i = xfeBindingsDict->next(i))
    {
        data = xfeBindingsDict->data(i);
        action = data.before('\t');
        keybinding = data.after('\t');
        str = action+TAB+xfeBindingsDict->key(i)+TAB+keybinding;
        xfeBindingsList->appendItem(str);
    }
    xfeBindingsList->sortItems();

    return(1);
}


// Sort Xfi list by action name
long KeybindingsBox::onCmdXfiSortByActionName(FXObject*, FXSelector, void*)
{
    xfiBindingsList->setSortFunc((xfiBindingsList->getSortFunc() == ascendingActionName) ? descendingActionName : ascendingActionName);
    xfiBindingsList->setSortHeader(0);
    xfiBindingsList->clearItems();
    FXString str, data, action, keybinding;
    for (int i = xfiBindingsDict->first(); i < xfiBindingsDict->size(); i = xfiBindingsDict->next(i))
    {
        data = xfiBindingsDict->data(i);
        action = data.before('\t');
        keybinding = data.after('\t');
        str = action+TAB+xfiBindingsDict->key(i)+TAB+keybinding;
        xfiBindingsList->appendItem(str);
    }
    xfiBindingsList->sortItems();

    return(1);
}


// Sort Xfi list by registry key name
long KeybindingsBox::onCmdXfiSortByRegistryKey(FXObject*, FXSelector, void*)
{
    xfiBindingsList->setSortFunc((xfiBindingsList->getSortFunc() == ascendingRegistryKey) ? descendingRegistryKey : ascendingRegistryKey);
    xfiBindingsList->setSortHeader(1);
    xfiBindingsList->clearItems();
    FXString str, data, action, keybinding;
    for (int i = xfiBindingsDict->first(); i < xfiBindingsDict->size(); i = xfiBindingsDict->next(i))
    {
        data = xfiBindingsDict->data(i);
        action = data.before('\t');
        keybinding = data.after('\t');
        str = action+TAB+xfiBindingsDict->key(i)+TAB+keybinding;
        xfiBindingsList->appendItem(str);
    }
    xfiBindingsList->sortItems();

    return(1);
}


// Sort Xfi list by key binding
long KeybindingsBox::onCmdXfiSortByKeyBinding(FXObject*, FXSelector, void*)
{
    xfiBindingsList->setSortFunc((xfiBindingsList->getSortFunc() == ascendingKeybinding) ? descendingKeybinding : ascendingKeybinding);
    xfiBindingsList->setSortHeader(2);
    xfiBindingsList->clearItems();
    FXString str, data, action, keybinding;
    for (int i = xfiBindingsDict->first(); i < xfiBindingsDict->size(); i = xfiBindingsDict->next(i))
    {
        data = xfiBindingsDict->data(i);
        action = data.before('\t');
        keybinding = data.after('\t');
        str = action+TAB+xfiBindingsDict->key(i)+TAB+keybinding;
        xfiBindingsList->appendItem(str);
    }
    xfiBindingsList->sortItems();

    return(1);
}


// Sort Xfw list by action name
long KeybindingsBox::onCmdXfwSortByActionName(FXObject*, FXSelector, void*)
{
    xfwBindingsList->setSortFunc((xfwBindingsList->getSortFunc() == ascendingActionName) ? descendingActionName : ascendingActionName);
    xfwBindingsList->setSortHeader(0);
    xfwBindingsList->clearItems();
    FXString str, data, action, keybinding;
    for (int i = xfwBindingsDict->first(); i < xfwBindingsDict->size(); i = xfwBindingsDict->next(i))
    {
        data = xfwBindingsDict->data(i);
        action = data.before('\t');
        keybinding = data.after('\t');
        str = action+TAB+xfwBindingsDict->key(i)+TAB+keybinding;
        xfwBindingsList->appendItem(str);
    }
    xfwBindingsList->sortItems();

    return(1);
}


// Sort Xfw list by registry key name
long KeybindingsBox::onCmdXfwSortByRegistryKey(FXObject*, FXSelector, void*)
{
    xfwBindingsList->setSortFunc((xfwBindingsList->getSortFunc() == ascendingRegistryKey) ? descendingRegistryKey : ascendingRegistryKey);
    xfwBindingsList->setSortHeader(1);
    xfwBindingsList->clearItems();
    FXString str, data, action, keybinding;
    for (int i = xfwBindingsDict->first(); i < xfwBindingsDict->size(); i = xfwBindingsDict->next(i))
    {
        data = xfwBindingsDict->data(i);
        action = data.before('\t');
        keybinding = data.after('\t');
        str = action+TAB+xfwBindingsDict->key(i)+TAB+keybinding;
        xfwBindingsList->appendItem(str);
    }
    xfwBindingsList->sortItems();

    return(1);
}


// Sort Xfw list by key binding
long KeybindingsBox::onCmdXfwSortByKeyBinding(FXObject*, FXSelector, void*)
{
    xfwBindingsList->setSortFunc((xfwBindingsList->getSortFunc() == ascendingKeybinding) ? descendingKeybinding : ascendingKeybinding);
    xfwBindingsList->setSortHeader(2);
    xfwBindingsList->clearItems();
    FXString str, data, action, keybinding;
    for (int i = xfwBindingsDict->first(); i < xfwBindingsDict->size(); i = xfwBindingsDict->next(i))
    {
        data = xfwBindingsDict->data(i);
        action = data.before('\t');
        keybinding = data.after('\t');
        str = action+TAB+xfwBindingsDict->key(i)+TAB+keybinding;
        xfwBindingsList->appendItem(str);
    }
    xfwBindingsList->sortItems();

    return(1);
}


// Clicked on a global list header button
long KeybindingsBox::onCmdGlbHeaderClicked(FXObject*, FXSelector, void* ptr)
{
    FXuint num = (FXuint)(FXuval)ptr;

    if (num < 3)
    {
        if (num == 0)
        {
            handle(this, FXSEL(SEL_COMMAND, ID_GLB_SORT_BY_ACTIONNAME), NULL);
        }
        else if (num == 1)
        {
            handle(this, FXSEL(SEL_COMMAND, ID_GLB_SORT_BY_REGISTRYKEY), NULL);
        }
        else if (num == 2)
        {
            handle(this, FXSEL(SEL_COMMAND, ID_GLB_SORT_BY_KEYBINDING), NULL);
        }
    }

    return(1);
}


// Clicked on a Xfe list header button
long KeybindingsBox::onCmdXfeHeaderClicked(FXObject*, FXSelector, void* ptr)
{
    FXuint num = (FXuint)(FXuval)ptr;

    if (num < 3)
    {
        if (num == 0)
        {
            handle(this, FXSEL(SEL_COMMAND, ID_XFE_SORT_BY_ACTIONNAME), NULL);
        }
        else if (num == 1)
        {
            handle(this, FXSEL(SEL_COMMAND, ID_XFE_SORT_BY_REGISTRYKEY), NULL);
        }
        else if (num == 2)
        {
            handle(this, FXSEL(SEL_COMMAND, ID_XFE_SORT_BY_KEYBINDING), NULL);
        }
    }

    return(1);
}


// Clicked on a Xfi list header button
long KeybindingsBox::onCmdXfiHeaderClicked(FXObject*, FXSelector, void* ptr)
{
    FXuint num = (FXuint)(FXuval)ptr;

    if (num < 3)
    {
        if (num == 0)
        {
            handle(this, FXSEL(SEL_COMMAND, ID_XFI_SORT_BY_ACTIONNAME), NULL);
        }
        else if (num == 1)
        {
            handle(this, FXSEL(SEL_COMMAND, ID_XFI_SORT_BY_REGISTRYKEY), NULL);
        }
        else if (num == 2)
        {
            handle(this, FXSEL(SEL_COMMAND, ID_XFI_SORT_BY_KEYBINDING), NULL);
        }
    }

    return(1);
}


// Clicked on a Xfw list header button
long KeybindingsBox::onCmdXfwHeaderClicked(FXObject*, FXSelector, void* ptr)
{
    FXuint num = (FXuint)(FXuval)ptr;

    if (num < 3)
    {
        if (num == 0)
        {
            handle(this, FXSEL(SEL_COMMAND, ID_XFW_SORT_BY_ACTIONNAME), NULL);
        }
        else if (num == 1)
        {
            handle(this, FXSEL(SEL_COMMAND, ID_XFW_SORT_BY_REGISTRYKEY), NULL);
        }
        else if (num == 2)
        {
            handle(this, FXSEL(SEL_COMMAND, ID_XFW_SORT_BY_KEYBINDING), NULL);
        }
    }

    return(1);
}


// Update global list header
long KeybindingsBox::onUpdGlbHeader(FXObject*, FXSelector, void*)
{
    // Update header arrow
    glbBindingsList->getHeader()->setArrowDir(0, (glbBindingsList->getSortFunc() == ascendingActionName) ? false : (glbBindingsList->getSortFunc() == descendingActionName) ? true : MAYBE);
    glbBindingsList->getHeader()->setArrowDir(1, (glbBindingsList->getSortFunc() == ascendingRegistryKey) ? false : (glbBindingsList->getSortFunc() == descendingRegistryKey) ? true : MAYBE);
    glbBindingsList->getHeader()->setArrowDir(2, (glbBindingsList->getSortFunc() == ascendingKeybinding) ? false : (glbBindingsList->getSortFunc() == descendingKeybinding) ? true : MAYBE);

    // Set minimum header size
    if (glbBindingsList->getHeaderSize(0) < MIN_HEADER_SIZE)
    {
        glbBindingsList->setHeaderSize(0, MIN_HEADER_SIZE);
    }
    if (glbBindingsList->getHeaderSize(1) < MIN_HEADER_SIZE)
    {
        glbBindingsList->setHeaderSize(1, MIN_HEADER_SIZE);
    }
    if (glbBindingsList->getHeaderSize(2) < MIN_HEADER_SIZE)
    {
        glbBindingsList->setHeaderSize(2, MIN_HEADER_SIZE);
    }

    return(1);
}


// Update Xfe list header
long KeybindingsBox::onUpdXfeHeader(FXObject*, FXSelector, void*)
{
    // Update header arrow
    xfeBindingsList->getHeader()->setArrowDir(0, (xfeBindingsList->getSortFunc() == ascendingActionName) ? false : (xfeBindingsList->getSortFunc() == descendingActionName) ? true : MAYBE);
    xfeBindingsList->getHeader()->setArrowDir(1, (xfeBindingsList->getSortFunc() == ascendingRegistryKey) ? false : (xfeBindingsList->getSortFunc() == descendingRegistryKey) ? true : MAYBE);
    xfeBindingsList->getHeader()->setArrowDir(2, (xfeBindingsList->getSortFunc() == ascendingKeybinding) ? false : (xfeBindingsList->getSortFunc() == descendingKeybinding) ? true : MAYBE);

    // Set minimum header size
    if (xfeBindingsList->getHeaderSize(0) < MIN_HEADER_SIZE)
    {
        xfeBindingsList->setHeaderSize(0, MIN_HEADER_SIZE);
    }
    if (xfeBindingsList->getHeaderSize(1) < MIN_HEADER_SIZE)
    {
        xfeBindingsList->setHeaderSize(1, MIN_HEADER_SIZE);
    }
    if (xfeBindingsList->getHeaderSize(2) < MIN_HEADER_SIZE)
    {
        xfeBindingsList->setHeaderSize(2, MIN_HEADER_SIZE);
    }

    return(1);
}


// Update Xfi list header
long KeybindingsBox::onUpdXfiHeader(FXObject*, FXSelector, void*)
{
    // Update header arrow
    xfiBindingsList->getHeader()->setArrowDir(0, (xfiBindingsList->getSortFunc() == ascendingActionName) ? false : (xfiBindingsList->getSortFunc() == descendingActionName) ? true : MAYBE);
    xfiBindingsList->getHeader()->setArrowDir(1, (xfiBindingsList->getSortFunc() == ascendingRegistryKey) ? false : (xfiBindingsList->getSortFunc() == descendingRegistryKey) ? true : MAYBE);
    xfiBindingsList->getHeader()->setArrowDir(2, (xfiBindingsList->getSortFunc() == ascendingKeybinding) ? false : (xfiBindingsList->getSortFunc() == descendingKeybinding) ? true : MAYBE);

    // Set minimum header size
    if (xfiBindingsList->getHeaderSize(0) < MIN_HEADER_SIZE)
    {
        xfiBindingsList->setHeaderSize(0, MIN_HEADER_SIZE);
    }
    if (xfiBindingsList->getHeaderSize(1) < MIN_HEADER_SIZE)
    {
        xfiBindingsList->setHeaderSize(1, MIN_HEADER_SIZE);
    }
    if (xfiBindingsList->getHeaderSize(2) < MIN_HEADER_SIZE)
    {
        xfiBindingsList->setHeaderSize(2, MIN_HEADER_SIZE);
    }

    return(1);
}


// Update Xfw list header
long KeybindingsBox::onUpdXfwHeader(FXObject*, FXSelector, void*)
{
    // Update header arrow
    xfwBindingsList->getHeader()->setArrowDir(0, (xfwBindingsList->getSortFunc() == ascendingActionName) ? false : (xfwBindingsList->getSortFunc() == descendingActionName) ? true : MAYBE);
    xfwBindingsList->getHeader()->setArrowDir(1, (xfwBindingsList->getSortFunc() == ascendingRegistryKey) ? false : (xfwBindingsList->getSortFunc() == descendingRegistryKey) ? true : MAYBE);
    xfwBindingsList->getHeader()->setArrowDir(2, (xfwBindingsList->getSortFunc() == ascendingKeybinding) ? false : (xfwBindingsList->getSortFunc() == descendingKeybinding) ? true : MAYBE);

    // Set minimum header size
    if (xfwBindingsList->getHeaderSize(0) < MIN_HEADER_SIZE)
    {
        xfwBindingsList->setHeaderSize(0, MIN_HEADER_SIZE);
    }
    if (xfwBindingsList->getHeaderSize(1) < MIN_HEADER_SIZE)
    {
        xfwBindingsList->setHeaderSize(1, MIN_HEADER_SIZE);
    }
    if (xfwBindingsList->getHeaderSize(2) < MIN_HEADER_SIZE)
    {
        xfwBindingsList->setHeaderSize(2, MIN_HEADER_SIZE);
    }

    return(1);
}


// Double clicked on an item in the global list
long KeybindingsBox::onCmdDefineGlbKeybindings(FXObject*, FXSelector, void*)
{
    // Get selected item string
    FXString itemtext = "";
    int      index = -1;

    for (int u = 0; u < glbBindingsList->getNumItems(); u++)
    {
        if (glbBindingsList->isItemSelected(u))
        {
            itemtext = glbBindingsList->getItemText(u);
            index = u;
        }
    }
    if (index < 0) // Should not happen
    {
        return(0);
    }

    // Decompose item text
    FXString data = itemtext.rbefore('\t');
    FXString key = itemtext.rafter('\t');
    FXString action = data.before('\t');
    FXString regkey = data.after('\t');

    // Input dialog
    FXString message;
    message.format(_("Press the combination of keys you want to use for the action: %s"), action.text());
    message = message+ "\n" + _("[Press space to disable the key binding for this action]");
    KeybindingsDialog* kbdialog = new KeybindingsDialog(this, key, message, _("Modify Key Binding"), keybindingsicon);

    // Accept was pressed
    if (kbdialog->execute(PLACEMENT_CURSOR))
    {
        // Convert the entered string into a valid key binding string
        FXString newkey = kbdialog->getKey();
        if (newkey == "Space")
        {
            newkey = "";
        }

        // Check if the new key binding is not already used elsewhere
        if (newkey != "")
        {
            FXString dictdata, dictkey;
            FXbool   exist_in_glb = false, exist_in_xfe = false, exist_in_xfi = false, exist_in_xfw = false;
            for (int i = glbBindingsDict->first(); i < glbBindingsDict->size(); i = glbBindingsDict->next(i))
            {
                dictdata = glbBindingsDict->data(i);
                dictkey = dictdata.after('\t');
                if (dictkey == newkey)
                {
                    exist_in_glb = true;
                    break;
                }
            }
            if (exist_in_glb)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("The key binding %s is already used in the global section.\n\
You should erase the existing key binding before assigning it again."), newkey.text());

                delete kbdialog;
                return(0);
            }
            for (int i = xfeBindingsDict->first(); i < xfeBindingsDict->size(); i = xfeBindingsDict->next(i))
            {
                dictdata = xfeBindingsDict->data(i);
                dictkey = dictdata.after('\t');
                if (dictkey == newkey)
                {
                    exist_in_xfe = true;
                    break;
                }
            }
            if (exist_in_xfe)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("The key binding %s is already used in the Xfe section.\n\
You should erase the existing key binding before assigning it again."), newkey.text());

                delete kbdialog;
                return(0);
            }
            for (int i = xfiBindingsDict->first(); i < xfiBindingsDict->size(); i = xfiBindingsDict->next(i))
            {
                dictdata = xfiBindingsDict->data(i);
                dictkey = dictdata.after('\t');
                if (dictkey == newkey)
                {
                    exist_in_xfi = true;
                    break;
                }
            }
            if (exist_in_xfi)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("The key binding %s is already used in the Xfi section.\n\
You should erase the existing key binding before assigning it again."), newkey.text());

                delete kbdialog;
                return(0);
            }
            for (int i = xfwBindingsDict->first(); i < xfwBindingsDict->size(); i = xfwBindingsDict->next(i))
            {
                dictdata = xfwBindingsDict->data(i);
                dictkey = dictdata.after('\t');
                if (dictkey == newkey)
                {
                    exist_in_xfw = true;
                    break;
                }
            }
            if (exist_in_xfw)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("The key binding %s is already used in the Xfw section.\n\
You should erase the existing key binding before assigning it again."), newkey.text());

                delete kbdialog;
                return(0);
            }
        }

        // Modify the item text
        itemtext = data+TAB+newkey;
        glbBindingsList->setItemText(index, itemtext);

        // Update dictionary
        FXString str = action+TAB+newkey;
        glbBindingsDict->replace(regkey.text(), str.text());

        changed = true;
    }

    // Cancel was pressed
    else
    {
        delete kbdialog;
        return(0);
    }

    delete kbdialog;
    return(1);
}


// Double clicked on an item in the Xfe list
long KeybindingsBox::onCmdDefineXfeKeybindings(FXObject*, FXSelector, void*)
{
    // Get selected item string
    FXString itemtext = "";
    int      index = -1;

    for (int u = 0; u < xfeBindingsList->getNumItems(); u++)
    {
        if (xfeBindingsList->isItemSelected(u))
        {
            itemtext = xfeBindingsList->getItemText(u);
            index = u;
        }
    }
    if (index < 0) // Should not happen
    {
        return(0);
    }

    // Decompose item text
    FXString data = itemtext.rbefore('\t');
    FXString key = itemtext.rafter('\t');
    FXString action = data.before('\t');
    FXString regkey = data.after('\t');

    // Input dialog
    FXString message;
    message.format(_("Press the combination of keys you want to use for the action: %s"), action.text());
    message = message+ "\n" + _("[Press space to disable the key binding for this action]");
    KeybindingsDialog* kbdialog = new KeybindingsDialog(this, key, message, _("Modify Key Binding"), keybindingsicon);

    // Accept was pressed
    if (kbdialog->execute(PLACEMENT_CURSOR))
    {
        // Convert the entered string into a valid key binding string
        FXString newkey = kbdialog->getKey();
        if (newkey == "Space")
        {
            newkey = "";
        }

        // Check if the new key binding is not already used elsewhere
        if (newkey != "")
        {
            FXString dictdata, dictkey;
            FXbool   exist_in_glb = false, exist_in_xfe = false;
            for (int i = glbBindingsDict->first(); i < glbBindingsDict->size(); i = glbBindingsDict->next(i))
            {
                dictdata = glbBindingsDict->data(i);
                dictkey = dictdata.after('\t');
                if (dictkey == newkey)
                {
                    exist_in_glb = true;
                    break;
                }
            }
            if (exist_in_glb)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("The key binding %s is already used in the global section.\n\
You should erase the existing key binding before assigning it again."), newkey.text());

                delete kbdialog;
                return(0);
            }
            for (int i = xfeBindingsDict->first(); i < xfeBindingsDict->size(); i = xfeBindingsDict->next(i))
            {
                dictdata = xfeBindingsDict->data(i);
                dictkey = dictdata.after('\t');
                if (dictkey == newkey)
                {
                    exist_in_xfe = true;
                    break;
                }
            }
            if (exist_in_xfe)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("The key binding %s is already used in the Xfe section.\n\
You should erase the existing key binding before assigning it again."), newkey.text());

                delete kbdialog;
                return(0);
            }
        }

        // Modify the item text
        itemtext = data+TAB+newkey;
        xfeBindingsList->setItemText(index, itemtext);

        // Update dictionary
        FXString str = action+TAB+newkey;
        xfeBindingsDict->replace(regkey.text(), str.text());

        changed = true;
    }

    // Cancel was pressed
    else
    {
        delete kbdialog;
        return(0);
    }

    delete kbdialog;
    return(1);
}


// Double clicked on an item in the Xfi list
long KeybindingsBox::onCmdDefineXfiKeybindings(FXObject*, FXSelector, void*)
{
    // Get selected item string
    FXString itemtext = "";
    int      index = -1;

    for (int u = 0; u < xfiBindingsList->getNumItems(); u++)
    {
        if (xfiBindingsList->isItemSelected(u))
        {
            itemtext = xfiBindingsList->getItemText(u);
            index = u;
        }
    }
    if (index < 0) // Should not happen
    {
        return(0);
    }

    // Decompose item text
    FXString data = itemtext.rbefore('\t');
    FXString key = itemtext.rafter('\t');
    FXString action = data.before('\t');
    FXString regkey = data.after('\t');

    // Input dialog
    FXString message;
    message.format(_("Press the combination of keys you want to use for the action: %s"), action.text());
    message = message+ "\n" + _("[Press space to disable the key binding for this action]");
    KeybindingsDialog* kbdialog = new KeybindingsDialog(this, key, message, _("Modify Key Binding"), keybindingsicon);

    // Accept was pressed
    if (kbdialog->execute(PLACEMENT_CURSOR))
    {
        // Convert the entered string into a valid key binding string
        FXString newkey = kbdialog->getKey();
        if (newkey == "Space")
        {
            newkey = "";
        }

        // Check if the new key binding is not already used elsewhere
        if (newkey != "")
        {
            FXString dictdata, dictkey;
            FXbool   exist_in_glb = false, exist_in_xfi = false;
            for (int i = glbBindingsDict->first(); i < glbBindingsDict->size(); i = glbBindingsDict->next(i))
            {
                dictdata = glbBindingsDict->data(i);
                dictkey = dictdata.after('\t');
                if (dictkey == newkey)
                {
                    exist_in_glb = true;
                    break;
                }
            }
            if (exist_in_glb)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("The key binding %s is already used in the global section.\n\
You should erase the existing key binding before assigning it again."), newkey.text());

                delete kbdialog;
                return(0);
            }
            for (int i = xfiBindingsDict->first(); i < xfiBindingsDict->size(); i = xfiBindingsDict->next(i))
            {
                dictdata = xfiBindingsDict->data(i);
                dictkey = dictdata.after('\t');
                if (dictkey == newkey)
                {
                    exist_in_xfi = true;
                    break;
                }
            }
            if (exist_in_xfi)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("The key binding %s is already used in the Xfi section.\n\
You should erase the existing key binding before assigning it again."), newkey.text());

                delete kbdialog;
                return(0);
            }
        }

        // Modify the item text
        itemtext = data+TAB+newkey;
        xfiBindingsList->setItemText(index, itemtext);

        // Update dictionary
        FXString str = action+TAB+newkey;
        xfiBindingsDict->replace(regkey.text(), str.text());

        changed = true;
    }

    // Cancel was pressed
    else
    {
        delete kbdialog;
        return(0);
    }

    delete kbdialog;
    return(1);
}


// Double clicked on an item in the Xfw list
long KeybindingsBox::onCmdDefineXfwKeybindings(FXObject*, FXSelector, void*)
{
    // Get selected item string
    FXString itemtext = "";
    int      index = -1;

    for (int u = 0; u < xfwBindingsList->getNumItems(); u++)
    {
        if (xfwBindingsList->isItemSelected(u))
        {
            itemtext = xfwBindingsList->getItemText(u);
            index = u;
        }
    }
    if (index < 0) // Should not happen
    {
        return(0);
    }

    // Decompose item text
    FXString data = itemtext.rbefore('\t');
    FXString key = itemtext.rafter('\t');
    FXString action = data.before('\t');
    FXString regkey = data.after('\t');

    // Input dialog
    FXString message;
    message.format(_("Press the combination of keys you want to use for the action: %s"), action.text());
    message = message+ "\n" + _("[Press space to disable the key binding for this action]");
    KeybindingsDialog* kbdialog = new KeybindingsDialog(this, key, message, _("Modify Key Binding"), keybindingsicon);

    // Accept was pressed
    if (kbdialog->execute(PLACEMENT_CURSOR))
    {
        // Convert the entered string into a valid key binding string
        FXString newkey = kbdialog->getKey();
        if (newkey == "Space")
        {
            newkey = "";
        }

        // Check if the new key binding is not already used elsewhere
        if (newkey != "")
        {
            FXString dictdata, dictkey;
            FXbool   exist_in_glb = false, exist_in_xfw = false;
            for (int i = glbBindingsDict->first(); i < glbBindingsDict->size(); i = glbBindingsDict->next(i))
            {
                dictdata = glbBindingsDict->data(i);
                dictkey = dictdata.after('\t');
                if (dictkey == newkey)
                {
                    exist_in_glb = true;
                    break;
                }
            }
            if (exist_in_glb)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("The key binding %s is already used in the global section.\n\
You should erase the existing key binding before assigning it again."), newkey.text());

                delete kbdialog;
                return(0);
            }
            for (int i = xfwBindingsDict->first(); i < xfwBindingsDict->size(); i = xfwBindingsDict->next(i))
            {
                dictdata = xfwBindingsDict->data(i);
                dictkey = dictdata.after('\t');
                if (dictkey == newkey)
                {
                    exist_in_xfw = true;
                    break;
                }
            }
            if (exist_in_xfw)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("The key binding %s is already used in the Xfw section.\n\
You should erase the existing key binding before assigning it again."), newkey.text());

                delete kbdialog;
                return(0);
            }
        }

        // Modify the item text
        itemtext = data+TAB+newkey;
        xfwBindingsList->setItemText(index, itemtext);

        // Update dictionary
        FXString str = action+TAB+newkey;
        xfwBindingsDict->replace(regkey.text(), str.text());

        changed = true;
    }

    // Cancel was pressed
    else
    {
        delete kbdialog;
        return(0);
    }

    delete kbdialog;
    return(1);
}


// Execute dialog box modally
FXuint KeybindingsBox::execute(FXuint placement)
{
    // Save binding dicts for cancel purpose
    FXString data, regkey;

    for (int i = glbBindingsDict->first(); i < glbBindingsDict->size(); i = glbBindingsDict->next(i))
    {
        regkey = glbBindingsDict->key(i);
        data = glbBindingsDict->data(i);
        glbBindingsDict_prev->replace(regkey.text(), data.text());
    }
    for (int i = xfeBindingsDict->first(); i < xfeBindingsDict->size(); i = xfeBindingsDict->next(i))
    {
        regkey = xfeBindingsDict->key(i);
        data = xfeBindingsDict->data(i);
        xfeBindingsDict_prev->replace(regkey.text(), data.text());
    }
    for (int i = xfiBindingsDict->first(); i < xfiBindingsDict->size(); i = xfiBindingsDict->next(i))
    {
        regkey = xfiBindingsDict->key(i);
        data = xfiBindingsDict->data(i);
        xfiBindingsDict_prev->replace(regkey.text(), data.text());
    }
    for (int i = xfwBindingsDict->first(); i < xfwBindingsDict->size(); i = xfwBindingsDict->next(i))
    {
        regkey = xfwBindingsDict->key(i);
        data = xfwBindingsDict->data(i);
        xfwBindingsDict_prev->replace(regkey.text(), data.text());
    }

    // Execute dialog
    FXuint ret = DialogBox::execute(placement);
    return(ret);
}
// Dialog to let the user enter a key binding

#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <fxkeys.h>

#include "xfeutils.h"
#include "KeybindingsDialog.h"



FXDEFMAP(KeybindingsDialog) KeybindingsDialogMap[] =
{
    FXMAPFUNC(SEL_KEYPRESS, 0, KeybindingsDialog::onCmdKeyPress),
};

// Object implementation
FXIMPLEMENT(KeybindingsDialog, DialogBox, KeybindingsDialogMap, ARRAYNUMBER(KeybindingsDialogMap))

// Construct a dialog box
KeybindingsDialog::KeybindingsDialog(FXWindow* win, FXString input, FXString message, FXString title, FXIcon* icon) :
    DialogBox(win, title, DECOR_TITLE|DECOR_BORDER|DECOR_STRETCHABLE|DECOR_MAXIMIZE|DECOR_CLOSE)
{
    // Buttons
    FXHorizontalFrame* buttons = new FXHorizontalFrame(this, PACK_UNIFORM_WIDTH|LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X, 0, 0, 0, 0, 10, 10, 5, 5);

    // Accept
    new FXButton(buttons, _("&Accept"), NULL, this, ID_ACCEPT, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT, 0, 0, 0, 0, 20, 20);

    // Cancel
    new FXButton(buttons, _("&Cancel"), NULL, this, ID_CANCEL, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT, 0, 0, 0, 0, 20, 20);

    // Vertical frame
    FXVerticalFrame* contents = new FXVerticalFrame(this, LAYOUT_SIDE_TOP|FRAME_NONE|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Icon and message line
    FXMatrix* matrix = new FXMatrix(contents, 2, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix, "", icon, LAYOUT_LEFT);
    new FXLabel(matrix, message.text(), NULL, JUSTIFY_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);

    // Label
    if (input=="")
    {
    	input=" "; // Otherwise no line will be added!
	}
    keylabel = new FXLabel(contents, input.text(), NULL, LAYOUT_CENTER_X);
}


void KeybindingsDialog::create()
{
    DialogBox::create();
}


// A key was pressed
long KeybindingsDialog::onCmdKeyPress(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    switch (event->code)
    {
    case KEY_Escape:
        handle(this, FXSEL(SEL_COMMAND, ID_CANCEL), NULL);
        return(1);

    case KEY_KP_Enter:
    case KEY_Return:
        handle(this, FXSEL(SEL_COMMAND, ID_ACCEPT), NULL);
        return(1);

    default:
        FXTopWindow::onKeyPress(sender, sel, ptr);

        // Get and display key binding string from user input
        FXString key = getKeybinding(event);
        keylabel->setText(key);
        return(1);
    }
    return(0);
}
// Message box. Taken from the FOX library and slightly modified for translation purpose.
// Also added a SU button

#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>

#include "icons.h"
#include "xfedefs.h"
#include "xfeutils.h"
#include "MessageBox.h"



// Padding for message box buttons
#define HORZ_PAD           30
#define VERT_PAD           2

#define BOX_BUTTON_MASK    (BOX_OK|BOX_OK_CANCEL|BOX_YES_NO|BOX_YES_NO_CANCEL|BOX_QUIT_CANCEL|BOX_QUIT_SAVE_CANCEL|BOX_OK_SU|BOX_YES_NO_ALL_CANCEL)


// Map
FXDEFMAP(MessageBox) MessageBoxMap[] =
{
    FXMAPFUNC(SEL_COMMAND, MessageBox::ID_CANCEL, MessageBox::onCmdCancel),
    FXMAPFUNCS(SEL_COMMAND, MessageBox::ID_CLICKED_YES, MessageBox::ID_CLICKED_ALL, MessageBox::onCmdClicked),
    FXMAPFUNC(SEL_COMMAND, MessageBox::ID_CLICKED_SU, MessageBox::onCmdSu),
};



// Object implementation
FXIMPLEMENT(MessageBox, DialogBox, MessageBoxMap, ARRAYNUMBER(MessageBoxMap))


// Construct message box with given caption, icon, and message text
MessageBox::MessageBox(FXWindow* owner, const FXString& caption, const FXString& text, FXIcon* ic, FXuint opts, FXuint textopts, int x, int y) :
    DialogBox(owner, caption, opts|DECOR_TITLE|DECOR_BORDER|DECOR_STRETCHABLE|DECOR_MAXIMIZE|DECOR_CLOSE, x, y, 0, 0, 0, 0, 0, 0, 4, 4)
{
    initialize(text, ic, opts&BOX_BUTTON_MASK, textopts);
}


// Construct free floating message box with given caption, icon, and message text
MessageBox::MessageBox(FXApp* a, const FXString& caption, const FXString& text, FXIcon* ic, FXuint opts, FXuint textopts, int x, int y) :
    DialogBox(a, caption, opts|DECOR_TITLE|DECOR_BORDER|DECOR_STRETCHABLE|DECOR_MINIMIZE|DECOR_MAXIMIZE|DECOR_CLOSE, x, y, 0, 0, 0, 0, 0, 0, 4, 4)
{
    initialize(text, ic, opts&BOX_BUTTON_MASK, textopts);
}


// Build contents
void MessageBox::initialize(const FXString& text, FXIcon* ic, FXuint whichbuttons, FXuint textoptions)
{
    FXButton*          initial;
    FXVerticalFrame*   content = new FXVerticalFrame(this, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    FXHorizontalFrame* info = new FXHorizontalFrame(content, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 10, 10, 10, 10);

    // Message text
    msg = new FXLabel(info, FXString::null, ic, textoptions);
    setText(text);

    FXHorizontalFrame* buttons = new FXHorizontalFrame(content, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|PACK_UNIFORM_WIDTH, 0, 0, 0, 0, 10, 10, 10, 10);
    if (whichbuttons == BOX_OK)
    {
        initial = new FXButton(buttons, _("&OK"), NULL, this, ID_CLICKED_OK, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        initial->setFocus();
    }
    else if (whichbuttons == BOX_OK_SU)
    {
        initial = new FXButton(buttons, _("&OK"), NULL, this, ID_CLICKED_OK, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);

        // Su button only if allowed
        FXbool root_mode = getApp()->reg().readUnsignedEntry("OPTIONS", "root_mode", TRUE);
        if (root_mode)
        {
            FXString key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_root_window", "Shift-F3");
            // Space before tab is used to set the correct button height
            FXButton* btn = new FXButton(buttons, " "+TAB+_("Launch Xfe as root")+PARS(key), minixferooticon, this, ID_CLICKED_SU, BUTTON_DEFAULT|ICON_AFTER_TEXT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
            FXHotKey  hotkey = _parseAccel(key);
            btn->addHotKey(hotkey);
        }
        initial->setFocus();
    }
    else if (whichbuttons == BOX_OK_CANCEL)
    {
        initial = new FXButton(buttons, _("&Cancel"), NULL, this, ID_CLICKED_CANCEL, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        new FXButton(buttons, _("&OK"), NULL, this, ID_CLICKED_OK, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        initial->setFocus();
    }
    else if (whichbuttons == BOX_YES_NO)
    {
        initial = new FXButton(buttons, _("&No"), NULL, this, ID_CLICKED_NO, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        new FXButton(buttons, _("&Yes"), NULL, this, ID_CLICKED_YES, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        initial->setFocus();
    }
    else if (whichbuttons == BOX_YES_NO_CANCEL)
    {
        initial = new FXButton(buttons, _("&Cancel"), NULL, this, ID_CLICKED_CANCEL, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        new FXButton(buttons, _("&Yes"), NULL, this, ID_CLICKED_YES, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        new FXButton(buttons, _("&No"), NULL, this, ID_CLICKED_NO, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        initial->setFocus();
    }
    else if (whichbuttons == BOX_QUIT_CANCEL)
    {
        initial = new FXButton(buttons, _("&Cancel"), NULL, this, ID_CLICKED_CANCEL, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        new FXButton(buttons, _("&Quit"), NULL, this, ID_CLICKED_QUIT, BUTTON_DEFAULT|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        initial->setFocus();
    }
    else if (whichbuttons == BOX_QUIT_SAVE_CANCEL)
    {
        initial = new FXButton(buttons, _("&Cancel"), NULL, this, ID_CLICKED_CANCEL, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        new FXButton(buttons, _("&Quit"), NULL, this, ID_CLICKED_QUIT, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        new FXButton(buttons, _("&Save"), NULL, this, ID_CLICKED_SAVE, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        initial->setFocus();
    }
    else if (whichbuttons == BOX_YES_NO_ALL_CANCEL)
    {
        initial = new FXButton(buttons, _("&Cancel"), NULL, this, ID_CLICKED_CANCEL, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        new FXButton(buttons, _("&Yes"), NULL, this, ID_CLICKED_YES, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        new FXButton(buttons, _("&No"), NULL, this, ID_CLICKED_NO, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        new FXButton(buttons, _("Yes for &All"), NULL, this, ID_CLICKED_ALL, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
        initial->setFocus();
    }
}


// Close dialog
long MessageBox::onCmdClicked(FXObject*, FXSelector sel, void*)
{
    getApp()->stopModal(this, BOX_CLICKED_YES+(FXSELID(sel)-ID_CLICKED_YES));
    hide();
    return(1);
}


// Launch a root Xfe (su mode)
long MessageBox::onCmdSu(FXObject*, FXSelector sel, void*)
{
    getApp()->stopModal(this, BOX_CLICKED_YES+(FXSELID(sel)-ID_CLICKED_YES));
    hide();

    // Wait cursor
    getApp()->beginWaitCursor();

    // Obtain preferred root mode
    FXbool use_sudo = getApp()->reg().readUnsignedEntry("OPTIONS", "use_sudo", FALSE);

    // Use sudo or su to launch xfe as root
    FXString title, sucmd, command;
    if (use_sudo)
    {
        title = _("Enter the user password:");
        sucmd = SUDOCMD;
    }
    else
    {
        title = _("Enter the root password:");
        sucmd = SUCMD;
    }

    // Get text font
    FXString fontspec = getApp()->reg().readStringEntry("SETTINGS", "textfont", DEFAULT_TEXT_FONT);
    if (fontspec.empty())
    {
		command = "st -t " + ::quote(title) + sucmd;
	}
	else
	{
		FXchar fontsize[32];
        FXFont* font = new FXFont(getApp(), fontspec);
        font->create();
		snprintf(fontsize, sizeof(fontsize), "%d",(int)(font->getSize()/10)); // Size is in deci-points, thus divide by 10
		command = "st -t " + ::quote(title) + " -f '" + (font->getFamily()).text() + ":pixelsize=" + fontsize + "'" + sucmd;
    }

    // Execute su or sudo command in an internal st terminal
    int status = runst(command);

    // If error
    if (status < 0)
    {
        MessageBox::error(getApp(), BOX_OK, _("Error"), _("An error has occurred!"));
        getApp()->endWaitCursor();
        return(0);
    }

    // Wait cursor
    getApp()->endWaitCursor();

    return(1);
}


// Close dialog with a cancel
long MessageBox::onCmdCancel(FXObject* sender, FXSelector, void* ptr)
{
    return(MessageBox::onCmdClicked(sender, FXSEL(SEL_COMMAND, ID_CLICKED_CANCEL), ptr));
}


// Show a modal error message
FXuint MessageBox::error(FXWindow* owner, FXuint opts, const char* caption, const char* message, ...)
{
    va_list arguments;

    va_start(arguments, message);
    MessageBox box(owner, caption, FXStringVFormat(message, arguments), errorbigicon, opts|DECOR_TITLE|DECOR_BORDER);
    va_end(arguments);
    return(box.execute());
}


// Show a modal error message, in free floating window
FXuint MessageBox::error(FXApp* app, FXuint opts, const char* caption, const char* message, ...)
{
    va_list arguments;

    va_start(arguments, message);
    MessageBox box(app, caption, FXStringVFormat(message, arguments), errorbigicon, opts|DECOR_TITLE|DECOR_BORDER);
    va_end(arguments);
    return(box.execute());
}


// Show a modal warning message
FXuint MessageBox::warning(FXWindow* owner, FXuint opts, const char* caption, const char* message, ...)
{
    va_list arguments;

    va_start(arguments, message);
    MessageBox box(owner, caption, FXStringVFormat(message, arguments), warningbigicon, opts|DECOR_TITLE|DECOR_BORDER);
    va_end(arguments);
    return(box.execute());
}


// Show a modal warning message, in free floating window
FXuint MessageBox::warning(FXApp* app, FXuint opts, const char* caption, const char* message, ...)
{
    va_list arguments;

    va_start(arguments, message);
    MessageBox box(app, caption, FXStringVFormat(message, arguments), warningbigicon, opts|DECOR_TITLE|DECOR_BORDER);
    va_end(arguments);
    return(box.execute());
}


// Show a modal question dialog
FXuint MessageBox::question(FXWindow* owner, FXuint opts, const char* caption, const char* message, ...)
{
    va_list arguments;

    va_start(arguments, message);
    MessageBox box(owner, caption, FXStringVFormat(message, arguments), questionbigicon, opts|DECOR_TITLE|DECOR_BORDER);
    va_end(arguments);
    return(box.execute());
}


// Show a modal question dialog, in free floating window
FXuint MessageBox::question(FXApp* app, FXuint opts, const char* caption, const char* message, ...)
{
    va_list arguments;

    va_start(arguments, message);
    MessageBox box(app, caption, FXStringVFormat(message, arguments), questionbigicon, opts|DECOR_TITLE|DECOR_BORDER);
    va_end(arguments);
    return(box.execute());
}


// Show a modal information dialog
FXuint MessageBox::information(FXWindow* owner, FXuint opts, const char* caption, const char* message, ...)
{
    va_list arguments;

    va_start(arguments, message);
    MessageBox box(owner, caption, FXStringVFormat(message, arguments), infobigicon, opts|DECOR_TITLE|DECOR_BORDER);
    va_end(arguments);
    return(box.execute());
}


// Show a modal information dialog, in free floating window
FXuint MessageBox::information(FXApp* app, FXuint opts, const char* caption, const char* message, ...)
{
    va_list arguments;

    va_start(arguments, message);
    MessageBox box(app, caption, FXStringVFormat(message, arguments), infobigicon, opts|DECOR_TITLE|DECOR_BORDER);
    va_end(arguments);
    return(box.execute());
}


// Set message text
void MessageBox::setText(FXString text)
{
    // Set message text with a maximum of MAX_MESSAGE_LENGTH characters per line
    msg->setText(::multiLines(text, MAX_MESSAGE_LENGTH));
}
#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <fxdefs.h>
#include <FXPNGIcon.h>

#include "icons.h"
#include "xfedefs.h"
#include "xfeutils.h"
#include "OverwriteBox.h"

// Padding for message box buttons
#define HORZ_PAD    30
#define VERT_PAD    2


// Map
FXDEFMAP(OverwriteBox) OverwriteBoxMap[] =
{
    FXMAPFUNCS(SEL_COMMAND, OverwriteBox::ID_CLICKED_CANCEL, OverwriteBox::ID_CLICKED_SKIP_ALL, OverwriteBox::onCmdClicked),
};



// Object implementation
FXIMPLEMENT(OverwriteBox, DialogBox, OverwriteBoxMap, ARRAYNUMBER(OverwriteBoxMap))


// Create message box with text
OverwriteBox::OverwriteBox(FXWindow* win, const FXString& name, const FXString& text, FXuint type, FXuint opts, int x, int y) :
    DialogBox(win, name, opts|DECOR_TITLE|DECOR_BORDER|DECOR_RESIZE|DECOR_CLOSE, x, y, 0, 0)
{
    FXVerticalFrame*   content = new FXVerticalFrame(this, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    FXHorizontalFrame* info = new FXHorizontalFrame(content, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 10, 10, 10, 10);

    new FXLabel(info, FXString::null, questionbigicon, ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Set message text with a maximum of MAX_MESSAGE_LENGTH characters per line
    FXString str = ::multiLines(text, MAX_MESSAGE_LENGTH);
    new FXLabel(info, str, NULL, JUSTIFY_LEFT|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    FXHorizontalFrame* buttons = new FXHorizontalFrame(content, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|PACK_UNIFORM_WIDTH, 0, 0, 0, 0, 10, 10, 10, 10);
	
	// Dialog with five options for multiple files
	if (type == OVWBOX_MULTIPLE_FILES)
	{
		new FXButton(buttons, _("&Cancel"), NULL, this, ID_CLICKED_CANCEL, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
		new FXButton(buttons, _("&Skip"), NULL, this, ID_CLICKED_SKIP, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
		new FXButton(buttons, _("Skip A&ll"), NULL, this, ID_CLICKED_SKIP_ALL, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
		new FXButton(buttons, _("&Yes"), NULL, this, ID_CLICKED_OVERWRITE, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
		new FXButton(buttons, _("Yes for &All"), NULL, this, ID_CLICKED_OVERWRITE_ALL, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
	}
	
	// Dialog with two options for single file
	else
	{
		new FXButton(buttons, _("&Cancel"), NULL, this, ID_CLICKED_CANCEL, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
		new FXButton(buttons, _("&Yes"), NULL, this, ID_CLICKED_OVERWRITE, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
	}
}


// Create message box with text, source and target size, source and target modified time
OverwriteBox::OverwriteBox(FXWindow* win, const FXString& name, const FXString& text, FXString& srcsize, FXString& srcmtime, FXString& tgtsize, FXString& tgtmtime, FXuint type, FXuint opts, int x, int y) :
    DialogBox(win, name, opts|DECOR_TITLE|DECOR_BORDER|DECOR_RESIZE|DECOR_CLOSE, x, y, 0, 0)
{
    FXVerticalFrame* content = new FXVerticalFrame(this, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    FXVerticalFrame* vframe = new FXVerticalFrame(content, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0);

    FXHorizontalFrame* info = new FXHorizontalFrame(vframe, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0);

    new FXLabel(info, FXString::null, questionbigicon, ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Set message text with a maximum of MAX_MESSAGE_LENGTH characters per line
    FXString str = ::multiLines(text, MAX_MESSAGE_LENGTH);
    new FXLabel(info, str, NULL, JUSTIFY_LEFT|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    FXMatrix* matrix = new FXMatrix(vframe, 5, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    new FXVerticalSeparator(matrix, SEPARATOR_NONE|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_CENTER_Y, 0, 0, 0, 0, 0, 40);
    new FXLabel(matrix, _("Source size:"), NULL, JUSTIFY_LEFT|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix, srcsize, NULL, JUSTIFY_LEFT|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix, _("- Modified date:"), NULL, JUSTIFY_LEFT|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix, srcmtime, NULL, JUSTIFY_LEFT|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    new FXVerticalSeparator(matrix, SEPARATOR_NONE|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_CENTER_Y, 0, 0, 0, 0, 0, 40);
    new FXLabel(matrix, _("Target size:"), NULL, JUSTIFY_LEFT|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix, tgtsize, NULL, JUSTIFY_LEFT|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix, _("- Modified date:"), NULL, JUSTIFY_LEFT|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix, tgtmtime, NULL, JUSTIFY_LEFT|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    FXHorizontalFrame* buttons = new FXHorizontalFrame(content, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|PACK_UNIFORM_WIDTH, 0, 0, 0, 0, 10, 10, 10, 10);

	// Dialog with five options for multiple files
	if (type == OVWBOX_MULTIPLE_FILES)
	{
		new FXButton(buttons, _("&Cancel"), NULL, this, ID_CLICKED_CANCEL, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
		new FXButton(buttons, _("&Skip"), NULL, this, ID_CLICKED_SKIP, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
		new FXButton(buttons, _("Skip A&ll"), NULL, this, ID_CLICKED_SKIP_ALL, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
		new FXButton(buttons, _("&Yes"), NULL, this, ID_CLICKED_OVERWRITE, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
		new FXButton(buttons, _("Yes for &All"), NULL, this, ID_CLICKED_OVERWRITE_ALL, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
	}

	// Dialog with two options for single file
	else
	{
		new FXButton(buttons, _("&Cancel"), NULL, this, ID_CLICKED_CANCEL, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
		new FXButton(buttons, _("&Yes"), NULL, this, ID_CLICKED_OVERWRITE, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_CENTER_X, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
	}
}



// Close dialog
long OverwriteBox::onCmdClicked(FXObject*, FXSelector sel, void*)
{
    getApp()->stopModal(this, OVWBOX_CLICKED_CANCEL+(FXSELID(sel)-ID_CLICKED_CANCEL));
    hide();
    return(1);
}
// Implementation of a path linker that allows to directly go to any parent directory
// Initially proposed and coded by Julian Mitchell <jupeos@gmail.com>

#include <sstream>
#include <fx.h>

#include "xfedefs.h"
#include "xfeutils.h"
#include "XFileExplorer.h"
#include "PathLinker.h"

#define REFRESH_INTERVAL    1000


FXDEFMAP(PathLinker) PathLinkerMap[] =
{
    FXMAPFUNC(SEL_FOCUSIN, PathLinker::ID_FOCUS_BUTTON, PathLinker::onCmdFocusButton),
    FXMAPFUNCS(SEL_LEFTBUTTONPRESS, PathLinker::ID_START_LINK, PathLinker::ID_END_LINK, PathLinker::pathButtonPressed),
    FXMAPFUNC(SEL_UPDATE, 0, PathLinker::onUpdPath),
};

FXIMPLEMENT(PathLinker, FXHorizontalFrame, PathLinkerMap, ARRAYNUMBER(PathLinkerMap))


// Construct object
PathLinker::PathLinker(FXComposite* a, FileList* flist, DirList* dlist, FXuint opts) : FXHorizontalFrame(a, opts, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2)
{
    filelist = flist;
    dirlist = dlist;

    // Add some path links
    int id = ID_START_LINK;
    for (int i = 0; i < MAX_LINKS; i++)
    {
        std::stringstream ss;
        ss << i;
        linkButtons.push_back(new FXButton(this, (ss.str() + PATHSEPSTRING).c_str(), NULL, this, id, BUTTON_NORMAL, 0, 0, 0, 0, 5, 5, 0, 0));
        id++;
        linkButtons[i]->hide();
        linkButtons[i]->setDefaultCursor(getApp()->getDefaultCursor(DEF_HAND_CURSOR));
    }

    // Initializations
    visitedPath = PATHSEPSTRING;
    nbActiveButtons = 0;
    currentButton = 0;

    // Right most button is a TextLabel and is only used for focus
    focusButton = new TextLabel(this, 0, this, ID_FOCUS_BUTTON, LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Create highlight font (bold if normal font is normal, and normal if normal font is bold)
    FXFontDesc fontdesc;
    normalFont = getApp()->getNormalFont();
    normalFont->getFontDesc(fontdesc);
    if (fontdesc.weight == FXFont::Normal)
    {
        fontdesc.weight = FXFont::Bold;
    }
    else
    {
        fontdesc.weight = FXFont::Normal;
    }
    highlightFont = new FXFont(getApp(), fontdesc);
    highlightFont->create();

    // Set the focus button initial color
    focusButton->setBackColor(getApp()->getBaseColor());
}


// Create the path linker
void PathLinker::create()
{
    FXHorizontalFrame::create();
}


// Destruct object
PathLinker::~PathLinker()
{
    delete highlightFont;
}


// Change current path
void PathLinker::setPath(FXString text)
{
    int nextPos = 0;
    int previousPos = 0;

    // Remove trailing /
    FXString path = ::cleanPath(text);

    // Indicates if actual path is included in the visited path
    int visited;

    if (path == PATHSEPSTRING)
    {
        visited = visitedPath.find(PATHSEPSTRING);
    }
    else
    {
        visited = visitedPath.find(path+PATHSEPSTRING);
    }

    // If actual path is included in the visited path
    FXuint index = 0;
    if (visited == 0)
    {
        nextPos = path.find(PATHSEPSTRING, 0);
        while (nextPos >= 0)
        {
            previousPos = nextPos + 1;
            nextPos = path.find(PATHSEPSTRING, previousPos);
            index++;
        }
        if (path.length() == 1)
        {
            index = 0;
        }
        path = visitedPath;
    }

    // Hide all of the link buttons
    for (int i = 0; i < MAX_LINKS; i++)
    {
        linkButtons[i]->hide();
        linkButtons[i]->setFont(normalFont);
        linkButtons[i]->setState(STATE_UP);
    }

    visitedPath = path;
    FXString displayText = visitedPath;

    FXuint ind = 0;
    nextPos = displayText.find(PATHSEPSTRING, 0);
    previousPos = 0;

    while (nextPos >= 0)
    {
        // Root path
        if (previousPos == 0)
        {
            setText(ind, displayText.mid(previousPos, nextPos - previousPos + 1));
        }

        // Other path
        else
        {
            setText(ind, displayText.mid(previousPos, nextPos - previousPos));
        }

        ind++;
        previousPos = nextPos + 1;
        nextPos = displayText.find(PATHSEPSTRING, previousPos);
    }
    nbActiveButtons = ind+1;
    setText(ind, displayText.mid(previousPos, displayText.length()));

    if (ind < MAX_LINKS) // Avoid crashing when the number of path links is too high
    {
        // If actual path is included in the visited path
        if (visited >= 0)
        {
            linkButtons[index]->setFont(highlightFont);
            linkButtons[index]->setState(STATE_DOWN);
            currentButton = index;
        }
        else
        {
            linkButtons[ind]->setFont(highlightFont);
            linkButtons[ind]->setState(STATE_DOWN);
            currentButton = ind;
        }
    }
}


// Update current path according to the clicked button
void PathLinker::updatePath(FXString text, FXuint index)
{
    // Remove trailing /
    FXString path = ::cleanPath(text);

    // Hide all of the link buttons
    for (int i = 0; i < MAX_LINKS; i++)
    {
        linkButtons[i]->hide();
        linkButtons[i]->setFont(normalFont);
        linkButtons[i]->setState(STATE_UP);
    }

    visitedPath = path;
    FXString displayText = visitedPath;

    int    nextPos = 0;
    int    previousPos = 0;
    FXuint ind = 0;
    nextPos = displayText.find(PATHSEPSTRING, 0);

    while (nextPos >= 0)
    {
        // Root path
        if (previousPos == 0)
        {
            setText(ind, displayText.mid(previousPos, nextPos - previousPos + 1));
        }

        // Other path
        else
        {
            setText(ind, displayText.mid(previousPos, nextPos - previousPos));
        }

        ind++;
        previousPos = nextPos + 1;
        nextPos = displayText.find(PATHSEPSTRING, previousPos);
    }
    nbActiveButtons = ind+1;

    setText(ind, displayText.mid(previousPos, displayText.length()));

    linkButtons[index]->setFont(highlightFont);
    linkButtons[index]->setState(STATE_DOWN);
    currentButton = index;
}


void PathLinker::setText(FXuint index, FXString displayText)
{
    if (index < MAX_LINKS)
    {
        // Avoid interpretation of the & character
        if (displayText.contains('&'))
        {
            displayText.substitute("&", 1, "&&", 2);
        }

        linkButtons[index]->setText(displayText);

        if (displayText.length())
        {
            linkButtons[index]->show();
        }
    }
}


// Button was pressed
long PathLinker::pathButtonPressed(FXObject* obj, FXSelector sel, void* ptr)
{
    // Set the focus on the file list
    filelist->setFocus();

    FXString filePath("");
    int      endId = FXSELID(sel);

    if (endId == ID_START_LINK)
    {
        // Selecting root dir
        filePath = PATHSEPSTRING;
    }
    else
    {
        int rpos = 0;
        rpos = visitedPath.rfind((char)PATHSEPSTRING[0], 0x7FFFFFFF, nbActiveButtons - (endId - ID_START_LINK + 1));
        filePath = visitedPath.left(rpos+1);
    }

    // Update the path text
    updatePath(visitedPath, endId - ID_START_LINK);

    // Update the FileList and DirList directory
    filelist->setDirectory(filePath);
    if (dirlist)
    {
        dirlist->setDirectory(filePath, true);
    }

    return(1);
}


// Gives the focus to the file list when clicking on the focus button
long PathLinker::onCmdFocusButton(FXObject* obj, FXSelector sel, void* ptr)
{
    // Set the focus on the file list
    filelist->setFocus();
    return(1);
}


// Update visited path to delete directories that don't exist anymore
// Also update in the case where the actual link differs from the actual path
long PathLinker::onUpdPath(FXObject* obj, FXSelector sel, void* ptr)
{
    // It is not necessary to update when the path linker is not visible
    if (shown())
    {
        // Current path of the file list (the real path)
        FXString currentpath = ::cleanPath(filelist->getDirectory());

        // Current path link (the one corresponding to the down button)
        FXString currentlink;
        if (currentButton == 0)
        {
            currentlink = PATHSEPSTRING;
        }
        else
        {
            currentlink = visitedPath.before((char)PATHSEPSTRING[0], currentButton+1);
        }

        // Test each link for existence and update to the current path if necessary
        FXString path = visitedPath;
        FXuint   n = 1;
        while (path != "")
        {
            if (!::exists(path))
            {
                visitedPath = filelist->getDirectory();
                setPath(visitedPath);
                break;
            }

            // Next path to test
            path = visitedPath.rbefore((char)PATHSEPSTRING[0], n);
            n++;
        }

        // If current link and current path differ, update to the current path
        if (currentlink != currentpath)
        {
            setPath(currentpath);
        }
    }

    return(0);
}


void PathLinker::unfocus(void)
{
    this->setBackColor(FXRGB(128, 128, 128));
    for (int i = 0; i < MAX_LINKS; i++)
    {
        linkButtons[i]->setBackColor(FXRGB(128, 128, 128));
        linkButtons[i]->setTextColor(FXRGB(255, 255, 255));
    }
    focusButton->setBackColor(FXRGB(128, 128, 128));
}


void PathLinker::focus(void)
{
    this->setBackColor(getApp()->getBaseColor());
    for (int i = 0; i < MAX_LINKS; i++)
    {
        linkButtons[i]->setBackColor(getApp()->getBaseColor());
        linkButtons[i]->setTextColor(getApp()->getForeColor());
    }
    focusButton->setBackColor(getApp()->getBaseColor());
}
// Preferences dialog box

#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <fxkeys.h>

#include "icons.h"
#include "xfedefs.h"
#include "xfeutils.h"
#include "FileDialog.h"
#include "FontDialog.h"
#include "XFileExplorer.h"
#include "MessageBox.h"
#include "Keybindings.h"
#include "Preferences.h"


FXbool Theme::operator !=(const Theme& t)
{
    for (int i = 0; i < NUM_COLORS; i++)
    {
        if (color[i] != t.color[i])
        {
            return(true);
        }
    }
    return(false);
}


// Main window
extern FXMainWindow* mainWindow;

// Single click navigation
extern FXbool single_click;

// File tooltips
extern FXbool file_tooltips;

// Relative resizing of the panels and columns in detailed mode
extern FXbool relative_resize;

// Save window position
extern FXbool save_win_pos;


// Create hilite color from given color for gradient controls
static FXColor makeHiliteColorGradient(FXColor color)
{
    FXuint r, g, b;

    r = FXREDVAL(color);
    g = FXGREENVAL(color);
    b = FXBLUEVAL(color);

    r = (FXuint)(FXMIN(1.2*r, 255));
    g = (FXuint)(FXMIN(1.2*g, 255));
    b = (FXuint)(FXMIN(1.2*b, 255));

    return(FXRGB(r, g, b));
}


// Create shadow color from given color for gradient controls
static FXColor makeShadowColorGradient(FXColor color)
{
    FXuint r, g, b;

    r = FXREDVAL(color);
    g = FXGREENVAL(color);
    b = FXBLUEVAL(color);

    r = (FXuint)(0.7*r);
    g = (FXuint)(0.7*g);
    b = (FXuint)(0.7*b);

    return(FXRGB(r, g, b));
}


// Map
FXDEFMAP(PreferencesBox) PreferencesMap[] =
{
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_ACCEPT, PreferencesBox::onCmdAccept),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_CANCEL, PreferencesBox::onCmdCancel),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_BROWSE_TXTEDIT, PreferencesBox::onCmdBrowse),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_BROWSE_TXTVIEW, PreferencesBox::onCmdBrowse),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_BROWSE_IMGVIEW, PreferencesBox::onCmdBrowse),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_BROWSE_ARCHIVER, PreferencesBox::onCmdBrowse),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_BROWSE_PDFVIEW, PreferencesBox::onCmdBrowse),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_BROWSE_VIDEOPLAY, PreferencesBox::onCmdBrowse),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_BROWSE_AUDIOPLAY, PreferencesBox::onCmdBrowse),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_BROWSE_XTERM, PreferencesBox::onCmdBrowse),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_BROWSE_MOUNTCMD, PreferencesBox::onCmdBrowse),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_BROWSE_UMOUNTCMD, PreferencesBox::onCmdBrowse),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_COLOR, PreferencesBox::onCmdColor),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_NORMALFONT, PreferencesBox::onCmdNormalFont),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_TEXTFONT, PreferencesBox::onCmdTextFont),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_THEME, PreferencesBox::onCmdTheme),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_BROWSE_ICON_PATH, PreferencesBox::onCmdBrowsePath),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_START_HOMEDIR, PreferencesBox::onCmdStartDir),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_START_CURRENTDIR, PreferencesBox::onCmdStartDir),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_START_LASTDIR, PreferencesBox::onCmdStartDir),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_SU_CMD, PreferencesBox::onCmdSuMode),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_SUDO_CMD, PreferencesBox::onCmdSuMode),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_STANDARD_CONTROLS, PreferencesBox::onCmdControls),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_CLEARLOOKS_CONTROLS, PreferencesBox::onCmdControls),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_WHEELADJUST, PreferencesBox::onCmdWheelAdjust),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_SCROLLBARSIZE, PreferencesBox::onCmdScrollBarSize),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_CHANGE_KEYBINDINGS, PreferencesBox::onCmdChangeKeyBindings),
    FXMAPFUNC(SEL_COMMAND, PreferencesBox::ID_RESTORE_KEYBINDINGS, PreferencesBox::onCmdRestoreKeyBindings),
    FXMAPFUNC(SEL_UPDATE, PreferencesBox::ID_STANDARD_CONTROLS, PreferencesBox::onUpdControls),
    FXMAPFUNC(SEL_UPDATE, PreferencesBox::ID_CLEARLOOKS_CONTROLS, PreferencesBox::onUpdControls),
    FXMAPFUNC(SEL_UPDATE, PreferencesBox::ID_COLOR, PreferencesBox::onUpdColor),
    FXMAPFUNC(SEL_UPDATE, PreferencesBox::ID_WHEELADJUST, PreferencesBox::onUpdWheelAdjust),
    FXMAPFUNC(SEL_UPDATE, PreferencesBox::ID_SCROLLBARSIZE, PreferencesBox::onUpdScrollBarSize),
    FXMAPFUNC(SEL_UPDATE, PreferencesBox::ID_SINGLE_CLICK_FILEOPEN, PreferencesBox::onUpdSingleClickFileopen),
    FXMAPFUNC(SEL_UPDATE, PreferencesBox::ID_CONFIRM_TRASH, PreferencesBox::onUpdTrash),
    FXMAPFUNC(SEL_UPDATE, PreferencesBox::ID_TRASH_BYPASS, PreferencesBox::onUpdTrash),
    FXMAPFUNC(SEL_UPDATE, PreferencesBox::ID_CONFIRM_DEL_EMPTYDIR, PreferencesBox::onUpdConfirmDelEmptyDir),
    FXMAPFUNC(SEL_UPDATE, PreferencesBox::ID_SU_CMD, PreferencesBox::onUpdSuMode),
    FXMAPFUNC(SEL_UPDATE, PreferencesBox::ID_SUDO_CMD, PreferencesBox::onUpdSuMode),
    FXMAPFUNC(SEL_UPDATE, PreferencesBox::ID_START_HOMEDIR, PreferencesBox::onUpdStartDir),
    FXMAPFUNC(SEL_UPDATE, PreferencesBox::ID_START_CURRENTDIR, PreferencesBox::onUpdStartDir),
    FXMAPFUNC(SEL_UPDATE, PreferencesBox::ID_START_LASTDIR, PreferencesBox::onUpdStartDir),
};

// Object implementation
FXIMPLEMENT(PreferencesBox, DialogBox, PreferencesMap, ARRAYNUMBER(PreferencesMap))

// Construct window
PreferencesBox::PreferencesBox(FXWindow* win, FXColor listbackcolor, FXColor listforecolor, FXColor highlightcolor, FXColor pbarcolor, FXColor attentioncolor, FXColor scrollbarcolor) : DialogBox(win, _("Preferences"), DECOR_TITLE|DECOR_BORDER|DECOR_MAXIMIZE|DECOR_STRETCHABLE|DECOR_CLOSE)
{
    currTheme.name = _("Current Theme");
    currTheme.color[0] = getApp()->getBaseColor();
    currTheme.color[1] = getApp()->getBorderColor();
    currTheme.color[2] = getApp()->getBackColor();
    currTheme.color[3] = getApp()->getForeColor();
    currTheme.color[4] = getApp()->getSelbackColor();
    currTheme.color[5] = getApp()->getSelforeColor();
    currTheme.color[6] = listbackcolor;
    currTheme.color[7] = listforecolor;
    currTheme.color[8] = highlightcolor;
    currTheme.color[9] = pbarcolor;
    currTheme.color[10] = attentioncolor;
    currTheme.color[11] = scrollbarcolor;

    Themes[0] = currTheme;
    Themes[1] = Theme("Clearlooks", FXRGB(237, 236, 235), FXRGB(0, 0, 0), FXRGB(255, 255, 255), FXRGB(0, 0, 0), FXRGB(139, 175, 220), FXRGB(255, 255, 255), FXRGB(255, 255, 255), FXRGB(0, 0, 0), FXRGB(238, 238, 238), FXRGB(121, 153, 192), FXRGB(255, 0, 0), FXRGB(149, 178, 215));
    Themes[2] = Theme("Human", FXRGB(239, 235, 231), FXRGB(0, 0, 0), FXRGB(238, 238, 238), FXRGB(0, 0, 0), FXRGB(211, 170, 123), FXRGB(255, 255, 255), FXRGB(238, 238, 238), FXRGB(0, 0, 0), FXRGB(255, 255, 255), FXRGB(195, 158, 114), FXRGB(255, 0, 0), FXRGB(212, 172, 124));
    Themes[3] = Theme("Sea Sky", FXRGB(165, 178, 198), FXRGB(0, 0, 0), FXRGB(255, 255, 255), FXRGB(0, 0, 0), FXRGB(49, 101, 156), FXRGB(255, 255, 255), FXRGB(255, 255, 255), FXRGB(0, 0, 0), FXRGB(238, 238, 238), FXRGB(49, 101, 156), FXRGB(255, 0, 0), FXRGB(68, 106, 146));
    Themes[4] = Theme("Blue Slate", FXRGB(156, 186, 205), FXRGB(0, 0, 0), FXRGB(197, 194, 197), FXRGB(0, 0, 0), FXRGB(82, 129, 148), FXRGB(255, 255, 255), FXRGB(197, 194, 197), FXRGB(0, 0, 0), FXRGB(238, 238, 238), FXRGB(82, 129, 148), FXRGB(255, 0, 0), FXRGB(156, 186, 205));
    Themes[5] = Theme("FOX", FXRGB(237, 233, 227), FXRGB(0, 0, 0), FXRGB(255, 255, 255), FXRGB(0, 0, 0), FXRGB(10, 36, 106), FXRGB(255, 255, 255), FXRGB(255, 255, 255), FXRGB(0, 0, 0), FXRGB(238, 238, 238), FXRGB(10, 36, 106), FXRGB(255, 0, 0), FXRGB(237, 233, 227));
    Themes[6] = Theme("GNOME2", FXRGB(220, 218, 213), FXRGB(0, 0, 0), FXRGB(255, 255, 255), FXRGB(0, 0, 0), FXRGB(75, 105, 131), FXRGB(255, 255, 255), FXRGB(255, 255, 255), FXRGB(0, 0, 0), FXRGB(238, 238, 238), FXRGB(75, 105, 131), FXRGB(255, 0, 0), FXRGB(134, 171, 217));
    Themes[7] = Theme("KDE3", FXRGB(238, 238, 230), FXRGB(0, 0, 0), FXRGB(255, 255, 255), FXRGB(0, 0, 0), FXRGB(255, 222, 118), FXRGB(0, 0, 0), FXRGB(255, 255, 255), FXRGB(0, 0, 0), FXRGB(238, 238, 238), FXRGB(255, 222, 118), FXRGB(255, 0, 0), FXRGB(238, 238, 230));
    Themes[8] = Theme("XFCE4", FXRGB(238, 238, 238), FXRGB(0, 0, 0), FXRGB(238, 238, 238), FXRGB(0, 0, 0), FXRGB(99, 119, 146), FXRGB(255, 255, 255), FXRGB(255, 255, 255), FXRGB(0, 0, 0), FXRGB(238, 238, 238), FXRGB(99, 119, 146), FXRGB(255, 0, 0), FXRGB(238, 238, 238));
    Themes[9] = Theme("CDE", FXRGB(156, 153, 156), FXRGB(0, 0, 0), FXRGB(131, 129, 131), FXRGB(255, 255, 255), FXRGB(49, 97, 131), FXRGB(255, 255, 255), FXRGB(131, 129, 131), FXRGB(255, 255, 255), FXRGB(165, 162, 165), FXRGB(49, 97, 131), FXRGB(255, 0, 0), FXRGB(156, 153, 156));

    // Buttons
    FXHorizontalFrame* buttons = new FXHorizontalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X, 0, 0, 0, 0, 10, 10, 5, 5);

    // Contents
    FXHorizontalFrame* contents = new FXHorizontalFrame(this, LAYOUT_SIDE_TOP|FRAME_NONE|LAYOUT_FILL_X|LAYOUT_FILL_Y|PACK_UNIFORM_WIDTH);

    // Accept
    FXButton* ok = new FXButton(buttons, _("&Accept"), NULL, this, PreferencesBox::ID_ACCEPT, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    ok->addHotKey(KEY_Return);
    ok->setFocus();

    // Cancel
    new FXButton(buttons, _("&Cancel"), NULL, this, PreferencesBox::ID_CANCEL, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);

    // Switcher
    FXTabBook* tabbook = new FXTabBook(contents, NULL, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y|LAYOUT_RIGHT);

    // First tab - General options
    new FXTabItem(tabbook, _("&General"), NULL);
    FXVerticalFrame* options = new FXVerticalFrame(tabbook, FRAME_RAISED);

    FXGroupBox* group = new FXGroupBox(options, _("Options"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    trashcan = new FXCheckButton(group, _("Use trash can for file deletion (safe delete)"));
    trashbypass = new FXCheckButton(group, _("Include a command to bypass the trash can (permanent delete)"), this, ID_TRASH_BYPASS);
    autosave = new FXCheckButton(group, _("Auto save layout"));
    savewinpos = new FXCheckButton(group, _("Save window position"));
    diropen = new FXCheckButton(group, _("Single click folder open"));
    fileopen = new FXCheckButton(group, _("Single click file open"), this, ID_SINGLE_CLICK_FILEOPEN);
    filetooltips = new FXCheckButton(group, _("Display tooltips in file and folder lists"), this, ID_FILE_TOOLTIPS);
    relativeresize = new FXCheckButton(group, _("Relative resizing of file lists"), this, ID_RELATIVE_RESIZE);
    showpathlink = new FXCheckButton(group, _("Display a path linker above file lists"), this, ID_SHOW_PATHLINK);
#ifdef STARTUP_NOTIFICATION
    usesn = new FXCheckButton(group, _("Notify when applications start up"));
#endif

    FXMatrix* matrix = new FXMatrix(group, 2, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix, _("Date format used in file and folder lists:\n(Type 'man strftime' in a terminal for help on the format)"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    timeformat = new FXTextField(matrix, 15, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    oldtimeformat = getApp()->reg().readStringEntry("SETTINGS", "time_format", DEFAULT_TIME_FORMAT);
    timeformat->setText(oldtimeformat);

    new FXTabItem(tabbook, _("&Modes"), NULL);
    FXVerticalFrame* modes = new FXVerticalFrame(tabbook, FRAME_RAISED);

    startdirmode = getApp()->reg().readUnsignedEntry("OPTIONS", "startdir_mode", START_HOMEDIR) + ID_START_HOMEDIR;
    oldstartdirmode = startdirmode;
    startdirtarget.connect(startdirmode);

    group = new FXGroupBox(modes, _("Starting mode"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXRadioButton(group, _("Start in home folder"), this, PreferencesBox::ID_START_HOMEDIR);
    new FXRadioButton(group, _("Start in current folder"), this, PreferencesBox::ID_START_CURRENTDIR);
    new FXRadioButton(group, _("Start in last visited folder"), this, PreferencesBox::ID_START_LASTDIR);

    group = new FXGroupBox(modes, _("Scrolling mode"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    matrix = new FXMatrix(group, 2, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP);
    scroll = new FXCheckButton(matrix, _("Smooth scrolling in file lists and text windows"));
    FXbool smoothscroll = getApp()->reg().readUnsignedEntry("SETTINGS", "smooth_scroll", true);
    scroll->setCheck(smoothscroll);
    new FXLabel(matrix, "", NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    new FXLabel(matrix, _("Mouse scrolling speed:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    FXSpinner* spinner = new FXSpinner(matrix, 3, this, PreferencesBox::ID_WHEELADJUST, JUSTIFY_RIGHT|LAYOUT_FILL_X|LAYOUT_FILL_ROW, 0, 0, 0, 0, 2, 2, 1, 1);
    spinner->setRange(1, 100);
    new FXLabel(matrix, _("Scrollbar width:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    spinner = new FXSpinner(matrix, 3, this, PreferencesBox::ID_SCROLLBARSIZE, JUSTIFY_RIGHT|LAYOUT_FILL_X|LAYOUT_FILL_ROW, 0, 0, 0, 0, 2, 2, 1, 1);
    spinner->setRange(1, 100);

    group = new FXGroupBox(modes, _("Root mode"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    rootmode = new FXCheckButton(group, _("Allow root mode"));
    FXRadioButton* subutton = new FXRadioButton(group, _("Authentication using su (uses root password)"), this, ID_SU_CMD);
    FXRadioButton* sudobutton = new FXRadioButton(group, _("Authentication using sudo (uses user password)"), this, ID_SUDO_CMD);

    FXbool root_mode = getApp()->reg().readUnsignedEntry("OPTIONS", "root_mode", true);
    rootmode->setCheck(root_mode);

    if (getuid() == 0) // Super user
    {
        rootmode->disable();
        subutton->disable();
        sudobutton->disable();
    }
    use_sudo = getApp()->reg().readUnsignedEntry("OPTIONS", "use_sudo", false);

    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
    trashcan->setCheck(use_trash_can);

    if (trashcan->getCheck())
    {
        FXbool use_trash_bypass = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_bypass", false);
        trashbypass->setCheck(use_trash_bypass);
    }
    else
    {
        trashbypass->disable();
    }

    FXbool auto_save_layout = getApp()->reg().readUnsignedEntry("OPTIONS", "auto_save_layout", true);
    autosave->setCheck(auto_save_layout);

    FXbool save_win_pos = getApp()->reg().readUnsignedEntry("SETTINGS", "save_win_pos", false);
    savewinpos->setCheck(save_win_pos);

    // Single click navigation
    single_click = getApp()->reg().readUnsignedEntry("SETTINGS", "single_click", SINGLE_CLICK_NONE);
    if (single_click == SINGLE_CLICK_DIR)
    {
        diropen->setCheck(true);
        fileopen->setCheck(false);
    }
    else if (single_click == SINGLE_CLICK_DIR_FILE)
    {
        diropen->setCheck(true);
        fileopen->setCheck(true);
    }
    else
    {
        diropen->setCheck(false);
        fileopen->setCheck(false);
    }

    // File tooltips
    if (file_tooltips == false)
    {
        filetooltips->setCheck(false);
    }
    else
    {
        filetooltips->setCheck(true);
    }

    // Relative resizing
    if (relative_resize == false)
    {
        relativeresize->setCheck(false);
    }
    else
    {
        relativeresize->setCheck(true);
    }

    // Display path linker
    show_pathlink = getApp()->reg().readUnsignedEntry("SETTINGS", "show_pathlinker", true);
    if (show_pathlink == false)
    {
        showpathlink->setCheck(false);
    }
    else
    {
        showpathlink->setCheck(true);
    }

#ifdef STARTUP_NOTIFICATION
    FXbool use_sn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    usesn->setCheck(use_sn);
#endif

    // Second tab - Dialogs
    new FXTabItem(tabbook, _("&Dialogs"), NULL);
    FXVerticalFrame* dialogs = new FXVerticalFrame(tabbook, FRAME_RAISED);
    group = new FXGroupBox(dialogs, _("Confirmations"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    ask = new FXCheckButton(group, _("Confirm copy/move/rename/symlink"));
    dnd = new FXCheckButton(group, _("Confirm drag and drop"));
    trashmv = new FXCheckButton(group, _("Confirm move to trash/restore from trash"), this, ID_CONFIRM_TRASH);
    del = new FXCheckButton(group, _("Confirm delete"));
    del_emptydir = new FXCheckButton(group, _("Confirm delete non empty folders"), this, ID_CONFIRM_DEL_EMPTYDIR);
    overwrite = new FXCheckButton(group, _("Confirm overwrite"));
    exec = new FXCheckButton(group, _("Confirm execute text files"));
    properties = new FXCheckButton(group, _("Confirm change properties"));

    group = new FXGroupBox(dialogs, _("Warnings"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    folder_warning = new FXCheckButton(group, _("Warn when setting current folder in search window"));
#if defined(linux)
    mount = new FXCheckButton(group, _("Warn when mount points are not responding"));
    show_mount = new FXCheckButton(group, _("Display mount / unmount success messages"));
#endif
    preserve_date_warning = new FXCheckButton(group, _("Warn when date preservation failed"));
    root_warning = new FXCheckButton(group, _("Warn if running as root"));

    FXbool confirm_trash = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_trash", true);
    trashmv->setCheck(confirm_trash);
    FXbool confirm_del = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete", true);
    del->setCheck(confirm_del);
    FXbool confirm_properties = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_properties", true);
    properties->setCheck(confirm_properties);
    FXbool confirm_del_emptydir = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete_emptydir", true);
    del_emptydir->setCheck(confirm_del_emptydir);
    FXbool confirm_overwrite = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_overwrite", true);
    overwrite->setCheck(confirm_overwrite);
    FXbool confirm_exec = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_execute", true);
    exec->setCheck(confirm_exec);
    FXbool ask_before_copy = getApp()->reg().readUnsignedEntry("OPTIONS", "ask_before_copy", true);
    ask->setCheck(ask_before_copy);
    FXbool confirm_dnd = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_drag_and_drop", true);
    dnd->setCheck(confirm_dnd);

#if defined(linux)
    FXbool mount_warn = getApp()->reg().readUnsignedEntry("OPTIONS", "mount_warn", true);
    FXbool mount_messages = getApp()->reg().readUnsignedEntry("OPTIONS", "mount_messages", true);
    mount->setCheck(mount_warn);
    show_mount->setCheck(mount_messages);
#endif

    FXbool folder_warn = getApp()->reg().readUnsignedEntry("OPTIONS", "folderwarn", true);
    folder_warning->setCheck(folder_warn);

    FXbool preserve_date_warn = getApp()->reg().readUnsignedEntry("OPTIONS", "preserve_date_warn", true);
    preserve_date_warning->setCheck(preserve_date_warn);

    FXbool root_warn = getApp()->reg().readUnsignedEntry("OPTIONS", "root_warn", true);
    if (getuid()) // Simple user
    {
        root_warning->disable();
    }
    else
    {
        root_warning->setCheck(root_warn);
    }

    // Third tab - Programs
    new FXTabItem(tabbook, _("&Programs"), NULL);
    FXVerticalFrame* programs = new FXVerticalFrame(tabbook, FRAME_RAISED);
    group = new FXGroupBox(programs, _("Default programs"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    matrix = new FXMatrix(group, 3, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    new FXLabel(matrix, _("Text viewer:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    txtviewer = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_BROWSE_TXTVIEW, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    oldtxtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
    txtviewer->setText(oldtxtviewer);

    new FXLabel(matrix, _("Text editor:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    txteditor = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_BROWSE_TXTEDIT, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    oldtxteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
    txteditor->setText(oldtxteditor);

    new FXLabel(matrix, _("File comparator:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    filecomparator = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_BROWSE_TXTEDIT, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    oldfilecomparator = getApp()->reg().readStringEntry("PROGS", "filecomparator", DEFAULT_FILECOMPARATOR);
    filecomparator->setText(oldfilecomparator);

    new FXLabel(matrix, _("Image editor:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    imgeditor = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_BROWSE_IMGVIEW, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    oldimgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
    imgeditor->setText(oldimgeditor);

    new FXLabel(matrix, _("Image viewer:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    imgviewer = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_BROWSE_IMGVIEW, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    oldimgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
    imgviewer->setText(oldimgviewer);

    new FXLabel(matrix, _("Archiver:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    archiver = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_BROWSE_ARCHIVER, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    oldarchiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);
    archiver->setText(oldarchiver);

    new FXLabel(matrix, _("Pdf viewer:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    pdfviewer = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_BROWSE_PDFVIEW, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    oldpdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
    pdfviewer->setText(oldpdfviewer);

    new FXLabel(matrix, _("Audio player:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    audioplayer = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_BROWSE_AUDIOPLAY, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    oldaudioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
    audioplayer->setText(oldaudioplayer);

    new FXLabel(matrix, _("Video player:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    videoplayer = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_BROWSE_VIDEOPLAY, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    oldvideoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
    videoplayer->setText(oldvideoplayer);

    new FXLabel(matrix, _("Terminal:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    xterm = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_BROWSE_XTERM, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    oldxterm = getApp()->reg().readStringEntry("PROGS", "xterm", DEFAULT_TERMINAL);
    xterm->setText(oldxterm);

    group = new FXGroupBox(programs, _("Volume management"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    matrix = new FXMatrix(group, 3, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    new FXLabel(matrix, _("Mount:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    mountcmd = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_BROWSE_MOUNTCMD, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    oldmountcmd = getApp()->reg().readStringEntry("PROGS", "mount", DEFAULT_MOUNTCMD);
    mountcmd->setText(oldmountcmd);

    new FXLabel(matrix, _("Unmount:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    umountcmd = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_BROWSE_UMOUNTCMD, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    oldumountcmd = getApp()->reg().readStringEntry("PROGS", "unmount", DEFAULT_UMOUNTCMD);
    umountcmd->setText(oldumountcmd);


    // Fourth tab - Visual
    new FXTabItem(tabbook, _("&Themes"), NULL);
    FXVerticalFrame* visual = new FXVerticalFrame(tabbook, FRAME_RAISED);
    FXGroupBox*      themes = new FXGroupBox(visual, _("Color theme"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    FXPacker*        pack = new FXPacker(themes, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_Y|LAYOUT_FILL_X, 0, 0, 0, 0, 0, 0, 0, 0);
    themesList = new FXList(pack, this, ID_THEME, LIST_BROWSESELECT|FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    themesList->setNumVisible(7);
    for (int i = 0; i < NUM_THEMES; i++)
    {
        themesList->appendItem(Themes[i].name);
    }
    themesList->setCurrentItem(0);

    FXGroupBox* colors = new FXGroupBox(visual, _("Custom colors"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X);
    FXMatrix*   matrix3 = new FXMatrix(colors, 2, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    colorsBox = new FXComboBox(matrix3, NUM_COLORS, NULL, 0, COMBOBOX_STATIC|LAYOUT_FILL_X|LAYOUT_SIDE_RIGHT|LAYOUT_CENTER_Y);
    colorsBox->setNumVisible(NUM_COLORS);
    cwell = new FXColorWell(matrix3, FXRGB(0, 0, 0), this, ID_COLOR, LAYOUT_FILL_X|LAYOUT_FILL_COLUMN|LAYOUT_FILL_Y, 0, 0, 0, 0, 10, 10, 0, 0);
    cwell->setTipText(_("Double click to customize the color"));

    colorsBox->appendItem(_("Base color"));
    colorsBox->appendItem(_("Border color"));
    colorsBox->appendItem(_("Background color"));
    colorsBox->appendItem(_("Text color"));
    colorsBox->appendItem(_("Selection background color"));
    colorsBox->appendItem(_("Selection text color"));
    colorsBox->appendItem(_("File list background color"));
    colorsBox->appendItem(_("File list text color"));
    colorsBox->appendItem(_("File list highlight color"));
    colorsBox->appendItem(_("Progress bar color"));
    colorsBox->appendItem(_("Attention color"));
    colorsBox->appendItem(_("Scrollbar color"));
    colorsBox->setCurrentItem(0);

    // Controls theme
    FXGroupBox* button = new FXGroupBox(visual, _("Controls"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    use_clearlooks = getApp()->reg().readUnsignedEntry("SETTINGS", "use_clearlooks", true);
    new FXRadioButton(button, _("Standard (classic controls)"), this, ID_STANDARD_CONTROLS);
    new FXRadioButton(button, _("Clearlooks (modern looking controls)"), this, ID_CLEARLOOKS_CONTROLS);

    // Find iconpath from the Xfe registry settings or set it to DEFAULTICONPATH
    FXGroupBox* group2 = new FXGroupBox(visual, _("Icon theme path"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X);
    FXMatrix*   matrix2 = new FXMatrix(group2, 2, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    iconpath = new FXTextField(matrix2, 40, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    new FXButton(matrix2, _("\tSelect path..."), filedialogicon, this, ID_BROWSE_ICON_PATH, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    oldiconpath = getApp()->reg().readStringEntry("SETTINGS", "iconpath", DEFAULTICONPATH);
    iconpath->setText(oldiconpath);

    // Fifth tab - Fonts
    new FXTabItem(tabbook, _("&Fonts"), NULL);
    FXVerticalFrame* fonts = new FXVerticalFrame(tabbook, FRAME_RAISED);
    FXGroupBox*      fgroup = new FXGroupBox(fonts, _("Fonts"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    FXMatrix* fmatrix = new FXMatrix(fgroup, 3, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(fmatrix, _("Normal font:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    normalfont = new FXTextField(fmatrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    new FXButton(fmatrix, _(" Select..."), NULL, this, ID_NORMALFONT, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y); //,0,0,0,0,20,20);
    oldnormalfont = getApp()->reg().readStringEntry("SETTINGS", "font", DEFAULT_NORMAL_FONT);
    normalfont->setText(oldnormalfont);

    new FXLabel(fmatrix, _("Text font:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    textfont = new FXTextField(fmatrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    new FXButton(fmatrix, _(" Select..."), NULL, this, ID_TEXTFONT, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y); //0,0,0,0,20,20);
    oldtextfont = getApp()->reg().readStringEntry("SETTINGS", "textfont", DEFAULT_TEXT_FONT);
    textfont->setText(oldtextfont);

    // Sixth tab - Key bindings
    new FXTabItem(tabbook, _("&Key Bindings"), NULL);
    FXVerticalFrame* keybindings = new FXVerticalFrame(tabbook, FRAME_RAISED);
    FXGroupBox*      kbgroup = new FXGroupBox(keybindings, _("Key Bindings"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    FXPacker* kbpack = new FXPacker(kbgroup, LAYOUT_FILL_X);
    new FXButton(kbpack, _("Modify key bindings..."), minikeybindingsicon, this, ID_CHANGE_KEYBINDINGS, FRAME_RAISED|FRAME_THICK|ICON_BEFORE_TEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X);  //,0,0,0,0,20,20);
    new FXButton(kbpack, _("Restore default key bindings..."), reloadicon, this, ID_RESTORE_KEYBINDINGS, FRAME_RAISED|FRAME_THICK|ICON_BEFORE_TEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X); //,0,0,0,0,20,20);

    // Initializations
    bindingsbox = NULL;
    glbBindingsDict = NULL;
    xfeBindingsDict = NULL;
    xfiBindingsDict = NULL;
    xfwBindingsDict = NULL;

    themesBox = NULL;
    bg = NULL;
    controls = NULL;

    trashbypass_prev = false;
    autosave_prev = false;
    savewinpos_prev = false;
    diropen_prev = false;
    fileopen_prev = false;
    filetooltips_prev = false;
    relativeresize_prev = false;
    show_pathlink_prev = false;
    wheellines_prev = 0;
    scrollbarsize_prev = 0;
    ask_prev = false;
    dnd_prev = false;
    trashmv_prev = false;
    del_prev = false;
    properties_prev = false;
    del_emptydir_prev = false;
    overwrite_prev = false;
    exec_prev = false;
    use_clearlooks_prev = false;
    rootmode_prev = false;
#ifdef STARTUP_NOTIFICATION
    usesn_prev = false;
#endif
#if defined(linux)
    mount_prev = false;
    show_mount_prev = false;
#endif
    root_warning_prev = false;
    folder_warning_prev = false;
    preserve_date_warning_prev = false;
    themelist_prev = false;
    smoothscroll_prev = false;
    use_sudo_prev = false;
    trashcan_prev = false;
}


long PreferencesBox::onUpdColor(FXObject* o, FXSelector s, void* p)
{
    FXColorWell* cwell = (FXColorWell*)o;
    int i = colorsBox->getCurrentItem();

    cwell->setRGBA(currTheme.color[i]);

    return(1);
}


long PreferencesBox::onCmdColor(FXObject* o, FXSelector s, void* p)
{
    FXColorWell* cwell = (FXColorWell*)o;
    int i = colorsBox->getCurrentItem();

    currTheme.color[i] = cwell->getRGBA();

    return(1);
}


long PreferencesBox::onCmdTheme(FXObject* o, FXSelector s, void* p)
{
    currTheme = Themes[themesList->getCurrentItem()];
    return(1);
}


long PreferencesBox::onCmdBrowsePath(FXObject* o, FXSelector s, void* p)
{
    FileDialog browse(this, _("Select an icon theme folder or an icon file"));

    browse.setSelectMode(SELECT_FILE_MIXED);
    browse.setDirectory(iconpath->getText());
    if (browse.execute())
    {
        FXString path = browse.getFilename();
        if (::isFile(path))
        {
            iconpath->setText(FXPath::directory(path).text());
        }
        else
        {
            iconpath->setText(path);
        }
    }
    return(1);
}


long PreferencesBox::onCmdBrowse(FXObject* o, FXSelector s, void* p)
{
    FileDialog  browse(this, _("Select an executable file"));
    const char* patterns[] =
    {
        _("All files"), "*", NULL
    };

    browse.setFilename(ROOTDIR);
    browse.setPatternList(patterns);
    browse.setSelectMode(SELECT_FILE_EXISTING);
    if (browse.execute())
    {
        FXString path = browse.getFilename();

        switch (FXSELID(s))
        {
        case ID_BROWSE_TXTVIEW:
            txtviewer->setText(FXPath::name(path));
            break;

        case ID_BROWSE_TXTEDIT:
            txteditor->setText(FXPath::name(path));
            break;

        case ID_BROWSE_FILECOMP:
            filecomparator->setText(FXPath::name(path));
            break;

        case ID_BROWSE_IMGVIEW:
            imgviewer->setText(FXPath::name(path));
            break;

        case ID_BROWSE_ARCHIVER:
            archiver->setText(FXPath::name(path));
            break;

        case ID_BROWSE_PDFVIEW:
            pdfviewer->setText(FXPath::name(path));
            break;

        case ID_BROWSE_AUDIOPLAY:
            audioplayer->setText(FXPath::name(path));
            break;

        case ID_BROWSE_VIDEOPLAY:
            videoplayer->setText(FXPath::name(path));
            break;

        case ID_BROWSE_XTERM:
            xterm->setText(FXPath::name(path));
            break;

        case ID_BROWSE_MOUNTCMD:
            mountcmd->setText(FXPath::name(path));
            break;

        case ID_BROWSE_UMOUNTCMD:
            umountcmd->setText(FXPath::name(path));
            break;
        }
    }
    return(1);
}


// Change normal font
long PreferencesBox::onCmdNormalFont(FXObject*, FXSelector, void*)
{
    FontDialog fontdlg(this, _("Change Normal Font"), DECOR_BORDER|DECOR_TITLE);
    FXFontDesc fontdesc;
    FXString   fontspec;

    fontspec = getApp()->reg().readStringEntry("SETTINGS", "font", DEFAULT_NORMAL_FONT);
    FXFont* nfont = new FXFont(getApp(), fontspec);
    nfont->create();
    nfont->getFontDesc(fontdesc);

    fontdlg.setFontSelection(fontdesc);
    if (fontdlg.execute())
    {
        fontdlg.getFontSelection(fontdesc);
        nfont->setFontDesc(fontdesc);
        fontspec = nfont->getFont();
        normalfont->setText(fontspec);
    }
    return(1);
}


// Change text font
long PreferencesBox::onCmdTextFont(FXObject*, FXSelector, void*)
{
    FontDialog fontdlg(this, _("Change Text Font"), DECOR_BORDER|DECOR_TITLE);
    FXFontDesc fontdesc;
    FXString   fontspec;

    fontspec = getApp()->reg().readStringEntry("SETTINGS", "textfont", DEFAULT_TEXT_FONT);
    FXFont* tfont = new FXFont(getApp(), fontspec);
    tfont->create();
    tfont->getFontDesc(fontdesc);
    fontdlg.setFontSelection(fontdesc);
    if (fontdlg.execute())
    {
        fontdlg.getFontSelection(fontdesc);
        tfont->setFontDesc(fontdesc);
        fontspec = tfont->getFont();
        textfont->setText(fontspec);
    }
    return(1);
}


// Change key bindings
long PreferencesBox::onCmdChangeKeyBindings(FXObject*, FXSelector, void*)
{
    FXString key, str;

    // String dictionary used to store global key bindings
    if (glbBindingsDict == NULL)
    {
        glbBindingsDict = new FXStringDict();
    }

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_back", "Ctrl-Backspace");
    str = _("Go to previous folder")+TAB+key;
    glbBindingsDict->insert("go_back", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_forward", "Shift-Backspace");
    str = _("Go to next folder")+TAB+key;
    glbBindingsDict->insert("go_forward", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_up", "Backspace");
    str = _("Go to parent folder")+TAB+key;
    glbBindingsDict->insert("go_up", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_home", "Ctrl-H");
    str = _("Go to home folder")+TAB+key;
    glbBindingsDict->insert("go_home", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_file", "Ctrl-N");
    str = _("Create new file")+TAB+key;
    glbBindingsDict->insert("new_file", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_folder", "F7");
    str = _("Create new folder")+TAB+key;
    glbBindingsDict->insert("new_folder", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "copy", "Ctrl-C");
    str = _("Copy to clipboard")+TAB+key;
    glbBindingsDict->insert("copy", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "cut", "Ctrl-X");
    str = _("Cut to clipboard")+TAB+key;
    glbBindingsDict->insert("cut", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "paste", "Ctrl-V");
    str = _("Paste from clipboard")+TAB+key;
    glbBindingsDict->insert("paste", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "big_icons", "F10");
    str = _("Big icon list")+TAB+key;
    glbBindingsDict->insert("big_icons", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "small_icons", "F11");
    str = _("Small icon list")+TAB+key;
    glbBindingsDict->insert("small_icons", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "detailed_file_list", "F12");
    str = _("Detailed file list")+TAB+key;
    glbBindingsDict->insert("detailed_file_list", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "open", "Ctrl-O");
    str = _("Open file")+TAB+key;
    glbBindingsDict->insert("open", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "quit", "Ctrl-Q");
    str = _("Quit application")+TAB+key;
    glbBindingsDict->insert("quit", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "select_all", "Ctrl-A");
    str = _("Select all")+TAB+key;
    glbBindingsDict->insert("select_all", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "deselect_all", "Ctrl-Z");
    str = _("Deselect all")+TAB+key;
    glbBindingsDict->insert("deselect_all", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "invert_selection", "Ctrl-I");
    str = _("Invert selection")+TAB+key;
    glbBindingsDict->insert("invert_selection", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "help", "F1");
    str = _("Display help")+TAB+key;
    glbBindingsDict->insert("help", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");
    str = _("Toggle display hidden files")+TAB+key;
    glbBindingsDict->insert("hidden_files", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");
    str = _("Toggle display thumbnails")+TAB+key;
    glbBindingsDict->insert("thumbnails", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_work", "Shift-F2");
    str = _("Go to working folder")+TAB+key;
    glbBindingsDict->insert("go_work", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "close", "Ctrl-W");
    str = _("Close window")+TAB+key;
    glbBindingsDict->insert("close", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "print", "Ctrl-P");
    str = _("Print file")+TAB+key;
    glbBindingsDict->insert("print", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "search", "Ctrl-F");
    str = _("Search")+TAB+key;
    glbBindingsDict->insert("search", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "search_prev", "Ctrl-Shift-G");
    str = _("Search previous")+TAB+key;
    glbBindingsDict->insert("search_prev", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "search_next", "Ctrl-G");
    str = _("Search next")+TAB+key;
    glbBindingsDict->insert("search_next", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "vert_panels", "Ctrl-Shift-F1");
    str = _("Vertical panels")+TAB+key;
    glbBindingsDict->insert("vert_panels", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "horz_panels", "Ctrl-Shift-F2");
    str = _("Horizontal panels")+TAB+key;
    glbBindingsDict->insert("horz_panels", str.text());

    // Key bindings specific to X File Explorer (Xfe)
    if (xfeBindingsDict == NULL)
    {
        xfeBindingsDict = new FXStringDict();
    }

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "refresh", "Ctrl-R");
    str = _("Refresh panels")+TAB+key;
    xfeBindingsDict->insert("refresh", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_symlink", "Ctrl-J");
    str = _("Create new symbolic link")+TAB+key;
    xfeBindingsDict->insert("new_symlink", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "properties", "F9");
    str = _("File properties")+TAB+key;
    xfeBindingsDict->insert("properties", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "move_to_trash", "Del");
    str = _("Move files to trash")+TAB+key;
    xfeBindingsDict->insert("move_to_trash", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "restore_from_trash", "Alt-Del");
    str = _("Restore files from trash")+TAB+key;
    xfeBindingsDict->insert("restore_from_trash", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "delete", "Shift-Del");
    str = _("Delete files")+TAB+key;
    xfeBindingsDict->insert("delete", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_window", "F3");
    str = _("Create new window")+TAB+key;
    xfeBindingsDict->insert("new_window", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_root_window", "Shift-F3");
    str = _("Create new root window")+TAB+key;
    xfeBindingsDict->insert("new_root_window", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "execute_command", "Ctrl-E");
    str = _("Execute command")+TAB+key;
    xfeBindingsDict->insert("execute_command", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "terminal", "Ctrl-T");
    str = _("Launch terminal")+TAB+key;
    xfeBindingsDict->insert("terminal", str.text());

#if defined(linux)
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mount", "Ctrl-M");
    str = _("Mount file system (Linux only)")+TAB+key;
    xfeBindingsDict->insert("mount", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "unmount", "Ctrl-U");
    str = _("Unmount file system (Linux only)")+TAB+key;
    xfeBindingsDict->insert("unmount", str.text());
#endif
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "one_panel", "Ctrl-F1");
    str = _("One panel mode")+TAB+key;
    xfeBindingsDict->insert("one_panel", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "tree_panel", "Ctrl-F2");
    str = _("Tree and panel mode")+TAB+key;
    xfeBindingsDict->insert("tree_panel", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "two_panels", "Ctrl-F3");
    str = _("Two panels mode")+TAB+key;
    xfeBindingsDict->insert("two_panels", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "tree_two_panels", "Ctrl-F4");
    str = _("Tree and two panels mode")+TAB+key;
    xfeBindingsDict->insert("tree_two_panels", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "clear_location", "Ctrl-L");
    str = _("Clear location bar")+TAB+key;
    xfeBindingsDict->insert("clear_location", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rename", "F2");
    str = _("Rename file")+TAB+key;
    xfeBindingsDict->insert("rename", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "copy_to", "F5");
    str = _("Copy files to location")+TAB+key;
    xfeBindingsDict->insert("copy_to", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "move_to", "F6");
    str = _("Move files to location")+TAB+key;
    xfeBindingsDict->insert("move_to", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "symlink_to", "Ctrl-S");
    str = _("Symlink files to location")+TAB+key;
    xfeBindingsDict->insert("symlink_to", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "add_bookmark", "Ctrl-B");
    str = _("Add bookmark")+TAB+key;
    xfeBindingsDict->insert("add_bookmark", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "synchronize_panels", "Ctrl-Y");
    str = _("Synchronize panels")+TAB+key;
    xfeBindingsDict->insert("synchronize_panels", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "switch_panels", "Ctrl-K");
    str = _("Switch panels")+TAB+key;
    xfeBindingsDict->insert("switch_panels", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_to_trash", "Ctrl-F8");
    str = _("Go to trash can")+TAB+key;
    xfeBindingsDict->insert("go_to_trash", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "empty_trash_can", "Ctrl-Del");
    str = _("Empty trash can")+TAB+key;
    xfeBindingsDict->insert("empty_trash_can", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "view", "Shift-F4");
    str = _("View")+TAB+key;
    xfeBindingsDict->insert("view", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "edit", "F4");
    str = _("Edit")+TAB+key;
    xfeBindingsDict->insert("edit", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "compare", "F8");
    str = _("Compare")+TAB+key;
    xfeBindingsDict->insert("compare", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_dirs", "Ctrl-F5");
    str = _("Toggle display hidden folders")+TAB+key;
    xfeBindingsDict->insert("hidden_dirs", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "filter", "Ctrl-D");
    str = _("Filter files")+TAB+key;
    xfeBindingsDict->insert("filter", str.text());


    // Key bindings specific to X File Image (Xfi)
    if (xfiBindingsDict == NULL)
    {
        xfiBindingsDict = new FXStringDict();
    }

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_100", "Ctrl-I");
    str = _("Zoom image to 100%")+TAB+key;
    xfiBindingsDict->insert("zoom_100", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_win", "Ctrl-F");
    str = _("Zoom to fit window")+TAB+key;
    xfiBindingsDict->insert("zoom_win", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_left", "Ctrl-L");
    str = _("Rotate image to left")+TAB+key;
    xfiBindingsDict->insert("rotate_left", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_right", "Ctrl-R");
    str = _("Rotate image to right")+TAB+key;
    xfiBindingsDict->insert("rotate_right", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_horizontally", "Ctrl-Shift-H");
    str = _("Mirror image horizontally")+TAB+key;
    xfiBindingsDict->insert("mirror_horizontally", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_vertically", "Ctrl-Shift-V");
    str = _("Mirror image vertically")+TAB+key;
    xfiBindingsDict->insert("mirror_vertically", str.text());

    // Key bindings specific to X File Write (Xfw)
    if (xfwBindingsDict == NULL)
    {
        xfwBindingsDict = new FXStringDict();
    }

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new", "Ctrl-N");
    str = _("Create new document")+TAB+key;
    xfwBindingsDict->insert("new", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "save", "Ctrl-S");
    str = _("Save changes to file")+TAB+key;
    xfwBindingsDict->insert("save", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "goto_line", "Ctrl-L");
    str = _("Goto line")+TAB+key;
    xfwBindingsDict->insert("goto_line", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "undo", "Ctrl-Z");
    str = _("Undo last change")+TAB+key;
    xfwBindingsDict->insert("undo", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "redo", "Ctrl-Y");
    str = _("Redo last change")+TAB+key;
    xfwBindingsDict->insert("redo", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "replace", "Ctrl-R");
    str = _("Replace string")+TAB+key;
    xfwBindingsDict->insert("replace", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "word_wrap", "Ctrl-K");
    str = _("Toggle word wrap mode")+TAB+key;
    xfwBindingsDict->insert("word_wrap", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "line_numbers", "Ctrl-T");
    str = _("Toggle line numbers mode")+TAB+key;
    xfwBindingsDict->insert("line_numbers", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "lower_case", "Ctrl-U");
    str = _("Toggle lower case mode")+TAB+key;
    xfwBindingsDict->insert("lower_case", str.text());

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "upper_case", "Ctrl-Shift-U");
    str = _("Toggle upper case mode")+TAB+key;
    xfwBindingsDict->insert("upper_case", str.text());

    // Display the key bindings dialog box
    if (bindingsbox == NULL)
    {
        bindingsbox = new KeybindingsBox(this, glbBindingsDict, xfeBindingsDict, xfiBindingsDict, xfwBindingsDict);
    }

    bindingsbox->execute(PLACEMENT_OWNER);

    return(1);
}


// Restore default key bindings
long PreferencesBox::onCmdRestoreKeyBindings(FXObject*, FXSelector, void*)
{
    // Confirmation message
    FXString   message = _("Do you really want to restore the default key bindings?\n\nAll your customizations will be lost!");
    MessageBox box(this, _("Restore default key bindings"), message, keybindingsicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);

    if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
    {
        return(0);
    }

    // Write default key bindings to the registry

    // Global key bindings
    getApp()->reg().writeStringEntry("KEYBINDINGS", "go_back", "Ctrl-Backspace");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "go_forward", "Shift-Backspace");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "go_up", "Backspace");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "go_home", "Ctrl-H");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "new_file", "Ctrl-N");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "new_folder", "F7");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "copy", "Ctrl-C");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "cut", "Ctrl-X");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "paste", "Ctrl-V");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "big_icons", "F10");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "small_icons", "F11");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "detailed_file_list", "F12");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "open", "Ctrl-O");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "quit", "Ctrl-Q");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "select_all", "Ctrl-A");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "deselect_all", "Ctrl-Z");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "invert_selection", "Ctrl-I");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "help", "F1");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "go_work", "Shift-F2");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "close", "Ctrl-W");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "print", "Ctrl-P");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "search", "Ctrl-F");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "search_prev", "Ctrl-Shift-G");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "search_next", "Ctrl-G");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "vert_panels", "Ctrl-Shift-F1");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "horz_panels", "Ctrl-Shift-F2");

    // Key bindings specific to X File Explorer (Xfe)
    getApp()->reg().writeStringEntry("KEYBINDINGS", "refresh", "Ctrl-R");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "new_symlink", "Ctrl-J");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "properties", "F9");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "move_to_trash", "Del");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "restore_from_trash", "Alt-Del");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "delete", "Shift-Del");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "new_window", "F3");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "new_root_window", "Shift-F3");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "execute_command", "Ctrl-E");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "terminal", "Ctrl-T");
#if defined(linux)
    getApp()->reg().writeStringEntry("KEYBINDINGS", "mount", "Ctrl-M");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "unmount", "Ctrl-U");
#endif
    getApp()->reg().writeStringEntry("KEYBINDINGS", "one_panel", "Ctrl-F1");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "tree_panel", "Ctrl-F2");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "two_panels", "Ctrl-F3");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "tree_two_panels", "Ctrl-F4");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "clear_location", "Ctrl-L");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "rename", "F2");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "copy_to", "F5");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "move_to", "F6");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "symlink_to", "Ctrl-S");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "add_bookmark", "Ctrl-B");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "synchronize_panels", "Ctrl-Y");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "switch_panels", "Ctrl-K");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "go_to_trash", "Ctrl-F8");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "empty_trash_can", "Ctrl-Del");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "view", "Shift-F4");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "edit", "F4");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "compare", "F8");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "hidden_dirs", "Ctrl-F5");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "filter", "Ctrl-D");

    // Key bindings specific to X File Image (Xfi)
    getApp()->reg().writeStringEntry("KEYBINDINGS", "zoom_100", "Ctrl-I");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "zoom_win", "Ctrl-F");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "rotate_left", "Ctrl-L");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "rotate_right", "Ctrl-R");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "mirror_horizontally", "Ctrl-Shift-H");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "mirror_vertically", "Ctrl-Shift-V");

    // Key bindings specific to X File Write (Xfw)
    getApp()->reg().writeStringEntry("KEYBINDINGS", "new", "Ctrl-N");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "save", "Ctrl-S");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "goto_line", "Ctrl-L");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "undo", "Ctrl-Z");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "redo", "Ctrl-Y");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "replace", "Ctrl-R");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "word_wrap", "Ctrl-K");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "line_numbers", "Ctrl-T");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "lower_case", "Ctrl-U");
    getApp()->reg().writeStringEntry("KEYBINDINGS", "upper_case", "Ctrl-Shift-U");

    // Finally, update the registry
    getApp()->reg().write();

    // Ask the user if he wants to restart Xfe
    if (BOX_CLICKED_CANCEL != MessageBox::question(this, BOX_OK_CANCEL, _("Restart"), _("Key bindings will be changed after restart.\nRestart X File Explorer now?")))
    {
        mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_RESTART), NULL);
    }

    return(1);
}


long PreferencesBox::onCmdAccept(FXObject* o, FXSelector s, void* p)
{
    FXbool restart_theme = false;
    FXbool restart_smoothscroll = false;
    FXbool restart_scrollbarsize = false;
    FXbool restart_pathlink = false;
    FXbool restart_controls = false;
    FXbool restart_normalfont = false;
    FXbool restart_textfont = false;

    if (iconpath->getText() == "")
    {
        iconpath->setText(oldiconpath);
    }

    // Icon path has changed
    if (oldiconpath != iconpath->getText())
    {
        getApp()->reg().writeStringEntry("SETTINGS", "iconpath", iconpath->getText().text());
        getApp()->reg().write();
        restart_theme = true;
    }

    // Normal font has changed
    if (oldnormalfont != normalfont->getText())
    {
        getApp()->reg().writeStringEntry("SETTINGS", "font", normalfont->getText().text());
        getApp()->reg().write();
        restart_normalfont = true;
    }

    // Text font has changed
    if (oldtextfont != textfont->getText())
    {
        getApp()->reg().writeStringEntry("SETTINGS", "textfont", textfont->getText().text());
        getApp()->reg().write();
        restart_textfont = true;
    }

    // Note: code below is for compatibility with pre 1.40 Xfe versions
    // To be removed in the future!

    // Text viewer has changed
    if (oldtxtviewer != txtviewer->getText())
    {
        // Update the txtviewer string
        FXString newtxtviewer = txtviewer->getText().text();
        getApp()->reg().writeStringEntry("PROGS", "txtviewer", newtxtviewer.text());

        // Update each filetype where the old txtviewer was used
        FXStringDict* strdict = getApp()->reg().find("FILETYPES");
        FileDict*     assoc = new FileDict(getApp());

        FXString key, value, newvalue;
        FXString strtmp, open, view, edit, command;
        for (int i = strdict->first(); i < strdict->size(); i = strdict->next(i))
        {
            // Read key and value of each filetype
            key = strdict->key(i);
            value = strdict->data(i);

            // Replace the old txtviewer string with the new one
            if (value.contains(oldtxtviewer))
            {
                // Obtain the open, view, edit and command strings
                strtmp = value.before(';', 1);
                command = value.after(';', 1);
                open = strtmp.section(',', 0);
                view = strtmp.section(',', 1);
                edit = strtmp.section(',', 2);

                // Replace only the view string, if needed
                if (view == oldtxtviewer)
                {
                    //view=newtxtviewer;
                    view = "<txtviewer>";
                }

                // Replace with the new value
                value = open + "," + view + "," + edit + ";" + command;
                assoc->replace(key.text(), value.text());
            }
        }
    }

    // Text editor has changed
    if (oldtxteditor != txteditor->getText())
    {
        // Update the txteditor string
        FXString newtxteditor = txteditor->getText().text();
        getApp()->reg().writeStringEntry("PROGS", "txteditor", newtxteditor.text());

        // Note: code below is for compatibility with pre 1.40 Xfe versions
        // To be removed in the future!

        // Update each filetype where the old txteditor was used
        FXStringDict* strdict = getApp()->reg().find("FILETYPES");
        FileDict*     assoc = new FileDict(getApp());

        FXString key, value, newvalue;
        FXString strtmp, open, view, edit, command;
        for (int i = strdict->first(); i < strdict->size(); i = strdict->next(i))
        {
            // Read key and value of each filetype
            key = strdict->key(i);
            value = strdict->data(i);

            // Replace the old txteditor string with the new one
            if (value.contains(oldtxteditor))
            {
                // Obtain the open, view, edit and command strings
                strtmp = value.before(';', 1);
                command = value.after(';', 1);
                open = strtmp.section(',', 0);
                view = strtmp.section(',', 1);
                edit = strtmp.section(',', 2);

                // Replace only the open and edit strings, if needed
                if (open == oldtxteditor)
                {
                    //open=newtxteditor;
                    open = "<txteditor>";
                }
                if (edit == oldtxteditor)
                {
                    //edit=newtxteditor;
                    edit = "<txteditor>";
                }

                // Replace with the new value
                value = open + "," + view + "," + edit + ";" + command;
                assoc->replace(key.text(), value.text());
            }
        }
    }

    // File comparator has changed
    if (oldfilecomparator != filecomparator->getText())
    {
        // Update the filecomparator string
        FXString newfilecomparator = filecomparator->getText().text();
        getApp()->reg().writeStringEntry("PROGS", "filecomparator", newfilecomparator.text());
    }

    // Image editor has changed
    if (oldimgeditor != imgeditor->getText())
    {
        // Update the imgeditor string
        FXString newimgeditor = imgeditor->getText().text();
        getApp()->reg().writeStringEntry("PROGS", "imgeditor", newimgeditor.text());

        // Note: code below is for compatibility with pre 1.40 Xfe versions
        // To be removed in the future!

        // Update each filetype where the old imgeditor was used
        FXStringDict* strdict = getApp()->reg().find("FILETYPES");
        FileDict*     assoc = new FileDict(getApp());

        FXString key, value, newvalue;
        FXString strtmp, open, view, edit, command;
        for (int i = strdict->first(); i < strdict->size(); i = strdict->next(i))
        {
            // Read key and value of each filetype
            key = strdict->key(i);
            value = strdict->data(i);

            // Replace the old imgeditor string with the new one
            if (value.contains(oldimgeditor))
            {
                // Obtain the open, view, edit and command strings
                strtmp = value.before(';', 1);
                command = value.after(';', 1);
                open = strtmp.section(',', 0);
                view = strtmp.section(',', 1);
                edit = strtmp.section(',', 2);

                // Replace only the open and edit strings, if needed
                if (open == oldimgeditor)
                {
                    //open=newimgeditor;
                    open = "<imgeditor>";
                }
                if (edit == oldimgeditor)
                {
                    //edit=newimgeditor;
                    edit = "<imgeditor>";
                }

                // Replace with the new value
                value = open + "," + view + "," + edit + ";" + command;
                assoc->replace(key.text(), value.text());
            }
        }
    }

    // Image viewer has changed
    if (oldimgviewer != imgviewer->getText())
    {
        // Update the imgviewer string
        FXString newimgviewer = imgviewer->getText().text();
        getApp()->reg().writeStringEntry("PROGS", "imgviewer", newimgviewer.text());

        // Note: code below is for compatibility with pre 1.40 Xfe versions
        // To be removed in the future!

        // Update each filetype where the old imgviewer was used
        FXStringDict* strdict = getApp()->reg().find("FILETYPES");
        FileDict*     assoc = new FileDict(getApp());

        FXString key, value, newvalue;
        FXString strtmp, open, view, edit, command;
        for (int i = strdict->first(); i < strdict->size(); i = strdict->next(i))
        {
            // Read key and value of each filetype
            key = strdict->key(i);
            value = strdict->data(i);

            // Replace the old imgviewer string with the new one
            if (value.contains(oldimgviewer))
            {
                // Obtain the open, view, edit and command strings
                strtmp = value.before(';', 1);
                command = value.after(';', 1);
                open = strtmp.section(',', 0);
                view = strtmp.section(',', 1);
                edit = strtmp.section(',', 2);

                // Replace the open and view string, if needed
                if (open == oldimgviewer)
                {
                    //open=newimgviewer;
                    open = "<imgviewer>";
                }
                if (view == oldimgviewer)
                {
                    //view=newimgviewer;
                    view = "<imgviewer>";
                }

                // Replace with the new value
                value = open + "," + view + "," + edit + ";" + command;
                assoc->replace(key.text(), value.text());
            }
        }
    }

    // Archiver has changed
    if (oldarchiver != archiver->getText())
    {
        // Update the archiver string
        FXString newarchiver = archiver->getText().text();
        getApp()->reg().writeStringEntry("PROGS", "archiver", newarchiver.text());

        // Note: code below is for compatibility with pre 1.40 Xfe versions
        // To be removed in the future!

        // Update each filetype where the old archiver was used
        FXStringDict* strdict = getApp()->reg().find("FILETYPES");
        FileDict*     assoc = new FileDict(getApp());

        FXString key, value, newvalue;
        FXString strtmp, open, view, edit, command;
        for (int i = strdict->first(); i < strdict->size(); i = strdict->next(i))
        {
            // Read key and value of each filetype
            key = strdict->key(i);
            value = strdict->data(i);

            // Replace the old archiver string with the new one
            if (value.contains(oldarchiver))
            {
                // Obtain the open, view, edit and command strings
                strtmp = value.before(';', 1);
                command = value.after(';', 1);
                open = strtmp.section(',', 0);
                view = strtmp.section(',', 1);
                edit = strtmp.section(',', 2);

                // Replace the open, view and edit strings, if needed
                if (open == oldarchiver)
                {
                    //open=newarchiver;
                    open = "<archiver>";
                }
                if (view == oldarchiver)
                {
                    //view=newarchiver;
                    view = "<archiver>";
                }
                if (edit == oldarchiver)
                {
                    //edit=newarchiver;
                    edit = "<archiver>";
                }

                // Replace with the new value
                value = open + "," + view + "," + edit + ";" + command;
                assoc->replace(key.text(), value.text());
            }
        }
    }

    // PDF viewer has changed
    if (oldpdfviewer != pdfviewer->getText())
    {
        // Update the PDF viewer string
        FXString newpdfviewer = pdfviewer->getText().text();
        getApp()->reg().writeStringEntry("PROGS", "pdfviewer", newpdfviewer.text());

        // Note: code below is for compatibility with pre 1.40 Xfe versions
        // To be removed in the future!

        // Update each filetype where the old PDF viewer was used
        FXStringDict* strdict = getApp()->reg().find("FILETYPES");
        FileDict*     assoc = new FileDict(getApp());

        FXString key, value, newvalue;
        FXString strtmp, open, view, edit, command;
        for (int i = strdict->first(); i < strdict->size(); i = strdict->next(i))
        {
            // Read key and value of each filetype
            key = strdict->key(i);
            value = strdict->data(i);

            // Replace the old PDF viewer string with the new one
            if (value.contains(oldpdfviewer))
            {
                // Obtain the open, view, edit and command strings
                strtmp = value.before(';', 1);
                command = value.after(';', 1);
                open = strtmp.section(',', 0);
                view = strtmp.section(',', 1);
                edit = strtmp.section(',', 2);

                // Replace the open, view and edit strings, if needed
                if (open == oldpdfviewer)
                {
                    //open=newpdfviewer;
                    open = "<pdfviewer>";
                }
                if (view == oldpdfviewer)
                {
                    //view=newpdfviewer;
                    view = "<pdfviewer>";
                }

                // Replace with the new value
                value = open + "," + view + "," + edit + ";" + command;
                assoc->replace(key.text(), value.text());
            }
        }
    }

    // Audio player has changed
    if (oldaudioplayer != audioplayer->getText())
    {
        // Update the audio player string
        FXString newaudioplayer = audioplayer->getText().text();
        getApp()->reg().writeStringEntry("PROGS", "audioplayer", newaudioplayer.text());

        // Note: code below is for compatibility with pre 1.40 Xfe versions
        // To be removed in the future!

        // Update each filetype where the old audio player was used
        FXStringDict* strdict = getApp()->reg().find("FILETYPES");
        FileDict*     assoc = new FileDict(getApp());

        FXString key, value, newvalue;
        FXString strtmp, open, view, edit, command;
        for (int i = strdict->first(); i < strdict->size(); i = strdict->next(i))
        {
            // Read key and value of each filetype
            key = strdict->key(i);
            value = strdict->data(i);

            // Replace the old audio player string with the new one
            if (value.contains(oldaudioplayer))
            {
                // Obtain the open, view, edit and command strings
                strtmp = value.before(';', 1);
                command = value.after(';', 1);
                open = strtmp.section(',', 0);
                view = strtmp.section(',', 1);
                edit = strtmp.section(',', 2);

                // Replace the open, view and edit strings, if needed
                if (open == oldaudioplayer)
                {
                    //open=newaudioplayer;
                    open = "<audioplayer>";
                }
                if (view == oldaudioplayer)
                {
                    //view=newaudioplayer;
                    view = "<audioplayer>";
                }

                // Replace with the new value
                value = open + "," + view + "," + edit + ";" + command;
                assoc->replace(key.text(), value.text());
            }
        }
    }

    // Video player has changed
    if (oldvideoplayer != videoplayer->getText())
    {
        // Update the video player string
        FXString newvideoplayer = videoplayer->getText().text();
        getApp()->reg().writeStringEntry("PROGS", "videoplayer", newvideoplayer.text());

        // Note: code below is for compatibility with pre 1.40 Xfe versions
        // To be removed in the future!

        // Update each filetype where the old video player was used
        FXStringDict* strdict = getApp()->reg().find("FILETYPES");
        FileDict*     assoc = new FileDict(getApp());

        FXString key, value, newvalue;
        FXString strtmp, open, view, edit, command;
        for (int i = strdict->first(); i < strdict->size(); i = strdict->next(i))
        {
            // Read key and value of each filetype
            key = strdict->key(i);
            value = strdict->data(i);

            // Replace the old video player string with the new one
            if (value.contains(oldvideoplayer))
            {
                // Obtain the open, view, edit and command strings
                strtmp = value.before(';', 1);
                command = value.after(';', 1);
                open = strtmp.section(',', 0);
                view = strtmp.section(',', 1);
                edit = strtmp.section(',', 2);

                // Replace the open, view and edit strings, if needed
                if (open == oldvideoplayer)
                {
                    //open=newvideoplayer;
                    open = "<videoplayer>";
                }
                if (view == oldvideoplayer)
                {
                    //view=newvideoplayer;
                    view = "<videoplayer>";
                }

                // Replace with the new value
                value = open + "," + view + "," + edit + ";" + command;
                assoc->replace(key.text(), value.text());
            }
        }
    }

    // Terminal has changed
    if (oldxterm != xterm->getText())
    {
        getApp()->reg().writeStringEntry("PROGS", "xterm", xterm->getText().text());
    }

    // Mount command has changed
    if (oldmountcmd != mountcmd->getText())
    {
        getApp()->reg().writeStringEntry("PROGS", "mount", mountcmd->getText().text());
    }

    // Unmount command has changed
    if (oldumountcmd != umountcmd->getText())
    {
        getApp()->reg().writeStringEntry("PROGS", "unmount", umountcmd->getText().text());
    }


    getApp()->reg().writeUnsignedEntry("OPTIONS", "auto_save_layout", autosave->getCheck());
    getApp()->reg().writeUnsignedEntry("SETTINGS", "save_win_pos", savewinpos->getCheck());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "use_trash_can", trashcan->getCheck());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "use_trash_bypass", trashbypass->getCheck());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "ask_before_copy", ask->getCheck());
    getApp()->reg().writeUnsignedEntry("SETTINGS", "single_click", single_click);
    getApp()->reg().writeStringEntry("SETTINGS", "time_format", timeformat->getText().text());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "confirm_trash", trashmv->getCheck());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "confirm_delete", del->getCheck());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "confirm_properties", properties->getCheck());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "confirm_delete_emptydir", del_emptydir->getCheck());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "confirm_overwrite", overwrite->getCheck());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "confirm_execute", exec->getCheck());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "confirm_drag_and_drop", dnd->getCheck());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "folder_warn", folder_warning->getCheck());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "preserve_date_warn", preserve_date_warning->getCheck());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "startdir_mode", startdirmode-ID_START_HOMEDIR);
    getApp()->reg().writeUnsignedEntry("OPTIONS", "root_warn", root_warning->getCheck());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "root_mode", rootmode->getCheck());
#ifdef STARTUP_NOTIFICATION
    getApp()->reg().writeUnsignedEntry("OPTIONS", "use_startup_notification", usesn->getCheck());
#endif
#if defined(linux)
    getApp()->reg().writeUnsignedEntry("OPTIONS", "mount_warn", mount->getCheck());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "mount_messages", show_mount->getCheck());
#endif

    // Smooth scrolling
    getApp()->reg().writeUnsignedEntry("SETTINGS", "smooth_scroll", scroll->getCheck());
    if (scroll->getCheck() != smoothscroll_prev)
    {
        getApp()->reg().write();
        restart_smoothscroll = true;
    }

    // Scrollbar size
    if (getApp()->getScrollBarSize() != scrollbarsize_prev)
    {
        getApp()->reg().write();
        restart_scrollbarsize = true;
    }

    // Control themes
    getApp()->reg().writeUnsignedEntry("SETTINGS", "use_clearlooks", use_clearlooks);

    if (use_clearlooks != use_clearlooks_prev)
    {
        FXColor hilitecolor, shadowcolor;

        // Change control hilite and shadow colors when the control theme has changed
        if (use_clearlooks) // clearlooks
        {
            hilitecolor = makeHiliteColorGradient(currTheme.color[0]);
            shadowcolor = makeShadowColorGradient(currTheme.color[0]);
        }
        else // standard
        {
            hilitecolor = makeHiliteColor(currTheme.color[0]);
            shadowcolor = makeShadowColor(currTheme.color[0]);
        }
        getApp()->reg().writeColorEntry("SETTINGS", "hilitecolor", hilitecolor);
        getApp()->reg().writeColorEntry("SETTINGS", "shadowcolor", shadowcolor);

        getApp()->reg().write();
        restart_controls = true;
    }

    // Update some global options
    if (diropen->getCheck() && fileopen->getCheck())
    {
        single_click = SINGLE_CLICK_DIR_FILE;
    }
    else if (diropen->getCheck() && !fileopen->getCheck())
    {
        single_click = SINGLE_CLICK_DIR;
    }
    else
    {
        single_click = SINGLE_CLICK_NONE;
    }

    if (single_click == SINGLE_CLICK_DIR_FILE)
    {
        ((XFileExplorer*)mainWindow)->setDefaultCursor(getApp()->getDefaultCursor(DEF_HAND_CURSOR));
    }
    else
    {
        ((XFileExplorer*)mainWindow)->setDefaultCursor(getApp()->getDefaultCursor(DEF_ARROW_CURSOR));
    }

    // Update the file tooltips flag
    if (filetooltips->getCheck())
    {
        file_tooltips = true;
    }
    else
    {
        file_tooltips = false;
    }
    getApp()->reg().writeUnsignedEntry("SETTINGS", "file_tooltips", (FXuint)file_tooltips);

    // Update the relative resize flag
    if (relativeresize->getCheck())
    {
        relative_resize = true;
    }
    else
    {
        relative_resize = false;
    }
    getApp()->reg().writeUnsignedEntry("SETTINGS", "relative_resize", (FXuint)relative_resize);

    // Update the display path linker flag
    show_pathlink = showpathlink->getCheck();
    getApp()->reg().writeUnsignedEntry("SETTINGS", "show_pathlinker", show_pathlink);
    if (show_pathlink != show_pathlink_prev)
    {
        getApp()->reg().write();
        restart_pathlink = true;
    }

    // Theme has changed
    if (currTheme != Themes[0])
    {
        getApp()->reg().writeColorEntry("SETTINGS", "basecolor", currTheme.color[0]);
        getApp()->reg().writeColorEntry("SETTINGS", "bordercolor", currTheme.color[1]);
        getApp()->reg().writeColorEntry("SETTINGS", "backcolor", currTheme.color[2]);
        getApp()->reg().writeColorEntry("SETTINGS", "forecolor", currTheme.color[3]);
        getApp()->reg().writeColorEntry("SETTINGS", "selbackcolor", currTheme.color[4]);
        getApp()->reg().writeColorEntry("SETTINGS", "selforecolor", currTheme.color[5]);
        getApp()->reg().writeColorEntry("SETTINGS", "listbackcolor", currTheme.color[6]);
        getApp()->reg().writeColorEntry("SETTINGS", "listforecolor", currTheme.color[7]);
        getApp()->reg().writeColorEntry("SETTINGS", "highlightcolor", currTheme.color[8]);
        getApp()->reg().writeColorEntry("SETTINGS", "pbarcolor", currTheme.color[9]);
        getApp()->reg().writeColorEntry("SETTINGS", "attentioncolor", currTheme.color[10]);
        getApp()->reg().writeColorEntry("SETTINGS", "scrollbarcolor", currTheme.color[11]);

        // Control themes
        FXColor hilitecolor, shadowcolor;

        // Change control hilite and shadow colors when the control theme has changed
        if (use_clearlooks) // clearlooks
        {
            hilitecolor = makeHiliteColorGradient(currTheme.color[0]);
            shadowcolor = makeShadowColorGradient(currTheme.color[0]);
        }
        else // standard
        {
            hilitecolor = makeHiliteColor(currTheme.color[0]);
            shadowcolor = makeShadowColor(currTheme.color[0]);
        }
        getApp()->reg().writeColorEntry("SETTINGS", "hilitecolor", hilitecolor);
        getApp()->reg().writeColorEntry("SETTINGS", "shadowcolor", shadowcolor);

        getApp()->reg().write();
        restart_theme = true;
    }

    // Restart application if necessary
    if (restart_smoothscroll | restart_scrollbarsize|restart_theme|restart_pathlink|restart_controls|restart_normalfont|restart_textfont)
    {
        if (BOX_CLICKED_CANCEL != MessageBox::question(this, BOX_OK_CANCEL, _("Restart"), _("Preferences will be changed after restart.\nRestart X File Explorer now?")))
        {
            mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_RESTART), NULL);
        }
    }

    // Finally, update the registry
    getApp()->reg().write();

    // Refresh panels
    mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_REFRESH), NULL);

    DialogBox::onCmdAccept(o, s, p);
    return(1);
}


long PreferencesBox::onCmdCancel(FXObject* o, FXSelector s, void* p)
{
    // Reset preferences to their previous values

    // First tab - Options
    trashcan->setCheck(trashcan_prev);
    trashbypass->setCheck(trashbypass_prev);
    autosave->setCheck(autosave_prev);
    savewinpos->setCheck(savewinpos_prev);
    diropen->setCheck(diropen_prev);
    fileopen->setCheck(fileopen_prev);
    filetooltips->setCheck(filetooltips_prev);
    relativeresize->setCheck(relativeresize_prev);
    showpathlink->setCheck(show_pathlink_prev);
    getApp()->setWheelLines(wheellines_prev);
    getApp()->setScrollBarSize(scrollbarsize_prev);
    use_sudo = use_sudo_prev;
    getApp()->reg().writeUnsignedEntry("OPTIONS", "use_sudo", use_sudo);
    scroll->setCheck(smoothscroll_prev);
    rootmode->setCheck(rootmode_prev);
    timeformat->setText(oldtimeformat);
    startdirmode = oldstartdirmode;

#ifdef STARTUP_NOTIFICATION
    usesn->setCheck(usesn_prev);
#endif

    // Second tab - Dialogs
    ask->setCheck(ask_prev);
    dnd->setCheck(dnd_prev);
    trashmv->setCheck(trashmv_prev);
    del->setCheck(del_prev);
    properties->setCheck(properties_prev);
    del_emptydir->setCheck(del_emptydir_prev);
    overwrite->setCheck(overwrite_prev);
    exec->setCheck(exec_prev);
#if defined(linux)
    mount->setCheck(mount_prev);
    show_mount->setCheck(show_mount_prev);
#endif
    folder_warning->setCheck(folder_warning_prev);
    preserve_date_warning->setCheck(preserve_date_warning_prev);
    root_warning->setCheck(root_warning_prev);

    // Third tab - Programs
    txtviewer->setText(oldtxtviewer);
    txteditor->setText(oldtxteditor);
    filecomparator->setText(oldfilecomparator);
    imgeditor->setText(oldimgeditor);
    imgviewer->setText(oldimgviewer);
    archiver->setText(oldarchiver);
    pdfviewer->setText(oldpdfviewer);
    audioplayer->setText(oldaudioplayer);
    videoplayer->setText(oldvideoplayer);
    xterm->setText(oldxterm);
    mountcmd->setText(oldmountcmd);
    umountcmd->setText(oldumountcmd);

    // Fourth tab - Visual
    themesList->setCurrentItem(themelist_prev);
    currTheme = currTheme_prev;
    iconpath->setText(oldiconpath);
    use_clearlooks = use_clearlooks_prev;
    getApp()->reg().writeUnsignedEntry("SETTINGS", "use_clearlooks", use_clearlooks);

    // Fifth tab - Fonts
    normalfont->setText(oldnormalfont);
    textfont->setText(oldtextfont);

    // Finally, update the registry (really necessary?)
    getApp()->reg().write();

    DialogBox::onCmdCancel(o, s, p);
    return(1);
}


// Execute dialog box modally
FXuint PreferencesBox::execute(FXuint placement)
{
    // Save current preferences to restore them if cancel is pressed

    // First tab - Options
    trashcan_prev = trashcan->getCheck();
    trashbypass_prev = trashbypass->getCheck();
    autosave_prev = autosave->getCheck();
    savewinpos_prev = savewinpos->getCheck();
    diropen_prev = diropen->getCheck();
    fileopen_prev = fileopen->getCheck();
    filetooltips_prev = filetooltips->getCheck();
    relativeresize_prev = relativeresize->getCheck();
    show_pathlink_prev = showpathlink->getCheck();
    wheellines_prev = getApp()->getWheelLines();
    scrollbarsize_prev = getApp()->getScrollBarSize();
    use_sudo_prev = use_sudo;
    smoothscroll_prev = scroll->getCheck();
    rootmode_prev = rootmode->getCheck();
#ifdef STARTUP_NOTIFICATION
    usesn_prev = usesn->getCheck();
#endif

    // Second tab - Dialogs
    ask_prev = ask->getCheck();
    dnd_prev = dnd->getCheck();
    trashmv_prev = trashmv->getCheck();
    del_prev = del->getCheck();
    properties_prev = properties->getCheck();
    del_emptydir_prev = del_emptydir->getCheck();
    overwrite_prev = overwrite->getCheck();
    exec_prev = exec->getCheck();
#if defined(linux)
    mount_prev = mount->getCheck();
    show_mount_prev = show_mount->getCheck();
#endif
    folder_warning_prev = folder_warning->getCheck();
    preserve_date_warning_prev = preserve_date_warning->getCheck();
    root_warning_prev = root_warning->getCheck();

    // Third tab - Programs
    oldtxtviewer = txtviewer->getText();
    oldtxteditor = txteditor->getText();
    oldfilecomparator = filecomparator->getText();
    oldimgeditor = imgeditor->getText();
    oldimgviewer = imgviewer->getText();
    oldarchiver = archiver->getText();
    oldpdfviewer = pdfviewer->getText();
    oldaudioplayer = audioplayer->getText();
    oldvideoplayer = videoplayer->getText();
    oldxterm = xterm->getText();
    oldmountcmd = mountcmd->getText();
    oldumountcmd = umountcmd->getText();

    // Fourth tab - Visual
    themelist_prev = themesList->getCurrentItem();
    currTheme_prev = currTheme;
    oldiconpath = iconpath->getText();
    use_clearlooks_prev = use_clearlooks;

    // Fifth tab - Fonts
    oldnormalfont = normalfont->getText();
    oldtextfont = textfont->getText();

    create();
    show(placement);
    getApp()->refresh();
    return(getApp()->runModalFor(this));
}


// Update buttons related to the trash can option item
long PreferencesBox::onUpdTrash(FXObject* o, FXSelector, void*)
{
    if (trashcan->getCheck())
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    return(1);
}


// Update the confirm delete empty directories option item
long PreferencesBox::onUpdConfirmDelEmptyDir(FXObject* o, FXSelector, void*)
{
    if (del->getCheck())
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    return(1);
}


// Set root mode
long PreferencesBox::onCmdSuMode(FXObject*, FXSelector sel, void*)
{
    if (FXSELID(sel) == ID_SU_CMD)
    {
        use_sudo = false;
    }

    else if (FXSELID(sel) == ID_SUDO_CMD)
    {
        use_sudo = true;
    }

    getApp()->reg().writeUnsignedEntry("OPTIONS", "use_sudo", use_sudo);
    getApp()->reg().write();

    return(1);
}


// Update root mode radio button
long PreferencesBox::onUpdSuMode(FXObject* sender, FXSelector sel, void*)
{
    if (!rootmode->getCheck())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), NULL);
    }
    else
    {
        if (getuid()) // Simple user
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), NULL);
        }

        FXSelector updatemessage = FXSEL(SEL_COMMAND, ID_UNCHECK);

        if (FXSELID(sel) == ID_SU_CMD)
        {
            if (use_sudo)
            {
                updatemessage = FXSEL(SEL_COMMAND, ID_UNCHECK);
            }
            else
            {
                updatemessage = FXSEL(SEL_COMMAND, ID_CHECK);
            }
        }
        else if (FXSELID(sel) == ID_SUDO_CMD)
        {
            if (use_sudo)
            {
                updatemessage = FXSEL(SEL_COMMAND, ID_CHECK);
            }
            else
            {
                updatemessage = FXSEL(SEL_COMMAND, ID_UNCHECK);
            }
        }
        sender->handle(this, updatemessage, NULL);
    }
    return(1);
}


// Set root mode
long PreferencesBox::onCmdControls(FXObject*, FXSelector sel, void*)
{
    if (FXSELID(sel) == ID_STANDARD_CONTROLS)
    {
        use_clearlooks = false;
    }

    else if (FXSELID(sel) == ID_CLEARLOOKS_CONTROLS)
    {
        use_clearlooks = true;
    }

    getApp()->reg().writeUnsignedEntry("SETTINGS", "use_clearlooks", use_clearlooks);
    getApp()->reg().write();

    return(1);
}


// Update root mode radio button
long PreferencesBox::onUpdControls(FXObject* sender, FXSelector sel, void*)
{
    FXSelector updatemessage = FXSEL(SEL_COMMAND, ID_UNCHECK);

    if (FXSELID(sel) == ID_STANDARD_CONTROLS)
    {
        if (use_clearlooks)
        {
            updatemessage = FXSEL(SEL_COMMAND, ID_UNCHECK);
        }
        else
        {
            updatemessage = FXSEL(SEL_COMMAND, ID_CHECK);
        }
    }
    else if (FXSELID(sel) == ID_CLEARLOOKS_CONTROLS)
    {
        if (use_clearlooks)
        {
            updatemessage = FXSEL(SEL_COMMAND, ID_CHECK);
        }
        else
        {
            updatemessage = FXSEL(SEL_COMMAND, ID_UNCHECK);
        }
    }
    sender->handle(this, updatemessage, NULL);
    return(1);
}


// Set scroll wheel lines (Mathew Robertson <mathew@optushome.com.au>)
long PreferencesBox::onCmdWheelAdjust(FXObject* sender, FXSelector, void*)
{
    FXuint value;

    sender->handle(this, FXSEL(SEL_COMMAND, ID_GETINTVALUE), (void*)&value);
    getApp()->setWheelLines(value);
    getApp()->reg().write();
    return(1);
}


// Update the wheel lines button
long PreferencesBox::onUpdWheelAdjust(FXObject* sender, FXSelector, void*)
{
    FXuint value = getApp()->getWheelLines();

    sender->handle(this, FXSEL(SEL_COMMAND, ID_SETINTVALUE), (void*)&value);
    return(1);
}


// Set scrollbar size
long PreferencesBox::onCmdScrollBarSize(FXObject* sender, FXSelector, void*)
{
    FXuint value;

    sender->handle(this, FXSEL(SEL_COMMAND, ID_GETINTVALUE), (void*)&value);
    getApp()->setScrollBarSize(value);
    getApp()->reg().write();
    return(1);
}


// Update the scrollbar size button
long PreferencesBox::onUpdScrollBarSize(FXObject* sender, FXSelector, void*)
{
    FXuint value = getApp()->getScrollBarSize();

    sender->handle(this, FXSEL(SEL_COMMAND, ID_SETINTVALUE), (void*)&value);
    return(1);
}


// Update single click file open button
long PreferencesBox::onUpdSingleClickFileopen(FXObject* o, FXSelector, void*)
{
    if (diropen->getCheck())
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        fileopen->setCheck(false);
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    return(1);
}


// Start directory mode
long PreferencesBox::onCmdStartDir(FXObject*, FXSelector sel, void*)
{
    startdirmode = FXSELID(sel);
    //~ getApp()->reg().writeUnsignedEntry("OPTIONS","startdir_mode",startdirmode-ID_START_HOMEDIR);
    //~ getApp()->reg().write();

    return(1);
}


// Update start directory mode radio buttons
long PreferencesBox::onUpdStartDir(FXObject* sender, FXSelector sel, void*)
{
    sender->handle(this, (FXSELID(sel) == startdirmode) ? FXSEL(SEL_COMMAND, ID_CHECK) : FXSEL(SEL_COMMAND, ID_UNCHECK), (void*)&startdirmode);
    return(1);
}
// Properties box

#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <unistd.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <signal.h>
#include <pwd.h>
#include <grp.h>
#if defined(linux)
#include <mntent.h>
#endif

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "File.h"
#include "DialogBox.h"
#include "FileDialog.h"
#include "FilePanel.h"
#include "XFileExplorer.h"
#include "MessageBox.h"
#include "Properties.h"



// Global variables
extern FXMainWindow* mainWindow;
extern FXStringDict* fsdevices;
extern FXString      xdgdatahome;


// Map
FXDEFMAP(PermFrame) PermFrameMap[] = {};

// Object implementation
FXIMPLEMENT(PermFrame, FXVerticalFrame, PermFrameMap, ARRAYNUMBER(PermFrameMap))

PermFrame::PermFrame(FXComposite* parent, FXObject* target) :
    FXVerticalFrame(parent, FRAME_RAISED)
{
    FXHorizontalFrame* accessframe = new FXHorizontalFrame(this, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    FXHorizontalFrame* chmodframe = new FXHorizontalFrame(this, LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Permissions
    FXGroupBox* group1 = new FXGroupBox(accessframe, _("User"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X);

    ur = new FXCheckButton(group1, _("Read"), target, PropertiesBox::ID_RUSR);
    uw = new FXCheckButton(group1, _("Write"), target, PropertiesBox::ID_WUSR);
    ux = new FXCheckButton(group1, _("Execute"), target, PropertiesBox::ID_XUSR);
    FXGroupBox* group2 = new FXGroupBox(accessframe, _("Group"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X);
    gr = new FXCheckButton(group2, _("Read"), target, PropertiesBox::ID_RGRP);
    gw = new FXCheckButton(group2, _("Write"), target, PropertiesBox::ID_WGRP);
    gx = new FXCheckButton(group2, _("Execute"), target, PropertiesBox::ID_XGRP);
    FXGroupBox* group3 = new FXGroupBox(accessframe, _("Others"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X);
    or_ = new FXCheckButton(group3, _("Read"), target, PropertiesBox::ID_ROTH);
    ow = new FXCheckButton(group3, _("Write"), target, PropertiesBox::ID_WOTH);
    ox = new FXCheckButton(group3, _("Execute"), target, PropertiesBox::ID_XOTH);
    FXGroupBox* group4 = new FXGroupBox(accessframe, _("Special"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X);
    suid = new FXCheckButton(group4, _("Set UID"), target, PropertiesBox::ID_SUID);
    sgid = new FXCheckButton(group4, _("Set GID"), target, PropertiesBox::ID_SGID);
    svtx = new FXCheckButton(group4, _("Sticky"), target, PropertiesBox::ID_SVTX);

    // Owner
    FXGroupBox* group5 = new FXGroupBox(chmodframe, _("Owner"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(group5, _("User"));
    user = new FXComboBox(group5, 5, NULL, 0, COMBOBOX_STATIC|LAYOUT_FILL_X);
    user->setNumVisible(5);
    new FXLabel(group5, _("Group"));
    grp = new FXComboBox(group5, 5, NULL, 0, COMBOBOX_STATIC|LAYOUT_FILL_X);
    grp->setNumVisible(5);

    // User names (sorted in ascending order)
    struct passwd* pwde;
    while ((pwde = getpwent()))
    {
        user->appendItem(pwde->pw_name);
    }
    endpwent();
    user->setSortFunc(FXList::ascending);
    user->sortItems();

    // Group names (sorted in ascending order)
    struct group* grpe;
    while ((grpe = getgrent()))
    {
        grp->appendItem(grpe->gr_name);
    }
    endgrent();
    grp->setSortFunc(FXList::ascending);
    grp->sortItems();

    // Initializations
    cmd = 0;
    flt = 0;

    // Command
    FXGroupBox* group6 = new FXGroupBox(chmodframe, _("Command"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    FXMatrix*   matrix6 = new FXMatrix(group6, 2, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    cmd_radiotarget.connect(cmd);
    set = new FXRadioButton(matrix6, _("Set marked"), &cmd_radiotarget, FXDataTarget::ID_OPTION+PropertiesBox::ID_SET);
    rec = new FXCheckButton(matrix6, _("Recursively"), NULL, 0);
    clear = new FXRadioButton(matrix6, _("Clear marked"), &cmd_radiotarget, FXDataTarget::ID_OPTION+PropertiesBox::ID_CLEAR);
    flt_radiotarget.connect(flt);
    all = new FXRadioButton(matrix6, _("Files and folders"), &flt_radiotarget, FXDataTarget::ID_OPTION+PropertiesBox::ID_ALL);
    add = new FXRadioButton(matrix6, _("Add marked"), &cmd_radiotarget, FXDataTarget::ID_OPTION+PropertiesBox::ID_ADD);
    dironly = new FXRadioButton(matrix6, _("Folders only"), &flt_radiotarget, FXDataTarget::ID_OPTION+PropertiesBox::ID_DIRONLY);
    own = new FXCheckButton(matrix6, _("Owner only"), NULL, 0);
    fileonly = new FXRadioButton(matrix6, _("Files only"), &flt_radiotarget, FXDataTarget::ID_OPTION+PropertiesBox::ID_FILEONLY);
}


// Map
FXDEFMAP(PropertiesBox) PropertiesBoxMap[] =
{
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_ACCEPT_SINGLE, PropertiesBox::onCmdAcceptSingle),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_ACCEPT_MULT, PropertiesBox::onCmdAcceptMult),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_CANCEL, PropertiesBox::onCmdCancel),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_RUSR, PropertiesBox::onCmdCheck),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_WUSR, PropertiesBox::onCmdCheck),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_XUSR, PropertiesBox::onCmdCheck),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_RGRP, PropertiesBox::onCmdCheck),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_WGRP, PropertiesBox::onCmdCheck),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_XGRP, PropertiesBox::onCmdCheck),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_ROTH, PropertiesBox::onCmdCheck),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_WOTH, PropertiesBox::onCmdCheck),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_XOTH, PropertiesBox::onCmdCheck),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_SUID, PropertiesBox::onCmdCheck),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_SGID, PropertiesBox::onCmdCheck),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_SVTX, PropertiesBox::onCmdCheck),
    FXMAPFUNC(SEL_UPDATE, 0, PropertiesBox::onUpdSizeAndPerm),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_SET, PropertiesBox::onCmdCommand),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_CLEAR, PropertiesBox::onCmdCommand),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_ADD, PropertiesBox::onCmdCommand),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_DIRONLY, PropertiesBox::onCmdFilter),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_FILEONLY, PropertiesBox::onCmdFilter),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_ALL, PropertiesBox::onCmdFilter),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_BIG_ICON, PropertiesBox::onCmdBrowseIcon),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_MINI_ICON, PropertiesBox::onCmdBrowseIcon),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_BROWSE_OPEN, PropertiesBox::onCmdBrowse),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_BROWSE_VIEW, PropertiesBox::onCmdBrowse),
    FXMAPFUNC(SEL_COMMAND, PropertiesBox::ID_BROWSE_EDIT, PropertiesBox::onCmdBrowse),
    FXMAPFUNC(SEL_KEYPRESS, 0, PropertiesBox::onCmdKeyPress),
    FXMAPFUNC(SEL_CHORE, PropertiesBox::ID_WATCHPROCESS, PropertiesBox::onWatchProcess),
#ifdef STARTUP_NOTIFICATION
    FXMAPFUNC(SEL_UPDATE, PropertiesBox::ID_SNDISABLE, PropertiesBox::onUpdSnDisable),
#endif
};

// Object implementation
FXIMPLEMENT(PropertiesBox, DialogBox, PropertiesBoxMap, ARRAYNUMBER(PropertiesBoxMap))

// Construct window for one file
PropertiesBox::PropertiesBox(FXWindow* win, FXString file, FXString path) : DialogBox(win, _("Properties"), DECOR_TITLE|DECOR_BORDER|DECOR_MAXIMIZE|DECOR_STRETCHABLE|DECOR_CLOSE)
{
    FXulong     filesize;
    FXString    mod, changed, accessed;
    FXString    grpid, usrid;
    FXLabel*    sizelabel = NULL;
    struct stat linfo;
    FXString    type = "", extension, extension2, fileassoc;
    FXbool      isLink, isBrokenLink;
    FXString    pathname, referredpath;
    char        mnttype[64], used[64], avail[64], pctr[64], size[64];
    char        buf[MAXPATHLEN+1];
    FXString    hsize;
    FILE*       p;

    // Trash locations
    trashfileslocation = xdgdatahome + PATHSEPSTRING TRASHFILESPATH;
    trashinfolocation = xdgdatahome + PATHSEPSTRING TRASHINFOPATH;

    // Buttons
    FXHorizontalFrame* buttons = new FXHorizontalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X, 0, 0, 0, 0, 10, 10, 5, 5);

    // Contents
    FXVerticalFrame* contents = new FXVerticalFrame(this, LAYOUT_SIDE_TOP|FRAME_NONE|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Accept
    if (file != "..")
    {
        FXButton* ok = new FXButton(buttons, _("&Accept"), NULL, this, PropertiesBox::ID_ACCEPT_SINGLE, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
        ok->addHotKey(KEY_Return);
    }

    // Cancel
    new FXButton(buttons, _("&Cancel"), NULL, this, PropertiesBox::ID_CANCEL, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);

    // Switcher
    FXTabBook* tabbook = new FXTabBook(contents, NULL, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y|LAYOUT_RIGHT);

    // First item is General
    new FXTabItem(tabbook, _("&General"), NULL);
    FXPacker*        genpack = new FXPacker(tabbook, FRAME_RAISED);
    FXGroupBox*      generalgroup = new FXGroupBox(genpack, FXString::null, FRAME_NONE|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    FXVerticalFrame* generalframe = new FXVerticalFrame(generalgroup, LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Second item is Access Permissions
    FXTabItem* permtab = new FXTabItem(tabbook, _("&Permissions"), NULL);
    perm = new PermFrame(tabbook, this);

    // Permission tab is disabled for parent directory
    if (file == "..")
    {
        permtab->disable();
    }

    // Third tab - file associations
    FXTabItem*       fassoctab = new FXTabItem(tabbook, _("&File Associations"), NULL);
    FXPacker*        fassocpack = new FXPacker(tabbook, FRAME_RAISED);
    FXGroupBox*      fassocgroup = new FXGroupBox(fassocpack, FXString::null, FRAME_NONE|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    FXVerticalFrame* contassoc = new FXVerticalFrame(fassocgroup, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    FXMatrix*        matrix = new FXMatrix(contassoc, 3, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    fassoctab->disable();
    new FXLabel(matrix, _("Extension:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_CENTER_Y);

    // Use a read-only FXTextField instead of a FXLabel, to allow long strings
    ext = new FXTextField(matrix, 20, NULL, 0, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_CENTER_Y|TEXTFIELD_READONLY|_TEXTFIELD_NOFRAME);
    ext->setBackColor(getApp()->getBaseColor());

    new FXLabel(matrix, "", NULL, 0);

    new FXLabel(matrix, _("Description:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_CENTER_Y);
    descr = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X|LAYOUT_CENTER_Y);
    new FXLabel(matrix, "", NULL, 0);

    new FXLabel(matrix, _("Open:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_CENTER_Y);
    open = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X|LAYOUT_CENTER_Y);
    new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_BROWSE_OPEN, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_FILL_X|LAYOUT_CENTER_Y, 0, 0, 0, 0, 10, 10);

    int is_ar = false;

    FXString viewlbl = _("View:");
    FXString editlbl = _("Edit:");

    extension = file.rafter('.', 1).lower();
    if ((extension == "gz") || (extension == "tgz") || (extension == "tar") || (extension == "taz") || (extension == "bz2") ||
        (extension == "tbz2") || (extension == "tbz") || (extension == "xz") || (extension == "txz") || (extension == "zip") ||
        (extension == "7z") || (extension == "Z") || (extension == "lzh") || (extension == "rar") ||
        (extension == "ace") || (extension == "arj"))
    {
        is_ar = true; // archive
        viewlbl = _("Extract:");
    }
#if defined(linux)
    else if (extension == "rpm")
    {
        editlbl = _("Install/Upgrade:");
    }
#endif
    new FXLabel(matrix, viewlbl, NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_CENTER_Y);
    view = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X|LAYOUT_CENTER_Y);
    new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_BROWSE_VIEW, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_FILL_X|LAYOUT_CENTER_Y, 0, 0, 0, 0, 10, 10);

    if (!is_ar)
    {
        new FXLabel(matrix, editlbl, NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_CENTER_Y);
        edit = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X|LAYOUT_CENTER_Y);
        new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_BROWSE_EDIT, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_FILL_X|LAYOUT_CENTER_Y, 0, 0, 0, 0, 10, 10);
    }
    else
    {
        edit = NULL;
    }

    new FXLabel(matrix, _("Big Icon:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_CENTER_Y);
    bigic = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X|LAYOUT_CENTER_Y);
    bigicbtn = new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_BIG_ICON, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_FILL_X|LAYOUT_CENTER_Y, 0, 0, 0, 0, 10, 10);

    new FXLabel(matrix, _("Mini Icon:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_CENTER_Y);
    miniic = new FXTextField(matrix, 30, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X|LAYOUT_CENTER_Y);
    miniicbtn = new FXButton(matrix, _("\tSelect file..."), filedialogicon, this, ID_MINI_ICON, FRAME_RAISED|FRAME_THICK|LAYOUT_FILL_X|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 10, 10);

    // File name
    new FXLabel(generalframe, _("Name"), NULL, JUSTIFY_LEFT);
    input = new FXTextField(generalframe, 60, NULL, 0, FRAME_THICK|FRAME_SUNKEN|LAYOUT_SIDE_TOP|LAYOUT_FILL_X);

    // Complete file path name
    pathname = path+PATHSEPSTRING+file;
    parentdir = path;
    filename = file;

    // Unused in this case
    files = NULL;
    paths = NULL;

    // Initialize mount point flag
    isMountpoint = false;

    // Warn if non UTF-8 file name
    if (!isUtf8(pathname.text(), pathname.length()))
    {
        new FXLabel(generalframe, _("=> Warning: file name is not UTF-8 encoded!"), NULL, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW);
    }

    // Get file/link stat info
    if (lstatrep(pathname.text(), &linfo) != 0)
    {
        return;
    }

    // Obtain user name
    usrid = FXSystem::userName(linfo.st_uid);

    // Obtain group name
    grpid = FXSystem::groupName(linfo.st_gid);
    perm->user->setText(usrid);
    perm->grp->setText(grpid);
    oldgrp = grpid;
    oldusr = usrid;

    // Test if link or broken link
    // When valid link, get the referred file path
    isLink = S_ISLNK(linfo.st_mode);
    isBrokenLink = false;
    if (isLink)
    {
        // Broken link
        struct stat info;
        if (statrep(pathname.text(), &info) != 0)
        {
            isBrokenLink = true;
        }

        // Get the path name of the linked file
        referredpath = ::readLink(pathname);
    }

    orig_mode = linfo.st_mode;

    // Initialize exec flag
    executable = false;

    // Read time format
    FXString timeformat = getApp()->reg().readStringEntry("SETTINGS", "time_format", DEFAULT_TIME_FORMAT);

    // Mod time of the file / link
    mod = FXSystem::time(timeformat.text(), linfo.st_mtime);

    // Change time of the file / link
    changed = FXSystem::time(timeformat.text(), linfo.st_ctime);

    // Accessed time of the file / link
    accessed = FXSystem::time(timeformat.text(), linfo.st_atime);

    // Size of the file / link
    filesize = (FXulong)linfo.st_size;

    // Is it a directory?
	nbseldirs = 0;
    isDirectory = S_ISDIR(linfo.st_mode);
    if (isDirectory)
    {
        // Directory path
        FXString dirpath = FXPath::absolute(parentdir, file);

#if defined(linux)
        FILE*          mtab = setmntent(MTAB_PATH, "r");
        struct mntent* mnt;
        if (mtab)
        {
            while ((mnt = getmntent(mtab)))
            {
                if (!streq(mnt->mnt_type, MNTTYPE_IGNORE) && !streq(mnt->mnt_type, MNTTYPE_SWAP))
                {
                    if (streq(mnt->mnt_dir, dirpath.text()))
                    {
                        isMountpoint = true;
                        snprintf(buf, sizeof(buf)-1, _("Filesystem (%s)"), mnt->mnt_fsname);
                        type = buf;
                        strlcpy(mnttype, mnt->mnt_type, strlen(mnt->mnt_type)+1);
                    }
                }
            }
            endmntent(mtab);
        }
#endif
        // If it is a mount point
        if (isMountpoint)
        {
            // Caution : use the -P option to be POSIX compatible!
            snprintf(buf, sizeof(buf)-1, "df -P -B 1 '%s'", pathname.text());
            p = popen(buf, "r");
            FXbool success = true;
            if (fgets(buf, sizeof(buf), p) == NULL)
            {
                success = false;
            }
            if (fgets(buf, sizeof(buf), p) == NULL)
            {
                success = false;
            }
            if (success)
            {
                strtok(buf, " ");
                strtok(NULL, " ");
                char* pstr;
                pstr = strtok(NULL, " ");
                strlcpy(used, pstr, strlen(pstr)+1);  // get used
                pstr = strtok(NULL, " ");
                strlcpy(avail, pstr, strlen(pstr)+1); // get available
                pstr = strtok(NULL, " ");
                strlcpy(pctr, pstr, strlen(pstr)+1);  // get percentage
            }
            else
            {
                strlcpy(used, "", 1);
                strlcpy(avail, "", 1);
                strlcpy(pctr, "", 1);
            }
            pclose(p);
        }

        // If it is a folder
        else
        {
            type = _("Folder");
            nbseldirs = 1;
        }
    }

    else if (S_ISCHR(linfo.st_mode))
    {
        type = _("Character Device");
    }
    else if (S_ISBLK(linfo.st_mode))
    {
        type = _("Block Device");
    }
    else if (S_ISFIFO(linfo.st_mode))
    {
        type = _("Named Pipe");
    }
    else if (S_ISSOCK(linfo.st_mode))
    {
        type = _("Socket");
    }

    // Regular file or link
    else
    {
        // Try to use association table
        extension2 = FXPath::name(pathname).rafter('.', 2).lower();
        if ((extension2 == "tar.gz") || (extension2 == "tar.bz2") || (extension2 == "tar.xz") || (extension2 == "tar.z"))
        {
            extension = extension2;
        }
        else
        {
            extension = FXPath::name(pathname).rafter('.', 1).lower();
        }

        if (extension != "")
        {
            fileassoc = getApp()->reg().readStringEntry("FILETYPES", extension.text(), "");
        }

        // If we have an association
        if (!fileassoc.empty())
        {
            FXString c;
            type = fileassoc.section(';', 1);
            if (type == "")
            {
                if (linfo.st_mode&(S_IXUSR|S_IXGRP|S_IXOTH))
                {
                    type = _("Executable");
                    executable = true;
                }
                else
                {
                    type = _("Document");
                }
            }
            ext->setText(extension);
            c = fileassoc.section(';', 0);
            descr->setText(fileassoc.section(';', 1));
            open->setText(c.section(',', 0));
            view->setText(c.section(',', 1));
            if (edit)
            {
                edit->setText(c.section(',', 2));
            }
            bigic->setText(fileassoc.section(';', 2));
            miniic->setText(fileassoc.section(';', 3));
            if (!isLink)
            {
                fassoctab->enable();
            }

            // Load big and mini icons
            FXString iconpath = getApp()->reg().readStringEntry("SETTINGS", "iconpath", DEFAULTICONPATH);

            FXIcon* bigicon = loadiconfile(getApp(), iconpath, bigic->getText());
            if (bigicon)
            {
                bigicbtn->setIcon(bigicon);
            }

            FXIcon* miniicon = loadiconfile(getApp(), iconpath, miniic->getText());
            if (miniicon)
            {
                miniicbtn->setIcon(miniicon);
            }
        }
        else
        {
            ext->setText(extension);
            if (linfo.st_mode&(S_IXUSR|S_IXGRP|S_IXOTH))
            {
                type = _("Executable");
                executable = true;
            }
            else
            {
                type = _("Document");
            }
            if (!isLink)
            {
                fassoctab->enable();
            }
        }
    }

    // Modify file type for broken links
    if (isBrokenLink)
    {
        type = _("Broken link");
    }

    // For links, get the file type of the referred file
    else if (isLink)
    {
        struct stat info;
        if (statrep(referredpath.text(), &info) == 0)
        {
            // Folder
            if (S_ISDIR(info.st_mode))
            {
                type = _("Folder");
            }

            // File
            else
            {
                // Try to use association table
                extension2 = FXPath::name(referredpath).rafter('.', 2).lower();
                if ((extension2 == "tar.gz") || (extension2 == "tar.bz2") || (extension2 == "tar.xz") || (extension2 == "tar.z"))
                {
                    extension = extension2;
                }
                else
                {
                    extension = FXPath::name(referredpath).rafter('.', 1).lower();
                }

                if (extension != "")
                {
                    fileassoc = getApp()->reg().readStringEntry("FILETYPES", extension.text(), "");
                }

                // If we have an association
                if (!fileassoc.empty())
                {
                    type = fileassoc.section(';', 1);
                }

                // No association
                else
                {
                    if (S_ISCHR(info.st_mode))
                    {
                        type = _("Character Device");
                    }
                    else if (S_ISBLK(info.st_mode))
                    {
                        type = _("Block Device");
                    }
                    else if (S_ISFIFO(info.st_mode))
                    {
                        type = _("Named Pipe");
                    }
                    else if (S_ISSOCK(info.st_mode))
                    {
                        type = _("Socket");
                    }
                    else if (info.st_mode&(S_IXUSR|S_IXGRP|S_IXOTH))
                    {
                        type = _("Executable");
                        executable = true;
                    }
                    else
                    {
                        type = _("Document");
                    }
                }
            }
        }
        type = _("Link to ")+type;
    }

    // Parent directory name not editable
    if (file == "..")
    {
        input->setEditable(false);
    }

    // Root directory name not editable
    if ((file == "") && (path == ROOTDIR))
    {
        input->setText(ROOTDIR);
        input->setEditable(false);
    }
    else
    {
        input->setText(file);
    }

    input->setFocus();

    // Set permissions
    perm->ur->setCheck((linfo.st_mode & S_IRUSR) ? true : false);
    perm->uw->setCheck((linfo.st_mode & S_IWUSR) ? true : false);
    perm->ux->setCheck((linfo.st_mode & S_IXUSR) ? true : false);

    perm->gr->setCheck((linfo.st_mode & S_IRGRP) ? true : false);
    perm->gw->setCheck((linfo.st_mode & S_IWGRP) ? true : false);
    perm->gx->setCheck((linfo.st_mode & S_IXGRP) ? true : false);

    perm->or_->setCheck((linfo.st_mode & S_IROTH) ? true : false);
    perm->ow->setCheck((linfo.st_mode & S_IWOTH) ? true : false);
    perm->ox->setCheck((linfo.st_mode & S_IXOTH) ? true : false);

    perm->suid->setCheck((linfo.st_mode & S_ISUID) ? true : false);
    perm->sgid->setCheck((linfo.st_mode & S_ISGID) ? true : false);
    perm->svtx->setCheck((linfo.st_mode & S_ISVTX) ? true : false);

    perm->set->setCheck();
    perm->all->setCheck();

    FXLabel* mtType = NULL, *mtUsed = NULL, *mtFree = NULL, *fileType = NULL, *fileChanged = NULL, *fileAccessed = NULL, *fileModified = NULL;
    FXbool   isInTrash = false;

    fileSize = NULL;

    // Properties are different for mount points
    if (isMountpoint)
    {
        FXGroupBox* mtgroup = new FXGroupBox(generalframe, _("Mount point"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X);
        FXMatrix*   mtmatrix = new FXMatrix(mtgroup, 2, MATRIX_BY_COLUMNS|LAYOUT_FILL_X|LAYOUT_FILL_Y);
        new FXLabel(mtmatrix, _("Mount type:"), NULL, LAYOUT_LEFT|JUSTIFY_LEFT);
        fileType = new FXLabel(mtmatrix, FXString::null, NULL, LAYOUT_LEFT|LAYOUT_FILL_COLUMN|JUSTIFY_LEFT);
        new FXLabel(mtmatrix, _("Used:"), NULL, LAYOUT_LEFT);
        mtUsed = new FXLabel(mtmatrix, FXString::null, NULL, LAYOUT_LEFT|LAYOUT_FILL_COLUMN|JUSTIFY_LEFT);
        new FXLabel(mtmatrix, _("Free:"), NULL, LAYOUT_LEFT);
        mtFree = new FXLabel(mtmatrix, FXString::null, NULL, LAYOUT_LEFT|LAYOUT_FILL_COLUMN|JUSTIFY_LEFT);
        new FXLabel(mtmatrix, _("File system:"), NULL, LAYOUT_LEFT);
        mtType = new FXLabel(mtmatrix, FXString::null, NULL, LAYOUT_LEFT|LAYOUT_FILL_COLUMN|JUSTIFY_LEFT);
        new FXLabel(mtmatrix, _("Location:"), NULL, LAYOUT_LEFT);
        location = new TextLabel(mtmatrix, 30, 0, 0, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW|FRAME_NONE);
    	location->setBackColor(getApp()->getBaseColor());
    }
    else
    {
        FXGroupBox* attrgroup = new FXGroupBox(generalframe, _("Properties"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X);
        FXMatrix*   attrmatrix = new FXMatrix(attrgroup, 2, MATRIX_BY_COLUMNS|LAYOUT_FILL_X|LAYOUT_FILL_Y);
        new FXLabel(attrmatrix, _("Type:"), NULL, LAYOUT_LEFT);
        fileType = new FXLabel(attrmatrix, FXString::null, NULL, LAYOUT_LEFT|LAYOUT_FILL_COLUMN|JUSTIFY_LEFT);
        sizelabel = new FXLabel(attrmatrix, _("Total size:"), NULL, LAYOUT_LEFT);
        fileSize = new FXLabel(attrmatrix, "\n", NULL, LAYOUT_LEFT|LAYOUT_FILL_COLUMN|JUSTIFY_LEFT);
        new FXLabel(attrmatrix, FXString::null, NULL, LAYOUT_LEFT|JUSTIFY_LEFT);
        fileSizeDetails = new FXLabel(attrmatrix, FXString::null, NULL, LAYOUT_LEFT|JUSTIFY_LEFT);
        new FXLabel(attrmatrix, _("Location:"), NULL, LAYOUT_LEFT);
        location = new TextLabel(attrmatrix, 30, 0, 0, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW|FRAME_NONE);
    	location->setBackColor(getApp()->getBaseColor());

        if (isLink & !isBrokenLink)
        {
            new FXLabel(attrmatrix, _("Link to:"), NULL, LAYOUT_LEFT);
            linkto = new FXLabel(attrmatrix, FXString::null, NULL, LAYOUT_LEFT|LAYOUT_FILL_COLUMN);
        }
        else if (isBrokenLink)
        {
            new FXLabel(attrmatrix, _("Broken link to:"), NULL, LAYOUT_LEFT);
            linkto = new FXLabel(attrmatrix, FXString::null, NULL, LAYOUT_LEFT|LAYOUT_FILL_COLUMN);
        }

        // If the file is in the trash can
        if (parentdir.left(trashfileslocation.length()) == trashfileslocation)
        {
            isInTrash = true;

            new FXLabel(attrmatrix, _("Original location:"), NULL, LAYOUT_LEFT);
            origlocation = new FXLabel(attrmatrix, FXString::null, NULL, LAYOUT_LEFT|LAYOUT_FILL_COLUMN);
        }

        FXGroupBox* timegroup = new FXGroupBox(generalframe, _("File Time"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X);
        FXMatrix*   timematrix = new FXMatrix(timegroup, 2, MATRIX_BY_COLUMNS|LAYOUT_FILL_X|LAYOUT_FILL_Y);
        new FXLabel(timematrix, _("Last Modified:"), NULL, LAYOUT_LEFT);
        fileModified = new FXLabel(timematrix, FXString::null, NULL, LAYOUT_LEFT|LAYOUT_FILL_COLUMN);
        new FXLabel(timematrix, _("Last Changed:"), NULL, LAYOUT_LEFT);
        fileChanged = new FXLabel(timematrix, FXString::null, NULL, LAYOUT_LEFT|LAYOUT_FILL_COLUMN);
        new FXLabel(timematrix, _("Last Accessed:"), NULL, LAYOUT_LEFT);
        fileAccessed = new FXLabel(timematrix, FXString::null, NULL, LAYOUT_LEFT|LAYOUT_FILL_COLUMN);

#ifdef STARTUP_NOTIFICATION
        sngroup = new FXGroupBox(generalframe, _("Startup Notification"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X);
        snbutton = new FXCheckButton(sngroup, _("Disable startup notification for this executable"), this, ID_SNDISABLE);

        sndisable_prev = false;
        FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
        if (snexcepts != "")
        {
            FXString entry;
            for (int i = 0; ; i++)
            {
                entry = snexcepts.section(':', i);
                if (streq(entry.text(), ""))
                {
                    break;
                }
                if (streq(entry.text(), filename.text()))
                {
                    sndisable_prev = true;
                    break;
                }
            }
        }
        snbutton->setCheck(sndisable_prev);
#endif

        // If the file is in the trash can
        if (isInTrash)
        {
            new FXLabel(timematrix, _("Deletion Date:"), NULL, LAYOUT_LEFT);
            deletiondate = new FXLabel(timematrix, FXString::null, NULL, LAYOUT_LEFT|LAYOUT_FILL_COLUMN);
        }
    }

    // File or mount type
    fileType->setText(type.text());

    // Parent directory
    FXString text = parentdir;

    // Insert line breaks if text has one line and more than allowed number of characters
    if ((text.find('\n') < 0) && (text.length() > MAX_MESSAGE_LENGTH))
    {
        // Insert \n in the message every MAX_MESSAGE_LENGTH chars
        int nb = text.length()/MAX_MESSAGE_LENGTH;
        for (int n = 1; n <= nb; n++)
        {
            text.insert(n*MAX_MESSAGE_LENGTH, '\n');
        }
    }

	// Set location text
	location->setNumColumns(text.length());
    location->setText(text);

    // Referred file for valid or broken link
    if (isLink)
    {
        linkto->setText(referredpath);
    }

    // If directory
    if (isDirectory)
    {
        // if mount point
        if (isMountpoint)
        {
            hsize = ::hSize(used);
            snprintf(size, sizeof(size)-1, "%s (%s)", hsize.text(), pctr);
            mtUsed->setText(size);
            hsize = ::hSize(avail);
            mtFree->setText(hsize);
            mtType->setText(mnttype);
        }
        // if folder
        else
        {
            fileModified->setText(mod);
            fileChanged->setText(changed);
            fileAccessed->setText(accessed);
        }
    }
    // Regular file
    else
    {
#if __WORDSIZE == 64
        snprintf(size, sizeof(size)-1, "%lu", filesize);
#else
        snprintf(size, sizeof(size)-1, "%llu", filesize);
#endif
        hsize = ::hSize(size);
#if __WORDSIZE == 64
        snprintf(size, sizeof(size)-1, _("%s (%lu bytes)"), hsize.text(), filesize);
#else
        snprintf(size, sizeof(size)-1, _("%s (%llu bytes)"), hsize.text(), filesize);
#endif
        sizelabel->setText(_("Size:"));
        fileSize->setText(size);
        fileModified->setText(mod);
        fileChanged->setText(changed);
        fileAccessed->setText(accessed);
    }

    // If the file is in the trash can
    if (isInTrash)
    {
        // Obtain trash base name and sub path
        FXString subpath = parentdir+PATHSEPSTRING;
        subpath.erase(0, trashfileslocation.length()+1);
        FXString trashbasename = subpath.before('/');
        if (trashbasename == "")
        {
            trashbasename = FXPath::name(pathname);
        }
        subpath.erase(0, trashbasename.length());

        // Read the .trashinfo file
        FILE*    fp;
        char     line[1024];
        FXString origpath = "", delstr = "";
        FXlong   deldate = 0;
        FXbool   success = true;
        FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+trashbasename+".trashinfo";
        if ((fp = fopen(trashinfopathname.text(), "r")) != NULL)
        {
            // Read the first three lines and get the strings
            if (fgets(line, sizeof(line), fp) == NULL)
            {
                success = false;
            }
            if (fgets(line, sizeof(line), fp) == NULL)
            {
                success = false;
            }
            if (success)
            {
                origpath = line;
                origpath = origpath.after('=');
                origpath = origpath.before('\n');
            }
            if (fgets(line, sizeof(line), fp) == NULL)
            {
                success = false;
            }
            if (success)
            {
                delstr = line;
                delstr = delstr.after('=');
                delstr = delstr.before('\n');
            }
            fclose(fp);
        }

        // Eventually include sub path in the original path
        if (subpath == "")
        {
            origpath = origpath+subpath;
        }
        else
        {
            origpath = origpath+subpath+FXPath::name(pathname);
        }

        // Convert date
        deldate = deltime(delstr);
        if (deldate != 0)
        {
            delstr = FXSystem::time(timeformat.text(), deldate);
        }

        // Maybe there is no deletion information
        if (delstr != "")
        {
            origlocation->setText(origpath);
            deletiondate->setText(delstr);
        }
    }

    mode = orig_mode;
    perm->cmd = PropertiesBox::ID_SET;
    perm->flt = PropertiesBox::ID_ALL;
    files = &file;
    source = file;
    num = 1;

    descr_prev = descr->getText();
    open_prev = open->getText();
    view_prev = view->getText();
    if (edit)
    {
        edit_prev = edit->getText();
    }
    bigic_prev = bigic->getText();
    miniic_prev = miniic->getText();

    // Flag used to avoid computing recursive size more than once
    recsize = true;

    // Class variable initializations
    origlocation = NULL;
    deletiondate = NULL;
    name_encoding = NULL;
    username = NULL;
    grpname = NULL;
	pid = -1;
	totaldirsize = 0;
	totalnbfiles = 0;
	totalnbsubdirs = 0;
}


// Construct window for multiple files
PropertiesBox::PropertiesBox(FXWindow* win, FXString* file, int n, FXString* path) : DialogBox(win, _("Properties"), DECOR_TITLE|DECOR_BORDER|DECOR_MAXIMIZE|DECOR_STRETCHABLE|DECOR_CLOSE)
{
    struct stat linfo;
    FXString    grpid, usrid;
    FXString    type, extension, extension2, fileassoc;
    char        buf[MAXPATHLEN+1];
    int         i, nbselfiles = 0, dotdot = 0;
    FXbool      firstfile = true;

    isDirectory = false;
	nbseldirs = 0;

    // Buttons
    FXHorizontalFrame* buttons = new FXHorizontalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X, 0, 0, 0, 0, 10, 10, 5, 5);

    // Contents
    FXVerticalFrame* contents = new FXVerticalFrame(this, LAYOUT_SIDE_TOP|FRAME_NONE|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Accept
    FXButton* ok = new FXButton(buttons, _("&Accept"), NULL, this, PropertiesBox::ID_ACCEPT_MULT, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    ok->addHotKey(KEY_Return);

    // Cancel
    new FXButton(buttons, _("&Cancel"), NULL, this, PropertiesBox::ID_CANCEL, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);

    // Switcher
    FXTabBook* tabbook = new FXTabBook(contents, NULL, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y|LAYOUT_RIGHT);

    // First item is General
    new FXTabItem(tabbook, _("&General"), NULL);
    FXVerticalFrame* generalframe = new FXVerticalFrame(tabbook, FRAME_RAISED);
    FXGroupBox*      attrgroup = new FXGroupBox(generalframe, _("Properties"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    FXMatrix*        attrmatrix = new FXMatrix(attrgroup, 2, MATRIX_BY_COLUMNS|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(attrmatrix, _("Selection:"), NULL, LAYOUT_LEFT|JUSTIFY_LEFT);
    FXLabel* filesSelected = new FXLabel(attrmatrix, FXString::null, NULL, LAYOUT_LEFT|JUSTIFY_LEFT);
    new FXLabel(attrmatrix, FXString::null, NULL, LAYOUT_LEFT|JUSTIFY_LEFT);
    FXLabel* filesSelectedDetails = new FXLabel(attrmatrix, FXString::null, NULL, LAYOUT_LEFT|JUSTIFY_LEFT);
    new FXLabel(attrmatrix, _("Type:"), NULL, LAYOUT_LEFT|JUSTIFY_LEFT);
    FXLabel* filesType = new FXLabel(attrmatrix, FXString::null, NULL, LAYOUT_LEFT|JUSTIFY_LEFT);
    new FXLabel(attrmatrix, _("Total size:"), NULL, LAYOUT_LEFT|JUSTIFY_LEFT);
    fileSize = new FXLabel(attrmatrix, FXString::null, NULL, LAYOUT_LEFT|JUSTIFY_LEFT);
    new FXLabel(attrmatrix, FXString::null, NULL, LAYOUT_LEFT|JUSTIFY_LEFT);
    fileSizeDetails = new FXLabel(attrmatrix, FXString::null, NULL, LAYOUT_LEFT|JUSTIFY_LEFT);

    // Second item is Access Permissions
    new FXTabItem(tabbook, _("&Permissions"), NULL);
    perm = new PermFrame(tabbook, this);

    // Get file/link info of the first file of the list
    // This is used as a guess for the username, group and permissions of the whole list
    FXString pathname = path[0]+PATHSEPSTRING+file[0];
    if (lstatrep(pathname.text(), &linfo) != 0)
    {
        return;
    }

    // Obtain user name
    usrid = FXSystem::userName(linfo.st_uid);

    // Obtain group name
    grpid = FXSystem::groupName(linfo.st_gid);

    orig_mode = linfo.st_mode;

    perm->ur->setCheck((linfo.st_mode & S_IRUSR) ? true : false);
    perm->uw->setCheck((linfo.st_mode & S_IWUSR) ? true : false);
    perm->ux->setCheck((linfo.st_mode & S_IXUSR) ? true : false);

    perm->gr->setCheck((linfo.st_mode & S_IRGRP) ? true : false);
    perm->gw->setCheck((linfo.st_mode & S_IWGRP) ? true : false);
    perm->gx->setCheck((linfo.st_mode & S_IXGRP) ? true : false);

    perm->or_->setCheck((linfo.st_mode & S_IROTH) ? true : false);
    perm->ow->setCheck((linfo.st_mode & S_IWOTH) ? true : false);
    perm->ox->setCheck((linfo.st_mode & S_IXOTH) ? true : false);

    perm->suid->setCheck((linfo.st_mode & S_ISUID) ? true : false);
    perm->sgid->setCheck((linfo.st_mode & S_ISGID) ? true : false);
    perm->svtx->setCheck((linfo.st_mode & S_ISVTX) ? true : false);

    perm->add->setCheck();
    perm->all->setCheck();

    perm->user->setText(usrid);
    perm->grp->setText(grpid);

    mode = orig_mode;
    perm->cmd = PropertiesBox::ID_SET;
    perm->flt = PropertiesBox::ID_ALL;
    files = file;
    paths = path;
    source = "";
    num = n;

    // Number of selected files / directories and file type
    for (i = 0; i < num; i++)
    {
        FXString pathname = paths[i]+PATHSEPSTRING+files[i];
        if (lstatrep(pathname.text(), &linfo) != 0)
        {
            continue;
        }

        // Special case of the ".." directory
        if (files[i] == "..")
        {
            dotdot = 1;
            continue;
        }

        // Is it a directory?
        isDirectory = S_ISDIR(linfo.st_mode);
        if (isDirectory)
        {
            nbseldirs++;
        }

        else // Regular file
        {
            nbselfiles++;

            // Try to use association table
            extension2 = files[i].rafter('.', 2).lower();
            if ((extension2 == "tar.gz") || (extension2 == "tar.bz2") || (extension2 == "tar.xz") || (extension2 == "tar.z"))
            {
                extension = extension2;
            }
            else
            {
                extension = extension = files[i].rafter('.', 1).lower();
            }

            if (extension != "")
            {
                fileassoc = getApp()->reg().readStringEntry("FILETYPES", extension.text(), "");
            }

            // Keep the first encountered type
            if (firstfile)
            {
                // If we have an association
                if (!fileassoc.empty())
                {
                    type = fileassoc.section(';', 1);
                }
                else
                {
                    type = _("Document");
                }
                firstfile = false;
            }
            else
            {
                // If we have an association
                if (!fileassoc.empty())
                {
                    if (fileassoc.section(';', 1) != type)
                    {
                        type = _("Multiple types");
                    }
                }
                else
                {
                    if (type != _("Document"))
                    {
                        type = _("Multiple types");
                    }
                }
            }
        }
    }

    // Special cases of the file type
    if (nbselfiles == 0)
    {
        type = _("Folder");
    }

    if ((nbseldirs >= 1) && (nbselfiles >= 1))
    {
        type = _("Multiple types");
    }

    // Number of selected files
    snprintf(buf, sizeof(buf)-1, _("%d items"), num);
    filesSelected->setText(buf);

	if (nbselfiles <= 1 && nbseldirs+dotdot <= 1)
	{
	    snprintf(buf, sizeof(buf)-1, _("%d file, %d folder"), nbselfiles, nbseldirs+dotdot);
	}
	else if (nbselfiles <= 1 && nbseldirs+dotdot > 1)
	{
	    snprintf(buf, sizeof(buf)-1, _("%d file, %d folders"), nbselfiles, nbseldirs+dotdot);
	}
	else if (nbselfiles > 1 && nbseldirs+dotdot <= 1)
	{
	    snprintf(buf, sizeof(buf)-1, _("%d files, %d folder"), nbselfiles, nbseldirs+dotdot);
	}
	else
	{
	    snprintf(buf, sizeof(buf)-1, _("%d files, %d folders"), nbselfiles, nbseldirs+dotdot);
	}

    filesSelectedDetails->setText(buf);

    // Display type of selected files
    filesType->setText(type);

    // Flag used to avoid computing recursive size more than once
    recsize = true;

    // Class variable initializations
    executable = false;
    isMountpoint = false;
#ifdef STARTUP_NOTIFICATION
    snbutton = NULL;
    sngroup = NULL;
    sndisable_prev = false;
#endif
    input = NULL;
    username = NULL;
    grpname = NULL;
    open = NULL;
    view = NULL;
    edit = NULL;
    descr = NULL;
    bigic = NULL;
    bigicbtn = NULL;
    miniic = NULL;
    miniicbtn = NULL;
    location = NULL;
    origlocation = NULL;
    linkto = NULL;
    deletiondate = NULL;
    ext = NULL;
    name_encoding = NULL;
	pid = -1;
	totaldirsize = 0;
	totalnbfiles = 0;
	totalnbsubdirs = 0;
}


// Make window
void PropertiesBox::create()
{
    DialogBox::create();
}


// Dialog for single selected file
long PropertiesBox::onCmdAcceptSingle(FXObject* o, FXSelector s, void* p)
{
    char**   str = NULL;
    int      rc = 0;
    File*    f = NULL;
    char     file[MAXPATHLEN];
    FXString oldfileassoc, fileassoc, op, v, e;

	FXbool confirm = false;
	
#ifdef STARTUP_NOTIFICATION
	if (executable && snbutton->getCheck() != sndisable_prev)
	{
		confirm = true;
	}
#endif
	
    FXbool cond;
    if (edit) // Condition is not the same if edit exist or not
    {
        cond = (open->getText() != open_prev || view->getText() != view_prev || edit->getText() != edit_prev ||
                descr->getText() != descr_prev || bigic->getText() != bigic_prev || miniic->getText() != miniic_prev);
    }
    else
    {
        cond = (open->getText() != open_prev || view->getText() != view_prev || descr->getText() != descr_prev ||
                bigic->getText() != bigic_prev || miniic->getText() != miniic_prev);
    }
	
	if (cond)
	{
		confirm = true;
	}

    // Source and target path names
    FXString targetpath;
    FXString sourcepath = parentdir+"/"+source;
    FXString target = input->getText();
    FXString targetparentdir = FXPath::directory(target);
    if (targetparentdir == "")
    {
        targetparentdir = parentdir;
        targetpath = targetparentdir+"/"+target;
    }
    else
    {
        targetpath = target;
    }

    if (source != target)
    {
		confirm = true;
	}

    if ((oldgrp != perm->grp->getText()) || (oldusr != perm->user->getText()) || perm->rec->getCheck())
    {
		confirm = true;
	}

    if (!perm->own->getCheck() && ((mode != orig_mode) || perm->rec->getCheck()))
    {
		confirm = true;
	}

    FXbool confirm_properties = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_properties", true);

	if (confirm == true && confirm_properties == true)
	{
		FXString message;
		if (::isDirectory(sourcepath))
		{
			message = _("Change properties of the selected folder?");
		}
		else
		{
			message = _("Change properties of the selected file?");
		}

		MessageBox box(this, _("Confirm Change Properties"), message, bigattribicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);


		if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
		{
			return(0);
		}
	}

    // Kill child process, if exists
    if (pid >0)
    {
    	kill(pid, SIGTERM);
    	
    	pid = -1;

		totaldirsize = 0;
		totalnbfiles = 0;
		totalnbsubdirs = 0;
   	
    	getApp()->removeChore(this, ID_WATCHPROCESS);
	}

#ifdef STARTUP_NOTIFICATION
    // If file is an executable file
    if (executable)
    {
        FXbool sndisable = snbutton->getCheck();
        if (sndisable != sndisable_prev)
        {
            // List of startup notification exceptions
            FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");

            // Add to list if not already present
            if (sndisable)
            {
                FXbool notinlist = true;
                if (snexcepts != "")
                {
                    FXString entry;
                    for (int i = 0; ; i++)
                    {
                        entry = snexcepts.section(':', i);
                        if (streq(entry.text(), ""))
                        {
                            break;
                        }
                        if (streq(entry.text(), filename.text()))
                        {
                            notinlist = false;
                            break;
                        }
                    }
                }

                if (notinlist)
                {
                    snexcepts += filename + ":";
                }
            }

            // Remove from list if already present
            else
            {
                FXbool inlist = false;
                int    pos = 0;
                if (snexcepts != "")
                {
                    FXString entry;
                    for (int i = 0; ; i++)
                    {
                        entry = snexcepts.section(':', i);
                        if (streq(entry.text(), ""))
                        {
                            break;
                        }
                        if (streq(entry.text(), filename.text()))
                        {
                            inlist = true;
                            break;
                        }
                        pos += entry.length()+1;
                    }
                }

                if (inlist)
                {
                    snexcepts.erase(pos, filename.length()+1);
                }
            }

            // Write updated list to the registry
            getApp()->reg().writeStringEntry("OPTIONS", "startup_notification_exceptions", snexcepts.text());
            getApp()->reg().write();
        }
    }
#endif

    if (cond)
    {
        op = open->getText();
        v = view->getText();
        if (!v.empty())
        {
            v = "," + v;
        }
        if (edit)
        {
            e = edit->getText();
            if (!e.empty())
            {
                e = "," + e;
            }
        }

        fileassoc = ext->getText();
        fileassoc += "=";
        fileassoc += op + v + e + ";";
        fileassoc += descr->getText() + ";";
        fileassoc += bigic->getText() + ";" + miniic->getText() + ";;";

        if (ext->getText() != "")
        {
            oldfileassoc = getApp()->reg().readStringEntry("FILETYPES", ext->getText().text(), "");
            if ((oldfileassoc == "") || (fileassoc.section('=', 1) != oldfileassoc))
            {
                FXString command = fileassoc.section('=', 1);
                getApp()->reg().writeStringEntry("FILETYPES", ext->getText().text(), command.text());

                // Handle file association
                str = new char* [2];
                str[0] = new char[strlen(ext->getText().text())+1];
                str[1] = new char[strlen(command.text())+1];
                strlcpy(str[0], ext->getText().text(), ext->getText().length()+1);
                strlcpy(str[1], command.text(), command.length()+1);
                mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ASSOC), str);
            }
        }
    }

    if ( target == "" || target == ".." || target == "." )
    {
        MessageBox::warning(this, BOX_OK, _("Warning"), _("Invalid file name, operation cancelled"));
        input->setText(source);
        return(0);
    }

    // Rename file if necessary
    if (source != target)
    {
		// Target name contains '/'
		if (target.contains(PATHSEPCHAR))
		{
			if (::isDirectory(sourcepath))
			{
				MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in folder names, operation cancelled"));
			}
			else
			{
				MessageBox::warning(this, BOX_OK, _("Warning"), _("The / character is not allowed in file names, operation cancelled"));
			}
        	input->setText(source);
			return(0);
		}

        // Source path is not writable
        if (!::isWritable(sourcepath))
        {
            MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), source.text());
            return(0);
        }

        // Target parent directory doesn't exist or is not writable
        if (!::exists(targetparentdir))
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), targetparentdir.text());
            return(0);
        }
        if (!::isWritable(targetparentdir))
        {
            MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetparentdir.text());
            return(0);
        }

        // Rename file or directory
        else
        {
            File* f;
            f = new File(this, _("File rename"), RENAME);
            f->create();
            f->rename(sourcepath, targetpath);
            delete f;
        }
    }

    // Change perm

    // Caution : chown must be done *before* chmod because chown can clear suid and sgid bits

    // Chown only if user or group have changed or recursive flag is set
    rc = 0;
    if ((oldgrp != perm->grp->getText()) || (oldusr != perm->user->getText()) || perm->rec->getCheck())
    {
        f = new File(this, _("File owner"), CHOWN);
        f->create();

        uid_t          uid = 32768;
        gid_t          gid = 32768;
        struct passwd* pwde;
        while ((pwde = getpwent()))
        {
            if (perm->user->getText() == pwde->pw_name)
            {
                uid = pwde->pw_uid;
            }
        }
        endpwent();

        struct group* grpe;
        while ((grpe = getgrent()))
        {
            if (perm->grp->getText() == grpe->gr_name)
            {
                gid = grpe->gr_gid;
            }
        }
        endgrent();

        // Wait cursor
        getApp()->beginWaitCursor();

        // Perform chown on the selected file or directory
        errno = 0;
        rc = f->chown((char*)targetpath.text(), file, uid, gid, perm->rec->getCheck(), perm->dironly->getCheck(), perm->fileonly->getCheck());
        int errcode = errno;

        // If action is cancelled in progress dialog
        if (f->isCancelled())
        {
            f->hideProgressDialog();
            MessageBox::error(this, BOX_OK, _("Warning"), _("Change owner cancelled!"));
            delete f;
            getApp()->endWaitCursor();
            return(0);
        }
        getApp()->endWaitCursor();

        // Handle chown errors
        if (rc)
        {
            f->hideProgressDialog();
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Chown in %s failed: %s"), file, strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Chown in %s failed"), file);
            }
            delete f;
            return(0);
        }
        delete f;
    }

    // Chmod if owner only is not set and permissions are changed or recursive flag is set
    if (!perm->own->getCheck() && ((mode != orig_mode) || perm->rec->getCheck()))
    {
        if (perm->suid->getCheck() || perm->sgid->getCheck() || perm->svtx->getCheck())
        {
            if (BOX_CLICKED_CANCEL == MessageBox::warning(this, BOX_OK_CANCEL, _("Warning"), _("Setting special permissions could be unsafe! Is that you really want to do?")))
            {
                return(0);
            }
        }

        struct stat linfo;
        mode_t m;
        
        // Cannot stat target
        if (lstatrep(targetpath.text(), &linfo) != 0)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Chmod in %s failed: %s"), file, strerror(errno));
            return(0);
        }

        f = new File(this, _("File permissions"), CHMOD);
        f->create();

        switch (perm->cmd)
        {
        case PropertiesBox::ID_ADD:
            m = linfo.st_mode|mode;
            break;

        case PropertiesBox::ID_CLEAR:
            m = linfo.st_mode & ~mode;
            break;

        case PropertiesBox::ID_SET:
            m = mode;
            break;

        default:
            delete f;
            return(0);
        }

        // Wait cursor
        getApp()->beginWaitCursor();

        // Perform chmod on the selected file or directory
        errno = 0;
        rc = f->chmod((char*)targetpath.text(), file, m, perm->rec->getCheck(), perm->dironly->getCheck(), perm->fileonly->getCheck());
        int errcode = errno;

        // If action is cancelled in progress dialog
        if (f->isCancelled())
        {
            f->hideProgressDialog();
            MessageBox::error(this, BOX_OK, _("Warning"), _("Change file permissions cancelled!"));
            delete f;
            getApp()->endWaitCursor();
            return(0);
        }
        getApp()->endWaitCursor();

        // Handle chmod errors
        if (rc)
        {
            f->hideProgressDialog();
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Chmod in %s failed: %s"), file, strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Chmod in %s failed"), file);
            }
            delete f;
            return(0);
        }
        delete f;
    }

	DialogBox::onCmdAccept(o, s, p);

	// Redraw file lists
    ((XFileExplorer*)mainWindow)->deselectAll();
    ((XFileExplorer*)mainWindow)->refreshPanels();

	// Delete object
	delete this;

    return(1);
}


// Dialog for multiple selected files
long PropertiesBox::onCmdAcceptMult(FXObject* o, FXSelector s, void* p)
{
    int   rc = 0, i;
    File* f = NULL;
    char  file[MAXPATHLEN];

    FXbool confirm_properties = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_properties", true);

	if (confirm_properties)
	{
		MessageBox box(this, _("Confirm Change Properties"), _("Apply permissions to the selected items?"), bigattribicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
		if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
		{
			return(0);
		}
	}

	// Kill child process, if exists
    if (pid >0)
    {
    	kill(pid, SIGTERM);
    	
    	pid = -1;

		totaldirsize = 0;
		totalnbfiles = 0;
		totalnbsubdirs = 0;
   	
    	getApp()->removeChore(this, ID_WATCHPROCESS);
	}

    // Caution : chown must be done *before* chmod because chown can clear suid and sgid bits

    // Chown
    rc = 0;
    f = new File(this, _("File owner"), CHOWN);
    f->create();

    // Wait cursor
    getApp()->beginWaitCursor();

    for (i = 0; i < num; i++)
    {
        struct stat linfo;
        FXString    pathname = FXPath::absolute(paths[i], files[i]);
        if (lstatrep(pathname.text(), &linfo) != 0)
        {
            continue;
        }

        uid_t          uid = 32768;
        gid_t          gid = 32768;
        struct passwd* pwde;
        while ((pwde = getpwent()))
        {
            if (perm->user->getText() == pwde->pw_name)
            {
                uid = pwde->pw_uid;
            }
        }
        endpwent();

        struct group* grpe;
        while ((grpe = getgrent()))
        {
            if (perm->grp->getText() == grpe->gr_name)
            {
                gid = grpe->gr_gid;
            }
        }
        endgrent();

        errno = 0;
        if (files[i] != "..")
        {
            rc = f->chown((char*)pathname.text(), file, uid, gid, perm->rec->getCheck(), perm->dironly->getCheck(), perm->fileonly->getCheck());
        }
        int errcode = errno;

        // If action is cancelled in progress dialog
        if (f->isCancelled())
        {
            f->hideProgressDialog();
            MessageBox::error(this, BOX_OK, _("Warning"), _("Change owner cancelled!"));
            delete f;
            getApp()->endWaitCursor();
            return(0);
        }

        // Handle chown errors
        if (rc)
        {
            f->hideProgressDialog();
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Chown in %s failed: %s"), file, strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Chown in %s failed"), file);
            }
            delete f;
            getApp()->endWaitCursor();
            return(0);
        }
    }
    delete f;
    getApp()->endWaitCursor();

    // Chmod if owner only is not set
    if (!perm->own->getCheck())
    {
        if (perm->suid->getCheck() || perm->sgid->getCheck() || perm->svtx->getCheck())
        {
            if (BOX_CLICKED_CANCEL == MessageBox::warning(this, BOX_OK_CANCEL, _("Warning"), _("Setting special permissions could be unsafe! Is that you really want to do?")))
            {
                return(0);
            }
        }

        f = new File(this, _("File permissions"), CHMOD);
        f->create();

        // Wait cursor
        getApp()->beginWaitCursor();

        for (i = 0; i < num; i++)
        {
            struct stat linfo;
            mode_t      m;

            FXString pathname = FXPath::absolute(paths[i], files[i]);
            if (lstatrep(pathname.text(), &linfo) != 0)
            {
                continue;
            }

            switch (perm->cmd)
            {
            case PropertiesBox::ID_ADD:
                m = linfo.st_mode|mode;
                break;

            case PropertiesBox::ID_CLEAR:
                m = linfo.st_mode & ~mode;
                break;

            case PropertiesBox::ID_SET:
                m = mode;
                break;

            default:
                delete f;
                getApp()->endWaitCursor();
                return(0);
            }

            if ((files[i] != "..") && !perm->own->getCheck())
            {
                errno = 0;
                rc = f->chmod((char*)pathname.text(), file, m, perm->rec->getCheck(), perm->dironly->getCheck(), perm->fileonly->getCheck());
                int errcode = errno;

                // If action is cancelled in progress dialog
                if (f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Warning"), _("Change file(s) permissions cancelled!"));
                    delete f;
                    getApp()->endWaitCursor();
                    return(0);
                }

                // Handle chmod errors
                if (rc)
                {
                    f->hideProgressDialog();
                    if (errcode)
                    {
                        MessageBox::error(this, BOX_OK, _("Error"), _("Chmod in %s failed: %s"), file, strerror(errcode));
                    }
                    else
                    {
                        MessageBox::error(this, BOX_OK, _("Error"), _("Chmod in %s failed"), file);
                    }
                    delete f;
                    getApp()->endWaitCursor();
                    return(0);
                }
            }
        }
        delete f;
        getApp()->endWaitCursor();
    }

    DialogBox::onCmdAccept(o, s, p);

    // Redraw the file lists
    ((XFileExplorer*)mainWindow)->deselectAll();
    ((XFileExplorer*)mainWindow)->refreshPanels();
	
	delete[]files;
	delete[]paths;
	delete this;

    return(1);
}


// Cancel dialog
long PropertiesBox::onCmdCancel(FXObject* o, FXSelector s, void* p)
{
	// Kill child process, if exists
    if (pid >0)
    {
    	kill(pid, SIGTERM);
    	
    	pid = -1;
    	
 		totaldirsize = 0;
		totalnbfiles = 0;
		totalnbsubdirs = 0;

   		getApp()->removeChore(this, ID_WATCHPROCESS);
	}

    DialogBox::onCmdCancel(o, s, p);

	delete this;

    return(1);
}


long PropertiesBox::onCmdCommand(FXObject* o, FXSelector s, void* p)
{
    perm->cmd = FXSELID(s);
    return(1);
}


long PropertiesBox::onCmdFilter(FXObject* o, FXSelector s, void* p)
{
    perm->flt = FXSELID(s);
    return(1);
}


long PropertiesBox::onCmdCheck(FXObject* o, FXSelector s, void* p)
{
    int xmode = 0;

    switch (FXSELID(s))
    {
    case PropertiesBox::ID_RUSR:
        xmode = S_IRUSR;
        break;

    case PropertiesBox::ID_WUSR:
        xmode = S_IWUSR;
        break;

    case PropertiesBox::ID_XUSR:
        xmode = S_IXUSR;
        break;

    case PropertiesBox::ID_RGRP:
        xmode = S_IRGRP;
        break;

    case PropertiesBox::ID_WGRP:
        xmode = S_IWGRP;
        break;

    case PropertiesBox::ID_XGRP:
        xmode = S_IXGRP;
        break;

    case PropertiesBox::ID_ROTH:
        xmode = S_IROTH;
        break;

    case PropertiesBox::ID_WOTH:
        xmode = S_IWOTH;
        break;

    case PropertiesBox::ID_XOTH:
        xmode = S_IXOTH;
        break;

    case PropertiesBox::ID_SUID:
        xmode = S_ISUID;
        break;

    case PropertiesBox::ID_SGID:
        xmode = S_ISGID;
        break;

    case PropertiesBox::ID_SVTX:
        xmode = S_ISVTX;
        break;
    }
    FXCheckButton* ch = (FXCheckButton*)o;
    if (!ch->getCheck())
    {
        mode &= ~xmode;
    }
    else
    {
        mode |= xmode;
    }

    return(1);
}


long PropertiesBox::onCmdBrowse(FXObject* o, FXSelector s, void* p)
{
    FileDialog  browseProgram(this, _("Select an executable file"));
    const char* patterns[] =
    {
        _("All files"), "*", NULL
    };

    browseProgram.setFilename(ROOTDIR);
    browseProgram.setPatternList(patterns);
    browseProgram.setSelectMode(SELECT_FILE_EXISTING);
    if (browseProgram.execute())
    {
        FXString path = browseProgram.getFilename();
        switch (FXSELID(s))
        {
        case ID_BROWSE_OPEN:
            open->setText(FXPath::name(path));
            break;

        case ID_BROWSE_VIEW:
            view->setText(FXPath::name(path));
            break;

        case ID_BROWSE_EDIT:
            if (edit)
            {
                edit->setText(FXPath::name(path));
            }
            break;
        }
    }
    return(1);
}


long PropertiesBox::onCmdBrowseIcon(FXObject* o, FXSelector s, void* p)
{
    FXString icon;

    if (FXSELID(s) == ID_BIG_ICON)
    {
        icon = bigic->getText();
    }
    else
    {
        icon = miniic->getText();
    }

    FXString    iconpath = getApp()->reg().readStringEntry("SETTINGS", "iconpath", DEFAULTICONPATH);
    const char* patterns[] =
    {
        _("PNG Images"), "*.png",
        _("GIF Images"), "*.gif",
        _("BMP Images"), "*.bmp", NULL
    };
    FileDialog browseIcon(this, _("Select an icon file"));
    browseIcon.setFilename(iconpath+PATHSEPSTRING+icon);
    browseIcon.setPatternList(patterns);
    browseIcon.setSelectMode(SELECT_FILE_EXISTING);
    if (browseIcon.execute())
    {
        FXString path;

        path = browseIcon.getFilename();
        if (!::exists(path))
        {
            return(0);
        }
        if (FXSELID(s) == ID_BIG_ICON)
        {
            // Load big icon
            bigic->setText(path);

            FXIcon* bigicon = loadiconfile(getApp(), path, bigic->getText());
            if (bigicon)
            {
                bigicbtn->setIcon(bigicon);
            }
        }
        else
        {
            // Load mini icon
            miniic->setText(path);

            FXIcon* miniicon = loadiconfile(getApp(), path, miniic->getText());
            miniicbtn->setIcon(miniicon);
        }
    }
    return(1);
}


// Watch progress of child process
long PropertiesBox::onWatchProcess(FXObject*, FXSelector, void*)
{
    char buf[1024];
    char size[256];
    int nread;


	FXString strbuf, hsize;
	FXString dsize, subdirs, files;
	FXuint nbsubdirs=0, nbfiles;
	FXulong dirsize;

    if ((waitpid(pid, NULL, WNOHANG) == 0))
    {
        // Child is still running, just wait
        getApp()->addChore(this, ID_WATCHPROCESS);

        // Read data from the running child (first, set I-O to non-blocking)
        int pflags;
        if ((pflags = fcntl(pipes[0], F_GETFL)) >= 0)
        {
            pflags |= O_NONBLOCK;
            if (fcntl(pipes[0], F_SETFL, pflags) >= 0)
            {
                // Now read the data from the pipe
                while ((nread = read(pipes[0], buf, sizeof(buf)-1)) > 0)
                {
                    buf[nread] = '\0';

                    // Get last string between two slashes
                    // or before the slash if there is only one
                    strbuf = buf;
					strbuf = strbuf.rbefore('/');
					if (strbuf.rfind('/') >= 0)
					{
						strbuf=strbuf.rafter('/');
					}
					
					dsize = strbuf.section(' ',0);
					files = strbuf.section(' ',1);
					subdirs = strbuf.section(' ',2);

					hsize = ::hSize((char*)dsize.text());

					// Directory size, number of files, number of sub directories
					dirsize = FXULongVal(dsize);
					nbfiles = FXUIntVal(files);
					nbsubdirs = FXUIntVal(subdirs);
					if (nbsubdirs > 0)
					{
						nbsubdirs--;
					}

#if __WORDSIZE == 64
					snprintf(size,sizeof(size)-1,_("%s (%lu bytes)"),hsize.text(),dirsize);        
#else
					snprintf(size,sizeof(size)-1,_("%s (%llu bytes)"),hsize.text(),dirsize);        
#endif	
					fileSize->setText(size);

					if (nbfiles-nbsubdirs-nbseldirs <= 1 && nbsubdirs <= 1)
					{
						snprintf(size, sizeof(size)-1, _("%u file, %u subfolder"), nbfiles-nbsubdirs-nbseldirs, nbsubdirs);					
					}
					else if (nbfiles-nbsubdirs-nbseldirs <= 1 && nbsubdirs > 1)
					{
						snprintf(size, sizeof(size)-1, _("%u file, %u subfolders"), nbfiles-nbsubdirs-nbseldirs, nbsubdirs);					
					}
					else if (nbfiles-nbsubdirs-nbseldirs > 1 && nbsubdirs <= 1)
					{
						snprintf(size, sizeof(size)-1, _("%u files, %u subfolder"), nbfiles-nbsubdirs-nbseldirs, nbsubdirs);					
					}
					else
					{
						snprintf(size, sizeof(size)-1, _("%u files, %u subfolders"), nbfiles-nbsubdirs-nbseldirs, nbsubdirs);					
					}

					fileSizeDetails->setText(size);

					if (nread < (int)(sizeof(buf)-1))
					{
						break;
					}
                }
            }
        }
    }

    else
    {
        // Child has finished.
        // Read data from the finished child
        while ((nread = read(pipes[0], buf, sizeof(buf)-1)) > 0)
        {
			buf[nread] = '\0';

			// Get last string between two slashes
			strbuf = buf;
			strbuf = strbuf.rbefore('/');

			if (strbuf.rfind('/') >= 0)
			{
				strbuf = strbuf.rafter('/');
				
				dsize = strbuf.section(' ',0);
				files = strbuf.section(' ',1);
				subdirs = strbuf.section(' ',2);
				
				hsize = ::hSize((char*)dsize.text());
				
				// Directory size, number of files, number of sub directories
				dirsize = FXULongVal(dsize);
				nbfiles = FXUIntVal(files);
				nbsubdirs = FXUIntVal(subdirs);
				if (nbsubdirs >0)
				{
					nbsubdirs--;
				}

#if __WORDSIZE == 64
				snprintf(size,sizeof(size)-1,_("%s (%lu bytes)"),hsize.text(),dirsize);        
#else
				snprintf(size,sizeof(size)-1,_("%s (%llu bytes)"),hsize.text(),dirsize);        
#endif
				fileSize->setText(size);

				if (nbfiles-nbsubdirs-nbseldirs <= 1 && nbsubdirs <= 1)
				{
					snprintf(size, sizeof(size)-1, _("%u file, %u subfolder"), nbfiles-nbsubdirs-nbseldirs, nbsubdirs);					
				}
				else if (nbfiles-nbsubdirs-nbseldirs <= 1 && nbsubdirs > 1)
				{
					snprintf(size, sizeof(size)-1, _("%u file, %u subfolders"), nbfiles-nbsubdirs-nbseldirs, nbsubdirs);					
				}
				else if (nbfiles-nbsubdirs-nbseldirs > 1 && nbsubdirs <= 1)
				{
					snprintf(size, sizeof(size)-1, _("%u files, %u subfolder"), nbfiles-nbsubdirs-nbseldirs, nbsubdirs);					
				}
				else
				{
					snprintf(size, sizeof(size)-1, _("%u files, %u subfolders"), nbfiles-nbsubdirs-nbseldirs, nbsubdirs);					
				}

				fileSizeDetails->setText(size);
			}

			if (nread < (int)(sizeof(buf)-1))
			{
				break;
			}
		}

        // Close pipes
        ::close(pipes[0]);
        ::close(pipes[1]);   
    }

    return(1);
}


// Update recursive directory size and permissions
long PropertiesBox::onUpdSizeAndPerm(FXObject* o, FXSelector s, void* p)
{
    // Update recursive size only one time
    if (recsize)
    {
        char buf[MAXPATHLEN+1];
        FXString hsize;

        // Single file
        if (num == 1)
        {
            // Directory but not mount point
            if (isDirectory && !isMountpoint)
            {
                FXuint  nbfiles=0, nbsubdirs=0;
                FXulong dirsize=0;

                FXString dirpath = FXPath::absolute(parentdir, filename);
                strlcpy(buf, dirpath.text(), dirpath.length()+1);

				// Open pipes to communicate with child process
				if (pipe(pipes) == -1)
				{
					perror("pipe");
					exit(EXIT_FAILURE);
				}

				// Create child process
				pid = fork();
				
				if (pid == -1)
				{
					perror("fork");
					exit(EXIT_FAILURE);
				}
				if (pid == 0) // Child
				{
					if (nbsubdirs > 0)
					{
						nbsubdirs--;
					}
					
					pathsize(buf, &nbfiles, &nbsubdirs, &dirsize, pipes);

					_exit(EXIT_SUCCESS);
				}
				else // Parent
				{
					// Make sure we get called so we can check when child has finished
					getApp()->addChore(this, ID_WATCHPROCESS);
				}
            }
        }

        // Multiple files
        else
        {
			// Open pipes to communicate with child process
			if (pipe(pipes) == -1)
			{
				perror("pipe");
				exit(EXIT_FAILURE);
			}

			// Create child process
			pid = fork();
						
			if (pid == -1)
			{
				perror("fork");
				exit(EXIT_FAILURE);
			}
			if (pid == 0) // Child
			{
				struct stat info;

				// Total size and files type
				for (int i = 0; i < num; i++)
				{
					FXString pathname;

					if (paths == NULL)
					{
						pathname = FXPath::absolute(parentdir, files[i]);
					}
					else
					{
						pathname = FXPath::absolute(paths[i], files[i]);
					}

					if (lstatrep(pathname.text(), &info) != 0)
					{
						continue;
					}

					// Special case of the ".." directory
					if (files[i] == "..")
					{
						continue;
					}

					// Is it a directory?
					isDirectory = S_ISDIR(info.st_mode);
					if (isDirectory)
					{
						strlcpy(buf, pathname.text(), pathname.length()+1);
						
						if (totalnbsubdirs > 0)
						{
							totalnbsubdirs--;
						}
						
						pathsize(buf, &totalnbfiles, &totalnbsubdirs, &totaldirsize, pipes);
					}
					else // Regular file
					{
						strlcpy(buf, pathname.text(), pathname.length()+1);
						pathsize(buf, &totalnbfiles, &totalnbsubdirs, &totaldirsize, pipes);
					}
            	}

				_exit(EXIT_SUCCESS);
			}
			else // Parent
			{
				// Make sure we get called so we can check when child has finished
				getApp()->addChore(this, ID_WATCHPROCESS);
			}
        }
    }

    recsize = false;

    // Update permissions
    if (perm->rec->getCheck())
    {
        perm->dironly->enable();
        perm->fileonly->enable();
        perm->all->enable();
    }
    else
    {
        perm->all->disable();
        perm->dironly->disable();
        perm->fileonly->disable();
    }

    if (perm->own->getCheck())
    {
        perm->set->disable();
        perm->clear->disable();
        perm->add->disable();
        perm->ur->disable();
        perm->uw->disable();
        perm->ux->disable();
        perm->gr->disable();
        perm->gw->disable();
        perm->gx->disable();
        perm->or_->disable();
        perm->ow->disable();
        perm->ox->disable();
        perm->suid->disable();
        perm->sgid->disable();
        perm->svtx->disable();
    }
    else
    {
        perm->set->enable();
        perm->clear->enable();
        perm->add->enable();
        perm->ur->enable();
        perm->uw->enable();
        perm->ux->enable();
        perm->gr->enable();
        perm->gw->enable();
        perm->gx->enable();
        perm->or_->enable();
        perm->ow->enable();
        perm->ox->enable();
        perm->suid->enable();
        perm->sgid->enable();
        perm->svtx->enable();
    }

    return(1);
}


long PropertiesBox::onCmdKeyPress(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    switch (event->code)
    {
    case KEY_Escape:
        handle(this, FXSEL(SEL_COMMAND, ID_CANCEL), NULL);
        return(1);

    case KEY_KP_Enter:
    case KEY_Return:
        handle(this, FXSEL(SEL_COMMAND, ID_ACCEPT_SINGLE), NULL);
        return(1);

    default:
        FXTopWindow::onKeyPress(sender, sel, ptr);
        return(1);
    }
    return(0);
}


#ifdef STARTUP_NOTIFICATION
// Update the startup notification button depending on the file exec status
long PropertiesBox::onUpdSnDisable(FXObject*, FXSelector, void*)
{
    FXbool usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);

    if (usesn && executable)
    {
        sngroup->enable();
        snbutton->enable();
    }
    else
    {
        sngroup->disable();
        snbutton->disable();
    }
    return(1);
}


#endif
// Search panel
#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <fxkeys.h>


#include <FXPNGIcon.h>
#include <FXJPGIcon.h>
#include <FXTIFIcon.h>


#include "xfedefs.h"
#include "startupnotification.h"
#include "icons.h"
#include "File.h"
#include "FileDict.h"
#include "FileDialog.h"
#include "FileList.h"
#include "MessageBox.h"
#include "ArchInputDialog.h"
#include "HistInputDialog.h"
#include "BrowseInputDialog.h"
#include "OverwriteBox.h"
#include "CommandWindow.h"
#include "ExecuteBox.h"
#include "XFileExplorer.h"
#include "SearchPanel.h"



#if defined(linux)
extern FXStringDict* fsdevices; // Devices from fstab
#endif

// Global Variables
extern FXMainWindow* mainWindow;
extern FXString      homedir;
extern FXString      xdgdatahome;
extern FXbool        allowPopupScroll;
extern FXuint        single_click;

// Clipboard
extern FXString clipboard;
extern FXuint   clipboard_type;

extern char OpenHistory[OPEN_HIST_SIZE][MAX_COMMAND_SIZE];
extern int  OpenNum;

#if defined(linux)
extern FXbool pkg_format;
#endif

// Button separator margins and height
#define SEP_SPACE     5
#define SEP_HEIGHT    20


// Map
FXDEFMAP(SearchPanel) SearchPanelMap[] =
{
    FXMAPFUNC(SEL_CLIPBOARD_LOST, 0, SearchPanel::onClipboardLost),
    FXMAPFUNC(SEL_CLIPBOARD_GAINED, 0, SearchPanel::onClipboardGained),
    FXMAPFUNC(SEL_CLIPBOARD_REQUEST, 0, SearchPanel::onClipboardRequest),
    FXMAPFUNC(SEL_CLICKED, SearchPanel::ID_FILELIST, SearchPanel::onCmdItemClicked),
    FXMAPFUNC(SEL_DOUBLECLICKED, SearchPanel::ID_FILELIST, SearchPanel::onCmdItemDoubleClicked),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_GOTO_PARENTDIR, SearchPanel::onCmdGotoParentdir),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_OPEN_WITH, SearchPanel::onCmdOpenWith),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_OPEN, SearchPanel::onCmdOpen),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_VIEW, SearchPanel::onCmdEdit),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_EDIT, SearchPanel::onCmdEdit),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_COMPARE, SearchPanel::onCmdCompare),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_REFRESH, SearchPanel::onCmdRefresh),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_PROPERTIES, SearchPanel::onCmdProperties),
    FXMAPFUNC(SEL_MIDDLEBUTTONPRESS, SearchPanel::ID_FILELIST, SearchPanel::onCmdEdit),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_SELECT_ALL, SearchPanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_DESELECT_ALL, SearchPanel::onCmdSelect),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_SELECT_INVERSE, SearchPanel::onCmdSelect),
    FXMAPFUNC(SEL_RIGHTBUTTONRELEASE, SearchPanel::ID_FILELIST, SearchPanel::onCmdPopupMenu),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_POPUP_MENU, SearchPanel::onCmdPopupMenu),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_COPY_CLIPBOARD, SearchPanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_CUT_CLIPBOARD, SearchPanel::onCmdCopyCut),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_FILE_COPYTO, SearchPanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_FILE_MOVETO, SearchPanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_FILE_RENAME, SearchPanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_FILE_SYMLINK, SearchPanel::onCmdFileMan),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_ADD_TO_ARCH, SearchPanel::onCmdAddToArch),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_EXTRACT, SearchPanel::onCmdExtract),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_FILE_TRASH, SearchPanel::onCmdFileTrash),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_FILE_DELETE, SearchPanel::onCmdFileDelete),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_GO_SCRIPTDIR, SearchPanel::onCmdGoScriptDir),
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_DIR_USAGE, SearchPanel::onCmdDirUsage),
    FXMAPFUNC(SEL_UPDATE, SearchPanel::ID_STATUS, SearchPanel::onUpdStatus),
    FXMAPFUNC(SEL_UPDATE, SearchPanel::ID_FILE_RENAME, SearchPanel::onUpdSelMult),
    FXMAPFUNC(SEL_UPDATE, SearchPanel::ID_GOTO_PARENTDIR, SearchPanel::onUpdSelMult),
    FXMAPFUNC(SEL_UPDATE, SearchPanel::ID_COMPARE, SearchPanel::onUpdCompare),
    FXMAPFUNC(SEL_UPDATE, SearchPanel::ID_COPY_CLIPBOARD, SearchPanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, SearchPanel::ID_CUT_CLIPBOARD, SearchPanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, SearchPanel::ID_PROPERTIES, SearchPanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, SearchPanel::ID_FILE_TRASH, SearchPanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, SearchPanel::ID_FILE_DELETE, SearchPanel::onUpdMenu),
    FXMAPFUNC(SEL_UPDATE, SearchPanel::ID_DIR_USAGE, SearchPanel::onUpdDirUsage),
#if defined(linux)
    FXMAPFUNC(SEL_COMMAND, SearchPanel::ID_PKG_QUERY, SearchPanel::onCmdPkgQuery),
    FXMAPFUNC(SEL_UPDATE, SearchPanel::ID_PKG_QUERY, SearchPanel::onUpdPkgQuery),
#endif
};


// Object implementation
FXIMPLEMENT(SearchPanel, FXVerticalFrame, SearchPanelMap, ARRAYNUMBER(SearchPanelMap))



// Contruct Search Panel
SearchPanel::SearchPanel(FXComposite* p, FXuint name_size, FXuint dir_size, FXuint size_size, FXuint type_size, FXuint ext_size,
                         FXuint modd_size, FXuint user_size, FXuint grou_size, FXuint attr_size, FXColor listbackcolor, FXColor listforecolor,
                         FXuint opts, int x, int y, int w, int h) :
    FXVerticalFrame(p, opts, x, y, w, h, 0, 0, 0, 0)
{
    //mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);
    //mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_ANIMTHROB));

    // Global container
    FXVerticalFrame* cont = new FXVerticalFrame(this, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1);

    // Container for the action toolbar
    FXHorizontalFrame* toolbar = new FXHorizontalFrame(cont, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, DEFAULT_SPACING, DEFAULT_SPACING, DEFAULT_SPACING, DEFAULT_SPACING, 0, 0);

    // File list
    FXVerticalFrame* cont2 = new FXVerticalFrame(cont, LAYOUT_FILL_Y|LAYOUT_FILL_X|FRAME_SUNKEN, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    list = new FileList(this, cont2, this, ID_FILELIST, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_DETAILED|_FILELIST_SEARCH);
    list->setHeaderSize(0, name_size);
    list->setHeaderSize(1, dir_size);
    list->setHeaderSize(2, size_size);
    list->setHeaderSize(3, type_size);
    list->setHeaderSize(4, ext_size);
    list->setHeaderSize(5, modd_size);
    list->setHeaderSize(6, user_size);
    list->setHeaderSize(7, grou_size);
    list->setHeaderSize(8, attr_size);
    list->setTextColor(listforecolor);
    list->setBackColor(listbackcolor);

	// Set list style
    FXuint liststyle = getApp()->reg().readUnsignedEntry("SEARCH PANEL", "liststyle", _ICONLIST_DETAILED);
    list->setListStyle(liststyle);
	
	// Set dirs first
    FXuint dirsfirst = getApp()->reg().readUnsignedEntry("SEARCH PANEL", "dirs_first", 1);
    list->setDirsFirst(dirsfirst);

	// Set ignore case
    FXuint ignorecase = getApp()->reg().readUnsignedEntry("SEARCH PANEL", "ignore_case", 1);
    list->setIgnoreCase(ignorecase);

    // Toolbar buttons
    FXHotKey hotkey;
    FXString key;

    // Refresh panel toolbar button
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "refresh", "Ctrl-R");
    refreshbtn = new FXButton(toolbar, TAB+_("Refresh panel")+PARS(key), reloadicon, this, SearchPanel::ID_REFRESH, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT);
    hotkey = _parseAccel(key);
    refreshbtn->addHotKey(hotkey);

    // Goto dir toolbar button
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_up", "Backspace");
    gotodirbtn = new FXButton(toolbar, TAB+_("Go to parent folder")+PARS(key), gotodiricon, this, SearchPanel::ID_GOTO_PARENTDIR, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT);
    hotkey = _parseAccel(key);
    gotodirbtn->addHotKey(hotkey);

    // Copy / cut / properties toolbar buttons
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "copy", "Ctrl-C");
    copybtn = new FXButton(toolbar, TAB+_("Copy selected files to clipboard")+PARS(key), copy_clpicon, this, SearchPanel::ID_COPY_CLIPBOARD, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT);
    hotkey = _parseAccel(key);
    copybtn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "cut", "Ctrl-X");
    cutbtn = new FXButton(toolbar, TAB+_("Cut selected files to clipboard")+PARS(key), cut_clpicon, this, SearchPanel::ID_CUT_CLIPBOARD, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT);
    hotkey = _parseAccel(key);
    cutbtn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "properties", "F9");
    propbtn = new FXButton(toolbar, TAB+_("Show properties of selected files")+PARS(key), attribicon, this, SearchPanel::ID_PROPERTIES, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT);
    hotkey = _parseAccel(key);
    propbtn->addHotKey(hotkey);

    // Separator
    new FXFrame(toolbar, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE);
    new FXVerticalSeparator(toolbar, LAYOUT_SIDE_TOP|LAYOUT_CENTER_Y|SEPARATOR_GROOVE|LAYOUT_FIX_HEIGHT, 0, 0, 0, SEP_HEIGHT);
    new FXFrame(toolbar, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE);

    // Move to trash / delete toolbar buttons
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "move_to_trash", "Del");
    trashbtn = new FXButton(toolbar, TAB+_("Move selected files to trash can")+PARS(key), filedeleteicon, this, SearchPanel::ID_FILE_TRASH, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT);
    hotkey = _parseAccel(key);
    trashbtn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "delete", "Shift-Del");
    delbtn = new FXButton(toolbar, TAB+_("Delete selected files")+PARS(key), filedelete_permicon, this, SearchPanel::ID_FILE_DELETE, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT);
    hotkey = _parseAccel(key);
    delbtn->addHotKey(hotkey);

    // Separator
    new FXFrame(toolbar, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE);
    new FXVerticalSeparator(toolbar, LAYOUT_SIDE_TOP|LAYOUT_CENTER_Y|SEPARATOR_GROOVE|LAYOUT_FIX_HEIGHT, 0, 0, 0, SEP_HEIGHT);
    new FXFrame(toolbar, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE);

    // Icon view toolbar buttons
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "big_icons", "F10");
    bigiconsbtn = new FXButton(toolbar, TAB+_("Big icon list")+PARS(key), bigiconsicon, list, IconList::ID_SHOW_BIG_ICONS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED);
    hotkey = _parseAccel(key);
    bigiconsbtn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "small_icons", "F11");
    smalliconsbtn = new FXButton(toolbar, TAB+_("Small icon list")+PARS(key), smalliconsicon, list, IconList::ID_SHOW_MINI_ICONS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED);
    hotkey = _parseAccel(key);
    smalliconsbtn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "detailed_file_list", "F12");
    detailsbtn = new FXButton(toolbar, TAB+_("Detailed file list")+PARS(key), detailsicon, list, IconList::ID_SHOW_DETAILS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED);
    hotkey = _parseAccel(key);
    detailsbtn->addHotKey(hotkey);

    // Status bar
    statusbar = new FXHorizontalFrame(cont, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 3, 3, 3, 3);
    statusbar->setTarget(this);
    statusbar->setSelector(FXSEL(SEL_UPDATE, SearchPanel::ID_STATUS));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");
    thumbbtn = new FXToggleButton(statusbar, TAB+_("Show thumbnails")+PARS(key), TAB+_("Hide thumbnails")+PARS(key), showthumbicon, hidethumbicon, this->list,
                                  FileList::ID_TOGGLE_THUMBNAILS, TOGGLEBUTTON_TOOLBAR|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED);
    hotkey = _parseAccel(key);
    thumbbtn->addHotKey(hotkey);

    new FXHorizontalFrame(statusbar, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0);
    status = new FXLabel(statusbar, _("Status"), NULL, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X);

    corner = new FXDragCorner(statusbar);

    // File associations
    associations = NULL;
    associations = new FileDict(getApp());

    // Dialogs
    archdialog = NULL;
    opendialog = NULL;
    operationdialogsingle = NULL;
    operationdialogrename = NULL;
    operationdialogmultiple = NULL;
    comparedialog = NULL;

    // Trahscan locations
    trashfileslocation = xdgdatahome + PATHSEPSTRING TRASHFILESPATH;
    trashinfolocation = xdgdatahome + PATHSEPSTRING TRASHINFOPATH;

    // Default programs identifiers
    progs["<txtviewer>"] = TXTVIEWER;
    progs["<txteditor>"] = TXTEDITOR;
    progs["<imgviewer>"] = IMGVIEWER;
    progs["<imgeditor>"] = IMGEDITOR;
    progs["<pdfviewer>"] = PDFVIEWER;
    progs["<audioplayer>"] = AUDIOPLAYER;
    progs["<videoplayer>"] = VIDEOPLAYER;
    progs["<archiver>"] = ARCHIVER;

    // Class variable initializations
    ctrlflag = false;
    shiftf10 = false;
}


// Create window
void SearchPanel::create()
{
    // Register standard uri-list type
    urilistType = getApp()->registerDragType("text/uri-list");

    // Register special uri-list type used for Gnome, XFCE and Xfe
    xfelistType = getApp()->registerDragType("x-special/gnome-copied-files");

    // Register special uri-list type used for KDE
    kdelistType = getApp()->registerDragType("application/x-kde-cutselection");

    // Register standard UTF-8 text type used for file dialogs
    utf8Type = getApp()->registerDragType("UTF8_STRING");

    FXVerticalFrame::create();

    // Single click navigation
    if (single_click == SINGLE_CLICK_DIR_FILE)
    {
        list->setDefaultCursor(getApp()->getDefaultCursor(DEF_HAND_CURSOR));
    }
    else
    {
        list->setDefaultCursor(getApp()->getDefaultCursor(DEF_ARROW_CURSOR));
    }
}


// Clean up
SearchPanel::~SearchPanel()
{
    delete list;
    if (opendialog != NULL)
    {
        delete opendialog;
    }
    if (archdialog != NULL)
    {
        delete archdialog;
    }
    if (operationdialogsingle != NULL)
    {
        delete operationdialogsingle;
    }
    if (operationdialogrename != NULL)
    {
        delete operationdialogrename;
    }
    if (operationdialogmultiple != NULL)
    {
        delete operationdialogmultiple;
    }
    if (comparedialog != NULL)
    {
        delete comparedialog;
    }
}


// Double Click on File Item
long SearchPanel::onCmdItemDoubleClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    // Wait cursor
    getApp()->beginWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);

    FXlong item = (FXlong)ptr;
    if (item > -1)
    {
#ifdef STARTUP_NOTIFICATION
        // Startup notification option and exceptions (if any)
        FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
        FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

        // Default programs
        FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
        FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
        FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
        FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
        FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
        FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
        FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
        FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

        FXString cmd, cmdname, filename, pathname, parentdir;

        // File name and path
        filename = list->getItemFilename(item);
        pathname = list->getItemFullPathname(item);

        // If directory, open the directory
        if (list->isItemDirectory(item))
        {
            // Does not have access
            if (!::isReadExecutable(pathname))
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _(" Permission to: %s denied."), pathname.text());
                getApp()->endWaitCursor();
		mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                return(0);
            }

            // Change directory in Xfe
            ((XFileExplorer*)mainWindow)->setDirectory(pathname);

            // Raise the Xfe window
            ((XFileExplorer*)mainWindow)->raise();
            ((XFileExplorer*)mainWindow)->setFocus();

            // Warning message when setting current folder in Xfe
            FXbool warn = getApp()->reg().readUnsignedEntry("OPTIONS", "folder_warn", true);
            if (warn)
            {
                MessageBox::information(((XFileExplorer*)mainWindow), BOX_OK, _("Information"), _("Current folder has been set to '%s'"), pathname.text());
            }
        }
        else if (list->isItemFile(item))
        {
            // Parent directory
            parentdir = FXPath::directory(pathname);

            // Update associations dictionary
            FileDict*  assocdict = new FileDict(getApp());
            FileAssoc* association = assocdict->findFileBinding(pathname.text());

            // If there is an association
            if (association)
            {
                // Use it to open the file
                if (association->command.section(',', 0) != "")
                {
                    cmdname = association->command.section(',', 0);

                    // Use a default program if possible
                    switch (progs[cmdname])
                    {
                    case TXTVIEWER:
                        cmdname = txtviewer;
                        break;

                    case TXTEDITOR:
                        cmdname = txteditor;
                        break;

                    case IMGVIEWER:
                        cmdname = imgviewer;
                        break;

                    case IMGEDITOR:
                        cmdname = imgeditor;
                        break;

                    case PDFVIEWER:
                        cmdname = pdfviewer;
                        break;

                    case AUDIOPLAYER:
                        cmdname = audioplayer;
                        break;

                    case VIDEOPLAYER:
                        cmdname = videoplayer;
                        break;

                    case ARCHIVER:
                        cmdname = archiver;
                        break;

                    case NONE: // No program found
                        ;
                        break;
                    }

                    // If command exists, run it
                    if (::existCommand(cmdname))
                    {
                        cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                        runcmd(cmd, cmdname, parentdir, searchdir, usesn, snexcepts);
#else
                        runcmd(cmd, parentdir, searchdir);
#endif
                    }

                    // If command does not exist, call the "Open with..." dialog
                    else
                    {
			mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                        getApp()->endWaitCursor();
                        this->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }

                // Or execute the file
                else if (list->isItemExecutable(item))
                {
                    execFile(pathname);
                }

                // Or call the "Open with..." dialog
                else
                {
		    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                    getApp()->endWaitCursor();
                    this->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                }
            }

            // If no association but executable
            else if (list->isItemExecutable(item))
            {
                execFile(pathname);
            }

            // Other cases
            else
            {
		mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                getApp()->endWaitCursor();
                this->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
            }
        }
    }

    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
    getApp()->endWaitCursor();

    return(1);
}


// Execute file with an optional confirm dialog
void SearchPanel::execFile(FXString pathname)
{
    int      ret;
    FXString cmd, cmdname, parentdir;

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // Parent directory
    parentdir = FXPath::directory(pathname);

    // File is executable, but is it a text file?
    FXString str = mimetype(pathname);
    FXbool   isTextFile = true;
    if (strstr(str.text(), "charset=binary"))
    {
        isTextFile = false;
    }

    // With confirmation dialog
    FXbool confirm_execute = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_execute", true);
    if (isTextFile && (confirm_execute == 1))
    {
        FXString msg;
        msg.format(_("File %s is an executable text file, what do you want to do?"), pathname.text());
        ExecuteBox* dlg = new ExecuteBox(this, _("Confirm Execute"), msg);
        FXuint      answer = dlg->execute(PLACEMENT_CURSOR);
        delete dlg;

        // Execute
        if (answer == EXECBOX_CLICKED_EXECUTE)
        {
            cmdname = FXPath::name(pathname);
            cmd = ::quote(pathname);
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, parentdir, searchdir, usesn, snexcepts);
#else
            runcmd(cmd, parentdir, searchdir);
#endif
        }

        // Execute in console mode
        if (answer == EXECBOX_CLICKED_CONSOLE)
        {
            ret = chdir(parentdir.text());
            if (ret < 0)
            {
                int errcode = errno;
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), parentdir.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), parentdir.text());
                }
            }

            cmdname = FXPath::name(pathname);
            cmd = ::quote(pathname);

            // Make and show command window
            // The CommandWindow object will delete itself when closed!
            CommandWindow* cmdwin = new CommandWindow(getApp(), _("Command log"), cmd, 30, 80);
            cmdwin->create();
            cmdwin->setIcon(runicon);
        }

        // Edit
        if (answer == EXECBOX_CLICKED_EDIT)
        {
            FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
            cmd = txteditor;
            cmdname = cmd;

            // If command exists, run it
            if (::existCommand(cmdname))
            {
                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                runcmd(cmd, cmdname, parentdir, searchdir, usesn, snexcepts);
#else
                runcmd(cmd, parentdir, searchdir);
#endif
            }

            // If command does not exist, call the "Open with..." dialog
            else
            {
                this->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
            }
        }
    }

    // Without confirmation dialog
    else
    {
        cmdname = FXPath::name(pathname);
        cmd = ::quote(pathname);
#ifdef STARTUP_NOTIFICATION
        runcmd(cmd, cmdname, parentdir, searchdir, usesn, snexcepts);
#else
        runcmd(cmd, parentdir, searchdir);
#endif
    }
}


// Single click on File Item
long SearchPanel::onCmdItemClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    if (single_click != SINGLE_CLICK_NONE)
    {
        // Default programs
        FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
        FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
        FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
        FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
        FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
        FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
        FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
        FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

        // In detailed mode, avoid single click when cursor is not over the first column
        int    x, y;
        FXuint state;
        getCursorPosition(x, y, state);
        FXbool allow = true;
        if (!(list->getListStyle()&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS)) && ((x-list->getXPosition()) > list->getHeaderSize(0)))
        {
            allow = false;
        }

        // Single click with control or shift
        if (state&(CONTROLMASK|SHIFTMASK))
        {
            return(1);
        }

        // Single click without control or shift
        else
        {
            FXString cmd, cmdname, filename, pathname, parentdir;

            // Wait cursor
	    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);
            getApp()->beginWaitCursor();

#ifdef STARTUP_NOTIFICATION
            // Startup notification option and exceptions (if any)
            FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
            FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

            FXlong item = (FXlong)ptr;
            if (item > -1)
            {
                // File name and path
                filename = list->getItemFilename(item);
                pathname = list->getItemFullPathname(item);

                // If directory, open the directory
                if ((single_click != SINGLE_CLICK_NONE) && list->isItemDirectory(item) && allow)
                {
                    // Does not have access
                    if (!::isReadExecutable(pathname))
                    {
                        MessageBox::error(this, BOX_OK_SU, _("Error"), _(" Permission to: %s denied."), pathname.text());
                        getApp()->endWaitCursor();
	    		mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                        return(0);
                    }

                    // Change directory in Xfe
                    ((XFileExplorer*)mainWindow)->setDirectory(pathname);

                    // Raise the Xfe window
                    ((XFileExplorer*)mainWindow)->raise();
                    ((XFileExplorer*)mainWindow)->setFocus();

                    // Warning message when setting current folder in Xfe
                    FXbool warn = getApp()->reg().readUnsignedEntry("OPTIONS", "folder_warn", true);
                    if (warn)
                    {
                        MessageBox::information(((XFileExplorer*)mainWindow), BOX_OK, _("Information"), _("Current folder has been set to '%s'"), pathname.text());
                    }
                }

                // If file, use the association if any
                else if ((single_click == SINGLE_CLICK_DIR_FILE) && list->isItemFile(item) && allow)
                {
                    // Parent directory
                    parentdir = FXPath::directory(pathname);

                    // Update associations dictionary
                    FileDict*  assocdict = new FileDict(getApp());
                    FileAssoc* association = assocdict->findFileBinding(pathname.text());

                    // If there is an association
                    if (association)
                    {
                        // Use it to open the file
                        if (association->command.section(',', 0) != "")
                        {
                            cmdname = association->command.section(',', 0);

                            // Use a default program if possible
                            switch (progs[cmdname])
                            {
                            case TXTVIEWER:
                                cmdname = txtviewer;
                                break;

                            case TXTEDITOR:
                                cmdname = txteditor;
                                break;

                            case IMGVIEWER:
                                cmdname = imgviewer;
                                break;

                            case IMGEDITOR:
                                cmdname = imgeditor;
                                break;

                            case PDFVIEWER:
                                cmdname = pdfviewer;
                                break;

                            case AUDIOPLAYER:
                                cmdname = audioplayer;
                                break;

                            case VIDEOPLAYER:
                                cmdname = videoplayer;
                                break;

                            case ARCHIVER:
                                cmdname = archiver;
                                break;

                            case NONE: // No program found
                                ;
                                break;
                            }

                            // If command exists, run it
                            if (::existCommand(cmdname))
                            {
                                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                                runcmd(cmd, cmdname, parentdir, searchdir, usesn, snexcepts);
#else
                                runcmd(cmd, parentdir, searchdir);
#endif
                            }

                            // If command does not exist, call the "Open with..." dialog
                            else
                            {
                                getApp()->endWaitCursor();
			        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                                this->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                            }
                        }

                        // Or execute the file
                        else if (list->isItemExecutable(item))
                        {
                            execFile(pathname);
                        }

                        // Or call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
			    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                            this->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // If no association but executable
                    else if (list->isItemExecutable(item))
                    {
                        execFile(pathname);
                    }

                    // Other cases
                    else
                    {
                        getApp()->endWaitCursor();
		        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                        this->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }
            }
	    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
            getApp()->endWaitCursor();
        }
    }
    return(1);
}


// Open with
long SearchPanel::onCmdOpenWith(FXObject*, FXSelector, void*)
{
    char** str = NULL;

    if (list->getNumSelectedItems() == 0)
    {
        return(0);
    }

    FXString cmd = "", cmdname;
    if (opendialog == NULL)
    {
        opendialog = new HistInputDialog(this, "", _("Open selected file(s) with:"), _("Open With"), "", bigfileopenicon, HIST_INPUT_EXECUTABLE_FILE, true, _("A&ssociate"));
    }
    opendialog->setText(cmd);

    // Dialog with history list and associate checkbox
    opendialog->CursorEnd();
    opendialog->selectAll();
    opendialog->clearItems();
    for (int i = 0; i < OpenNum; i++)
    {
        opendialog->appendItem(OpenHistory[i]);
    }
    opendialog->sortItems();
    opendialog->setDirectory(ROOTDIR);
    if (opendialog->execute())
    {
        cmd = opendialog->getText();
        if (cmd == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u))
            {
                // Handles "associate" checkbox for "open with..." dialog
                if (opendialog->getOption())
                {
                    FXString filename = list->getItemFilename(u);
                    FXString ext = filename.rafter('.', 2).lower();

                    if ((ext == "tar.gz") || (ext == "tar.bz2") || (ext == "tar.xz") || (ext == "tar.z")) // Special cases
                    {
                    }
                    else
                    {
                        ext = FXPath::extension(filename).lower();
                    }

                    if (ext == "")
                    {
                        ext = FXPath::name(filename);
                    }

                    FileAssoc* association = list->getItemAssoc(u);

                    if (association)
                    {
                        // Update existing association
                        FXString oldfileassoc = getApp()->reg().readStringEntry("FILETYPES", ext.text(), "");
                        oldfileassoc.erase(0, oldfileassoc.section(';', 0).section(',', 0).length());
                        oldfileassoc.prepend(opendialog->getText());
                        getApp()->reg().writeStringEntry("FILETYPES", ext.text(), oldfileassoc.text());

                        // Handle file association
                        str = new char* [2];
                        str[0] = new char[strlen(ext.text())+1];
                        str[1] = new char[strlen(oldfileassoc.text())+1];
                        strlcpy(str[0], ext.text(), ext.length()+1);
                        strlcpy(str[1], oldfileassoc.text(), oldfileassoc.length()+1);
                        mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ASSOC), str);
                    }
                    else
                    {
                        // New association
                        FXString newcmd = opendialog->getText().append(";Document;;;;");
                        getApp()->reg().writeStringEntry("FILETYPES", ext.text(), newcmd.text());

                        // Handle file association
                        str = new char* [2];
                        str[0] = new char[strlen(ext.text())+1];
                        str[1] = new char[strlen(newcmd.text())+1];
                        strlcpy(str[0], ext.text(), ext.length()+1);
                        strlcpy(str[1], newcmd.text(), newcmd.length()+1);
                        mainWindow->handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ASSOC), str);
                    }
                }
                // End

                FXString pathname = list->getItemFullPathname(u);
                cmdname = cmd;
                cmd += " ";
                cmd = cmd+::quote(pathname);
            }
        }

        // Run command if it exists
        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);
        getApp()->beginWaitCursor();

#ifdef STARTUP_NOTIFICATION
        // Startup notification option and exceptions (if any)
        FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
        FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

        // If command exists, run it
        if (::existCommand(cmdname))
#ifdef STARTUP_NOTIFICATION
        {
            runcmd(cmd, cmdname, searchdir, searchdir, usesn, snexcepts);
        }
#else
        {
            runcmd(cmd, searchdir, searchdir);
        }
#endif
        // If command does not exist, call the "Open with..." dialog
        else
        {
            mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
            getApp()->endWaitCursor();
            this->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
            return(1);
        }

        // Update history list
        OpenNum = opendialog->getHistorySize();
        cmd = opendialog->getText();

        // Check if cmd is a new string, i.e. is not already in history
        FXbool newstr = true;
        for (int i = 0; i < OpenNum-1; i++)
        {
            if (streq(OpenHistory[i], cmd.text()))
            {
                newstr = false;
                break;
            }
        }

        // Restore original history order
        opendialog->clearItems();
        for (int i = 0; i < OpenNum; i++)
        {
            opendialog->appendItem(OpenHistory[i]);
        }

        // History limit reached
        if (OpenNum > OPEN_HIST_SIZE)
        {
            OpenNum--;
        }

        // New string
        if (newstr)
        {
            // FIFO
            strlcpy(OpenHistory[0], cmd.text(), cmd.length()+1);
            for (int i = 1; i < OpenNum; i++)
            {
                strlcpy(OpenHistory[i], opendialog->getHistoryItem(i-1).text(), opendialog->getHistoryItem(i-1).length()+1);
            }
        }
	mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
        getApp()->endWaitCursor();
    }

    return(1);
}


// Open single or multiple files
long SearchPanel::onCmdOpen(FXObject*, FXSelector, void*)
{
    // Wait cursor
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);
    getApp()->beginWaitCursor();

    FXString   pathname, samecmd, cmd, cmdname, itemslist = " ";
    FileAssoc* association;
    FXbool     same = true;
    FXbool     first = true;

    if (list->getNumSelectedItems() == 0)
    {
        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
        getApp()->endWaitCursor();
        return(0);
    }

    // Default programs
    FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
    FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
    FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
    FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
    FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
    FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
    FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
    FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

    // Update associations dictionary
    FileDict* assocdict = new FileDict(getApp());

    // Check if all files have the same association
    for (int u = 0; u < list->getNumItems(); u++)
    {
        if (list->isItemSelected(u))
        {
            // Increment number of selected items
            pathname = list->getItemFullPathname(u);
            association = assocdict->findFileBinding(pathname.text());

            if (association)
            {
                cmd = association->command.section(',', 0);

                // Use a default program if possible
                switch (progs[cmd])
                {
                case TXTVIEWER:
                    cmd = txtviewer;
                    break;

                case TXTEDITOR:
                    cmd = txteditor;
                    break;

                case IMGVIEWER:
                    cmd = imgviewer;
                    break;

                case IMGEDITOR:
                    cmd = imgeditor;
                    break;

                case PDFVIEWER:
                    cmd = pdfviewer;
                    break;

                case AUDIOPLAYER:
                    cmd = audioplayer;
                    break;

                case VIDEOPLAYER:
                    cmd = videoplayer;
                    break;

                case ARCHIVER:
                    cmd = archiver;
                    break;

                case NONE: // No program found
                    ;
                    break;
                }

                if (cmd != "")
                {
                    // First selected item
                    if (first)
                    {
                        samecmd = cmd;
                        first = false;
                    }

                    if (samecmd != cmd)
                    {
                        same = false;
                        break;
                    }

                    // List of selected items
                    itemslist += ::quote(pathname) + " ";
                }
                else
                {
                    same = false;
                    break;
                }
            }
            else
            {
                same = false;
                break;
            }
        }
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // Same command for all files : open them
    if (same)
    {
        cmdname = samecmd;

        // If command exists, run it
        if (::existCommand(cmdname))
        {
            cmd = samecmd+itemslist;
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, searchdir, searchdir, usesn, snexcepts);
#else
            runcmd(cmd, searchdir, searchdir);
#endif
        }

        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
            this->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
        }
    }

    // Files have different commands : handle them separately
    else
    {
        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u))
            {
                pathname = list->getItemFullPathname(u);
                association = assocdict->findFileBinding(pathname.text());

                // If there is an association
                if (association)
                {
                    // Use it to open the file
                    cmd = association->command.section(',', 0);

                    // Use a default program if possible
                    switch (progs[cmd])
                    {
                    case TXTVIEWER:
                        cmd = txtviewer;
                        break;

                    case TXTEDITOR:
                        cmd = txteditor;
                        break;

                    case IMGVIEWER:
                        cmd = imgviewer;
                        break;

                    case IMGEDITOR:
                        cmd = imgeditor;
                        break;

                    case PDFVIEWER:
                        cmd = pdfviewer;
                        break;

                    case AUDIOPLAYER:
                        cmd = audioplayer;
                        break;

                    case VIDEOPLAYER:
                        cmd = videoplayer;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No program found
                        ;
                        break;
                    }

                    if (cmd != "")
                    {
                        cmdname = cmd;

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, searchdir, searchdir, usesn, snexcepts);
#else
                            runcmd(cmd, searchdir, searchdir);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
		            mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                            this->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }

                    // or execute the file
                    else if (list->isItemExecutable(u))
                    {
                        execFile(pathname);
                    }

                    // or call the "Open with..." dialog
                    else
                    {
                        getApp()->endWaitCursor();
		        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                        this->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                    }
                }

                // If no association but executable
                else if (list->isItemExecutable(u))
                {
                    execFile(pathname);
                }

                // Other cases
                else
                {
                    getApp()->endWaitCursor();
	            mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                    this->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                }
            }
        }
    }

    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
    getApp()->endWaitCursor();

    return(1);
}


// View/Edit files
long SearchPanel::onCmdEdit(FXObject*, FXSelector s, void*)
{
    // Wait cursor
    getApp()->beginWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);

    FXString   pathname, samecmd, cmd, cmdname, itemslist = " ";
    FileAssoc* association;
    FXbool     same = true;
    FXbool     first = true;

    if (list->getNumSelectedItems() == 0)
    {
        getApp()->endWaitCursor();
        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
        return(0);
    }

    FXString txtviewer = getApp()->reg().readStringEntry("PROGS", "txtviewer", DEFAULT_TXTVIEWER);
    FXString txteditor = getApp()->reg().readStringEntry("PROGS", "txteditor", DEFAULT_TXTEDITOR);
    FXString imgviewer = getApp()->reg().readStringEntry("PROGS", "imgviewer", DEFAULT_IMGVIEWER);
    FXString imgeditor = getApp()->reg().readStringEntry("PROGS", "imgeditor", DEFAULT_IMGEDITOR);
    FXString pdfviewer = getApp()->reg().readStringEntry("PROGS", "pdfviewer", DEFAULT_PDFVIEWER);
    FXString audioplayer = getApp()->reg().readStringEntry("PROGS", "audioplayer", DEFAULT_AUDIOPLAYER);
    FXString videoplayer = getApp()->reg().readStringEntry("PROGS", "videoplayer", DEFAULT_VIDEOPLAYER);
    FXString archiver = getApp()->reg().readStringEntry("PROGS", "archiver", DEFAULT_ARCHIVER);

    // Update associations dictionary
    FileDict* assocdict = new FileDict(getApp());

    // Check if all files have the same association
    for (int u = 0; u < list->getNumItems(); u++)
    {
        if (list->isItemSelected(u))
        {
            // Increment number of selected items
            pathname = list->getItemFullPathname(u);
            association = assocdict->findFileBinding(pathname.text());

            // If there is an association
            if (association)
            {
                // Use it to edit/view the files
                if (FXSELID(s) == ID_EDIT) // Edit
                {
                    cmd = association->command.section(',', 2);

                    // Use a default editor if possible
                    switch (progs[cmd])
                    {
                    case TXTEDITOR:
                        cmd = txteditor;
                        break;

                    case IMGEDITOR:
                        cmd = imgeditor;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No default editor found
                        ;
                        break;
                    }

                    if (cmd.length() == 0)
                    {
                        cmd = txteditor;
                    }
                }
                else // Any other is View
                {
                    cmd = association->command.section(',', 1);

                    // Use a default viewer if possible
                    switch (progs[cmd])
                    {
                    case TXTVIEWER:
                        cmd = txtviewer;
                        break;

                    case IMGVIEWER:
                        cmd = imgviewer;
                        break;

                    case PDFVIEWER:
                        cmd = pdfviewer;
                        break;

                    case AUDIOPLAYER:
                        cmd = audioplayer;
                        break;

                    case VIDEOPLAYER:
                        cmd = videoplayer;
                        break;

                    case ARCHIVER:
                        cmd = archiver;
                        break;

                    case NONE: // No default viewer found
                        ;
                        break;
                    }

                    if (cmd.length() == 0)
                    {
                        cmd = txtviewer;
                    }
                }
                if (cmd.text() != NULL)
                {
                    // First selected item
                    if (first)
                    {
                        samecmd = cmd;
                        first = false;
                    }

                    if (samecmd != cmd)
                    {
                        same = false;
                        break;
                    }

                    // List of selected items
                    itemslist += ::quote(pathname) + " ";
                }
                else
                {
                    same = false;
                    break;
                }
            }

            // No association
            else
            {
                same = false;
                break;
            }
        }
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    // Same association for all files : execute the associated or default editor or viewer
    if (same)
    {
        cmdname = samecmd;

        // If command exists, run it
        if (::existCommand(cmdname))
        {
            cmd = cmdname+itemslist;
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd, cmdname, searchdir, searchdir, usesn, snexcepts);
#else
            runcmd(cmd, searchdir, searchdir);
#endif
        }

        // If command does not exist, call the "Open with..." dialog
        else
        {
            getApp()->endWaitCursor();
	    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
            this->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
        }
    }

    // Files have different associations : handle them separately
    else
    {
        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u))
            {
                pathname = list->getItemFullPathname(u);

                // Only View / Edit regular files (not directories)
                if (::isFile(pathname))
                {
                    association = assocdict->findFileBinding(pathname.text());

                    // If there is an association
                    if (association)
                    {
                        // Use it to edit/view the file
                        if (FXSELID(s) == ID_EDIT) // Edit
                        {
                            cmd = association->command.section(',', 2);

                            // Use a default editor if possible
                            switch (progs[cmd])
                            {
                            case TXTEDITOR:
                                cmd = txteditor;
                                break;

                            case IMGEDITOR:
                                cmd = imgeditor;
                                break;

                            case ARCHIVER:
                                cmd = archiver;
                                break;
                            }

                            if (cmd.length() == 0)
                            {
                                cmd = txteditor;
                            }
                        }
                        else // Any other is View
                        {
                            cmd = association->command.section(',', 1);

                            // Use a default viewer if possible
                            switch (progs[cmd])
                            {
                            case TXTVIEWER:
                                cmd = txtviewer;
                                break;

                            case IMGVIEWER:
                                cmd = imgviewer;
                                break;

                            case PDFVIEWER:
                                cmd = pdfviewer;
                                break;

                            case AUDIOPLAYER:
                                cmd = audioplayer;
                                break;

                            case VIDEOPLAYER:
                                cmd = videoplayer;
                                break;

                            case ARCHIVER:
                                cmd = archiver;
                                break;

                            case NONE: // No default viewer found
                                ;
                                break;
                            }

                            if (cmd.length() == 0)
                            {
                                cmd = txtviewer;
                            }
                        }
                        if (cmd.text() != NULL)
                        {
                            cmdname = cmd;

                            // If command exists, run it
                            if (::existCommand(cmdname))
                            {
                                cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                                runcmd(cmd, cmdname, searchdir, searchdir, usesn, snexcepts);
#else
                                runcmd(cmd, searchdir, searchdir);
#endif
                            }

                            // If command does not exist, call the "Open with..." dialog
                            else
                            {
                                getApp()->endWaitCursor();
			        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                                this->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                            }
                        }
                    }

                    // No association
                    else
                    {
                        if (FXSELID(s) == ID_EDIT)
                        {
                            cmd = txteditor;
                        }
                        else
                        {
                            cmd = txtviewer;
                        }

                        cmdname = cmd;

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd = cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd, cmdname, searchdir, searchdir, usesn, snexcepts);
#else
                            runcmd(cmd, searchdir, searchdir);
#endif
                        }

                        // If command does not exist, call the "Open with..." dialog
                        else
                        {
                            getApp()->endWaitCursor();
			    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                            this->handle(this, FXSEL(SEL_COMMAND, ID_OPEN_WITH), NULL);
                        }
                    }
                }
            }
        }
    }

    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
    getApp()->endWaitCursor();

    return(1);
}


// Compare two files
long SearchPanel::onCmdCompare(FXObject*, FXSelector s, void*)
{
    list->setFocus();
    int num = list->getNumSelectedItems();

    // Only one or two selected items can be handled
    if ((num != 1) && (num != 2))
    {
        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
        getApp()->endWaitCursor();
        return(0);
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool   usesn = getApp()->reg().readUnsignedEntry("OPTIONS", "use_startup_notification", true);
    FXString snexcepts = getApp()->reg().readStringEntry("OPTIONS", "startup_notification_exceptions", "");
#endif

    FXString filecomparator = getApp()->reg().readStringEntry("PROGS", "filecomparator", DEFAULT_FILECOMPARATOR);
    FXString pathname, cmd, cmdname, itemslist = " ";

    // One selected item
    if (num == 1)
    {
        // Get the selected item
        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u))
            {
                pathname = list->getItemFullPathname(u);
                itemslist += ::quote(pathname) + " ";
            }
        }

        // Open a dialog to select the other item to be compared
        if (comparedialog == NULL)
        {
            comparedialog = new BrowseInputDialog(this, "", "", _("Compare"), _("With:"), bigcompareicon, BROWSE_INPUT_FILE);
        }
        comparedialog->setIcon(bigcompareicon);
        comparedialog->setMessage(pathname);
        comparedialog->setText("");
        int rc = 1;
        rc = comparedialog->execute(PLACEMENT_CURSOR);

        // Get item path and add it to the list
        FXString str = comparedialog->getText();
        itemslist += ::quote(str);
        if (!rc || (str == ""))
        {
            return(0);
        }
    }

    // Two selected items
    else if (num == 2)
    {
        // Get the two selected items
        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u))
            {
                pathname = list->getItemFullPathname(u);
                itemslist += ::quote(pathname) + " ";
            }
        }
    }

    // Wait cursor
    getApp()->beginWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);

    // If command exists, run it
    cmdname = filecomparator;
    if (::existCommand(cmdname))
    {
        cmd = cmdname+itemslist;
#ifdef STARTUP_NOTIFICATION
        runcmd(cmd, cmdname, searchdir, searchdir, usesn, snexcepts);
#else
        runcmd(cmd, searchdir, searchdir);
#endif
    }

    // If command does not exist, issue an error message
    else
    {
        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
        getApp()->endWaitCursor();
        MessageBox::error(this, BOX_OK, _("Error"), _("Program %s not found. Please define a file comparator program in the Preferences dialog!"), cmdname.text());
    }

    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
    getApp()->endWaitCursor();

    return(1);
}


// Force panel refresh
long SearchPanel::onCmdRefresh(FXObject* sender, FXSelector, void*)
{
    list->onCmdRefresh(0, 0, 0);

    return(1);
}


// Go to parent directory
long SearchPanel::onCmdGotoParentdir(FXObject*, FXSelector, void*)
{
    if (list->getNumSelectedItems() != 1)
    {
        return(0);
    }

    // Get selected item path name
    FXString pathname;
    for (int u = 0; u < list->getNumItems(); u++)
    {
        if (list->isItemSelected(u))
        {
            pathname = list->getItemFullPathname(u);
            break;
        }
    }

    // Parent directory name
    FXString parentdir = FXPath::directory(pathname);

    // Does not have access
    if (!::isReadExecutable(parentdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _(" Permission to: %s denied."), parentdir.text());
        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
        getApp()->endWaitCursor();
        return(0);
    }

    // Change directory in Xfe
    ((XFileExplorer*)mainWindow)->setDirectory(parentdir);

    // Raise the Xfe window
    ((XFileExplorer*)mainWindow)->raise();
    ((XFileExplorer*)mainWindow)->setFocus();

    // Warning message when setting current folder in Xfe
    FXbool warn = getApp()->reg().readUnsignedEntry("OPTIONS", "folder_warn", true);
    if (warn)
    {
        MessageBox::information(((XFileExplorer*)mainWindow), BOX_OK, _("Information"), _("Current folder has been set to '%s'"), parentdir.text());
    }

    return(1);
}


// File or directory properties
long SearchPanel::onCmdProperties(FXObject* sender, FXSelector, void*)
{
    int num, itm;

    // There is one selected file in the file list
    num = list->getNumSelectedItems(&itm);
    if (num == 1)
    {
        FXString filename = list->getItemFilename(itm);
        FXString pathname = FXPath::directory(list->getItemFullPathname(itm));

        PropertiesBox* attrdlg = new PropertiesBox(this, filename, pathname);
        attrdlg->create();
        attrdlg->show(PLACEMENT_OWNER);
    }

    // There are multiple selected files in the file list
    else if (num > 1)
    {
        FXString* files = new FXString[num];
        FXString* paths = new FXString[num];

        int i = 0;
        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u))
            {
                files[i] = list->getItemText(u).section('\t', 0);
                paths[i] = FXPath::directory(list->getItemFullPathname(u));
                i++;
            }
        }

        PropertiesBox* attrdlg = new PropertiesBox(this, files, num, paths);
        attrdlg->create();
        attrdlg->show(PLACEMENT_OWNER);
    }
    return(1);
}


// Handle item selection
long SearchPanel::onCmdSelect(FXObject* sender, FXSelector sel, void* ptr)
{
    switch (FXSELID(sel))
    {
    case ID_SELECT_ALL:
        list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SELECT_ALL), ptr);
        return(1);

    case ID_DESELECT_ALL:
        list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), ptr);
        return(1);

    case ID_SELECT_INVERSE:
        list->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_SELECT_INVERSE), ptr);
        return(1);
    }
    return(1);
}


// Set search root path
void SearchPanel::setSearchPath(FXString path)
{
    searchdir = path;
    list->setDirectory(path, false);
}


// Append an item to the file list
// Note that thumbnails are not displayed here
long SearchPanel::appendItem(FXString& pathname)
{
    FXString    filename, dirname;
    FXString    grpid, usrid, atts, mod, ext, del;
    FileAssoc*  fileassoc;
    FXString    filetype, lowext;
    FXIcon*     big, *mini;
    time_t      filemtime, filectime;
    struct stat info, linfo;
    FXbool      isLink, isBrokenLink, isDir;

    // Only process valid file paths and paths different from the search directory
    if (lstatrep(pathname.text(), &linfo) == 0)
    {
        filename = FXPath::name(pathname);
        dirname = FXPath::directory(pathname);

        // Get file/link info and indicate if it is a link
        isLink = S_ISLNK(linfo.st_mode);
        isBrokenLink = false;

        // Find if it is a broken link
        if (isLink && (statrep(pathname.text(), &info) != 0))
        {
            isBrokenLink = true;
        }

        // File times
        filemtime = linfo.st_mtime;
        filectime = linfo.st_ctime;

        // Find if it is a folder
        isDir = false;
        if (S_ISDIR(linfo.st_mode))
        {
            isDir = true;
        }

        // Extension
        ext = FXPath::extension(pathname);

        // User name
        usrid = FXSystem::userName(linfo.st_uid);

        // Group name
        grpid = FXSystem::groupName(linfo.st_gid);

        // Permissions (caution : we don't use the FXSystem::modeString() function because
        // it seems to be incompatible with the info.st_mode format)
        atts = ::permissions(linfo.st_mode);

        // Mod time
        mod = FXSystem::time("%x %X", linfo.st_mtime);
        del = "";
        ext = "";

        // Obtain the extension for files only
        if (!isDir)
        {
            ext = FXPath::extension(pathname);
        }

        // Obtain the stat info on the file itself
        if (statrep(pathname.text(), &info) != 0)
        {
            // Except in the case of a broken link
            if (isBrokenLink)
            {
                lstatrep(pathname.text(), &info);
            }
            else
            {
                goto end;
            }
        }

        // Assume no associations
        fileassoc = NULL;

        // Determine icons and type
        if (isDir)
        {
            if (!::isReadExecutable(pathname))
            {
                big = bigfolderlockedicon;
                mini = minifolderlockedicon;
                filetype = _("Folder");
            }
            else
            {
                big = bigfoldericon;
                mini = minifoldericon;
                filetype = _("Folder");
            }
        }
        else if (S_ISCHR(info.st_mode))
        {
            big = bigchardevicon;
            mini = minichardevicon;
            filetype = _("Character Device");
        }
        else if (S_ISBLK(info.st_mode))
        {
            big = bigblockdevicon;
            mini = miniblockdevicon;
            filetype = _("Block Device");
        }
        else if (S_ISFIFO(info.st_mode))
        {
            big = bigpipeicon;
            mini = minipipeicon;
            filetype = _("Named Pipe");
        }
        else if (S_ISSOCK(info.st_mode))
        {
            big = bigsocketicon;
            mini = minisocketicon;
            filetype = _("Socket");
        }
        else if ((info.st_mode&(S_IXUSR|S_IXGRP|S_IXOTH)) && !(S_ISDIR(info.st_mode) || S_ISCHR(info.st_mode) || S_ISBLK(info.st_mode) || S_ISFIFO(info.st_mode) || S_ISSOCK(info.st_mode)))
        {
            big = bigexecicon;
            mini = miniexecicon;
            filetype = _("Executable");
            if (associations)
            {
                fileassoc = associations->findFileBinding(pathname.text());
            }
        }
        else
        {
            big = bigdocicon;
            mini = minidocicon;
            filetype = _("Document");
            if (associations)
            {
                fileassoc = associations->findFileBinding(pathname.text());
            }
        }

        // If association is found, use it
        if (fileassoc)
        {
            filetype = fileassoc->extension.text();

            if (fileassoc->bigicon)
            {
                big = fileassoc->bigicon;
            }
            if (fileassoc->miniicon)
            {
                mini = fileassoc->miniicon;
            }
        }

        // Symbolic links have a specific type
        if (isBrokenLink)
        {
            filetype = _("Broken link");
        }

        else if (isLink)
        {
            if (associations)
            {
                // Don't forget to remove trailing '/' here!
                fileassoc = associations->findFileBinding(::cleanPath(::readLink(pathname)).text());
                if (fileassoc)
                {
                    filetype = _("Link to ")+fileassoc->extension;
                }
                else
                {
                    filetype = _("Link to ")+filetype;
                }
            }
        }

        // Don't display the file size for directories
        FXString hsize;
        if (isDir)
        {
            hsize = "";
        }
        else
        {
            char size[64];
#if __WORDSIZE == 64
            snprintf(size, sizeof(size)-1, "%lu", (FXulong)linfo.st_size);
#else
            snprintf(size, sizeof(size)-1, "%llu", (FXulong)linfo.st_size);
#endif
            hsize = ::hSize(size);
        }

#if defined(linux)
        // Devices have a specific icon
        if (fsdevices->find(pathname.text()))
        {
            filetype = _("Mount point");

            if (::streq(fsdevices->find(pathname.text()), "harddisk"))
            {
                big = bigharddiskicon;
                mini = harddiskicon;
            }
            else if (::streq(fsdevices->find(pathname.text()), "nfsdisk"))
            {
                big = bignfsdriveicon;
                mini = nfsdriveicon;
            }
            else if (::streq(fsdevices->find(pathname.text()), "smbdisk"))
            {
                big = bignfsdriveicon;
                mini = nfsdriveicon;
            }
            else if (::streq(fsdevices->find(pathname.text()), "floppy"))
            {
                big = bigfloppyicon;
                mini = floppyicon;
            }
            else if (::streq(fsdevices->find(pathname.text()), "cdrom"))
            {
                big = bigcdromicon;
                mini = cdromicon;
            }
            else if (::streq(fsdevices->find(pathname.text()), "zip"))
            {
                big = bigzipicon;
                mini = zipicon;
            }
        }
#endif

        // Symbolic links have a specific icon
        if (isLink)
        {
            // Broken link
            if (isBrokenLink)
            {
                big = bigbrokenlinkicon;
                mini = minibrokenlinkicon;
            }
            else
            {
                big = biglinkicon;
                mini = minilinkicon;
            }
        }

        // Add item to the file list
        FXString str = filename + "\t" + dirname + "\t" + hsize + "\t" + filetype + "\t" + ext + "\t" + mod + "\t" + usrid +"\t" + grpid + "\t" + atts + "\t" + del + "\t" + pathname;

        // Append item to the list
        list->appendItem(str, big, mini);

        // Get last item
        int       count = list->getNumItems();
        FileItem* item = (FileItem*)list->getItem(count-1);

        if (item == NULL)
        {
            fprintf(stderr, "%s::appendItem: NULL item specified.\n", getClassName());
            exit(EXIT_FAILURE);
        }

        // Set icons
        item->setBigIcon(big, false);
        item->setMiniIcon(mini, false);

        // Set item flags from the obtained info
        if (S_ISDIR(info.st_mode))
        {
            item->state |= FileItem::FOLDER;
        }
        else
        {
            item->state &= ~FileItem::FOLDER;
        }
        if (S_ISLNK(info.st_mode))
        {
            item->state |= FileItem::SYMLINK;
        }
        else
        {
            item->state &= ~FileItem::SYMLINK;
        }
        if (S_ISCHR(info.st_mode))
        {
            item->state |= FileItem::CHARDEV;
        }
        else
        {
            item->state &= ~FileItem::CHARDEV;
        }
        if (S_ISBLK(info.st_mode))
        {
            item->state |= FileItem::BLOCKDEV;
        }
        else
        {
            item->state &= ~FileItem::BLOCKDEV;
        }
        if (S_ISFIFO(info.st_mode))
        {
            item->state |= FileItem::FIFO;
        }
        else
        {
            item->state &= ~FileItem::FIFO;
        }
        if (S_ISSOCK(info.st_mode))
        {
            item->state |= FileItem::SOCK;
        }
        else
        {
            item->state &= ~FileItem::SOCK;
        }
        if ((info.st_mode&(S_IXUSR|S_IXGRP|S_IXOTH)) && !(S_ISDIR(info.st_mode) || S_ISCHR(info.st_mode) || S_ISBLK(info.st_mode) || S_ISFIFO(info.st_mode) || S_ISSOCK(info.st_mode)))
        {
            item->state |= FileItem::EXECUTABLE;
        }
        else
        {
            item->state &= ~FileItem::EXECUTABLE;
        }

        // We can drag items
        item->state |= FileItem::DRAGGABLE;

        // Set item attributes
        item->size = (FXulong)linfo.st_size;
        item->assoc = fileassoc;
        item->date = filemtime;
        item->cdate = filectime;

        // And finally, don't forget to create the appended item!
        item->create();
    }
    else
    {
        return(0);
    }
end:

    return(1);
}


// File list context menu
long SearchPanel::onCmdPopupMenu(FXObject* o, FXSelector s, void* p)
{
    // No item in list
    if (list->getNumItems() == 0)
    {
        return(0);
    }

    list->setAllowRefresh(false);

    // Check if control key was pressed
    ctrlflag = false;
    shiftf10 = false;
    if (p != NULL)
    {
        FXEvent* event = (FXEvent*)p;
        if (event->state&CONTROLMASK)
        {
            ctrlflag = true;
        }
        if (event->state&SHIFTMASK && (event->code == KEY_F10))
        {
            shiftf10 = true;
        }
    }

    // Use to select the item under cursor when right clicking
    // Only when Shift-F10 was not pressed
    if (!shiftf10 && (list->getNumSelectedItems() <= 1))
    {
        int    x, y;
        FXuint state;
        list->getCursorPosition(x, y, state);

        int item = list->getItemAt(x, y);

        if (list->getCurrentItem() >= 0)
        {
            list->deselectItem(list->getCurrentItem());
        }
        if (item >= 0)
        {
            list->setCurrentItem(item);
            list->selectItem(item);
        }
    }

    // If control flag is set, deselect all items
    if (ctrlflag)
    {
        list->handle(o, FXSEL(SEL_COMMAND, FileList::ID_DESELECT_ALL), p);
    }

    // Popup menu pane
    FXMenuPane* menu = new FXMenuPane(this);
    int         x, y;
    FXuint      state;
    getRoot()->getCursorPosition(x, y, state);

    int num, itm;
    num = list->getNumSelectedItems(&itm);

    // No selection or control key was pressed
    if ((num == 0) || ctrlflag)
    {
        // Reset the control flag
        ctrlflag = false;

        new FXMenuCheck(menu, _("Thum&bnails"), list, FileList::ID_TOGGLE_THUMBNAILS);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("B&ig icons"), list, IconList::ID_SHOW_BIG_ICONS);
        new FXMenuRadio(menu, _("&Small icons"), list, IconList::ID_SHOW_MINI_ICONS);
        new FXMenuRadio(menu, _("F&ull file list"), list, IconList::ID_SHOW_DETAILS);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("&Rows"), list, FileList::ID_ARRANGE_BY_ROWS);
        new FXMenuRadio(menu, _("&Columns"), list, FileList::ID_ARRANGE_BY_COLUMNS);
        new FXMenuCheck(menu, _("Autosize"), list, FileList::ID_AUTOSIZE);
        new FXMenuSeparator(menu);
        new FXMenuRadio(menu, _("&Name"), list, FileList::ID_SORT_BY_NAME);
        new FXMenuRadio(menu, _("Si&ze"), list, FileList::ID_SORT_BY_SIZE);
        new FXMenuRadio(menu, _("&Type"), list, FileList::ID_SORT_BY_TYPE);
        new FXMenuRadio(menu, _("E&xtension"), list, FileList::ID_SORT_BY_EXT);
        new FXMenuRadio(menu, _("&Date"), list, FileList::ID_SORT_BY_TIME);
        new FXMenuRadio(menu, _("&User"), list, FileList::ID_SORT_BY_USER);
        new FXMenuRadio(menu, _("&Group"), list, FileList::ID_SORT_BY_GROUP);
        new FXMenuRadio(menu, _("Per&missions"), list, FileList::ID_SORT_BY_PERM);
        new FXMenuSeparator(menu);
        new FXMenuCheck(menu, _("I&gnore case"), list, FileList::ID_SORT_CASE);
        new FXMenuCheck(menu, _("Fold&ers first"), list, FileList::ID_DIRS_FIRST);
        new FXMenuCheck(menu, _("Re&verse order"), list, FileList::ID_SORT_REVERSE);
    }
    // Non empty selection
    else
    {
        // Submenu items
        FXMenuPane* submenu = new FXMenuPane(this);
        new FXMenuCheck(submenu, _("Thum&bnails"), list, FileList::ID_TOGGLE_THUMBNAILS);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("B&ig icons"), list, IconList::ID_SHOW_BIG_ICONS);
        new FXMenuRadio(submenu, _("&Small icons"), list, IconList::ID_SHOW_MINI_ICONS);
        new FXMenuRadio(submenu, _("&Full file list"), list, IconList::ID_SHOW_DETAILS);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("&Rows"), list, FileList::ID_ARRANGE_BY_ROWS);
        new FXMenuRadio(submenu, _("&Columns"), list, FileList::ID_ARRANGE_BY_COLUMNS);
        new FXMenuCheck(submenu, _("&Autosize"), list, FileList::ID_AUTOSIZE);
        new FXMenuSeparator(submenu);
        new FXMenuRadio(submenu, _("&Name"), list, FileList::ID_SORT_BY_NAME);
        new FXMenuRadio(submenu, _("Si&ze"), list, FileList::ID_SORT_BY_SIZE);
        new FXMenuRadio(submenu, _("&Type"), list, FileList::ID_SORT_BY_TYPE);
        new FXMenuRadio(submenu, _("E&xtension"), list, FileList::ID_SORT_BY_EXT);
        new FXMenuRadio(submenu, _("&Date"), list, FileList::ID_SORT_BY_TIME);
        new FXMenuRadio(submenu, _("&User"), list, FileList::ID_SORT_BY_USER);
        new FXMenuRadio(submenu, _("&Group"), list, FileList::ID_SORT_BY_GROUP);
        new FXMenuRadio(submenu, _("Per&missions"), list, FileList::ID_SORT_BY_PERM);
        new FXMenuSeparator(submenu);
        new FXMenuCheck(submenu, _("Ignore c&ase"), list, FileList::ID_SORT_CASE);
        new FXMenuCheck(submenu, _("Fold&ers first"), list, FileList::ID_DIRS_FIRST);
        new FXMenuCheck(submenu, _("Re&verse order"), list, FileList::ID_SORT_REVERSE);
        new FXMenuCascade(menu, _("Pane&l"), NULL, submenu);
        new FXMenuSeparator(menu);


        FXbool ar = false;
        if (list->getItem(itm) && list->isItemFile(itm))
        {
            new FXMenuCommand(menu, _("Open &with..."), fileopenicon, this, SearchPanel::ID_OPEN_WITH);
            new FXMenuCommand(menu, _("&Open"), fileopenicon, this, SearchPanel::ID_OPEN);
            FXString name = this->list->getItemText(itm).section('\t', 0);

            // Last and before last file extensions
            FXString ext1 = name.rafter('.', 1).lower();
            FXString ext2 = name.rafter('.', 2).lower();

            // Display the extract and package menus according to the archive extensions
            if ((num == 1) && ((ext2 == "tar.gz") || (ext2 == "tar.bz2") || (ext2 == "tar.xz") || (ext2 == "tar.z")))
            {
                ar = true;
                new FXMenuCommand(menu, _("E&xtract to..."), archexticon, this, SearchPanel::ID_EXTRACT);
            }
            else if ((num == 1) && ((ext1 == "gz") || (ext1 == "bz2") || (ext1 == "xz") || (ext1 == "z")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&Extract here"), archexticon, this, SearchPanel::ID_EXTRACT);
            }
            else if ((num == 1) && ((ext1 == "tar") || (ext1 == "tgz") || (ext1 == "tbz2") || (ext1 == "tbz") || (ext1 == "taz") || (ext1 == "txz") || (ext1 == "zip") || (ext1 == "7z") || (ext1 == "lzh") || (ext1 == "rar") || (ext1 == "ace") || (ext1 == "arj")))
            {
                ar = true;
                new FXMenuCommand(menu, _("E&xtract to..."), archexticon, this, SearchPanel::ID_EXTRACT);
            }
#if defined(linux)
            else if ((num == 1) && ((ext1 == "rpm") || (ext1 == "deb")))
            {
                ar = true;
                new FXMenuCommand(menu, _("&View"), packageicon, this, SearchPanel::ID_VIEW);
            }
#endif
            // Not archive nor package
            if (!ar)
            {
                new FXMenuCommand(menu, _("&View"), viewicon, this, SearchPanel::ID_VIEW);
                new FXMenuCommand(menu, _("&Edit"), editicon, this, SearchPanel::ID_EDIT);
                if (num == 1)
                {
                    new FXMenuCommand(menu, _("Com&pare..."), compareicon, this, SearchPanel::ID_COMPARE);
                }
                else
                {
                    new FXMenuCommand(menu, _("Com&pare"), compareicon, this, SearchPanel::ID_COMPARE);
                }
            }
        }
        if (!ar)
        {
            new FXMenuCommand(menu, _("&Add to archive..."), archaddicon, this, SearchPanel::ID_ADD_TO_ARCH);
        }
#if defined(linux)
        if ((num == 1) && !ar)
        {
            new FXMenuCommand(menu, _("&Packages query "), packageicon, this, SearchPanel::ID_PKG_QUERY);
        }
#endif

        // Build scripts menu
        new FXMenuSeparator(menu);
        FXString    scriptpath = homedir + PATHSEPSTRING CONFIGPATH PATHSEPSTRING XFECONFIGPATH PATHSEPSTRING SCRIPTPATH;
        FXMenuPane* scriptsmenu = new FXMenuPane(this);
        new FXMenuCascade(menu, _("Scripts"), runicon, scriptsmenu);
        readScriptDir(scriptsmenu, scriptpath);
        new FXMenuSeparator(scriptsmenu);
        new FXMenuCommand(scriptsmenu, _("&Go to script folder"), gotodiricon, this, SearchPanel::ID_GO_SCRIPTDIR);

        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("&Go to parent folder"), gotodiricon, this, SearchPanel::ID_GOTO_PARENTDIR);
        new FXMenuCommand(menu, _("&Copy"), copy_clpicon, this, SearchPanel::ID_COPY_CLIPBOARD);
        new FXMenuCommand(menu, _("C&ut"), cut_clpicon, this, SearchPanel::ID_CUT_CLIPBOARD);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("Re&name..."), renameiticon, this, SearchPanel::ID_FILE_RENAME);
        new FXMenuCommand(menu, _("Copy &to..."), copy_clpicon, this, SearchPanel::ID_FILE_COPYTO);
        new FXMenuCommand(menu, _("&Move to..."), moveiticon, this, SearchPanel::ID_FILE_MOVETO);
        new FXMenuCommand(menu, _("Symlin&k to..."), minilinkicon, this, SearchPanel::ID_FILE_SYMLINK);
        new FXMenuCommand(menu, _("M&ove to trash"), filedeleteicon, this, SearchPanel::ID_FILE_TRASH);
        new FXMenuCommand(menu, _("&Delete"), filedelete_permicon, this, SearchPanel::ID_FILE_DELETE);
        new FXMenuSeparator(menu);
        new FXMenuCommand(menu, _("Compare &sizes"), charticon, this, SearchPanel::ID_DIR_USAGE);
        new FXMenuCommand(menu, _("P&roperties"), attribicon, this, SearchPanel::ID_PROPERTIES);
    }
    menu->create();
    allowPopupScroll = true;  // Allow keyboard scrolling
    menu->popup(NULL, x, y);
    getApp()->runModalWhileShown(menu);
    allowPopupScroll = false;
    list->setAllowRefresh(true);

    return(1);
}


// Read all executable file names that are located into the script directory
// Sort entries alphabetically
int SearchPanel::readScriptDir(FXMenuPane* scriptsmenu, FXString dir)
{
    DIR*            dp;
    struct dirent** namelist;

    // Open directory
    if ((dp = opendir(dir.text())) == NULL)
    {
        return(0);
    }

    // Eventually add a / at the end of the directory name
    if (dir[dir.length()-1] != '/')
    {
        dir = dir+"/";
    }

    // Read directory and sort entries alphabetically
    int n = scandir(dir.text(), &namelist, NULL, alphasort);
    if (n < 0)
    {
        perror("scandir");
    }
    else
    {
        for (int k = 0; k < n; k++)
        {
            // Avoid hidden directories and '.' and '..'
            if (namelist[k]->d_name[0] != '.')
            {
                FXString pathname = dir + namelist[k]->d_name;

                // Recurse if non empty directory
                if (::isDirectory(pathname))
                {
                    if (!::isEmptyDir(pathname))
                    {
                        FXMenuPane* submenu = new FXMenuPane(this);
                        new FXMenuCascade(scriptsmenu, namelist[k]->d_name, NULL, submenu);
                        readScriptDir(submenu, pathname);
                    }
                }

                // Add only executable files to the list
                else if (isReadExecutable(pathname))
                {
                    new FXMenuCommand(scriptsmenu, namelist[k]->d_name + FXString("\t\t") + pathname, miniexecicon, this, FilePanel::ID_RUN_SCRIPT);
                }
            }
            free(namelist[k]);
        }
        free(namelist);
    }

    // Close directory
    (void)closedir(dp);

    return(1);
}


// Add files or directory to an archive
long SearchPanel::onCmdAddToArch(FXObject* o, FXSelector, void*)
{
    int      ret;
    FXString name, ext1, ext2, cmd, archive = "";
    File*    f;

    // Enter search directory
    ret = chdir(searchdir.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), searchdir.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), searchdir.text());
        }

        return(0);
    }

    // If only one item is selected, use its name as a starting guess for the archive name
    if (list->getNumSelectedItems() == 1)
    {
        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u))
            {
                name = list->getItemFilename(u);
                break;
            }
        }
        archive = name;
    }

    // Initial archive name with full path and default extension
    archive = homedir+PATHSEPSTRING+archive+".tar.gz";

    // Archive dialog
    if (archdialog == NULL)
    {
        archdialog = new ArchInputDialog(this, "");
    }
    archdialog->setText(archive);
    archdialog->CursorEnd();

    if (archdialog->execute())
    {
        if (archdialog->getText() == "")
        {
            MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
            return(0);
        }

        // Get string and preserve escape characters
        archive = ::quote(archdialog->getText());

        // Get extensions of the archive name
        ext1 = archdialog->getText().rafter('.', 1).lower();
        ext2 = archdialog->getText().rafter('.', 2).lower();

        // Handle different archive formats
        if (ext2 == "tar.gz")
        {
            cmd = "tar -zcvf "+archive+" ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jcvf "+archive+" ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jcvf "+archive+" ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zcvf "+archive+" ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -cvf "+archive+" ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gzip -v ";
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zcvf "+archive+" ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zcvf "+archive+" ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bzip2 -v ";
        }
        else if (ext1 == "xz")
        {
            cmd = "xz -v ";
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jcvf "+archive+" ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jcvf "+archive+" ";
        }
        else if (ext1 == "z")
        {
            cmd = "compress -v ";
        }
        else if (ext1 == "zip")
        {
            cmd = "zip -r "+archive+" ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z a "+archive+" ";
        }

        // Default archive format
        else
        {
            archive += ".tar.gz";
            cmd = "tar -zcvf "+archive+" ";
        }

        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u))
            {
                name = FXPath::relative(searchdir, list->getItemFullPathname(u));
                cmd += " ";
                cmd = cmd+::quote(name);
                cmd += " ";
            }
        }

        // Wait cursor
        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);
        getApp()->beginWaitCursor();

        // File object
        f = new File(this, _("Create archive"), ARCHIVE);
        f->create();

        // Create archive
        f->archive(archive, cmd);

        getApp()->endWaitCursor();
        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
        delete f;
    }
    return(1);
}


// Extract archive
long SearchPanel::onCmdExtract(FXObject*, FXSelector, void*)
{
    FXString name, ext1, ext2, cmd, dir;
    File*    f;

    // File selection dialog
    FileDialog  browse(this, _("Select a destination folder"));
    const char* patterns[] =
    {
        _("All Files"), "*", NULL
    };

    browse.setDirectory(homedir);
    browse.setPatternList(patterns);
    browse.setSelectMode(SELECT_FILE_DIRECTORY);

    int item;
    list->getNumSelectedItems(&item);
    if (list->getItem(item))
    {
        // Path
        FXString path = FXPath::directory(list->getItemFullPathname(item));

        // Archive name and extensions
        name = list->getItemText(item).text();
        ext1 = name.section('\t', 0).rafter('.', 1).lower();
        ext2 = name.section('\t', 0).rafter('.', 2).lower();
        name = ::quote(path + PATHSEPSTRING + name.section('\t', 0));

        // Handle different archive formats
        FXbool dialog = true;

        if (ext2 == "tar.gz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext2 == "tar.bz2")
        {
            cmd = "tar -jxvf ";
        }
        else if (ext2 == "tar.xz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext2 == "tar.z")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "tar")
        {
            cmd = "tar -xvf ";
        }
        else if (ext1 == "gz")
        {
            cmd = "gunzip -v ";
            dialog = false;
        }
        else if (ext1 == "tgz")
        {
            cmd = "tar -zxvf ";
        }
        else if (ext1 == "taz")
        {
            cmd = "tar -Zxvf ";
        }
        else if (ext1 == "bz2")
        {
            cmd = "bunzip2 -v ";
            dialog = false;
        }
        else if (ext1 == "xz")
        {
            cmd = "unxz -v ";
            dialog = false;
        }
        else if ((ext1 == "tbz2") || (ext1 == "tbz"))
        {
            cmd = "tar -jxvf ";
        }
        else if (ext1 == "txz")
        {
            cmd = "tar -Jxvf ";
        }
        else if (ext1 == "z")
        {
            cmd = "uncompress -v ";
            dialog = false;
        }
        else if (ext1 == "zip")
        {
            cmd = "unzip -o ";
        }
        else if (ext1 == "7z")
        {
            cmd = "7z x -y ";
        }
        else if (ext1 == "rar")
        {
            cmd = "unrar x -o+ ";
        }
        else if (ext1 == "lzh")
        {
            cmd = "lha -xf ";
        }
        else if (ext1 == "ace")
        {
            cmd = "unace x ";
        }
        else if (ext1 == "arj")
        {
            cmd = "arj x -y ";
        }
        else
        {
            cmd = "tar -zxvf ";
        }

        // Final extract command
        cmd += name+" ";

        // Extract with file dialog
        if (dialog)
        {
            // Extract archive
            if (browse.execute())
            {
                dir = browse.getFilename();

                if (isWritable(dir))
                {
                    // Wait cursor
                    getApp()->beginWaitCursor();
		    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);

                    // File object
                    f = new File(this, _("Extract archive"), EXTRACT);
                    f->create();

                    // Extract archive
                    f->extract(name, dir, cmd);

		    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                    getApp()->endWaitCursor();
                    delete f;
                }
                else
                {
                    MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), dir.text());
                }
            }
        }

        // Extract here (without file dialog)
        else
        {
            if (isWritable(path))
            {
                // Wait cursor
	        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);
                getApp()->beginWaitCursor();

                // File object
                f = new File(this, _("Extract archive"), EXTRACT);
                f->create();

                // Extract archive
                f->extract(name, path, cmd);

                getApp()->endWaitCursor();
	        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
                delete f;
            }
            else
            {
                MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), path.text());
            }
        }
    }

    return(1);
}


// Directory usage on file selection
long SearchPanel::onCmdDirUsage(FXObject* o, FXSelector, void*)
{
	FXString pathname, command, itemslist = " ";
	FXString cmd1 = "/usr/bin/du --apparent-size -k -s ";
	FXString cmd2 = " 2> /dev/null | /usr/bin/sort -rn | /usr/bin/cut -f2 | /usr/bin/xargs -d '\n' /usr/bin/du --apparent-size --total --si -s 2> /dev/null";

    // Construct selected files list
    for (int u = 0; u < list->getNumItems(); u++)
    {
        if (list->isItemSelected(u))
        {
 			pathname = list->getItemFullPathname(u);

            // List of selected items
            itemslist += ::quote(pathname) + " ";
        }
    }

	// Command to be executed
	command = cmd1 + itemslist + cmd2;

	// Make and show command window
	CommandWindow* cmdwin=new CommandWindow(getApp(),_("Sizes of Selected Items"),command,25,50);
	cmdwin->create();
	cmdwin->setIcon(charticon);

    return(1);
}


// Trash files from the file list
long SearchPanel::onCmdFileTrash(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    FXbool confirm_trash = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_trash", true);

    // If we don't have permission to write to the trash directory
    if (!::isWritable(trashfileslocation))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to trash location %s: Permission denied"), trashfileslocation.text());
        return(0);
    }

    // Items number in the file list
    int num = list->getNumSelectedItems();
    if (num < 1)
    {
        return(0);
    }

    if (confirm_trash)
    {
        FXString message;
        if (num == 1)
        {
            FXString pathname;
            for (int u = 0; u < list->getNumItems(); u++)
            {
                if (list->isItemSelected(u))
                {
                    pathname = list->getItemFullPathname(u);
                }
            }
            if (::isDirectory(pathname))
            {
                message.format(_("Move folder %s to trash can?"), pathname.text());
            }
            else
            {
                message.format(_("Move file %s to trash can?"), pathname.text());
            }
        }
        else
        {
            message.format(_("Move %s selected items to trash can?"), FXStringVal(num).text());
        }

        MessageBox box(this, _("Confirm Trash"), message, delete_bigicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
        if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
        {
            return(0);
        }
    }

    // Wait cursor
    getApp()->beginWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);

    // File object
    f = new File(this, _("Move to trash"), DELETE, num);
    f->create();
    list->setAllowRefresh(false);

    // Overwrite initialisations
    FXbool overwrite = false;
    FXbool overwrite_all = false;
    FXbool skip_all = false;

    // Delete selected files
    FXString filename, pathname;
    for (int u = 0; u < list->getNumItems(); u++)
    {
        if (list->isItemSelected(u))
        {
            // Get index of first selected item
            if (firstitem == 0)
            {
                firstitem = u;
            }

            // Get file name and path
            filename = list->getItemFilename(u);
            pathname = list->getItemFullPathname(u);

            // File could have already been trashed above in the tree
            if (!::exists(pathname))
            {
                continue;
            }

            // If we don't have permission to write to the file
            if (!::isWritable(pathname))
            {
                // Overwrite dialog if necessary
                if (!(overwrite_all | skip_all))
                {
                    f->hideProgressDialog();
                    FXString msg;
                    msg.format(_("File %s is write-protected, move it anyway to trash can?"), pathname.text());
  
					if (num ==1)
					{
						OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Trash"), msg, OVWBOX_SINGLE_FILE);
						FXuint answer = dlg->execute(PLACEMENT_OWNER);
						delete dlg;	
						if (answer == 1)
						{
							overwrite = true;
						}
						else
						{
							goto end;
						}
					}  
					else
					{
						OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Trash"), msg);
						FXuint        answer = dlg->execute(PLACEMENT_OWNER);
						delete dlg;
						switch (answer)
						{
						// Cancel
						case 0:
							goto end;
							break;

						// Overwrite
						case 1:
							overwrite = true;
							break;

						// Overwrite all
						case 2:
							overwrite_all = true;
							break;

						// Skip
						case 3:
							overwrite = false;
							break;

						// Skip all
						case 4:
							skip_all = true;
							break;
						}
					}
                }
                if ((overwrite | overwrite_all) & !skip_all)
                {
                    // Trash files path name
                    FXString trashpathname = createTrashpathname(pathname, trashfileslocation);

                    // Create trashinfo file
                    createTrashinfo(pathname, trashpathname, trashfileslocation, trashinfolocation);

                    // Move file to trash files location
                    int ret = f->move(pathname, trashpathname);

                    // An error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move to trash operation!"));
                        break;
                    }
                }
                f->showProgressDialog();
            }

            // If we have permission to write
            else
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(pathname, trashfileslocation);

                // Create trashinfo file
                createTrashinfo(pathname, trashpathname, trashfileslocation, trashinfolocation);

                // Move file to trash files location
                int ret = f->move(pathname, trashpathname);

                // An error has occurred
                if ((ret == 0) && !f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move to trash operation!"));
                    break;
                }

                // If action is cancelled in progress dialog
                if (f->isCancelled())
                {
                    f->hideProgressDialog();
                    MessageBox::error(this, BOX_OK, _("Warning"), _("Move to trash file operation cancelled!"));
                    break;
                }
            }
        }
    }
end:
    getApp()->endWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
    delete f;

    list->setAllowRefresh(true);
    list->onCmdRefresh(0, 0, 0);

    return(1);
}


// Definitively delete files from the file list or the tree list (no trash can)
long SearchPanel::onCmdFileDelete(FXObject*, FXSelector, void*)
{
    int   firstitem = 0;
    File* f = NULL;

    FXbool confirm_del = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete", true);
    FXbool confirm_del_emptydir = getApp()->reg().readUnsignedEntry("OPTIONS", "confirm_delete_emptydir", true);


    // Items number in the file list
    int num = list->getNumSelectedItems();

    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    if (num >= 1)
    {
        if (confirm_del)
        {
            FXString message;
            if (num == 1)
            {
                FXString pathname;
                for (int u = 0; u < list->getNumItems(); u++)
                {
                    if (list->isItemSelected(u))
                    {
                        pathname = list->getItemFullPathname(u);
                    }
                }
                if (::isDirectory(pathname))
                {
                    message.format(_("Definitively delete folder %s ?"), pathname.text());
                }
                else
                {
                    message.format(_("Definitively delete file %s ?"), pathname.text());
                }
            }
            else
            {
                message.format(_("Definitively delete %s selected items?"), FXStringVal(num).text());
            }
            MessageBox box(this, _("Confirm Delete"), message, delete_big_permicon, BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
            if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
            {
                return(0);
            }
        }
        // Wait cursor
        getApp()->beginWaitCursor();
	mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);

        // File object
        f = new File(this, _("File delete"), DELETE, num);
        f->create();
        list->setAllowRefresh(false);

        // Overwrite initialisations
        FXbool overwrite = false;
        FXbool overwrite_all = false;
        FXbool skip_all = false;
        FXbool ask_del_empty = true;
        FXbool skip_all_del_emptydir = false;

        // Delete selected files
        FXString filename, pathname;
        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u))
            {
                // Get index of first selected item
                if (firstitem == 0)
                {
                    firstitem = u;
                }

                // Get file name and path
                filename = list->getItemFilename(u);
                pathname = list->getItemFullPathname(u);

                // File could have already been deleted above in the tree
                if (!::exists(pathname))
                {
                    continue;
                }

                // Confirm empty directory deletion
                if (confirm_del & confirm_del_emptydir & ask_del_empty)
                {
                    if ((::isEmptyDir(pathname) == 0) && !::isLink(pathname))
                    {
                        if (skip_all_del_emptydir)
                        {
                            continue;
                        }

                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("Folder %s is not empty, delete it anyway?"), pathname.text());
                        OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg);
                        FXuint answer = dlg->execute(PLACEMENT_OWNER);
                        delete dlg;
                        switch (answer)
                        {
                        // Cancel
                        case 0:
                            goto end;
                            break;

                        // Yes
                        case 1:
                            break;

                        // Yes for all
                        case 2:
                            ask_del_empty = false;
                            break;

                        // Skip
                        case 3:
                            continue;
                            break;

                        // Skip all
                        case 4:
                            skip_all_del_emptydir = true;
                            continue;
                            break;
                        }
                        f->showProgressDialog();
                    }
                }

                // If we don't have permission to write to the file
                if (!::isWritable(pathname))
                {
                    // Overwrite dialog if necessary
                    if (!(overwrite_all | skip_all))
                    {
                        f->hideProgressDialog();
                        FXString msg;
                        msg.format(_("File %s is write-protected, delete it anyway?"), pathname.text());

                        if (num ==1)
                        {
                        	OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg, OVWBOX_SINGLE_FILE);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							if (answer == 1)
							{
								overwrite = true;
							}
							else
							{
								goto end;
							}							
						}
                        
                        else
                        {
							OverwriteBox* dlg = new OverwriteBox(this, _("Confirm Delete"), msg);
							FXuint answer = dlg->execute(PLACEMENT_OWNER);
							delete dlg;
							switch (answer)
							{
							// Cancel
							case 0:
								goto end;
								break;

							// Yes
							case 1:
								overwrite = true;
								break;

							// Yes for all
							case 2:
								overwrite_all = true;
								break;

							// Skip
							case 3:
								overwrite = false;
								break;

							// Skip all
							case 4:
								skip_all = true;
								break;
							}
						}
                    }
                    if ((overwrite | overwrite_all) & !skip_all)
                    {
                        // Definitively remove file or folder
                        f->remove(pathname);
                    }
                    f->showProgressDialog();
                }

                // If we have permission to write
                else
                {
                    // Definitively remove file or folder
                    f->remove(pathname);

                    // If is located at trash location, try to also remove the corresponding trashinfo file if it exists
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (pathname.left(trashfileslocation.length()) == trashfileslocation))
                    {
                        FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+filename+".trashinfo";
                        ::unlink(trashinfopathname.text());
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Delete file operation cancelled!"));
                        break;
                    }
                }
            }
        }
end:
        getApp()->endWaitCursor();
        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
        delete f;
    }

    list->setAllowRefresh(true);
    list->onCmdRefresh(0, 0, 0);

    return(1);
}


// We now really do have the clipboard, keep clipboard content
long SearchPanel::onClipboardGained(FXObject* sender, FXSelector sel, void* ptr)
{
    FXVerticalFrame::onClipboardGained(sender, sel, ptr);
    return(1);
}


// We lost the clipboard
long SearchPanel::onClipboardLost(FXObject* sender, FXSelector sel, void* ptr)
{
    FXVerticalFrame::onClipboardLost(sender, sel, ptr);
    return(1);
}


// Somebody wants our clipboard content
long SearchPanel::onClipboardRequest(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    FXuchar* data;
    FXuint   len;

    // Perhaps the target wants to supply its own data for the clipboard
    if (FXVerticalFrame::onClipboardRequest(sender, sel, ptr))
    {
        return(1);
    }

    // Clipboard target is xfelistType (Xfe, Gnome or XFCE)
    if (event->target == xfelistType)
    {
        // Prepend "copy" or "cut" as in the Gnome way and avoid duplicating these strings
        if ((clipboard.find("copy\n") < 0) && (clipboard.find("cut\n") < 0))
        {
            if (clipboard_type == CUT_CLIPBOARD)
            {
                clipboard = "cut\n" + clipboard;
            }
            else
            {
                clipboard = "copy\n" + clipboard;
            }
        }

        // Return clipboard content
        if (event->target == xfelistType)
        {
            if (!clipboard.empty())
            {
                len = clipboard.length();
                FXMEMDUP(&data, clipboard.text(), FXuchar, len);
                setDNDData(FROM_CLIPBOARD, event->target, data, len);

                // Return because xfelistType is not compatible with other types
                return(1);
            }
        }
    }

    // Clipboard target is kdelisType (KDE)
    if (event->target == kdelistType)
    {
        // The only data to be passed in this case is "0" for copy and "1" for cut
        // The uri data are passed using the standard uri-list type
        FXString flag;
        if (clipboard_type == CUT_CLIPBOARD)
        {
            flag = "1";
        }
        else
        {
            flag = "0";
        }

        // Return clipboard content
        if (event->target == kdelistType)
        {
            FXMEMDUP(&data, flag.text(), FXuchar, 1);
            setDNDData(FROM_CLIPBOARD, event->target, data, 1);
        }
    }

    // Clipboard target is urilistType (KDE apps ; non Gnome, non XFCE and non Xfe apps)
    if (event->target == urilistType)
    {
        if (!clipboard.empty())
        {
            len = clipboard.length();
            FXMEMDUP(&data, clipboard.text(), FXuchar, len);
            setDNDData(FROM_CLIPBOARD, event->target, data, len);

            return(1);
        }
    }

    // Clipboard target is utf8Type (to paste file pathes as text to other applications)
    if (event->target == utf8Type)
    {
        if (!clipboard.empty())
        {
            int      beg = 0, end = 0;
            FXString str = "";
            FXString pathname, url;

            // Clipboard don't contain 'copy\n' or 'cut\n' as first line
            if ((clipboard.find("copy\n") < 0) && (clipboard.find("cut\n") < 0))
            {
                // Remove the 'file:' prefix for each file path
                while (1)
                {
                    end = clipboard.find('\n', end);
                    if (end < 0) // Last line
                    {
                        end = clipboard.length();
                        url = clipboard.mid(beg, end-beg+1);
                        pathname = FXURL::decode(FXURL::fileFromURL(url));
                        str += pathname;
                        break;
                    }
                    url = clipboard.mid(beg, end-beg+1);
                    pathname = FXURL::decode(FXURL::fileFromURL(url));
                    str += pathname;
                    end++;
                    beg = end;
                }
                end = str.length();
            }

            // Clipboard contains 'copy\n' or 'cut\n' as first line, thus skip it
            else
            {
                // Start after the 'copy\n' or 'cut\n' prefix
                end = clipboard.find('\n', 0);
                end++;
                beg = end;

                // Remove the 'file:' prefix for each file path
                while (1)
                {
                    end = clipboard.find('\n', end);
                    if (end < 0) // Last line
                    {
                        end = clipboard.length();
                        url = clipboard.mid(beg, end-beg+1);
                        pathname = FXURL::decode(FXURL::fileFromURL(url));
                        str += pathname;
                        break;
                    }
                    url = clipboard.mid(beg, end-beg+1);
                    pathname = FXURL::decode(FXURL::fileFromURL(url));
                    str += pathname;
                    end++;
                    beg = end;
                }
                end = str.length();
            }

            if (!str.empty())
            {
                len = str.length();
                FXMEMDUP(&data, str.text(), FXuchar, len);
                setDNDData(FROM_CLIPBOARD, event->target, data, len);

                return(1);
            }
        }
    }
    return(0);
}


// Copy or cut to clipboard
long SearchPanel::onCmdCopyCut(FXObject*, FXSelector sel, void*)
{
    // Clear clipboard
    clipboard.clear();

    // Clipboard type
    if (FXSELID(sel) == ID_CUT_CLIPBOARD)
    {
        clipboard_type = CUT_CLIPBOARD;
    }
    else
    {
        clipboard_type = COPY_CLIPBOARD;
    }

    // Items number in the file list
    int num = list->getNumSelectedItems();

    if (num == 0)
    {
        return(0);
    }

    // If exist selected files, use them
    if (num >= 1)
    {
        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u))
            {
                FXString pathname = list->getItemFullPathname(u);
                clipboard += FXURL::encode(::fileToURI(pathname))+"\n";
            }
        }
    }

    // Remove the last \n of the list, for compatibility with some file managers (e.g. nautilus 2.30.1)
    clipboard.erase(clipboard.length()-1);

    // Acquire the clipboard
    FXDragType types[4];
    types[0] = xfelistType;
    types[1] = kdelistType;
    types[2] = urilistType;
    types[3] = utf8Type;

    if (acquireClipboard(types, 4))
    {
        return(0);
    }

    return(1);
}


// Copy/Move/Rename/Symlink file(s)
long SearchPanel::onCmdFileMan(FXObject* sender, FXSelector sel, void*)
{
    int      num;
    FXString src, targetdir, target, name, source;

    // Confirmation dialog?
    FXbool ask_before_copy = getApp()->reg().readUnsignedEntry("OPTIONS", "ask_before_copy", true);

    // Number of selected items
    num = list->getNumSelectedItems();

    // If no item, return
    if (num <= 0)
    {
        return(0);
    }

    // Obtain the list of source files
    for (int u = 0; u < list->getNumItems(); u++)
    {
        if (list->isItemSelected(u))
        {
            src += list->getItemFullPathname(u)+"\n";
        }
    }

    // Name and directory of the first source file
    source = src.section('\n', 0);
    name = FXPath::name(source);
    FXString dir = FXPath::directory(source);

    // Initialise target dir name
x:
    targetdir = homedir;
    if (targetdir != ROOTDIR)
    {
        target = targetdir+PATHSEPSTRING;
    }
    else
    {
        target = targetdir;
    }

    // Target dir for the rename command
    if (FXSELID(sel) == ID_FILE_RENAME)
    {
        targetdir = dir;
    }

    // Configure the command, title, message, etc.
    FXIcon*  icon = NULL;
    FXString command, title, message;
    if (FXSELID(sel) == ID_FILE_RENAME)
    {
        command = "rename";
        title = _("Rename");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Rename ");
            message += name;
            target = name;
            title = _("Rename");
        }
        else
        {
            return(0);
        }
    }
    if (FXSELID(sel) == ID_FILE_COPYTO)
    {
        command = "copy";
        title = _("Copy");
        icon = copy_bigicon;
        if (num == 1)
        {
            message = _("Copy ");
            message += source;
        }
        else
        {
            message.format(_("Copy %s items"), FXStringVal(num).text());
        }
    }
    if (FXSELID(sel) == ID_FILE_MOVETO)
    {
        command = "move";
        title = _("Move");
        icon = move_bigicon;
        if (num == 1)
        {
            message = _("Move ");
            message += source;
            title = _("Move");
        }
        else
        {
            message.format(_("Move %s items"), FXStringVal(num).text());
        }
    }
    if (FXSELID(sel) == ID_FILE_SYMLINK)
    {
        command = "symlink";
        title = _("Symlink");
        icon = link_bigicon;
        if (num == 1)
        {
            message = _("Symlink ");
            message += source;
            target += name;
        }
        else
        {
            message.format(_("Symlink %s items"), FXStringVal(num).text());
        }
    }

    // File operation dialog, if needed
    if (ask_before_copy || (source == target) || (FXSELID(sel) == ID_FILE_COPYTO) || (FXSELID(sel) == ID_FILE_MOVETO) || (FXSELID(sel) == ID_FILE_RENAME) || (FXSELID(sel) == ID_FILE_SYMLINK))
    {
        if (num == 1)
        {
            if (FXSELID(sel) == ID_FILE_RENAME)
            {
                if (operationdialogrename == NULL)
                {
                    operationdialogrename = new InputDialog(this, "", "", title, _("To:"), icon);
                }
                operationdialogrename->setTitle(title);
                operationdialogrename->setIcon(icon);
				operationdialogrename->setMessage(message);
                operationdialogrename->setText(target);

                if (::isDirectory(source))  // directory
                {
                    operationdialogrename->selectAll();
                }
                else
                {
                    int pos = target.rfind('.');
                    if (pos <= 0)
                    {
                        operationdialogrename->selectAll(); // no extension or dot file
                    }
                    else
                    {
                        operationdialogrename->setSelection(0, pos);
                    }
                }

                int rc = 1;
                rc = operationdialogrename->execute(PLACEMENT_CURSOR);
                target = operationdialogrename->getText();

                // Target name contains '/'
                if (target.contains(PATHSEPCHAR))
                {
					MessageBox::error(this, BOX_OK, _("Error"), _("Character '/' is not allowed in file or folder names, operation cancelled"));
					return(0);
				}

                if (!rc)
                {
                    return(0);
                }
            }
            else
            {
                if (operationdialogsingle == NULL)
                {
                    operationdialogsingle = new BrowseInputDialog(this, "", "", title, _("To:"), icon, BROWSE_INPUT_MIXED);
                }
                operationdialogsingle->setTitle(title);
                operationdialogsingle->setIcon(icon);
                operationdialogsingle->setMessage(message);
                operationdialogsingle->setText(target);


                // Select file name without path
                if (FXSELID(sel) == ID_FILE_SYMLINK)
                {
                    int pos = target.rfind(PATHSEPSTRING);
                    if (pos >= 0)
                    {
                        operationdialogsingle->setSelection(pos+1, target.length());
                    }
                }

                operationdialogsingle->setDirectory(targetdir);
                int rc = 1;
                rc = operationdialogsingle->execute(PLACEMENT_CURSOR);
                target = operationdialogsingle->getText();
                if (!rc)
                {
                    return(0);
                }
            }
        }
        else
        {
            if (operationdialogmultiple == NULL)
            {
                operationdialogmultiple = new BrowseInputDialog(this, "", "", title, _("To folder:"), icon, BROWSE_INPUT_FOLDER);
            }
            operationdialogmultiple->setTitle(title);
            operationdialogmultiple->setIcon(icon);
            operationdialogmultiple->setMessage(message);
            operationdialogmultiple->setText(target);
            operationdialogmultiple->CursorEnd();
            operationdialogmultiple->setDirectory(targetdir);
            int rc = 1;
            rc = operationdialogmultiple->execute(PLACEMENT_CURSOR);
            target = operationdialogmultiple->getText();
            if (!rc)
            {
                return(0);
            }
        }
    }

    // Nothing entered
    if (target == "")
    {
        MessageBox::warning(this, BOX_OK, _("Warning"), _("File name is empty, operation cancelled"));
        return(0);
    }

    // Except for rename, an absolute path is required
    if ((FXSELID(sel) != ID_FILE_RENAME) && !ISPATHSEP(target[0]))
    {
        MessageBox::warning(this, BOX_OK, _("Warning"), _("You must enter an absolute path!"));
        goto x;
    }

    // Update target and target parent directory
	target=::filePath(target,targetdir);
 	if (::isDirectory(target))
	{
		targetdir = target;
	}
	else
	{
		targetdir = FXPath::directory(target);
	}
 
    // Target directory not writable
    if (!::isWritable(targetdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetdir.text());
        return(0);
    }

    // Multiple sources and non existent destination
    if ((num > 1) && !::exists(target))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), target.text());
        return(0);
    }

    // Multiple sources and target is a file
    if ((num > 1) && ::isFile(target))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("%s is not a folder"), target.text());
        return(0);
    }

    // Target is a directory and is not writable
    if (::isDirectory(target) && !::isWritable(target))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), target.text());
        return(0);
    }

    // Target is a file and its parent directory is not writable
    if (::isFile(target) && !::isWritable(targetdir))
    {
        MessageBox::error(this, BOX_OK_SU, _("Error"), _("Can't write to %s: Permission denied"), targetdir.text());
        return(0);
    }

    // Target parent directory doesn't exist
    if (!::exists(targetdir))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Folder %s doesn't exist"), targetdir.text());
        return(0);
    }

    // Target parent directory is not a directory
    if (!::isDirectory(targetdir))
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("%s is not a folder"), targetdir.text());
        return(0);
    }

    // One source
    File* f = NULL;
    int   ret;
    if (num == 1)
    {
        // An empty source file name corresponds to the ".." file
        // Don't perform any file operation on it!
        if (source == "")
        {
            return(0);
        }

        // Wait cursor
        getApp()->beginWaitCursor();
        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);

        // File object
        if (command == "copy")
        {
            f = new File(this, _("File copy"), COPY, num);
            f->create();

            // If target file is located at trash location, also create the corresponding trashinfo file
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && (target == trashfileslocation))
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(source, trashfileslocation);

                // Adjust target name to get the _N suffix if any
                FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                // Create trashinfo file
                createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                // Copy source to trash target
                ret = f->copy(source, trashtarget);
            }

            // Copy source to target
            else
            {
                ret = f->copy(source, target);
            }

            // An error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
            }
        }
        else if (command == "rename")
        {
            f = new File(this, _("File rename"), RENAME, num);
            f->create();
            ret = f->rename(source, target);

            // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
            {
                FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                ::unlink(trashinfopathname.text());
            }
        }
        else if (command == "move")
        {
            f = new File(this, _("File move"), MOVE, num);
            f->create();

            // If target file is located at trash location, also create the corresponding trashinfo file
            // Do it silently and don't report any error if it fails
            FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
            if (use_trash_can && (target == trashfileslocation))
            {
                // Trash files path name
                FXString trashpathname = createTrashpathname(source, trashfileslocation);

                // Adjust target name to get the _N suffix if any
                FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                // Create trashinfo file
                createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                // Move source to trash target
                ret = f->move(source, trashtarget);
            }

            // Move source to target
            else
            {
                ret = f->move(source, target);
            }

            // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
            // Do it silently and don't report any error if it fails
            if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
            {
                FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                ::unlink(trashinfopathname.text());
            }

            // An error has occurred
            if ((ret == 0) && !f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
            }

            // If action is cancelled in progress dialog
            if (f->isCancelled())
            {
                f->hideProgressDialog();
                MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
            }
        }
        else if (command == "symlink")
        {
            f = new File(this, _("Symlink"), SYMLINK, num);
            f->create();
            f->symlink(source, target);
        }
        // Shouldn't happen
        else
        {
            exit(EXIT_FAILURE);
        }

        getApp()->endWaitCursor();
        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
        delete f;
    }

    // Multiple sources
    // Note : rename cannot be used in this case!
    else if (num > 1)
    {
        // Wait cursor
        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);
        getApp()->beginWaitCursor();

        // File object
        if (command == "copy")
        {
            f = new File(this, _("File copy"), COPY, num);
        }
        else if (command == "move")
        {
            f = new File(this, _("File move"), MOVE, num);
        }
        else if (command == "symlink")
        {
            f = new File(this, _("Symlink"), SYMLINK, num);
        }
        // Shouldn't happen
        else
        {
            exit(EXIT_FAILURE);
        }
        f->create();

        list->setAllowRefresh(false);

        // Loop on the multiple files
        for (int i = 0; i < num; i++)
        {
            // Individual source file
            source = src.section('\n', i);

            // File could have already been moved above in the tree
            if (!::exists(source))
            {
                continue;
            }

            // An empty file name corresponds to the ".." file (why?)
            // Don't perform any file operation on it!
            if (source != "")
            {
                if (command == "copy")
                {
                    // If target file is located at trash location, also create the corresponding trashinfo file
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (target == trashfileslocation))
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(source, trashfileslocation);

                        // Adjust target name to get the _N suffix if any
                        FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                        // Create trashinfo file
                        createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                        // Copy source to trash target
                        ret = f->copy(source, trashtarget);
                    }

                    // Copy source to target
                    else
                    {
                        ret = f->copy(source, target);
                    }

                    // An error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the copy file operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Copy file operation cancelled!"));
                        break;
                    }
                }
                else if (command == "move")
                {
                    // If target file is located at trash location, also create the corresponding trashinfo file
                    // Do it silently and don't report any error if it fails
                    FXbool use_trash_can = getApp()->reg().readUnsignedEntry("OPTIONS", "use_trash_can", true);
                    if (use_trash_can && (target == trashfileslocation))
                    {
                        // Trash files path name
                        FXString trashpathname = createTrashpathname(source, trashfileslocation);

                        // Adjust target name to get the _N suffix if any
                        FXString trashtarget = target+PATHSEPSTRING+FXPath::name(trashpathname);

                        // Create trashinfo file
                        createTrashinfo(source, trashpathname, trashfileslocation, trashinfolocation);

                        // Move source to trash target
                        ret = f->move(source, trashtarget);
                    }

                    // Move source to target
                    else
                    {
                        ret = f->move(source, target);
                    }

                    // If source file is located at trash location, try to also remove the corresponding trashinfo file if it exists
                    // Do it silently and don't report any error if it fails
                    if (use_trash_can && ret && (source.left(trashfileslocation.length()) == trashfileslocation))
                    {
                        FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(source)+".trashinfo";
                        ::unlink(trashinfopathname.text());
                    }

                    // An error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the move file operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Move file operation cancelled!"));
                        break;
                    }
                }
                else if (command == "symlink")
                {
                    ret = f->symlink(source, target);

                    // An error has occurred
                    if ((ret == 0) && !f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Error"), _("An error has occurred during the symlink operation!"));
                        break;
                    }

                    // If action is cancelled in progress dialog
                    if (f->isCancelled())
                    {
                        f->hideProgressDialog();
                        MessageBox::error(this, BOX_OK, _("Warning"), _("Symlink operation cancelled!"));
                        break;
                    }
                }
				// Shouldn't happen
				else
                {
                    exit(EXIT_FAILURE);
                }
            }
        }

        getApp()->endWaitCursor();
        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
        delete f;
    }

    // Force list refresh
    list->setAllowRefresh(true);
    list->onCmdRefresh(0, 0, 0);

    return(1);
}


// Go to script directory
long SearchPanel::onCmdGoScriptDir(FXObject* o, FXSelector sel, void*)
{
    FXString scriptpath = homedir + PATHSEPSTRING CONFIGPATH PATHSEPSTRING XFECONFIGPATH PATHSEPSTRING SCRIPTPATH;

    if (!::exists(scriptpath))
    {
        // Create the script directory according to the umask
        int mask = umask(0);
        umask(mask);
        errno = 0;
        int ret = mkpath(scriptpath.text(), 511 & ~mask);
        int errcode = errno;
        if (ret == -1)
        {
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create script folder %s: %s"), scriptpath.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create script folder %s"), scriptpath.text());
            }

            return(0);
        }
    }

    // Change directory in Xfe
    ((XFileExplorer*)mainWindow)->setDirectory(scriptpath);

    // Raise the Xfe window
    ((XFileExplorer*)mainWindow)->raise();
    ((XFileExplorer*)mainWindow)->setFocus();

    return(1);
}


// Clear file list and reset panel status
void SearchPanel::clearItems(void)
{
    status->setText(_("0 item"));
    list->clearItems();
}


// Update the status bar
long SearchPanel::onUpdStatus(FXObject* sender, FXSelector, void*)
{
    // Update the status bar
    int      item = -1;
    FXString str, linkto;
    char     size[64];
    FXulong  sz = 0;

    FXString hsize = _("0 bytes");
    FXString path = list->getDirectory();
    int      num = list->getNumSelectedItems();

    item = list->getCurrentItem();

    if (num > 1)
    {
		int nbdirs = 0;
        for (int u = 0; u < list->getNumItems(); u++)
        {
            if (list->isItemSelected(u) && !list->isItemDirectory(u))
            {
                sz += list->getItemFileSize(u);
#if __WORDSIZE == 64
                snprintf(size, sizeof(size)-1, "%lu", sz);
#else
                snprintf(size, sizeof(size)-1, "%llu", sz);
#endif
                hsize = ::hSize(size);
            }
            
            if (list->isItemDirectory(u))
            {
				nbdirs++;
			}
        }

        // Don't count the '..' directory
        if (nbdirs >= 1)
        {
			nbdirs--;
		}
		
		int nbfiles = num - nbdirs;
        if (nbdirs <= 1 && nbfiles <= 1)
        {
	        str.format(_("%s in %s selected items (%s folder, %s file)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
        else if (nbdirs <=1 && nbfiles > 1)
        {
	        str.format(_("%s in %s selected items (%s folder, %s files)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
        else if (nbdirs > 1 && nbfiles <= 1)
        {
	        str.format(_("%s in %s selected items (%s folders, %s file)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
		else
		{
	        str.format(_("%s in %s selected items (%s folders, %s files)"), hsize.text(), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
		}
    }
    else
    {
        // Nothing selected
        if ((num == 0) || (item < 0))
        {
            num = list->getNumItems();
            if (num == 1)
            {
                str = _("1 item");
            }
            else
            {
				int nbdirs = 0;
				for (int u = 0; u < num; u++)
				{
					if (list->isItemDirectory(u))
					{
						nbdirs++;
					}
				}       

				int nbfiles = num - nbdirs;
		        str.format(_("%s items (%s folders, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());
				if (nbdirs <= 1 && nbfiles <= 1)
				{
					str.format(_("%s items (%s folder, %s file)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else if (nbdirs <=1 && nbfiles > 1)
				{
					str.format(_("%s items (%s folder, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else if (nbdirs > 1 && nbfiles <= 1)
				{
					str.format(_("%s items (%s folders, %s file)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
				else
				{
					str.format(_("%s items (%s folders, %s files)"), FXStringVal(num).text(), FXStringVal(nbdirs).text(), FXStringVal(nbfiles).text());		
				}
            }
        }
        else // num=1
        {
            FXString string = list->getItemText(item);
            FXString name = string.section('\t', 0);
            FXString type = string.section('\t', 3);

            FXString date = string.section('\t', 5);
            FXString usr = string.section('\t', 6);
            FXString grp = string.section('\t', 7);
            FXString perm = string.section('\t', 8);

            if (type.contains(_("Broken link")))
            {
                linkto = ::readLink(path+PATHSEPSTRING+name);
                str = name + "->" + linkto.text() + " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
            else if (type.contains(_("Link")))
            {
                linkto = ::readLink(path+PATHSEPSTRING+name);
                str = name + "->" + linkto.text() + " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
            else
            {
                for (int u = 0; u < list->getNumItems(); u++)
                {
                    if (list->isItemSelected(u) && !list->isItemDirectory(u))
                    {
                        sz = list->getItemFileSize(u);
#if __WORDSIZE == 64
                        snprintf(size, sizeof(size)-1, "%lu", sz);
#else
                        snprintf(size, sizeof(size)-1, "%llu", sz);
#endif
                        hsize = ::hSize(size);
                        break;
                    }
                }
                str = hsize+ " | " + type + " | " + date + " | " + usr + " | " + grp + " | " + perm;
            }
        }
    }

    status->setText(str);

    return(1);
}


// Update the status of the menu items that should be disabled
// when the number of selected items is not one
long SearchPanel::onUpdSelMult(FXObject* o, FXSelector sel, void*)
{
    int num;

    num = list->getNumSelectedItems();

    if (num == 1)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update the file compare menu item
long SearchPanel::onUpdCompare(FXObject* o, FXSelector sel, void*)
{
    // Menu item is enabled only when two files are selected
    int num;

    num = list->getNumSelectedItems();

    if ((num == 1) || (num == 2))
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Update menu items and toolbar buttons that are related to file operations
long SearchPanel::onUpdMenu(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when nothing is selected
    int num;

    num = list->getNumSelectedItems();

    if (num == 0)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }

    return(1);
}


// Update directory usage menu item
long SearchPanel::onUpdDirUsage(FXObject* o, FXSelector, void*)
{
    // Menu item is enabled only when at least two items are selected
    int num, item;

    num = list->getNumSelectedItems(&item);
    if (num > 1)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    return(1);
}


#if defined(linux)

// Query packages data base
long SearchPanel::onCmdPkgQuery(FXObject* o, FXSelector sel, void*)
{
    FXString cmd;

    // Name of the current selected file
    FXString file = list->getCurrentFile();

    // Command to perform
    if (pkg_format == DEB_PKG)
    {
        cmd = "dpkg -S " + ::quote(file);
    }
    else if (pkg_format == RPM_PKG)
    {
        cmd = "rpm -qf " + ::quote(file);
    }
    else
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("No compatible package manager (rpm or dpkg) found!"));
        return(0);
    }

    // Query command
    cmd += " 2>&1";

    // Wait cursor
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);
    getApp()->beginWaitCursor();

    // Perform the command
    FILE* pcmd = popen(cmd.text(), "r");
    if (!pcmd)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Failed command: %s"), cmd.text());
        return(0);
    }

    // Get command output
    char     text[10000] = { 0 };
    FXString buf;
    while (fgets(text, sizeof(text), pcmd))
    {
        buf += text;
    }
    snprintf(text, sizeof(text)-1, "%s", buf.text());

    // Close the stream and display error message if any
    if ((pclose(pcmd) == -1) && (errno != ECHILD))   // ECHILD can be set if the child was caught by sigHarvest
    {
        mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
        getApp()->endWaitCursor();
        MessageBox::error(this, BOX_OK, _("Error"), "%s", text);
        return(0);
    }
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
    getApp()->endWaitCursor();

    // Get package name, or detect when the file isn't in a package
    FXString str = text;
    if (pkg_format == DEB_PKG)  // DEB based distribution
    {
        int idx = str.find(" ");               // Split output at first whitespace
        FXString pkgname = str.left(idx-1);    // Remove trailing colon
        FXString fname = str.right(str.length()-idx);
        fname.trim();                          // Remove leading space and trailing newline
        if (streq(fname.text(), file.text()))  // No other word than the file name
        {
            str = pkgname.text();
        }
        else
        {
            str = "";
        }
    }
    if (pkg_format == RPM_PKG)   // RPM based distribution
    {
        if (str.find(' ') != -1) // Space character exists in the string
        {
            str = "";
        }
    }

    // Display the related output message
    FXString message;
    if (str == "")
    {
        message.format(_("File %s does not belong to any package."), file.text());
        MessageBox::information(this, BOX_OK, _("Information"), "%s", message.text());
    }
    else
    {
        message.format(_("File %s belongs to the package: %s"), file.text(), str.text());
        MessageBox::information(this, BOX_OK, _("Information"), "%s", message.text());
    }

    return(1);
}


// Update the package query menu
long SearchPanel::onUpdPkgQuery(FXObject* o, FXSelector sel, void*)
{
    // Menu item is disabled when multiple selection
    // or when unique selection and the selected item is a directory

    int num;

    num = list->getNumSelectedItems();

    if (num > 1)
    {
        o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    else // num=1
    {
        int item = list->getCurrentItem();
        if ((item >= 0) && list->isItemDirectory(item))
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
        }
        else
        {
            o->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
        }
    }

    return(1);
}


#endif
// Search files dialog and panel
#include "config.h"
#include "i18n.h"

#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>

#include <fx.h>
#include <fxkeys.h>
#include <errno.h>
#include <pwd.h>
#include <grp.h>

#include "icons.h"
#include "xfeutils.h"
#include "FileDialog.h"
#include "MessageBox.h"
#include "TextWindow.h"
#include "SearchPanel.h"
#include "SearchWindow.h"
#include "XFileExplorer.h"

// List refresh counter limits
#define REFRESH_COUNT_LIMIT    10000
#define REFRESH_COUNT_SLOW     100
#define REFRESH_COUNT_FAST     1000

extern FXMainWindow* mainWindow;

// Map
FXDEFMAP(SearchWindow) SearchWindowMap[] =
{
    FXMAPFUNC(SEL_KEYPRESS, 0, SearchWindow::onKeyPress),
    FXMAPFUNC(SEL_IO_READ, SearchWindow::ID_READ_DATA, SearchWindow::onReadData),
    FXMAPFUNC(SEL_COMMAND, SearchWindow::ID_START, SearchWindow::onCmdStart),
    FXMAPFUNC(SEL_COMMAND, SearchWindow::ID_STOP, SearchWindow::onCmdStop),
    FXMAPFUNC(SEL_CLOSE, 0, SearchWindow::onCmdClose),
    FXMAPFUNC(SEL_COMMAND, SearchWindow::ID_CLOSE, SearchWindow::onCmdClose),
    FXMAPFUNC(SEL_COMMAND, SearchWindow::ID_RESET_OPTIONS, SearchWindow::onCmdResetOptions),
    FXMAPFUNC(SEL_COMMAND, SearchWindow::ID_BROWSE_PATH, SearchWindow::onCmdBrowsePath),
    FXMAPFUNC(SEL_VERIFY, SearchWindow::ID_PERM, SearchWindow::onPermVerify),
    FXMAPFUNC(SEL_COMMAND, SearchWindow::ID_MORE_OPTIONS, SearchWindow::onCmdMoreOptions),
    FXMAPFUNC(SEL_UPDATE, SearchWindow::ID_STOP, SearchWindow::onUpdStop),
    FXMAPFUNC(SEL_UPDATE, SearchWindow::ID_START, SearchWindow::onUpdStart),
    FXMAPFUNC(SEL_UPDATE, SearchWindow::ID_PERM, SearchWindow::onUpdPerm),
    FXMAPFUNC(SEL_UPDATE, SearchWindow::ID_SIZE, SearchWindow::onUpdSize),
};


// Object implementation
FXIMPLEMENT(SearchWindow, FXTopWindow, SearchWindowMap, ARRAYNUMBER(SearchWindowMap))



// Contruct free floating dialog
SearchWindow::SearchWindow(FXApp* app, const FXString& name, FXuint opts, int x, int y, int w, int h, int pl, int pr, int pt, int pb, int hs, int vs) :
    FXTopWindow(app, name, NULL, NULL, opts, x, y, w, h, pl, pr, pt, pb, hs, vs)
{
    setIcon(searchicon);

    // Vertical frame
    FXVerticalFrame* frame1 = new FXVerticalFrame(this, LAYOUT_SIDE_TOP|FRAME_NONE|LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0);

    // Vertical frame
    searchframe = new FXVerticalFrame(frame1, LAYOUT_SIDE_TOP|FRAME_NONE|LAYOUT_FILL_X);

    // Label and input field
    FXMatrix* matrix1 = new FXMatrix(searchframe, 4, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix1, _("Find files:"), NULL, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW);
    findfile = new FXTextField(matrix1, 40, 0, 0, LAYOUT_CENTER_Y|LAYOUT_CENTER_X|FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);

    findigncase = new FXCheckButton(matrix1, _("Ignore case\tIgnore file name case"), NULL, 0, JUSTIFY_NORMAL|ICON_BEFORE_TEXT|LAYOUT_CENTER_Y);
    FXuint ignorecase = getApp()->reg().readUnsignedEntry("SEARCH PANEL", "find_ignorecase", 0);
    findigncase->setCheck(ignorecase);

    // Hidden files
    findhidden = new FXCheckButton(matrix1, _("Hidden files\tShow hidden files and folders"), NULL, 0, JUSTIFY_NORMAL|ICON_BEFORE_TEXT|LAYOUT_CENTER_Y);
    FXuint hidden = getApp()->reg().readUnsignedEntry("SEARCH PANEL", "find_hidden", 0);
    findhidden->setCheck(hidden);

    FXMatrix* matrix2 = new FXMatrix(searchframe, 3, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix2, _("In folder:"), NULL, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW);
    wheredir = new FXTextField(matrix2, 40, 0, 0, LAYOUT_CENTER_Y|LAYOUT_CENTER_X|FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);
    dirbutton = new FXButton(matrix2, _("\tIn folder..."), filedialogicon, this, ID_BROWSE_PATH, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);

    FXMatrix* matrix3 = new FXMatrix(searchframe, 3, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXLabel(matrix3, _("Text contains:"), NULL, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW);
    greptext = new FXTextField(matrix3, 40, 0, 0, LAYOUT_CENTER_Y|LAYOUT_CENTER_X|FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW|LAYOUT_FILL_X);

    grepigncase = new FXCheckButton(matrix3, _("Ignore case\tIgnore text case"), NULL, 0, JUSTIFY_NORMAL|ICON_BEFORE_TEXT|LAYOUT_CENTER_Y);
    ignorecase = getApp()->reg().readUnsignedEntry("SEARCH PANEL", "grep_ignorecase", 0);
    grepigncase->setCheck(ignorecase);

    // Search options
    moreoptions = new FXCheckButton(searchframe, _("More options"), this, ID_MORE_OPTIONS, CHECKBUTTON_PLUS|JUSTIFY_NORMAL|ICON_BEFORE_TEXT|LAYOUT_CENTER_Y);
    moregroup = new FXGroupBox(searchframe, _("Search options"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X);
    resetoptions = new FXButton(moregroup, _("Reset\tReset search options"), NULL, this, SearchWindow::ID_RESET_OPTIONS, FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    FXbool moreopts = getApp()->reg().readUnsignedEntry("SEARCH PANEL", "moreoptions", 0);
    if (moreopts)
    {
        moreoptions->setCheck(true);
        moregroup->show();
    }
    else
    {
        moreoptions->setCheck(false);
        moregroup->hide();
    }

    // File size
    FXMatrix* matrix4 = new FXMatrix(moregroup, 6, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|PACK_UNIFORM_WIDTH, 0, 0, 0, 0, 4, 4, 4, 8, 4, 8);
    new FXLabel(matrix4, _("Min size:"), NULL, JUSTIFY_LEFT);
    minsize = new FXSpinner(matrix4, 10, this, SearchWindow::ID_SIZE, SPIN_NOMAX|JUSTIFY_LEFT);
    minsize->setTipText(_("Filter by minimum file size (kBytes)"));
    new FXLabel(matrix4, _("kB"), NULL, JUSTIFY_LEFT);

    new FXLabel(matrix4, _("Max size:"), NULL, JUSTIFY_LEFT);
    maxsize = new FXSpinner(matrix4, 10, this, SearchWindow::ID_SIZE, SPIN_NOMAX|JUSTIFY_LEFT);
    maxsize->setTipText(_("Filter by maximum file size (kBytes)"));
    new FXLabel(matrix4, _("kB"), NULL, JUSTIFY_LEFT);

    // Modification date
    new FXLabel(matrix4, _("Last modified before:"), NULL, JUSTIFY_LEFT);
    mindays = new FXSpinner(matrix4, 10, NULL, 0, SPIN_NOMAX|JUSTIFY_LEFT);
    mindays->setTipText(_("Filter by maximum modification date (days)"));
    new FXLabel(matrix4, _("Days"), NULL, JUSTIFY_LEFT);

    new FXLabel(matrix4, _("Last modified after:"), NULL, JUSTIFY_LEFT);
    maxdays = new FXSpinner(matrix4, 10, NULL, 0, SPIN_NOMAX|JUSTIFY_LEFT);
    maxdays->setTipText(_("Filter by minimum modification date (days)"));
    new FXLabel(matrix4, _("Days"), NULL, JUSTIFY_LEFT);

    // User and group
    new FXLabel(matrix4, _("User:"), NULL, JUSTIFY_LEFT);
    user = new FXComboBox(matrix4, 15, NULL, 0, COMBOBOX_STATIC);
    user->setNumVisible(5);
    userbtn = new FXCheckButton(matrix4, _("\tFilter by user name"), NULL, 0, JUSTIFY_LEFT|LAYOUT_CENTER_Y);

    new FXLabel(matrix4, _("Group:"), NULL, JUSTIFY_LEFT);
    grp = new FXComboBox(matrix4, 15, NULL, 0, COMBOBOX_STATIC);
    grp->setNumVisible(5);
    grpbtn = new FXCheckButton(matrix4, _("\tFilter by group name"), NULL, 0, JUSTIFY_LEFT|LAYOUT_CENTER_Y);

    // User names (sorted in ascending order)
    struct passwd* pwde;
    while ((pwde = getpwent()))
    {
        user->appendItem(pwde->pw_name);
    }
    endpwent();
    user->setSortFunc(FXList::ascending);
    user->sortItems();

    // Group names (sorted in ascending order)
    struct group* grpe;
    while ((grpe = getgrent()))
    {
        grp->appendItem(grpe->gr_name);
    }
    endgrent();
    grp->setSortFunc(FXList::ascending);
    grp->sortItems();

    // Set user name and group name
    struct stat linfo;
    if (lstatrep(FXSystem::getHomeDirectory().text(), &linfo) == 0)
    {
        uid = FXSystem::userName(linfo.st_uid);
        gid = FXSystem::groupName(linfo.st_gid);
        user->setText(uid);
        grp->setText(gid);
    }

    // File type
    new FXLabel(matrix4, _("File type:"), NULL, JUSTIFY_LEFT);
    type = new FXComboBox(matrix4, 15, NULL, 0, COMBOBOX_STATIC);
    type->setNumVisible(5);
    type->appendItem(_("File"));
    type->appendItem(_("Folder"));
    type->appendItem(_("Link"));
    type->appendItem(_("Socket"));
    type->appendItem(_("Pipe"));
    type->setCurrentItem(0);
    typebtn = new FXCheckButton(matrix4, _("\tFilter by file type"), NULL, 0, JUSTIFY_LEFT|LAYOUT_CENTER_Y);

    // Permissions (in octal)
    new FXLabel(matrix4, _("Permissions:"), NULL, JUSTIFY_LEFT);
    perm = new FXTextField(matrix4, 4, this, SearchWindow::ID_PERM, TEXTFIELD_INTEGER|TEXTFIELD_LIMITED|TEXTFIELD_OVERSTRIKE|FRAME_SUNKEN|FRAME_THICK);
    perm->setText("0644");
    perm->setNumColumns(4);
    permbtn = new FXCheckButton(matrix4, _("\tFilter by permissions (octal)"), NULL, 0, JUSTIFY_LEFT|LAYOUT_CENTER_Y);

    // Empty files
    new FXLabel(matrix4, _("Empty files:"), NULL, JUSTIFY_LEFT);
    emptybtn = new FXCheckButton(matrix4, _("\tEmpty files only"), NULL, 0, JUSTIFY_LEFT|LAYOUT_CENTER_Y);

    // Follow symlinks
    new FXLabel(matrix4, "", NULL, JUSTIFY_LEFT);
    new FXLabel(matrix4, _("Follow symbolic links:"), NULL, JUSTIFY_LEFT);
    linkbtn = new FXCheckButton(matrix4, _("\tSearch while following symbolic links"), NULL, 0, JUSTIFY_LEFT|LAYOUT_CENTER_Y);

    // Non recursive
    new FXLabel(matrix4, "", NULL, JUSTIFY_LEFT);
    new FXLabel(matrix4, _("Non recursive:"), NULL, JUSTIFY_LEFT);
    norecbtn = new FXCheckButton(matrix4, _("\tDon't search folders recursively"), NULL, 0, JUSTIFY_LEFT|LAYOUT_CENTER_Y);

    // Don't search in other file systems
    new FXLabel(matrix4, "", NULL, JUSTIFY_LEFT);
    new FXLabel(matrix4, _("Ignore other file systems:"), NULL, JUSTIFY_LEFT);
    nofsbtn = new FXCheckButton(matrix4, _("\tDon't search in other file systems"), NULL, 0, JUSTIFY_LEFT|LAYOUT_CENTER_Y);

    // Search results
    FXHorizontalFrame* frame2 = new FXHorizontalFrame(frame1, LAYOUT_SIDE_TOP|FRAME_NONE|LAYOUT_FILL_X, 0, 0, 0, 0, 0, 0, 0, 0);
    searchresults = new FXLabel(frame2, "", NULL, LAYOUT_CENTER_Y|LAYOUT_FILL_X);

    // Buttons
    FXHorizontalFrame* buttons = new FXHorizontalFrame(frame2, PACK_UNIFORM_WIDTH, 0, 0, 0, 0, 10, 10, 5, 5);

    // Start
    startbutton = new FXButton(buttons, _("&Start\tStart the search (F3)"), NULL, this, ID_START, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT, 0, 0, 0, 0, 20, 20);

    // Stop
    stopbutton = new FXButton(buttons, _("&Stop\tStop the search (Esc)"), NULL, this, ID_STOP, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT, 0, 0, 0, 0, 20, 20);


    // Search Panel
    FXColor listbackcolor = getApp()->reg().readColorEntry("SETTINGS", "listbackcolor", FXRGB(255, 255, 255));
    FXColor listforecolor = getApp()->reg().readColorEntry("SETTINGS", "listforecolor", FXRGB(0, 0, 0));
    searchpanel = new SearchPanel(frame1,
                                  getApp()->reg().readUnsignedEntry("SEARCH PANEL", "name_size", 200),
                                  getApp()->reg().readUnsignedEntry("SEARCH PANEL", "dir_size", 150),
                                  getApp()->reg().readUnsignedEntry("SEARCH PANEL", "size_size", 60),
                                  getApp()->reg().readUnsignedEntry("SEARCH PANEL", "type_size", 100),
                                  getApp()->reg().readUnsignedEntry("SEARCH PANEL", "ext_size", 100),
                                  getApp()->reg().readUnsignedEntry("SEARCH PANEL", "modd_size", 150),
                                  getApp()->reg().readUnsignedEntry("SEARCH PANEL", "user_size", 50),
                                  getApp()->reg().readUnsignedEntry("SEARCH PANEL", "grou_size", 50),
                                  getApp()->reg().readUnsignedEntry("SEARCH PANEL", "attr_size", 100),
                                  listbackcolor, listforecolor,
                                  LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Display thumbnails or not
    FXbool showthumbnails;
    showthumbnails = getApp()->reg().readUnsignedEntry("SEARCH PANEL", "showthumbnails", 0);
    searchpanel->showThumbnails(showthumbnails);

    // Read and set sort function for file list
    FXString sort_func = getApp()->reg().readStringEntry("SEARCH PANEL", "sort_func", "ascendingCase");
    if (sort_func == "ascendingCase")
    {
        searchpanel->setSortFunc(FileList::ascendingCase);
    }
    else if (sort_func == "ascendingCaseMix")
    {
        searchpanel->setSortFunc(FileList::ascendingCaseMix);
    }
    else if (sort_func == "descendingCase")
    {
        searchpanel->setSortFunc(FileList::descendingCase);
    }
    else if (sort_func == "descendingCaseMix")
    {
        searchpanel->setSortFunc(FileList::descendingCaseMix);
    }
    else if (sort_func == "ascending")
    {
        searchpanel->setSortFunc(FileList::ascending);
    }
    else if (sort_func == "ascendingMix")
    {
        searchpanel->setSortFunc(FileList::ascendingMix);
    }
    else if (sort_func == "descending")
    {
        searchpanel->setSortFunc(FileList::descending);
    }
    else if (sort_func == "descendingMix")
    {
        searchpanel->setSortFunc(FileList::descendingMix);
    }
    else if (sort_func == "ascendingDirCase")
    {
        searchpanel->setSortFunc(FileList::ascendingDirCase);
    }
    else if (sort_func == "ascendingDirCaseMix")
    {
        searchpanel->setSortFunc(FileList::ascendingDirCaseMix);
    }
    else if (sort_func == "descendingDirCase")
    {
        searchpanel->setSortFunc(FileList::descendingDirCase);
    }
    else if (sort_func == "descendingDirCaseMix")
    {
        searchpanel->setSortFunc(FileList::descendingDirCaseMix);
    }
    else if (sort_func == "ascendingDir")
    {
        searchpanel->setSortFunc(FileList::ascendingDir);
    }
    else if (sort_func == "ascendingDirMix")
    {
        searchpanel->setSortFunc(FileList::ascendingDirMix);
    }
    else if (sort_func == "descendingDir")
    {
        searchpanel->setSortFunc(FileList::descendingDir);
    }
    else if (sort_func == "descendingDirMix")
    {
        searchpanel->setSortFunc(FileList::descendingDirMix);
    }
    else if (sort_func == "ascendingSize")
    {
        searchpanel->setSortFunc(FileList::ascendingSize);
    }
    else if (sort_func == "ascendingSizeMix")
    {
        searchpanel->setSortFunc(FileList::ascendingSizeMix);
    }
    else if (sort_func == "descendingSize")
    {
        searchpanel->setSortFunc(FileList::descendingSize);
    }
    else if (sort_func == "descendingSizeMix")
    {
        searchpanel->setSortFunc(FileList::descendingSizeMix);
    }
    else if (sort_func == "ascendingType")
    {
        searchpanel->setSortFunc(FileList::ascendingType);
    }
    else if (sort_func == "ascendingTypeMix")
    {
        searchpanel->setSortFunc(FileList::ascendingTypeMix);
    }
    else if (sort_func == "descendingType")
    {
        searchpanel->setSortFunc(FileList::descendingType);
    }
    else if (sort_func == "descendingTypeMix")
    {
        searchpanel->setSortFunc(FileList::descendingTypeMix);
    }
    else if (sort_func == "ascendingExt")
    {
        searchpanel->setSortFunc(FileList::ascendingExt);
    }
    else if (sort_func == "ascendingExtMix")
    {
        searchpanel->setSortFunc(FileList::ascendingExtMix);
    }
    else if (sort_func == "descendingExt")
    {
        searchpanel->setSortFunc(FileList::descendingExt);
    }
    else if (sort_func == "descendingExtMix")
    {
        searchpanel->setSortFunc(FileList::descendingExtMix);
    }
    else if (sort_func == "ascendingTime")
    {
        searchpanel->setSortFunc(FileList::ascendingTime);
    }
    else if (sort_func == "ascendingTimeMix")
    {
        searchpanel->setSortFunc(FileList::ascendingTimeMix);
    }
    else if (sort_func == "descendingTime")
    {
        searchpanel->setSortFunc(FileList::descendingTime);
    }
    else if (sort_func == "descendingTimeMix")
    {
        searchpanel->setSortFunc(FileList::descendingTimeMix);
    }
    else if (sort_func == "ascendingUser")
    {
        searchpanel->setSortFunc(FileList::ascendingUser);
    }
    else if (sort_func == "ascendingUserMix")
    {
        searchpanel->setSortFunc(FileList::ascendingUserMix);
    }
    else if (sort_func == "descendingUser")
    {
        searchpanel->setSortFunc(FileList::descendingUser);
    }
    else if (sort_func == "descendingUserMix")
    {
        searchpanel->setSortFunc(FileList::descendingUserMix);
    }
    else if (sort_func == "ascendingGroup")
    {
        searchpanel->setSortFunc(FileList::ascendingGroup);
    }
    else if (sort_func == "ascendingGroupMix")
    {
        searchpanel->setSortFunc(FileList::ascendingGroupMix);
    }
    else if (sort_func == "descendingGroup")
    {
        searchpanel->setSortFunc(FileList::descendingGroup);
    }
    else if (sort_func == "descendingGroupMix")
    {
        searchpanel->setSortFunc(FileList::descendingGroupMix);
    }
    else if (sort_func == "ascendingPerm")
    {
        searchpanel->setSortFunc(FileList::ascendingPerm);
    }
    else if (sort_func == "ascendingPermMix")
    {
        searchpanel->setSortFunc(FileList::ascendingPermMix);
    }
    else if (sort_func == "descendingPerm")
    {
        searchpanel->setSortFunc(FileList::descendingPerm);
    }
    else if (sort_func == "descendingPermMix")
    {
        searchpanel->setSortFunc(FileList::descendingPermMix);
    }

    // Add some accelerators
    FXHotKey hotkey;
    FXString key;

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "select_all", "Ctrl-A");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, searchpanel, FXSEL(SEL_COMMAND, SearchPanel::ID_SELECT_ALL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "invert_selection", "Ctrl-I");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, searchpanel, FXSEL(SEL_COMMAND, SearchPanel::ID_SELECT_INVERSE));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "deselect_all", "Ctrl-Z");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, searchpanel, FXSEL(SEL_COMMAND, SearchPanel::ID_DESELECT_ALL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rename", "F2");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, searchpanel, FXSEL(SEL_COMMAND, SearchPanel::ID_FILE_RENAME));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "copy_to", "F5");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, searchpanel, FXSEL(SEL_COMMAND, SearchPanel::ID_FILE_COPYTO));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "move_to", "F6");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, searchpanel, FXSEL(SEL_COMMAND, SearchPanel::ID_FILE_MOVETO));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "symlink_to", "Ctrl-S");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, searchpanel, FXSEL(SEL_COMMAND, SearchPanel::ID_FILE_SYMLINK));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "open", "Ctrl-O");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, searchpanel, FXSEL(SEL_COMMAND, SearchPanel::ID_OPEN));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "view", "Shift-F4");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, searchpanel, FXSEL(SEL_COMMAND, SearchPanel::ID_VIEW));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "edit", "F4");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, searchpanel, FXSEL(SEL_COMMAND, SearchPanel::ID_EDIT));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "compare", "F8");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, searchpanel, FXSEL(SEL_COMMAND, SearchPanel::ID_COMPARE));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "close", "Ctrl-W");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, this, FXSEL(SEL_COMMAND, SearchWindow::ID_CLOSE));

    // Warning window
    warnwindow = new TextWindow(this, _("Warnings"), 30, 80);

    // Set text font for the warning window
    FXString fontspec;
    fontspec = getApp()->reg().readStringEntry("SETTINGS", "textfont", DEFAULT_TEXT_FONT);
    if (!fontspec.empty())
    {
        FXFont* font = new FXFont(getApp(), fontspec);
        font->create();
        warnwindow->setFont(font);
    }

    // Initialize variables
    application = app;
    count = 0;
    pid = -1;
    running = false;
}


// Create window
void SearchWindow::create()
{
    // Create windows
    FXTopWindow::create();
    warnwindow->create();
}


// Clean up
SearchWindow::~SearchWindow()
{
    delete searchpanel;
    delete warnwindow;
}


// Check input for permissions in octal
long SearchWindow::onPermVerify(FXObject* o, FXSelector sel, void* ptr)
{
    char* str = (char*)ptr;

    for (int i = 0; i < (int)strlen(str); i++)
    {
        if (str[i]-'0' > 7)
        {
            return(1);
        }
    }

    return(0);
}


// Display or hide the more options dialog
long SearchWindow::onCmdMoreOptions(FXObject* o, FXSelector sel, void*)
{
    if (moreoptions->getCheck())
    {
        moregroup->show();

        // Reset search options
        minsize->setValue(0);
        maxsize->setValue(0);
        mindays->setValue(0);
        maxdays->setValue(0);
        userbtn->setCheck(false);
        grpbtn->setCheck(false);
        typebtn->setCheck(false);
        permbtn->setCheck(false);
        emptybtn->setCheck(false);
        linkbtn->setCheck(false);
        perm->setText("0644");
        type->setCurrentItem(0);
        user->setText(uid);
        grp->setText(gid);
        norecbtn->setCheck(false);
        nofsbtn->setCheck(false);
    }
    else
    {
        moregroup->hide();
    }

    // Refresh layout
    searchframe->recalc();

    return(1);
}


// Close window
long SearchWindow::onCmdClose(FXObject*, FXSelector, void*)
{
    ::setWaitCursor(getApp(), END_CURSOR);
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);

    // Clear panel items
    searchpanel->clearItems();

    // Reset search options
    minsize->setValue(0);
    maxsize->setValue(0);
    mindays->setValue(0);
    maxdays->setValue(0);
    userbtn->setCheck(false);
    grpbtn->setCheck(false);
    typebtn->setCheck(false);
    permbtn->setCheck(false);
    emptybtn->setCheck(false);
    linkbtn->setCheck(false);
    perm->setText("0644");
    type->setCurrentItem(0);
    user->setText(uid);
    grp->setText(gid);
    norecbtn->setCheck(false);
    nofsbtn->setCheck(false);

    running = false;
    searchresults->setText("");

    if (pid != -1)
    {
        kill((-1*pid), SIGTERM); // Kills the process group
    }
    hide();

    return(1);
}


// Start the file search
long SearchWindow::onCmdStart(FXObject*, FXSelector, void*)
{
    // Set the search pattern from user input
    // Add '*' before and after the string if not present
    FXString searchpattern;

    if (findfile->getText() == "")
    {
        searchpattern = "*";
    }
    else if (findfile->getText().contains('*'))
    {
        searchpattern = findfile->getText();
    }
    else
    {
        searchpattern = "*" + findfile->getText() + "*";
    }

    // Set search path in search panel
    searchpanel->setSearchPath(wheredir->getText());

    // Compose the find and grep command according to the selected options

    // Follow symlinks
    if (linkbtn->getCheck())
    {
        searchcommand = "find -L " + ::quote(wheredir->getText());
    }
    else
    {
        searchcommand = "find -P " + ::quote(wheredir->getText());
    }

    // Ignore case
    FXString nameoption;
    if (findigncase->getCheck())
    {
        nameoption = " -iname \"";
    }
    else
    {
        nameoption = " -name \"";
    }

    // Min file size
    if (minsize->getValue() > 0)
    {
        searchcommand += " -size +" + FXStringVal(minsize->getValue()) + "k";
    }

    // Max file size
    if (maxsize->getValue() > 0)
    {
        searchcommand += " -size -" + FXStringVal(maxsize->getValue()) + "k";
    }

    // Date modified before
    if (mindays->getValue() > 0)
    {
        searchcommand += " -mtime -" + FXStringVal(mindays->getValue());
    }

    // Date modified after
    if (maxdays->getValue() > 0)
    {
        searchcommand += " -mtime +" + FXStringVal(maxdays->getValue());
    }

    // User
    if (userbtn->getCheck())
    {
        searchcommand += " -user " + user->getText();
    }

    // Group
    if (grpbtn->getCheck())
    {
        searchcommand += " -group " + grp->getText();
    }

    // Non recursive
    if (norecbtn->getCheck())
    {
        searchcommand += " -maxdepth 1 ";
    }

    // Don't search other file systems
    if (nofsbtn->getCheck())
    {
        searchcommand += " -mount ";
    }

    // File type
    if (typebtn->getCheck())
    {
        if (type->getCurrentItem() == 0)
        {
            searchcommand += " -type f";
        }

        else if (type->getCurrentItem() == 1)
        {
            searchcommand += " -type d";
        }

        else if (type->getCurrentItem() == 2)
        {
            searchcommand += " -type l";
        }

        else if (type->getCurrentItem() == 3)
        {
            searchcommand += " -type s";
        }

        else if (type->getCurrentItem() == 4)
        {
            searchcommand += " -type p";
        }
    }

    // Permissions
    if (permbtn->getCheck())
    {
        searchcommand += " -perm " + perm->getText();
    }

    // Empty files
    if (emptybtn->getCheck())
    {
        searchcommand += " -empty";
    }

    // Hidden files
    if (!findhidden->getCheck())
    {
        searchcommand += " \\( ! -regex '.*/\\..*' \\)";
    }

    // Without grep command
    if (greptext->getText() == "")
    {
        searchcommand += nameoption + searchpattern + "\" -print";
    }

    // With grep command
    else
    {
        searchcommand += nameoption + searchpattern + "\" -exec grep -q -s ";

        // Ignore case
        if (grepigncase->getCheck())
        {
            searchcommand += "-i ";
        }

        searchcommand += "\"" + greptext->getText() + "\" '{}' \\; -print";
    }

    // Clear all file list items
    searchpanel->clearItems();

    // Don't use standard cursor wait function
    ::setWaitCursor(getApp(), BEGIN_CURSOR);
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);

    searchresults->setText(_(">>>> Search started - Please wait... <<<<"));
    running = true;

    // Execute command
    count = 0;
    strprev = "";
    warnwindow->setText("");

    execCmd(searchcommand.text());

    return(1);
}


// Execute the search command and capture its output
int SearchWindow::execCmd(FXString command)
{
    // Open pipes to communicate with child process
    if ((pipe(in) == -1) || (pipe(out) == -1))
    {
        return(-1);
    }

    // Create child process
    pid = fork();
    if (pid == -1)
    {
		fprintf(stderr, _("Error: Fork failed: %s\n"), strerror(errno));
        return(-1);
    }
    application->addInput(out[0], INPUT_READ, this, ID_READ_DATA);

    if (pid == 0)
    {
        // Here, we are running as the child process!
        char* args[4];
        ::close(out[0]);
        int ret1 = ::dup2(out[1], STDOUT_FILENO);
        int ret2 = ::dup2(out[1], STDERR_FILENO);
        ::close(in[1]);
        int ret3 = ::dup2(in[0], STDIN_FILENO);

        if ((ret1 < 0) || (ret2 < 0) || (ret3 < 0))
        {
            int errcode = errno;
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't duplicate pipes: %s"), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't duplicate pipes"));
            }

            return(-1);
        }

        args[0] = (char*)"sh";           // Setup arguments
        args[1] = (char*)"-c";           // to run command
        args[2] = (char*)command.text(); // in a shell in
        args[3] = NULL;                  // a new process

        setpgid(0, 0);                   // Allows to kill the whole group
        execvp(args[0], args);           // Start a new process which will execute the command
        _exit(EXIT_FAILURE);             // We'll get here only if an error occurred
    }
    else
    {
        // Here, we are running as the parent process!
        ::close(out[1]);
        ::close(in[0]);
    }

    return(1);
}


// Read data from pipe
long SearchWindow::onReadData(FXObject*, FXSelector, void*)
{
    char     buf[4096];
    int      nread, status, beg, end;
    FXString strbuf, pathname;

    if (running)
    {
        // Stop refreshing the file list
        searchpanel->setAllowRefresh(false);

        nread = read(out[0], buf, 4095);
        if (nread > 0)
        {
            buf[nread] = '\0';

            // Caution : string strprev is initialized in onCmdStart()
            strbuf = strprev + buf;

            // Loop over lines in strbuf
            for (beg = 0; beg < strbuf.length(); beg = end+1)
            {
                // If line not complete, the fragment will be used in the next line
                if ((end = strbuf.find("\n", beg)) < 0)
                {
                    end = strbuf.length();
                    strprev = strbuf.mid(beg, end-beg);
                    break;
                }
                else
                {
                    strprev = "";
                }

                pathname = strbuf.mid(beg, end-beg);

                // Append item to the file panel
                // Only process valid file paths and paths different from the search directory
                if ((pathname != searchcommand) && (pathname != wheredir->getText()))
                {
                    if (pathname.find(PATHSEPSTRING) == 0)
                    {
                        if (searchpanel->appendItem(pathname))
                        {
                            count++;
                        }

                        // Refresh file list (two speeds depending on the number of items)
                        FXuint cnt = (count < REFRESH_COUNT_LIMIT ? count%REFRESH_COUNT_SLOW : count%REFRESH_COUNT_FAST);
                        if (cnt == 0)
                        {
                            searchpanel->setCurrentItem(count-1);
                            searchpanel->setStatusText(FXStringVal(count)+_(" items"));
                            getApp()->forceRefresh();
                            getApp()->repaint();
                        }
                    }
                    else
                    {
                        if (!warnwindow->shown())
                        {
                            warnwindow->show(PLACEMENT_OWNER);
                        }

                        pathname = pathname + "\n";

                        warnwindow->appendText(pathname.text());
                        warnwindow->scrollToLastLine();
                    }
                }
            }
        }

        // Nothing to read
        else if (nread == 0)
        {
            waitpid(pid, &status, 0);
            application->removeInput(out[0], INPUT_READ);
            searchresults->setText(_(">>>> Search results <<<<"));
            running = false;

            // Don't use standard cursor wait function
            ::setWaitCursor(getApp(), END_CURSOR);
	    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);

            // Update item count
            searchpanel->setStatusText(FXStringVal(count)+_(" items"));
            getApp()->repaint();

            // Force file list refresh
            searchpanel->setAllowRefresh(true);
            searchpanel->onCmdRefresh(0, 0, 0);
        }

        // Input / Output error
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Input / Output error"));
            application->removeInput(out[0], INPUT_READ);
            exit(EXIT_FAILURE);
        }
    }

    return(1);
}


// Kill process when clicking on the stop button
long SearchWindow::onCmdStop(FXObject*, FXSelector, void*)
{
    if (running)
    {
        ::setWaitCursor(getApp(), END_CURSOR);
	mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
        running = false;
        searchresults->setText(_(">>>> Search stopped... <<<<"));

        if (pid != -1)
        {
            kill((-1*pid), SIGTERM); // Kills the process group
        }
        application->removeInput(out[0], INPUT_READ);
        searchpanel->setAllowRefresh(true);
    }

    return(1);
}


// Update stop button and other UI buttons
long SearchWindow::onUpdStop(FXObject*, FXSelector, void*)
{
    if (running)
    {
        // Enable stop button while searching files
        stopbutton->enable();

        // Disable all other buttons
        searchpanel->disableButtons();
        findfile->disable();
        findigncase->disable();
        findhidden->disable();
        wheredir->disable();
        dirbutton->disable();
        greptext->disable();
        grepigncase->disable();
        moreoptions->disable();
        resetoptions->disable();
        minsize->disable();
        maxsize->disable();
        mindays->disable();
        maxdays->disable();
        userbtn->disable();
        grpbtn->disable();
        typebtn->disable();
        permbtn->disable();
        emptybtn->disable();
        linkbtn->disable();
        perm->disable();
        type->disable();
        user->disable();
        grp->disable();
        norecbtn->disable();
        nofsbtn->disable();
    }
    else
    {
        // Disable stop button while not searching files
        stopbutton->disable();

        // Enable all other buttons
        searchpanel->enableButtons();
        findfile->enable();
        findigncase->enable();
        findhidden->enable();
        wheredir->enable();
        dirbutton->enable();
        greptext->enable();
        grepigncase->enable();
        moreoptions->enable();
        resetoptions->enable();
        minsize->enable();
        maxsize->enable();
        mindays->enable();
        maxdays->enable();
        userbtn->enable();
        grpbtn->enable();
        typebtn->enable();
        permbtn->enable();
        emptybtn->enable();
        linkbtn->enable();
        perm->enable();
        type->enable();
        user->enable();
        grp->enable();
        norecbtn->enable();
        nofsbtn->enable();
    }

    return(1);
}


// Update start button
long SearchWindow::onUpdStart(FXObject*, FXSelector, void*)
{
    if (running)
    {
        startbutton->disable();
    }
    else
    {
        startbutton->enable();
    }

    return(1);
}


// Show window such that the cursor is in it
void SearchWindow::show(FXuint placement)
{
    // Clear all file list items
    searchpanel->clearItems();

    // Set focus on the find search field and select all chars
    findfile->setFocus();
    findfile->selectAll();

    // Pop the window
    FXTopWindow::show(placement);
}


// Keyboard press
long SearchWindow::onKeyPress(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    if (event->code == KEY_Escape)
    {
        // Kill process
        handle(this, FXSEL(SEL_COMMAND, ID_STOP), NULL);

        // Deselect files if any
        searchpanel->handle(sender, FXSEL(SEL_COMMAND, SearchPanel::ID_DESELECT_ALL), ptr);

        return(1);
    }
    else if ((event->code == KEY_F3) || ((searchpanel->hasFocus() == false) && (event->code == KEY_Return)))
    {
        // Start process
        handle(this, FXSEL(SEL_COMMAND, ID_START), NULL);
        return(1);
    }

    // Shift-F10 or menu was pressed : open popup menu
   	else if ((event->state&SHIFTMASK && event->code == KEY_F10) || event->code == KEY_Menu)
    {
        searchpanel->handle(sender, FXSEL(SEL_COMMAND, SearchPanel::ID_POPUP_MENU), ptr);
        return(1);
    }

    // Any other key was pressed : handle the pressed key in the usual way
    else
    {
        if (FXTopWindow::onKeyPress(sender, sel, ptr))
        {
            return(1);
        }
    }

    return(0);
}


// Execute dialog box modally
FXuint SearchWindow::execute(FXuint placement)
{
    create();
    show(placement);
    getApp()->refresh();
    return(getApp()->runModalFor(this));
}


// Browse the file system
long SearchWindow::onCmdBrowsePath(FXObject* o, FXSelector s, void* p)
{
    FileDialog browse(this, _("Select path"), 0, 0, 0, 650, 480);

    const char* patterns[] =
    {
        _("All Files"), "*", NULL
    };

    browse.setFilename(wheredir->getText());
    browse.setPatternList(patterns);

    // Browse files in mixed mode
    browse.setSelectMode(SELECT_FILE_DIRECTORY);
    if (browse.execute())
    {
        FXString path = browse.getFilename();
        wheredir->setText(path);
    }
    return(1);
}


// Update permission string
long SearchWindow::onUpdPerm(FXObject* sender, FXSelector, void*)
{
    int len = perm->getText().length();

    if (len < 4)
    {
        FXString str;
        if (len == 0)
        {
            perm->setText("0644");
        }

        else if (len == 1)
        {
            str = "000" + perm->getText();
        }

        else if (len == 2)
        {
            str = "00" + perm->getText();
        }

        else
        {
            str = "0" + perm->getText();
        }

        perm->setText(str);
    }

    return(1);
}


// Update size buttons
long SearchWindow::onUpdSize(FXObject* sender, FXSelector, void*)
{
    // Disable or enable size buttons
    if (emptybtn->getCheck())
    {
        minsize->setValue(0);
        maxsize->setValue(0);
        minsize->disable();
        maxsize->disable();
    }
    else
    {
        minsize->enable();
        maxsize->enable();
    }

    return(1);
}


// Reset search options
long SearchWindow::onCmdResetOptions(FXObject* o, FXSelector sel, void*)
{
    minsize->setValue(0);
    maxsize->setValue(0);
    mindays->setValue(0);
    maxdays->setValue(0);
    userbtn->setCheck(false);
    grpbtn->setCheck(false);
    typebtn->setCheck(false);
    permbtn->setCheck(false);
    emptybtn->setCheck(false);
    linkbtn->setCheck(false);
    perm->setText("0644");
    type->setCurrentItem(0);
    user->setText(uid);
    grp->setText(gid);
    norecbtn->setCheck(false);
    nofsbtn->setCheck(false);

    return(1);
}
// StringList class : implements a doubly linked list of FXString

#include <stdio.h>

#include <fx.h>

#include "StringList.h"


// Insert an item before the given item
void StringList::insertBeforeItem(FXString str, StringItem* item)
{
    StringItem* newItem;

    newItem = new StringItem();

    newItem->prev = item->prev;
    newItem->next = item;
    newItem->str = str;

    if (item->prev == NULL)
    {
        this->first = newItem;
    }
    if (item->next == NULL)
    {
        this->last = item;
    }

    item->prev = newItem;
}


// Insert an item before the first item
void StringList::insertFirstItem(FXString str)
{
    StringItem* newItem;

    if (this->first == NULL)
    {
        newItem = new StringItem();
        this->first = newItem;
        this->last = newItem;
        newItem->prev = NULL;
        newItem->next = NULL;
        newItem->str = str;
    }
    else
    {
        insertBeforeItem(str, this->first);
    }
}


// Insert an item after the given item
void StringList::insertAfterItem(FXString str, StringItem* item)
{
    StringItem* newItem;

    newItem = new StringItem();
    newItem->next = item->next;
    newItem->prev = item;
    newItem->str = str;

    if (item->next == NULL)
    {
        this->last = newItem;
    }
    item->next = newItem;
}


// Insert an item after the last item
void StringList::insertLastItem(FXString str)
{
    if (this->last == NULL)
    {
        insertFirstItem(str);
    }
    else
    {
        insertAfterItem(str, this->last);
    }
}


// Remove the first item
void StringList::removeFirstItem(void)
{
    removeItem(this->first);
}


// Remove the last item
void StringList::removeLastItem(void)
{
    removeItem(this->last);
}


// Remove the item before the given item
void StringList::removeBeforeItem(StringItem* item)
{
    if (item->prev == this->first)
    {
        this->first = item;
        this->first->prev = NULL;
    }
    else
    {
        removeItem(item->prev);
    }
}


// Remove the item after the given item
void StringList::removeAfterItem(StringItem* item)
{
    if (item->next == this->last)
    {
        this->last = item;
        this->last->next = NULL;
    }
    else
    {
        removeItem(item->next);
    }
}


// Number of items in the list
int StringList::getNumItems(void)
{
    StringItem* item;
    int         num = 0;

    item = this->first;

    while (item != NULL)
    {
        item = item->next;
        num++;
    }
    return(num);
}


// Remove a particular item
void StringList::removeItem(StringItem* item)
{
    if ((item == this->first) && (item == this->last))
    {
        this->first = NULL;
        this->last = NULL;
    }
    else if (item == this->first)
    {
        this->first = this->first->next;
        this->first->prev = NULL;
    }
    else if (item == this->last)
    {
        this->last = this->last->prev;
        this->last->next = NULL;
    }
    else
    {
        item->prev->next = item->next;
        item->next->prev = item->prev;
    }
}


// Remove all items before a given item
void StringList::removeAllItemsBefore(StringItem* item)
{
    StringItem* previtem;

    previtem = item->prev;
    if (previtem != NULL)
    {
        while (previtem != NULL)
        {
            removeItem(previtem);
            previtem = item->prev;
        }
    }
}


// Remove all items after a given item
void StringList::removeAllItemsAfter(StringItem* item)
{
    StringItem* nextitem;

    nextitem = item->next;
    if (nextitem != NULL)
    {
        while (nextitem != NULL)
        {
            removeItem(nextitem);
            nextitem = item->next;
        }
    }
}


// Remove all items
void StringList::removeAllItems(void)
{
    StringItem* item, *previtem;

    item = this->last;

    while (item != NULL)
    {
        previtem = item->prev;
        removeItem(item);
        if (previtem == NULL)
        {
            break;
        }
        item = previtem;
    }
}


// Get item based on its position (first position is 0)
StringItem* StringList::getItemAtPos(const int pos)
{
    int num = getNumItems();

    if ((num == 0) || (pos < 0) || (pos > num-1))
    {
        return(NULL);
    }

    StringItem* item;

    item = this->first;
    if (pos == 0)
    {
        return(item);
    }

    num = 0;
    while (item != NULL)
    {
        item = item->next;
        num++;
        if (pos == num)
        {
            break;
        }
    }
    return(item);
}


// Print the list from the first item
void StringList::printFromFirst(void)
{
    StringItem* item;

    item = this->first;

    fprintf(stdout, "\n=> printFromFirst\n");
    while (item != NULL)
    {
        fprintf(stdout, "str=%s\n", item->str.text());
        item = item->next;
    }
    fprintf(stdout, "<= printFromFirst\n\n");
}


// Print the list from endwards
void StringList::printFromLast(void)
{
    StringItem* item;

    item = this->last;

    fprintf(stdout, "\n=> printFromLast\n");
    while (item != NULL)
    {
        fprintf(stdout, "str=%s\n", item->str.text());
        item = item->prev;
    }
    fprintf(stdout, "<= printFromLast\n\n");
}


/*
 *
 * // To test this class
 * int main(void)
 * {
 *  StringList *strlist ;
 *  StringItem *item;
 *  FXString str;
 *
 *  strlist= new StringList();
 *
 *  // Insert at the end
 *  strlist->insertLastItem("test2");
 *  strlist->printFromFirst();
 *  strlist->insertLastItem("test3");
 *  strlist->printFromFirst();
 *  strlist->insertLastItem("test4");
 *  strlist->printFromFirst();
 *
 *  // Insert at the beginning
 *  strlist->insertFirstItem("test1");
 *  strlist->printFromFirst();
 *  strlist->insertFirstItem("test0");
 *  strlist->printFromFirst();
 *
 *  // Insert at the end
 *  strlist->insertLastItem("test5");
 *  strlist->printFromFirst();
 *  strlist->insertLastItem("test6");
 *  strlist->printFromFirst();
 *
 *  // Remove the first item
 *  strlist->removeFirstItem();
 *  strlist->printFromFirst();
 *
 *  // Remove the last item
 *  strlist->removeLastItem();
 *  strlist->printFromFirst();
 *
 *  // Number of items
 *  fprintf(stdout,"Number of items = %d\n\n",strlist->getNumItems());
 *
 *  // Get first item
 *  item=strlist->getFirst();
 *  if (item)
 *  {
 *      str=strlist->getString(item);
 *      fprintf(stdout,"str=%s\n",str.text());
 *  }
 *
 *  // Get last item
 *  item=strlist->getLast();
 *  if (item)
 *  {
 *      str=strlist->getString(item);
 *      fprintf(stdout,"str=%s\n",str.text());
 *  }
 *
 *  // Get next item
 *  item=strlist->getNext(item);
 *  if (item)
 *  {
 *      str=strlist->getString(item);
 *      fprintf(stdout,"str=%s\n",str.text());
 *  }
 *
 *  // Get item at some positions
 *  item=strlist->getItemAtPos(0);
 *  if (item)
 *  {
 *      str=strlist->getString(item);
 *      fprintf(stdout,"item at position 0 : str=%s\n",str.text());
 *  }
 *  item=strlist->getItemAtPos(3);
 *  if (item)
 *  {
 *      str=strlist->getString(item);
 *      fprintf(stdout,"item at position 3 : str=%s\n",str.text());
 *  }
 *
 *  // Remove all items before position 3
 *  strlist->removeAllItemsBefore(item);
 *  strlist->printFromFirst();
 *
 *  // Insert at the end
 *  strlist->insertLastItem("test6");
 *  strlist->insertLastItem("test7");
 *  strlist->insertLastItem("test8");
 *  strlist->printFromFirst();
 *
 *  // Remove all items after position 3
 *  item=strlist->getItemAtPos(3);
 *  strlist->removeAllItemsAfter(item);
 *  strlist->printFromFirst();
 *
 *  // Remove all items in the list
 *  //strlist->printFromFirst();
 *  //strlist->removeAllItems();
 *  //strlist->printFromFirst();
 *
 *  // Delete the list
 *  delete strlist;
 * }
 */
// Text label with selection/copy/paste capabilities
// Based on the FXTextField widget

#include <fx.h>
#include <fxkeys.h>
#include <FX88591Codec.h>
#include <FXUTF16Codec.h>

#include "TextLabel.h"

#define JUSTIFY_MASK    (JUSTIFY_HZ_APART|JUSTIFY_VT_APART)


// Map
FXDEFMAP(TextLabel) TextLabelMap[] =
{
    FXMAPFUNC(SEL_PAINT, 0, TextLabel::onPaint),
    FXMAPFUNC(SEL_UPDATE, 0, TextLabel::onUpdate),
    FXMAPFUNC(SEL_MOTION, 0, TextLabel::onMotion),
    FXMAPFUNC(SEL_TIMEOUT, TextLabel::ID_AUTOSCROLL, TextLabel::onAutoScroll),
    FXMAPFUNC(SEL_LEFTBUTTONPRESS, 0, TextLabel::onLeftBtnPress),
    FXMAPFUNC(SEL_LEFTBUTTONRELEASE, 0, TextLabel::onLeftBtnRelease),
    FXMAPFUNC(SEL_MIDDLEBUTTONPRESS, 0, TextLabel::onMiddleBtnPress),
    FXMAPFUNC(SEL_MIDDLEBUTTONRELEASE, 0, TextLabel::onMiddleBtnRelease),
    FXMAPFUNC(SEL_KEYPRESS, 0, TextLabel::onKeyPress),
    FXMAPFUNC(SEL_KEYRELEASE, 0, TextLabel::onKeyRelease),
    FXMAPFUNC(SEL_SELECTION_LOST, 0, TextLabel::onSelectionLost),
    FXMAPFUNC(SEL_SELECTION_GAINED, 0, TextLabel::onSelectionGained),
    FXMAPFUNC(SEL_SELECTION_REQUEST, 0, TextLabel::onSelectionRequest),
    FXMAPFUNC(SEL_CLIPBOARD_LOST, 0, TextLabel::onClipboardLost),
    FXMAPFUNC(SEL_CLIPBOARD_GAINED, 0, TextLabel::onClipboardGained),
    FXMAPFUNC(SEL_CLIPBOARD_REQUEST, 0, TextLabel::onClipboardRequest),
    FXMAPFUNC(SEL_FOCUSIN, 0, TextLabel::onFocusIn),
    FXMAPFUNC(SEL_FOCUSOUT, 0, TextLabel::onFocusOut),
    FXMAPFUNC(SEL_FOCUS_SELF, 0, TextLabel::onFocusSelf),
    FXMAPFUNC(SEL_UPDATE, TextLabel::ID_COPY_SEL, TextLabel::onUpdHaveSelection),
    FXMAPFUNC(SEL_UPDATE, TextLabel::ID_SELECT_ALL, TextLabel::onUpdselectAll),
    FXMAPFUNC(SEL_COMMAND, TextLabel::ID_CURSOR_HOME, TextLabel::onCmdCursorHome),
    FXMAPFUNC(SEL_COMMAND, TextLabel::ID_CURSOR_END, TextLabel::onCmdCursorEnd),
    FXMAPFUNC(SEL_COMMAND, TextLabel::ID_CURSOR_RIGHT, TextLabel::onCmdCursorRight),
    FXMAPFUNC(SEL_COMMAND, TextLabel::ID_CURSOR_LEFT, TextLabel::onCmdCursorLeft),
    FXMAPFUNC(SEL_COMMAND, TextLabel::ID_CURSOR_WORD_LEFT, TextLabel::onCmdCursorWordLeft),
    FXMAPFUNC(SEL_COMMAND, TextLabel::ID_CURSOR_WORD_RIGHT, TextLabel::onCmdCursorWordRight),
    FXMAPFUNC(SEL_COMMAND, TextLabel::ID_CURSOR_WORD_START, TextLabel::onCmdCursorWordStart),
    FXMAPFUNC(SEL_COMMAND, TextLabel::ID_CURSOR_WORD_END, TextLabel::onCmdCursorWordEnd),
    FXMAPFUNC(SEL_COMMAND, TextLabel::ID_MARK, TextLabel::onCmdMark),
    FXMAPFUNC(SEL_COMMAND, TextLabel::ID_EXTEND, TextLabel::onCmdExtend),
    FXMAPFUNC(SEL_COMMAND, TextLabel::ID_SELECT_ALL, TextLabel::onCmdselectAll),
    FXMAPFUNC(SEL_COMMAND, TextLabel::ID_DESELECT_ALL, TextLabel::onCmdDeselectAll),
    FXMAPFUNC(SEL_COMMAND, TextLabel::ID_COPY_SEL, TextLabel::onCmdCopySel),
};


// Object implementation
FXIMPLEMENT(TextLabel, FXFrame, TextLabelMap, ARRAYNUMBER(TextLabelMap))


// Delimiters
const char TextLabel::textDelimiters[] = "~.,/\\`'!@#$%^&*()-=+{}|[]\":;<>?";


// Construct and init
TextLabel::TextLabel(FXComposite* p, int ncols, FXObject* tgt, FXSelector sel, FXuint opts, int x, int y, int w, int h, int pl, int pr, int pt, int pb) :
    FXFrame(p, opts, x, y, w, h, pl, pr, pt, pb)
{
    if (ncols < 0)
    {
        ncols = 0;
    }
    flags |= FLAG_ENABLED;
    target = tgt;
    message = sel;
    if (!(options&JUSTIFY_RIGHT))
    {
        options |= JUSTIFY_LEFT;
    }

    // Note : cursor is not changed if the object is constructed with ncols=0
    if (ncols > 0)
    {
        defaultCursor = getApp()->getDefaultCursor(DEF_TEXT_CURSOR);
        dragCursor = getApp()->getDefaultCursor(DEF_TEXT_CURSOR);
    }

    delimiters = textDelimiters;
    font = getApp()->getNormalFont();
    backColor = getApp()->getBackColor();
    textColor = getApp()->getForeColor();
    selbackColor = getApp()->getSelbackColor();
    seltextColor = getApp()->getSelforeColor();
    cursorColor = getApp()->getForeColor();
    cursor = 0;
    anchor = 0;
    columns = ncols;
    shift = 0;
}


// Create X window
void TextLabel::create()
{
    FXFrame::create();
    if (!textType)
    {
        textType = getApp()->registerDragType(textTypeName);
    }
    if (!utf8Type)
    {
        utf8Type = getApp()->registerDragType(utf8TypeName);
    }
    if (!utf16Type)
    {
        utf16Type = getApp()->registerDragType(utf16TypeName);
    }
    font->create();
}


// Change the font
void TextLabel::setFont(FXFont* fnt)
{
    if (!fnt)
    {
        fxerror("%s::setFont: NULL font specified.\n", getClassName());
    }
    if (font != fnt)
    {
        font = fnt;
        recalc();
        update();
    }
}


// Enable the window
void TextLabel::enable()
{
    if (!(flags&FLAG_ENABLED))
    {
        FXFrame::enable();
        update();
    }
}


// Disable the window
void TextLabel::disable()
{
    if (flags&FLAG_ENABLED)
    {
        FXFrame::disable();
        update();
    }
}


// Get default width
int TextLabel::getDefaultWidth()
{
    return(padleft+padright+(border<<1)+columns*font->getTextWidth("8", 1));
}


// Get default height
int TextLabel::getDefaultHeight()
{
    return(padtop+padbottom+(border<<1)+font->getFontHeight());
}


// Implement auto-hide or auto-gray modes
long TextLabel::onUpdate(FXObject* sender, FXSelector sel, void* ptr)
{
    if (!FXFrame::onUpdate(sender, sel, ptr))
    {
        if (options&TEXTFIELD_AUTOHIDE)
        {
            if (shown())
            {
                hide();
                recalc();
            }
        }
        if (options&TEXTFIELD_AUTOGRAY)
        {
            disable();
        }
    }
    return(1);
}


// We now really do have the selection; repaint the text field
long TextLabel::onSelectionGained(FXObject* sender, FXSelector sel, void* ptr)
{
    FXFrame::onSelectionGained(sender, sel, ptr);
    update();
    return(1);
}


// We lost the selection somehow; repaint the text field
long TextLabel::onSelectionLost(FXObject* sender, FXSelector sel, void* ptr)
{
    FXFrame::onSelectionLost(sender, sel, ptr);
    update();
    return(1);
}


// Somebody wants our selection; the text field will furnish it if the target doesn't
long TextLabel::onSelectionRequest(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    FXString string;
    FXuint   start;
    FXuint   len;

    // Make sure
    FXASSERT(0 <= anchor && anchor <= contents.length());
    FXASSERT(0 <= cursor && cursor <= contents.length());

    // Perhaps the target wants to supply its own data for the selection
    if (FXFrame::onSelectionRequest(sender, sel, ptr))
    {
        return(1);
    }

    // Recognize the request?
    if ((event->target == stringType) || (event->target == textType) || (event->target == utf8Type) || (event->target == utf16Type))
    {
        // Figure selected bytes
        if (anchor < cursor)
        {
            start = anchor;
            len = cursor-anchor;
        }
        else
        {
            start = cursor;
            len = anchor-cursor;
        }

        // Get selected fragment
        string = contents.mid(start, len);

        // If password mode, replace by stars
        if (options&TEXTFIELD_PASSWD)
        {
            string.assign('*', string.count());
        }

        // Return text of the selection as UTF-8
        if (event->target == utf8Type)
        {
            setDNDData(FROM_SELECTION, event->target, string);
            return(1);
        }

        // Return text of the selection translated to 8859-1
        if ((event->target == stringType) || (event->target == textType))
        {
            FX88591Codec ascii;
            setDNDData(FROM_SELECTION, event->target, ascii.utf2mb(string));
            return(1);
        }

        // Return text of the selection translated to UTF-16
        if (event->target == utf16Type)
        {
            FXUTF16LECodec unicode;           // FIXME maybe other endianness for unix
            setDNDData(FROM_SELECTION, event->target, unicode.utf2mb(string));
            return(1);
        }
    }
    return(0);
}


// We now really do have the clipboard, keep clipped text
long TextLabel::onClipboardGained(FXObject* sender, FXSelector sel, void* ptr)
{
    FXFrame::onClipboardGained(sender, sel, ptr);
    return(1);
}


// We lost the clipboard, free clipped text
long TextLabel::onClipboardLost(FXObject* sender, FXSelector sel, void* ptr)
{
    FXFrame::onClipboardLost(sender, sel, ptr);
    clipped.clear();
    return(1);
}


// Somebody wants our clipped text
long TextLabel::onClipboardRequest(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    FXString string;

    // Perhaps the target wants to supply its own data for the clipboard
    if (FXFrame::onClipboardRequest(sender, sel, ptr))
    {
        return(1);
    }

    // Recognize the request?
    if ((event->target == stringType) || (event->target == textType) || (event->target == utf8Type) || (event->target == utf16Type))
    {
        // Get clipped string
        string = clipped;

        // If password mode, replace by stars
        if (options&TEXTFIELD_PASSWD)
        {
            string.assign('*', string.count());
        }

        // Return clipped text as as UTF-8
        if (event->target == utf8Type)
        {
            setDNDData(FROM_CLIPBOARD, event->target, string);
            return(1);
        }

        // Return clipped text translated to 8859-1
        if ((event->target == stringType) || (event->target == textType))
        {
            FX88591Codec ascii;
            setDNDData(FROM_CLIPBOARD, event->target, ascii.utf2mb(string));
            return(1);
        }

        // Return text of the selection translated to UTF-16
        if (event->target == utf16Type)
        {
            FXUTF16LECodec unicode;             // FIXME maybe other endianness for unix
            setDNDData(FROM_CLIPBOARD, event->target, unicode.utf2mb(string));
            return(1);
        }
    }
    return(0);
}


// Gained focus
long TextLabel::onFocusIn(FXObject* sender, FXSelector sel, void* ptr)
{
    FXFrame::onFocusIn(sender, sel, ptr);
    if (hasSelection())
    {
        update(border, border, width-(border<<1), height-(border<<1));
    }
    return(1);
}


// Lost focus
long TextLabel::onFocusOut(FXObject* sender, FXSelector sel, void* ptr)
{
    FXFrame::onFocusOut(sender, sel, ptr);
    if (hasSelection())
    {
        update(border, border, width-(border<<1), height-(border<<1));
    }
    return(1);
}


// Focus on widget itself
long TextLabel::onFocusSelf(FXObject* sender, FXSelector sel, void* ptr)
{
    if (FXFrame::onFocusSelf(sender, sel, ptr))
    {
        FXEvent* event = (FXEvent*)ptr;
        if ((event->type == SEL_KEYPRESS) || (event->type == SEL_KEYRELEASE))
        {
            handle(this, FXSEL(SEL_COMMAND, ID_SELECT_ALL), NULL);
        }
        return(1);
    }
    return(0);
}


// If window can have focus
bool TextLabel::canFocus() const
{
    return(true);
}


// Into focus chain
void TextLabel::setFocus()
{
    FXFrame::setFocus();
    setDefault(true);
    flags &= ~FLAG_UPDATE;
    if (getApp()->hasInputMethod())
    {
        createComposeContext();
    }
}


// Out of focus chain
void TextLabel::killFocus()
{
    FXFrame::killFocus();
    setDefault(MAYBE);
    flags |= FLAG_UPDATE;
    if (flags&FLAG_CHANGED)
    {
        flags &= ~FLAG_CHANGED;
        if (!(options&TEXTFIELD_ENTER_ONLY))
        {
            if (target)
            {
                target->tryHandle(this, FXSEL(SEL_COMMAND, message), (void*)contents.text());
            }
        }
    }
    if (getApp()->hasInputMethod())
    {
        destroyComposeContext();
    }
}


// Pressed left button
long TextLabel::onLeftBtnPress(FXObject*, FXSelector, void* ptr)
{
    FXEvent* ev = (FXEvent*)ptr;

    handle(this, FXSEL(SEL_FOCUS_SELF, 0), ptr);
    if (isEnabled())
    {
        grab();
        if (target && target->tryHandle(this, FXSEL(SEL_LEFTBUTTONPRESS, message), ptr))
        {
            return(1);
        }
        flags &= ~FLAG_UPDATE;
        if (ev->click_count == 1)
        {
            setCursorPos(index(ev->win_x));
            if (ev->state&SHIFTMASK)
            {
                extendSelection(cursor);
            }
            else
            {
                killSelection();
                setAnchorPos(cursor);
            }
            makePositionVisible(cursor);
            flags |= FLAG_PRESSED;
        }
        else
        {
            setAnchorPos(0);
            setCursorPos(contents.length());
            extendSelection(contents.length());
            makePositionVisible(cursor);
        }
        return(1);
    }
    return(0);
}


// Released left button
long TextLabel::onLeftBtnRelease(FXObject*, FXSelector, void* ptr)
{
    if (isEnabled())
    {
        ungrab();
        flags &= ~FLAG_PRESSED;
        if (target && target->tryHandle(this, FXSEL(SEL_LEFTBUTTONRELEASE, message), ptr))
        {
            return(1);
        }
    }
    return(0);
}


// Moved
long TextLabel::onMotion(FXObject*, FXSelector, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    int      t;

    if (flags&FLAG_PRESSED)
    {
        if ((event->win_x < (border+padleft)) || ((width-border-padright) < event->win_x))
        {
            if (!getApp()->hasTimeout(this, ID_AUTOSCROLL))
            {
                getApp()->addTimeout(this, ID_AUTOSCROLL, getApp()->getScrollSpeed(), event);
            }
        }
        else
        {
            getApp()->removeTimeout(this, ID_AUTOSCROLL);
            t = index(event->win_x);
            if (t != cursor)
            {
                cursor = t;
                extendSelection(cursor);
            }
        }
        return(1);
    }
    return(0);
}


// Automatic scroll
long TextLabel::onAutoScroll(FXObject*, FXSelector, void* ptr)
{
    register FXEvent* event = (FXEvent*)ptr;

    if (flags&FLAG_PRESSED)
    {
        register int newcursor = cursor;
        register int ll = border+padleft;
        register int rr = width-border-padright;
        register int ww = rr-ll;
        register int tw;

        if (options&TEXTFIELD_PASSWD)
        {
            tw = font->getTextWidth("*", 1)*contents.count();
        }
        else
        {
            tw = font->getTextWidth(contents.text(), contents.length());
        }

        // Text right-aligned
        if (options&JUSTIFY_RIGHT)
        {
            // Scroll left
            if (event->win_x < ll)
            {
                if (tw > ww)
                {
                    shift += ll-event->win_x;
                    if (ww > tw-shift)
                    {
                        shift = tw-ww;
                    }
                    else
                    {
                        getApp()->addTimeout(this, ID_AUTOSCROLL, getApp()->getScrollSpeed(), event);
                    }
                }
                newcursor = index(ll);
            }

            // Scroll right
            if (rr < event->win_x)
            {
                if (tw > ww)
                {
                    shift += rr-event->win_x;
                    if (shift <= 0)
                    {
                        shift = 0;
                    }
                    else
                    {
                        getApp()->addTimeout(this, ID_AUTOSCROLL, getApp()->getScrollSpeed(), event);
                    }
                }
                newcursor = index(rr);
            }
        }

        // Text left-aligned
        else if (options&JUSTIFY_LEFT)
        {
            // Scroll left
            if (event->win_x < ll)
            {
                if (tw > ww)
                {
                    shift += ll-event->win_x;
                    if (shift >= 0)
                    {
                        shift = 0;
                    }
                    else
                    {
                        getApp()->addTimeout(this, ID_AUTOSCROLL, getApp()->getScrollSpeed(), event);
                    }
                }
                newcursor = index(ll);
            }

            // Scroll right
            if (rr < event->win_x)
            {
                if (tw > ww)
                {
                    shift += rr-event->win_x;
                    if (shift+tw < ww)
                    {
                        shift = ww-tw;
                    }
                    else
                    {
                        getApp()->addTimeout(this, ID_AUTOSCROLL, getApp()->getScrollSpeed(), event);
                    }
                }
                newcursor = index(rr);
            }
        }

        // Text centered
        else
        {
            // Scroll left
            if (event->win_x < ll)
            {
                if (tw > ww)
                {
                    shift += ll-event->win_x;
                    if (shift > tw/2-ww/2)
                    {
                        shift = tw/2-ww/2;
                    }
                    else
                    {
                        getApp()->addTimeout(this, ID_AUTOSCROLL, getApp()->getScrollSpeed(), event);
                    }
                }
                newcursor = index(ll);
            }

            // Scroll right
            if (rr < event->win_x)
            {
                if (tw > ww)
                {
                    shift += rr-event->win_x;
                    if (shift < (ww-ww/2)-tw/2)
                    {
                        shift = (ww-ww/2)-tw/2;
                    }
                    else
                    {
                        getApp()->addTimeout(this, ID_AUTOSCROLL, getApp()->getScrollSpeed(), event);
                    }
                }
                newcursor = index(rr);
            }
        }

        // Extend the selection
        if (newcursor != cursor)
        {
            cursor = newcursor;
            extendSelection(cursor);
        }
    }
    return(1);
}


// Update somebody who works on the selection
long TextLabel::onUpdHaveSelection(FXObject* sender, FXSelector, void* ptr)
{
    sender->handle(this, hasSelection() ? FXSEL(SEL_COMMAND, ID_ENABLE) : FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    return(1);
}


// Update somebody who works on the selection
long TextLabel::onUpdselectAll(FXObject* sender, FXSelector, void* ptr)
{
    sender->handle(this, contents.empty() ? FXSEL(SEL_COMMAND, ID_DISABLE) : FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    return(1);
}


// Move the cursor to new valid position
void TextLabel::setCursorPos(int pos)
{
    pos = contents.validate(FXCLAMP(0, pos, contents.length()));
    if (cursor != pos)
    {
        cursor = pos;
    }
}


// Set anchor position to valid position
void TextLabel::setAnchorPos(int pos)
{
    anchor = contents.validate(FXCLAMP(0, pos, contents.length()));
}


// Fix scroll amount after text changes or widget resize
void TextLabel::layout()
{
    register int rr = width-border-padright;
    register int ll = border+padleft;
    register int ww = rr-ll;
    register int tw;

    if (!xid)
    {
        return;
    }

    // Figure text width
    if (options&TEXTFIELD_PASSWD)
    {
        tw = font->getTextWidth("*", 1)*contents.count();
    }
    else
    {
        tw = font->getTextWidth(contents.text(), contents.length());
    }

    // Constrain shift
    if (options&JUSTIFY_RIGHT)
    {
        if (ww >= tw)
        {
            shift = 0;
        }
        else if (shift < 0)
        {
            shift = 0;
        }
        else if (shift > tw-ww)
        {
            shift = tw-ww;
        }
    }
    else if (options&JUSTIFY_LEFT)
    {
        if (ww >= tw)
        {
            shift = 0;
        }
        else if (shift > 0)
        {
            shift = 0;
        }
        else if (shift < ww-tw)
        {
            shift = ww-tw;
        }
    }
    else
    {
        if (ww >= tw)
        {
            shift = 0;
        }
        else if (shift > tw/2-ww/2)
        {
            shift = tw/2-ww/2;
        }
        else if (shift < (ww-ww/2)-tw/2)
        {
            shift = (ww-ww/2)-tw/2;
        }
    }

    // Keep cursor in the picture if resizing field
    makePositionVisible(cursor);

    // Always redraw
    update();

    flags &= ~FLAG_DIRTY;
}


// Force position to become fully visible; we assume layout is correct
void TextLabel::makePositionVisible(int pos)
{
    register int rr = width-border-padright;
    register int ll = border+padleft;
    register int ww = rr-ll;
    register int oldshift = shift;
    register int xx;

    if (!xid)
    {
        return;
    }
    pos = contents.validate(FXCLAMP(0, pos, contents.length()));
    if (options&JUSTIFY_RIGHT)
    {
        if (options&TEXTFIELD_PASSWD)
        {
            xx = font->getTextWidth("*", 1)*contents.count(pos, contents.length());
        }
        else
        {
            xx = font->getTextWidth(&contents[pos], contents.length()-pos);
        }
        if (shift-xx > 0)
        {
            shift = xx;
        }
        else if (shift-xx < -ww)
        {
            shift = xx-ww;
        }
    }
    else if (options&JUSTIFY_LEFT)
    {
        if (options&TEXTFIELD_PASSWD)
        {
            xx = font->getTextWidth("*", 1)*contents.index(pos);
        }
        else
        {
            xx = font->getTextWidth(contents.text(), pos);
        }
        if (shift+xx < 0)
        {
            shift = -xx;
        }
        else if (shift+xx >= ww)
        {
            shift = ww-xx;
        }
    }
    else
    {
        if (options&TEXTFIELD_PASSWD)
        {
            xx = font->getTextWidth("*", 1)*contents.index(pos)-(font->getTextWidth("*", 1)*contents.count())/2;
        }
        else
        {
            xx = font->getTextWidth(contents.text(), pos)-font->getTextWidth(contents.text(), contents.length())/2;
        }
        if (shift+ww/2+xx < 0)
        {
            shift = -ww/2-xx;
        }
        else if (shift+ww/2+xx >= ww)
        {
            shift = ww-ww/2-xx;
        }
    }
    if (shift != oldshift)
    {
        update(border, border, width-(border<<1), height-(border<<1));
    }
}


// Find index from coord
int TextLabel::index(int x) const
{
    register int rr = width-border-padright;
    register int ll = border+padleft;
    register int mm = (ll+rr)/2;
    register int pos, xx, cw;

    if (options&TEXTFIELD_PASSWD)
    {
        cw = font->getTextWidth("*", 1);
        if (options&JUSTIFY_RIGHT)
        {
            xx = rr-cw*contents.count();
        }
        else if (options&JUSTIFY_LEFT)
        {
            xx = ll;
        }
        else
        {
            xx = mm-(cw*contents.count())/2;
        }
        xx += shift;
        pos = contents.offset((x-xx+(cw>>1))/cw);
    }
    else
    {
        if (options&JUSTIFY_RIGHT)
        {
            xx = rr-font->getTextWidth(contents.text(), contents.length());
        }
        else if
        (options&JUSTIFY_LEFT)
        {
            xx = ll;
        }
        else
        {
            xx = mm-font->getTextWidth(contents.text(), contents.length())/2;
        }
        xx += shift;
        for (pos = 0; pos < contents.length(); pos = contents.inc(pos))
        {
            cw = font->getTextWidth(&contents[pos], contents.extent(pos));
            if (x < (xx+(cw>>1)))
            {
                break;
            }
            xx += cw;
        }
    }
    if (pos < 0)
    {
        pos = 0;
    }
    if (pos > contents.length())
    {
        pos = contents.length();
    }
    return(pos);
}


// Find coordinate from index
int TextLabel::coord(int i) const
{
    register int rr = width-border-padright;
    register int ll = border+padleft;
    register int mm = (ll+rr)/2;
    register int pos;

    FXASSERT(0 <= i && i <= contents.length());
    if (options&JUSTIFY_RIGHT)
    {
        if (options&TEXTFIELD_PASSWD)
        {
            pos = rr-font->getTextWidth("*", 1)*(contents.count()-contents.index(i));
        }
        else
        {
            pos = rr-font->getTextWidth(&contents[i], contents.length()-i);
        }
    }
    else if (options&JUSTIFY_LEFT)
    {
        if (options&TEXTFIELD_PASSWD)
        {
            pos = ll+font->getTextWidth("*", 1)*contents.index(i);
        }
        else
        {
            pos = ll+font->getTextWidth(contents.text(), i);
        }
    }
    else
    {
        if (options&TEXTFIELD_PASSWD)
        {
            pos = mm+font->getTextWidth("*", 1)*contents.index(i)-(font->getTextWidth("*", 1)*contents.count())/2;
        }
        else
        {
            pos = mm+font->getTextWidth(contents.text(), i)-font->getTextWidth(contents.text(), contents.length())/2;
        }
    }
    return(pos+shift);
}


// Return true if position is visible
FXbool TextLabel::isPosVisible(int pos) const
{
    if ((0 <= pos) && (pos <= contents.length()))
    {
        register int x = coord(contents.validate(pos));
        return(border+padleft <= x && x <= width-border-padright);
    }
    return(false);
}


// Return true if position pos is selected
FXbool TextLabel::isPosSelected(int pos) const
{
    return(hasSelection() && FXMIN(anchor, cursor) <= pos && pos <= FXMAX(anchor, cursor));
}


// Draw text fragment
void TextLabel::drawTextFragment(FXDCWindow& dc, int x, int y, int fm, int to)
{
    x += font->getTextWidth(contents.text(), fm);
    y += font->getFontAscent();
    dc.drawText(x, y, &contents[fm], to-fm);
}


// Draw range of text
void TextLabel::drawTextRange(FXDCWindow& dc, int fm, int to)
{
    register int sx, ex, xx, yy, cw, hh, ww, si, ei, lx, rx, t;
    register int rr = width-border-padright;
    register int ll = border+padleft;
    register int mm = (ll+rr)/2;

    if (to <= fm)
    {
        return;
    }

    dc.setFont(font);

    // Text color
    dc.setForeground(textColor);

    // Height
    hh = font->getFontHeight();

    // Text sticks to top of field
    if (options&JUSTIFY_TOP)
    {
        yy = padtop+border;
    }

    // Text sticks to bottom of field
    else if (options&JUSTIFY_BOTTOM)
    {
        yy = height-padbottom-border-hh;
    }

    // Text centered in y
    else
    {
        yy = border+padtop+(height-padbottom-padtop-(border<<1)-hh)/2;
    }

    if (anchor < cursor)
    {
        si = anchor;
        ei = cursor;
    }
    else
    {
        si = cursor;
        ei = anchor;
    }


    // Normal mode
    ww = font->getTextWidth(contents.text(), contents.length());

    // Text sticks to right of field
    if (options&JUSTIFY_RIGHT)
    {
        xx = shift+rr-ww;
    }

    // Text sticks on left of field
    else if (options&JUSTIFY_LEFT)
    {
        xx = shift+ll;
    }

    // Text centered in field
    else
    {
        xx = shift+mm-ww/2;
    }

    // Reduce to avoid drawing excessive amounts of text
    lx = xx+font->getTextWidth(&contents[0], fm);
    rx = lx+font->getTextWidth(&contents[fm], to-fm);
    while (fm < to)
    {
        t = contents.inc(fm);
        cw = font->getTextWidth(&contents[fm], t-fm);
        if (lx+cw >= 0)
        {
            break;
        }
        lx += cw;
        fm = t;
    }
    while (fm < to)
    {
        t = contents.dec(to);
        cw = font->getTextWidth(&contents[t], to-t);
        if (rx-cw < width)
        {
            break;
        }
        rx -= cw;
        to = t;
    }

    // Adjust selected range
    if (si < fm)
    {
        si = fm;
    }
    if (ei > to)
    {
        ei = to;
    }

    // Nothing selected
    if (!hasSelection() || (to <= si) || (ei <= fm))
    {
        drawTextFragment(dc, xx, yy, fm, to);
    }

    // Stuff selected
    else
    {
        if (fm < si)
        {
            drawTextFragment(dc, xx, yy, fm, si);
        }
        else
        {
            si = fm;
        }
        if (ei < to)
        {
            drawTextFragment(dc, xx, yy, ei, to);
        }
        else
        {
            ei = to;
        }
        if (si < ei)
        {
            sx = xx+font->getTextWidth(contents.text(), si);
            ex = xx+font->getTextWidth(contents.text(), ei);
            if (hasFocus())
            {
                dc.setForeground(selbackColor);
                dc.fillRectangle(sx, padtop+border, ex-sx, height-padtop-padbottom-(border<<1));
                dc.setForeground(seltextColor);
                drawTextFragment(dc, xx, yy, si, ei);
            }
            else
            {
                dc.setForeground(baseColor);
                dc.fillRectangle(sx, padtop+border, ex-sx, height-padtop-padbottom-(border<<1));
                dc.setForeground(textColor);
                drawTextFragment(dc, xx, yy, si, ei);
            }
        }
    }
}


// Handle repaint
long TextLabel::onPaint(FXObject*, FXSelector, void* ptr)
{
    FXEvent*   ev = (FXEvent*)ptr;
    FXDCWindow dc(this, ev);

    // Draw frame
    drawFrame(dc, 0, 0, width, height);

    // Gray background if disabled
    if (isEnabled())
    {
        dc.setForeground(backColor);
    }
    else
    {
        dc.setForeground(baseColor);
    }

    // Draw background
    dc.fillRectangle(border, border, width-(border<<1), height-(border<<1));

    // Draw text, clipped against frame interior
    dc.setClipRectangle(border, border, width-(border<<1), height-(border<<1));
    drawTextRange(dc, 0, contents.length());

    return(1);
}


// Move cursor to begin of line
long TextLabel::onCmdCursorHome(FXObject*, FXSelector, void*)
{
    setCursorPos(0);
    makePositionVisible(0);
    return(1);
}


// Move cursor to end of line
long TextLabel::onCmdCursorEnd(FXObject*, FXSelector, void*)
{
    setCursorPos(contents.length());
    makePositionVisible(cursor);
    return(1);
}


// Move cursor right
long TextLabel::onCmdCursorRight(FXObject*, FXSelector, void*)
{
    setCursorPos(contents.inc(cursor));
    makePositionVisible(cursor);
    return(1);
}


// Move cursor left
long TextLabel::onCmdCursorLeft(FXObject*, FXSelector, void*)
{
    setCursorPos(contents.dec(cursor));
    makePositionVisible(cursor);
    return(1);
}


// Check if w is delimiter
static FXbool isdelimiter(const char* delimiters, FXwchar w)
{
    return(w < 256 && strchr(delimiters, w)); // FIXME for w>256
}


// Find end of previous word
int TextLabel::leftWord(int pos) const
{
    register int pp = pos, p;

    // Ensure input is valid
    FXASSERT(0 <= pos && pos <= contents.length());

    // Back up until space or delimiter
    while (0 <= (p = contents.dec(pp)) && !Unicode::isSpace(contents.wc(p)) && !isdelimiter(delimiters, contents.wc(p)))
    {
        pp = p;
    }

    // Back up over run of spaces
    while (0 <= (p = contents.dec(pp)) && Unicode::isSpace(contents.wc(p)))
    {
        pp = p;
    }

    // One more in case we didn't move
    if ((pos == pp) && (0 <= (p = contents.dec(pp))))
    {
        pp = p;
    }

    return(pp);
}


// Find begin of next word
int TextLabel::rightWord(int pos) const
{
    register int pp = pos;

    // Ensure input is valid
    FXASSERT(0 <= pos && pos <= contents.length());

    // Advance until space or delimiter
    while (pp < contents.length() && !Unicode::isSpace(contents.wc(pp)) && !isdelimiter(delimiters, contents.wc(pp)))
    {
        pp = contents.inc(pp);
    }

    // Advance over run of spaces
    while (pp < contents.length() && Unicode::isSpace(contents.wc(pp)))
    {
        pp = contents.inc(pp);
    }

    // One more in case we didn't move
    if ((pos == pp) && (pp < contents.length()))
    {
        pp = contents.inc(pp);
    }

    return(pp);
}


// Find begin of a word
int TextLabel::wordStart(int pos) const
{
    register int p;

    FXASSERT(0 <= pos && pos <= contents.length());
    if ((pos == contents.length()) || Unicode::isSpace(contents.wc(pos)))
    {
        while (0 <= (p = contents.dec(pos)) && Unicode::isSpace(contents.wc(p)))
        {
            pos = p;
        }
    }
    else if (isdelimiter(delimiters, contents.wc(pos)))
    {
        while (0 <= (p = contents.dec(pos)) && isdelimiter(delimiters, contents.wc(p)))
        {
            pos = p;
        }
    }
    else
    {
        while (0 <= (p = contents.dec(pos)) && !isdelimiter(delimiters, contents.wc(p)) && !Unicode::isSpace(contents.wc(p)))
        {
            pos = p;
        }
    }
    return(pos);
}


// Find end of word
int TextLabel::wordEnd(int pos) const
{
    FXASSERT(0 <= pos && pos <= contents.length());
    if ((pos == contents.length()) || Unicode::isSpace(contents.wc(pos)))
    {
        while (pos < contents.length() && Unicode::isSpace(contents.wc(pos)))
        {
            pos = contents.inc(pos);
        }
    }
    else if (isdelimiter(delimiters, contents.wc(pos)))
    {
        while (pos < contents.length() && isdelimiter(delimiters, contents.wc(pos)))
        {
            pos = contents.inc(pos);
        }
    }
    else
    {
        while (pos < contents.length() && !isdelimiter(delimiters, contents.wc(pos)) && !Unicode::isSpace(contents.wc(pos)))
        {
            pos = contents.inc(pos);
        }
    }
    return(pos);
}


// Move cursor word right
long TextLabel::onCmdCursorWordRight(FXObject*, FXSelector, void*)
{
    setCursorPos(rightWord(cursor));
    makePositionVisible(cursor);
    return(1);
}


// Move cursor word left
long TextLabel::onCmdCursorWordLeft(FXObject*, FXSelector, void*)
{
    setCursorPos(leftWord(cursor));
    makePositionVisible(cursor);
    return(1);
}


// Move cursor to word start
long TextLabel::onCmdCursorWordStart(FXObject*, FXSelector, void*)
{
    setCursorPos(wordStart(cursor));
    makePositionVisible(cursor);
    return(1);
}


// Move cursor to word end
long TextLabel::onCmdCursorWordEnd(FXObject*, FXSelector, void*)
{
    setCursorPos(wordEnd(cursor));
    makePositionVisible(cursor);
    return(1);
}


// Mark
long TextLabel::onCmdMark(FXObject*, FXSelector, void*)
{
    setAnchorPos(cursor);
    return(1);
}


// Extend
long TextLabel::onCmdExtend(FXObject*, FXSelector, void*)
{
    extendSelection(cursor);
    return(1);
}


// Select All
long TextLabel::onCmdselectAll(FXObject*, FXSelector, void*)
{
    selectAll();
    makePositionVisible(cursor);
    return(1);
}


// Deselect All
long TextLabel::onCmdDeselectAll(FXObject*, FXSelector, void*)
{
    killSelection();
    return(1);
}


// Copy onto cliboard
long TextLabel::onCmdCopySel(FXObject*, FXSelector, void*)
{
    if (hasSelection())
    {
        FXDragType types[4];
        types[0] = stringType;
        types[1] = textType;
        types[2] = utf8Type;
        types[3] = utf16Type;
        if (acquireClipboard(types, 4))
        {
            if (anchor < cursor)
            {
                clipped = contents.mid(anchor, cursor-anchor);
            }
            else
            {
                clipped = contents.mid(cursor, anchor-cursor);
            }
        }
    }
    return(1);
}


// Pressed a key
long TextLabel::onKeyPress(FXObject*, FXSelector, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    if (isEnabled())
    {
        if (target && target->tryHandle(this, FXSEL(SEL_KEYPRESS, message), ptr))
        {
            return(1);
        }
        flags &= ~FLAG_UPDATE;
        switch (event->code)
        {
        case KEY_Right:
        case KEY_KP_Right:
            if (!(event->state&SHIFTMASK))
            {
                handle(this, FXSEL(SEL_COMMAND, ID_DESELECT_ALL), NULL);
            }
            if (event->state&CONTROLMASK)
            {
                handle(this, FXSEL(SEL_COMMAND, ID_CURSOR_WORD_RIGHT), NULL);
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, ID_CURSOR_RIGHT), NULL);
            }
            if (event->state&SHIFTMASK)
            {
                handle(this, FXSEL(SEL_COMMAND, ID_EXTEND), NULL);
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, ID_MARK), NULL);
            }
            return(1);

        case KEY_Left:
        case KEY_KP_Left:
            if (!(event->state&SHIFTMASK))
            {
                handle(this, FXSEL(SEL_COMMAND, ID_DESELECT_ALL), NULL);
            }
            if (event->state&CONTROLMASK)
            {
                handle(this, FXSEL(SEL_COMMAND, ID_CURSOR_WORD_LEFT), NULL);
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, ID_CURSOR_LEFT), NULL);
            }
            if (event->state&SHIFTMASK)
            {
                handle(this, FXSEL(SEL_COMMAND, ID_EXTEND), NULL);
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, ID_MARK), NULL);
            }
            return(1);

        case KEY_Home:
        case KEY_KP_Home:
            if (!(event->state&SHIFTMASK))
            {
                handle(this, FXSEL(SEL_COMMAND, ID_DESELECT_ALL), NULL);
            }
            handle(this, FXSEL(SEL_COMMAND, ID_CURSOR_HOME), NULL);
            if (event->state&SHIFTMASK)
            {
                handle(this, FXSEL(SEL_COMMAND, ID_EXTEND), NULL);
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, ID_MARK), NULL);
            }
            return(1);

        case KEY_End:
        case KEY_KP_End:
            if (!(event->state&SHIFTMASK))
            {
                handle(this, FXSEL(SEL_COMMAND, ID_DESELECT_ALL), NULL);
            }
            handle(this, FXSEL(SEL_COMMAND, ID_CURSOR_END), NULL);
            if (event->state&SHIFTMASK)
            {
                handle(this, FXSEL(SEL_COMMAND, ID_EXTEND), NULL);
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, ID_MARK), NULL);
            }
            return(1);

        case KEY_Return:
        case KEY_KP_Enter:
            getApp()->beep();
            return(1);

        case KEY_a:
            if (!(event->state&CONTROLMASK))
            {
                goto ins;
            }
            handle(this, FXSEL(SEL_COMMAND, ID_SELECT_ALL), NULL);
            return(1);

        case KEY_c:
            if (!(event->state&CONTROLMASK))
            {
                goto ins;
            }
            break;

        case KEY_F16:                             // Sun Copy key
            handle(this, FXSEL(SEL_COMMAND, ID_COPY_SEL), NULL);
            return(1);

        default:
ins:
            if ((event->state&(CONTROLMASK|ALTMASK)) || ((FXuchar)event->text[0] < 32))
            {
                return(0);
            }
            return(1);
        }
    }
    return(0);
}


// Key Release
long TextLabel::onKeyRelease(FXObject*, FXSelector, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    if (isEnabled())
    {
        if (target && target->tryHandle(this, FXSEL(SEL_KEYRELEASE, message), ptr))
        {
            return(1);
        }
        switch (event->code)
        {
        case KEY_Right:
        case KEY_KP_Right:
        case KEY_Left:
        case KEY_KP_Left:
        case KEY_Home:
        case KEY_KP_Home:
        case KEY_End:
        case KEY_KP_End:
        case KEY_Insert:
        case KEY_KP_Insert:
        case KEY_Delete:
        case KEY_KP_Delete:
        case KEY_BackSpace:
        case KEY_Return:
        case KEY_F20:                             // Sun Cut key
        case KEY_F16:                             // Sun Copy key
        case KEY_F18:                             // Sun Paste key
            return(1);

        case KEY_a:
        case KEY_x:
        case KEY_c:
        case KEY_v:
            if (event->state&CONTROLMASK)
            {
                return(1);
            }
            break;

        default:
            if ((event->state&(CONTROLMASK|ALTMASK)) || ((FXuchar)event->text[0] < 32))
            {
                return(0);
            }
            return(1);
        }
    }
    return(0);
}


// Kill the selection
FXbool TextLabel::killSelection()
{
    if (hasSelection())
    {
        releaseSelection();
        update(border, border, width-(border<<1), height-(border<<1));
        return(true);
    }
    return(false);
}


// Select all text
FXbool TextLabel::selectAll()
{
    setAnchorPos(0);
    setCursorPos(contents.length());
    extendSelection(cursor);
    return(true);
}


// Set selection
FXbool TextLabel::setSelection(int pos, int len)
{
    setAnchorPos(pos);
    setCursorPos(pos+len);
    extendSelection(cursor);
    return(true);
}


// Extend selection
FXbool TextLabel::extendSelection(int pos)
{
    // Don't select text if ncols=0
    if (columns == 0)
    {
        return(true);
    }

    FXDragType types[4];

    // Validate position to start of character
    pos = contents.validate(FXCLAMP(0, pos, contents.length()));

    // Got a selection at all?
    if (anchor != pos)
    {
        types[0] = stringType;
        types[1] = textType;
        types[2] = utf8Type;
        types[3] = utf16Type;
        if (!hasSelection())
        {
            acquireSelection(types, 4);
        }
    }
    else
    {
        if (hasSelection())
        {
            releaseSelection();
        }
    }

    update(border, border, width-(border<<1), height-(border<<1));
    return(true);
}


// Change the text and move cursor to end
void TextLabel::setText(const FXString& text, FXbool notify)
{
    killSelection();
    if (contents != text)
    {
        contents = text;
        anchor = contents.length();
        cursor = contents.length();
        if (xid)
        {
            layout();
        }
        if (notify && target)
        {
            target->tryHandle(this, FXSEL(SEL_COMMAND, message), (void*)contents.text());
        }
    }
}


// Set text color
void TextLabel::setTextColor(FXColor clr)
{
    if (textColor != clr)
    {
        textColor = clr;
        update();
    }
}


// Set select background color
void TextLabel::setSelBackColor(FXColor clr)
{
    if (selbackColor != clr)
    {
        selbackColor = clr;
        update();
    }
}


// Set selected text color
void TextLabel::setSelTextColor(FXColor clr)
{
    if (seltextColor != clr)
    {
        seltextColor = clr;
        update();
    }
}


// Set cursor color
void TextLabel::setCursorColor(FXColor clr)
{
    if (clr != cursorColor)
    {
        cursorColor = clr;
        update();
    }
}


// Change number of columns
void TextLabel::setNumColumns(int ncols)
{
    if (ncols < 0)
    {
        ncols = 0;
    }
    if (columns != ncols)
    {
        shift = 0;
        columns = ncols;
        layout();   // This may not be necessary!
        recalc();
        update();
    }
}


// Set text justify style
void TextLabel::setJustify(FXuint style)
{
    FXuint opts = (options&~JUSTIFY_MASK) | (style&JUSTIFY_MASK);

    if (options != opts)
    {
        shift = 0;
        options = opts;
        recalc();
        update();
    }
}


// Get text justify style
FXuint TextLabel::getJustify() const
{
    return(options&JUSTIFY_MASK);
}


// Clean up
TextLabel::~TextLabel()
{
    getApp()->removeTimeout(this, ID_AUTOSCROLL);
    font = (FXFont*)-1L;
}
// Text widget with a close button
#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>

#include <fx.h>

#include "icons.h"
#include "TextWindow.h"


// Map
FXDEFMAP(TextWindow) TextWindowMap[] = {};


// Object implementation
FXIMPLEMENT(TextWindow, DialogBox, TextWindowMap, ARRAYNUMBER(TextWindowMap))


// Construct Text dialog box
TextWindow::TextWindow(FXWindow* owner, const FXString& name, int nblines, int nbcols) :
    DialogBox(owner, name, DECOR_ALL, 0, 0, 0, 0, 6, 6, 6, 6, 4, 4)
{
    // Bottom part
    FXHorizontalFrame* closebox = new FXHorizontalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|PACK_UNIFORM_WIDTH);
    FXButton*          button = new FXButton(closebox, _("&Close"), NULL, this, DialogBox::ID_ACCEPT, BUTTON_INITIAL|BUTTON_DEFAULT|LAYOUT_RIGHT|FRAME_RAISED|FRAME_THICK, 0, 0, 0, 0, 20, 20, 5, 5);

    // Text part
    FXHorizontalFrame* textbox = new FXHorizontalFrame(this, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_SUNKEN|FRAME_THICK, 0, 0, 0, 0, 0, 0, 0, 0);

    text = new FXText(textbox, NULL, 0, TEXT_READONLY|TEXT_WORDWRAP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    text->setVisibleRows(nblines);
    text->setVisibleColumns(nbcols);

    button->setFocus();
}


// Construct Text dialog box
TextWindow::TextWindow(FXApp* app, const FXString& name, int nblines, int nbcols) :
    DialogBox(app, name, DECOR_ALL, 0, 0, 0, 0, 6, 6, 6, 6, 4, 4)
{
    // Bottom part
    FXHorizontalFrame* closebox = new FXHorizontalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|PACK_UNIFORM_WIDTH);
    FXButton*          button = new FXButton(closebox, _("&Close"), NULL, this, DialogBox::ID_ACCEPT, BUTTON_INITIAL|BUTTON_DEFAULT|LAYOUT_RIGHT|FRAME_RAISED|FRAME_THICK, 0, 0, 0, 0, 20, 20, 5, 5);

    // Text part
    FXHorizontalFrame* textbox = new FXHorizontalFrame(this, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_SUNKEN, 0, 0, 0, 0, 0, 0, 0, 0);

    text = new FXText(textbox, NULL, 0, TEXT_READONLY|TEXT_WORDWRAP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    text->setVisibleRows(nblines);
    text->setVisibleColumns(nbcols);

    button->setFocus();
}


// Change the text in the buffer to new text
void TextWindow::setText(const char* str)
{
    text->setText(str, strlen(str));
    getApp()->repaint();
}


// Append new text at the end of the buffer
void TextWindow::appendText(const char* str)
{
    text->appendText(str, strlen(str));
    getApp()->repaint();
}


// Change the text in the buffer to new text
void TextWindow::setFont(FXFont* font)
{
    text->setFont(font);
    getApp()->repaint();
}


// Scroll to the last line
void TextWindow::scrollToLastLine(void)
{
    text->makePositionVisible(text->getLength());
    getApp()->repaint();
}


// Get text length
int TextWindow::getLength(void)
{
    return(text->getLength());
}


// Clean up
TextWindow::~TextWindow()
{
    text = (FXText*)-1;
}
// This is adapted from 'adie', a text editor found
// in the FOX library and written by Jeroen van der Zijp.

#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>
#include <FX88591Codec.h>
#include <FXUTF16Codec.h>
#include <FXString.h>


#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "startupnotification.h"
#include "FileDialog.h"
#include "FontDialog.h"
#include "MessageBox.h"
#include "InputDialog.h"
#include "WriteWindow.h"
#include "XFileWrite.h"
#include <iostream>

extern FXbool allowPopupScroll;
FXbool        save_win_pos;

int mwidth;

FXIMPLEMENT_ABSTRACT(FXTextCommand, FXCommand, NULL, 0)

// Return size of record plus any data kept here
FXuint FXTextCommand::size() const
{
    return(sizeof(FXTextCommand)+ndel);
}


FXIMPLEMENT_ABSTRACT(FXTextInsert, FXTextCommand, NULL, 0)

// Insert command
FXTextInsert::FXTextInsert(FXText* txt, int p, int ni, const char* ins) : FXTextCommand(txt, p, 0, ni)
{
    FXMALLOC(&buffer, char, ni);
    memcpy(buffer, ins, ni);
}


// Undo an insert removes the inserted text
void FXTextInsert::undo()
{
    text->removeText(pos, nins, true);
    text->setCursorPos(pos);
    text->makePositionVisible(pos);
}


// Redo an insert inserts the same old text again
void FXTextInsert::redo()
{
    text->insertText(pos, buffer, nins, true);
    text->setCursorPos(pos+nins);
    text->makePositionVisible(pos+nins);
}


FXIMPLEMENT_ABSTRACT(FXTextDelete, FXTextCommand, NULL, 0)

// Delete command
FXTextDelete::FXTextDelete(FXText* txt, int p, int nd, const char* del) : FXTextCommand(txt, p, nd, 0)
{
    FXMALLOC(&buffer, char, nd);
    memcpy(buffer, del, nd);
}


// Undo a delete reinserts the old text
void FXTextDelete::undo()
{
    text->insertText(pos, buffer, ndel, true);
    text->setCursorPos(pos+ndel);
    text->makePositionVisible(pos+ndel);
}


// Redo a delete removes it again
void FXTextDelete::redo()
{
    text->removeText(pos, ndel, true);
    text->setCursorPos(pos);
    text->makePositionVisible(pos);
}


FXIMPLEMENT_ABSTRACT(FXTextReplace, FXTextCommand, NULL, 0)

// Replace command
FXTextReplace::FXTextReplace(FXText* txt, int p, int nd, int ni, const char* del, const char* ins) : FXTextCommand(txt, p, nd, ni)
{
    FXMALLOC(&buffer, char, nd+ni);
    memcpy(buffer, del, nd);
    memcpy(buffer+nd, ins, ni);
}


// Undo a replace reinserts the old text
void FXTextReplace::undo()
{
    text->replaceText(pos, nins, buffer, ndel, true);
    text->setCursorPos(pos+ndel);
    text->makePositionVisible(pos+ndel);
}


// Redo a replace reinserts the new text
void FXTextReplace::redo()
{
    text->replaceText(pos, ndel, buffer+ndel, nins, true);
    text->setCursorPos(pos+nins);
    text->makePositionVisible(pos+nins);
}


// Preferences class

// Map
FXDEFMAP(Preferences) PreferencesMap[] =
{
    FXMAPFUNC(SEL_COMMAND, Preferences::ID_ACCEPT, Preferences::onCmdAccept),
    FXMAPFUNC(SEL_COMMAND, Preferences::ID_CANCEL, Preferences::onCmdCancel),
    FXMAPFUNC(SEL_COMMAND, Preferences::ID_TEXT_BACK, Preferences::onCmdTextBackColor),
    FXMAPFUNC(SEL_CHANGED, Preferences::ID_TEXT_BACK, Preferences::onCmdTextBackColor),
    FXMAPFUNC(SEL_UPDATE, Preferences::ID_TEXT_BACK, Preferences::onUpdTextBackColor),
    FXMAPFUNC(SEL_COMMAND, Preferences::ID_TEXT_FORE, Preferences::onCmdTextForeColor),
    FXMAPFUNC(SEL_CHANGED, Preferences::ID_TEXT_FORE, Preferences::onCmdTextForeColor),
    FXMAPFUNC(SEL_UPDATE, Preferences::ID_TEXT_FORE, Preferences::onUpdTextForeColor),
    FXMAPFUNC(SEL_COMMAND, Preferences::ID_TEXT_SELBACK, Preferences::onCmdTextSelBackColor),
    FXMAPFUNC(SEL_CHANGED, Preferences::ID_TEXT_SELBACK, Preferences::onCmdTextSelBackColor),
    FXMAPFUNC(SEL_UPDATE, Preferences::ID_TEXT_SELBACK, Preferences::onUpdTextSelBackColor),
    FXMAPFUNC(SEL_COMMAND, Preferences::ID_TEXT_SELFORE, Preferences::onCmdTextSelForeColor),
    FXMAPFUNC(SEL_CHANGED, Preferences::ID_TEXT_SELFORE, Preferences::onCmdTextSelForeColor),
    FXMAPFUNC(SEL_UPDATE, Preferences::ID_TEXT_SELFORE, Preferences::onUpdTextSelForeColor),
    FXMAPFUNC(SEL_COMMAND, Preferences::ID_TEXT_HILITEBACK, Preferences::onCmdTextHiliteBackColor),
    FXMAPFUNC(SEL_CHANGED, Preferences::ID_TEXT_HILITEBACK, Preferences::onCmdTextHiliteBackColor),
    FXMAPFUNC(SEL_UPDATE, Preferences::ID_TEXT_HILITEBACK, Preferences::onUpdTextHiliteBackColor),
    FXMAPFUNC(SEL_COMMAND, Preferences::ID_TEXT_HILITEFORE, Preferences::onCmdTextHiliteForeColor),
    FXMAPFUNC(SEL_CHANGED, Preferences::ID_TEXT_HILITEFORE, Preferences::onCmdTextHiliteForeColor),
    FXMAPFUNC(SEL_UPDATE, Preferences::ID_TEXT_HILITEFORE, Preferences::onUpdTextHiliteForeColor),
    FXMAPFUNC(SEL_COMMAND, Preferences::ID_TEXT_CURSOR, Preferences::onCmdTextCursorColor),
    FXMAPFUNC(SEL_CHANGED, Preferences::ID_TEXT_CURSOR, Preferences::onCmdTextCursorColor),
    FXMAPFUNC(SEL_UPDATE, Preferences::ID_TEXT_CURSOR, Preferences::onUpdTextCursorColor),
    FXMAPFUNC(SEL_COMMAND, Preferences::ID_TEXT_NUMBACK, Preferences::onCmdTextBarColor),
    FXMAPFUNC(SEL_CHANGED, Preferences::ID_TEXT_NUMBACK, Preferences::onCmdTextBarColor),
    FXMAPFUNC(SEL_UPDATE, Preferences::ID_TEXT_NUMBACK, Preferences::onUpdTextBarColor),
    FXMAPFUNC(SEL_COMMAND, Preferences::ID_TEXT_NUMFORE, Preferences::onCmdTextNumberColor),
    FXMAPFUNC(SEL_CHANGED, Preferences::ID_TEXT_NUMFORE, Preferences::onCmdTextNumberColor),
    FXMAPFUNC(SEL_UPDATE, Preferences::ID_TEXT_NUMFORE, Preferences::onUpdTextNumberColor),
};

// Object implementation
FXIMPLEMENT(Preferences, DialogBox, PreferencesMap, ARRAYNUMBER(PreferencesMap))

// Construct
Preferences::Preferences(WriteWindow* owner) : DialogBox(owner, _("XFileWrite Preferences"), DECOR_TITLE|DECOR_BORDER|DECOR_MAXIMIZE|DECOR_STRETCHABLE|DECOR_CLOSE)
{
    // Get the editor text widget from the owner
    editwin = owner;
    editor = owner->getEditor();

    // Set title
    setTitle(_("XFileWrite Preferences"));

    // Buttons
    FXHorizontalFrame* buttons = new FXHorizontalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X, 0, 0, 0, 0, 10, 10, 5, 5);

    // Contents
    FXHorizontalFrame* contents = new FXHorizontalFrame(this, LAYOUT_SIDE_TOP|FRAME_NONE|LAYOUT_FILL_X|LAYOUT_FILL_Y|PACK_UNIFORM_WIDTH);

    // Accept
    FXButton* ok = new FXButton(buttons, _("&Accept"), NULL, this, Preferences::ID_ACCEPT, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);
    ok->addHotKey(KEY_Return);

    // Cancel
    new FXButton(buttons, _("&Cancel"), NULL, this, Preferences::ID_CANCEL, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);

    // Switcher
    FXTabBook* tabbook = new FXTabBook(contents, NULL, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y|LAYOUT_RIGHT);

    // First tab - Editor
    new FXTabItem(tabbook, _("&Editor"), NULL);
    FXVerticalFrame* editor = new FXVerticalFrame(tabbook, FRAME_RAISED);
    FXGroupBox*      group = new FXGroupBox(editor, _("Text"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X);
    FXMatrix*        matrix = new FXMatrix(group, 2, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    new FXLabel(matrix, _("Wrap margin:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    wrapmargin = new FXTextField(matrix, 10, NULL, 0, TEXTFIELD_INTEGER|JUSTIFY_RIGHT|FRAME_SUNKEN|FRAME_THICK|LAYOUT_CENTER_Y|LAYOUT_FILL_X|LAYOUT_FILL_ROW, 0, 0, 0, 0, 2, 2, 1, 1);
    int wrapcols = getApp()->reg().readIntEntry("OPTIONS", "wrapcols", 80);
    wrapmargin->setText(FXStringVal(wrapcols));

    new FXLabel(matrix, _("Tabulation size:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    tabsize = new FXTextField(matrix, 10, NULL, 0, TEXTFIELD_INTEGER|JUSTIFY_RIGHT|FRAME_SUNKEN|FRAME_THICK|LAYOUT_CENTER_Y|LAYOUT_FILL_X|LAYOUT_FILL_ROW, 0, 0, 0, 0, 2, 2, 1, 1);
    int tabcols = getApp()->reg().readIntEntry("OPTIONS", "tabcols", 8);
    tabsize->setText(FXStringVal(tabcols));

    new FXLabel(matrix, _("Strip carriage returns:")+(FXString)"                ", NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    stripcr = new FXCheckButton(matrix, FXString::null, NULL, 0, LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FILL_ROW, 0, 0, 0, 0, 0, 0, 0, 0);
    int stripreturn = getApp()->reg().readIntEntry("OPTIONS", "stripreturn", false);
    stripcr->setCheck(stripreturn);

    // Second tab - Colors
    new FXTabItem(tabbook, _("&Colors"), NULL);
    FXVerticalFrame* colors = new FXVerticalFrame(tabbook, FRAME_RAISED);
    group = new FXGroupBox(colors, _("Text"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X);
    FXMatrix* matrix1 = new FXMatrix(group, 2, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    group = new FXGroupBox(colors, _("Lines"), GROUPBOX_TITLE_LEFT|FRAME_GROOVE|LAYOUT_FILL_X);
    FXMatrix* matrix2 = new FXMatrix(group, 2, MATRIX_BY_COLUMNS|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y);

    new FXLabel(matrix1, _("Background:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    new FXColorWell(matrix1, FXRGB(0, 0, 0), this, Preferences::ID_TEXT_BACK, FRAME_SUNKEN|FRAME_THICK|LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT|LAYOUT_FILL_ROW, 0, 0, 40, 24);

    new FXLabel(matrix1, _("Text:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    new FXColorWell(matrix1, FXRGB(0, 0, 0), this, Preferences::ID_TEXT_FORE, FRAME_SUNKEN|FRAME_THICK|LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT|LAYOUT_FILL_ROW, 0, 0, 40, 24);

    new FXLabel(matrix1, _("Selected text background:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    new FXColorWell(matrix1, FXRGB(0, 0, 0), this, Preferences::ID_TEXT_SELBACK, FRAME_SUNKEN|FRAME_THICK|LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT|LAYOUT_FILL_ROW, 0, 0, 40, 24);

    new FXLabel(matrix1, _("Selected text:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    new FXColorWell(matrix1, FXRGB(0, 0, 0), this, Preferences::ID_TEXT_SELFORE, FRAME_SUNKEN|FRAME_THICK|LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT|LAYOUT_FILL_ROW, 0, 0, 40, 24);

    new FXLabel(matrix1, _("Highlighted text background:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    new FXColorWell(matrix1, FXRGB(0, 0, 0), this, Preferences::ID_TEXT_HILITEBACK, FRAME_SUNKEN|FRAME_THICK|LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT|LAYOUT_FILL_ROW, 0, 0, 40, 24);

    new FXLabel(matrix1, _("Highlighted text:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    new FXColorWell(matrix1, FXRGB(0, 0, 0), this, Preferences::ID_TEXT_HILITEFORE, FRAME_SUNKEN|FRAME_THICK|LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT|LAYOUT_FILL_ROW, 0, 0, 40, 24);

    new FXLabel(matrix1, _("Cursor:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    new FXColorWell(matrix1, FXRGB(0, 0, 0), this, Preferences::ID_TEXT_CURSOR, FRAME_SUNKEN|FRAME_THICK|LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT|LAYOUT_FILL_ROW, 0, 0, 40, 24);

    new FXLabel(matrix2, _("Line numbers background:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    new FXColorWell(matrix2, FXRGB(0, 0, 0), this, Preferences::ID_TEXT_NUMBACK, FRAME_SUNKEN|FRAME_THICK|LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT|LAYOUT_FILL_ROW, 0, 0, 40, 24);

    new FXLabel(matrix2, _("Line numbers foreground:"), NULL, JUSTIFY_LEFT|LAYOUT_FILL_COLUMN|LAYOUT_FILL_ROW);
    new FXColorWell(matrix2, FXRGB(0, 0, 0), this, Preferences::ID_TEXT_NUMFORE, FRAME_SUNKEN|FRAME_THICK|LAYOUT_LEFT|LAYOUT_CENTER_Y|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT|LAYOUT_FILL_ROW, 0, 0, 40, 24);

    // Class variable initializations
    stripcr_prev = false;
    textcolor_prev = FXRGB(0, 0, 0);
    backcolor_prev = FXRGB(0, 0, 0);
    textcolor_prev = FXRGB(0, 0, 0);
    backcolor_prev = FXRGB(0, 0, 0);
    seltextcolor_prev = FXRGB(0, 0, 0);
    selbackcolor_prev = FXRGB(0, 0, 0);
    hilitetextcolor_prev = FXRGB(0, 0, 0);
    hilitebackcolor_prev = FXRGB(0, 0, 0);
    cursorcolor_prev = FXRGB(0, 0, 0);
    barcolor_prev = FXRGB(0, 0, 0);
    numbercolor_prev = FXRGB(0, 0, 0);
}


long Preferences::onCmdAccept(FXObject* o, FXSelector s, void* p)
{
    // Update preferences to their new values

    editor->setWrapColumns(FXIntVal(wrapmargin->getText()));
    getApp()->reg().writeIntEntry("OPTIONS", "wrapcols", FXIntVal(wrapmargin->getText()));

    editor->setTabColumns(FXIntVal(tabsize->getText()));
    getApp()->reg().writeIntEntry("OPTIONS", "tabcols", FXIntVal(tabsize->getText()));

    editor->setTabColumns(FXIntVal(tabsize->getText()));
    getApp()->reg().writeIntEntry("OPTIONS", "tabcols", FXIntVal(tabsize->getText()));

    editwin->setStripcr(stripcr->getCheck());
    getApp()->reg().writeIntEntry("OPTIONS", "stripreturn", stripcr->getCheck());


    // Finally, update the registry
    getApp()->reg().write();

    DialogBox::onCmdAccept(o, s, p);

    return(1);
}


long Preferences::onCmdCancel(FXObject* o, FXSelector s, void* p)
{
    // Reset preferences to their previous values

    // First tab - Editor
    wrapmargin->setText(wrapmargin_prev);
    tabsize->setText(tabsize_prev);
    stripcr->setCheck(stripcr_prev);

    // Second tab - Colors
    editor->setTextColor(textcolor_prev);
    editor->setBackColor(backcolor_prev);
    editor->setSelTextColor(seltextcolor_prev);
    editor->setSelBackColor(selbackcolor_prev);
    editor->setHiliteTextColor(hilitetextcolor_prev);
    editor->setHiliteBackColor(hilitebackcolor_prev);
    editor->setCursorColor(cursorcolor_prev);
    editor->setBarColor(barcolor_prev);
    editor->setNumberColor(numbercolor_prev);

    DialogBox::onCmdCancel(o, s, p);
    return(1);
}


// Execute dialog box modally
FXuint Preferences::execute(FXuint placement)
{
    // Save current preferences to restore them if cancel is pressed

    // First tab - Editor
    wrapmargin_prev = wrapmargin->getText();
    tabsize_prev = tabsize->getText();
    stripcr_prev = stripcr->getCheck();

    // Second tab - Colors
    textcolor_prev = editor->getTextColor();
    backcolor_prev = editor->getBackColor();
    seltextcolor_prev = editor->getSelTextColor();
    selbackcolor_prev = editor->getSelBackColor();
    hilitetextcolor_prev = editor->getHiliteTextColor();
    hilitebackcolor_prev = editor->getHiliteBackColor();
    cursorcolor_prev = editor->getCursorColor();
    barcolor_prev = editor->getBarColor();
    numbercolor_prev = editor->getNumberColor();

    // Display dialog
    create();
    show(placement);
    getApp()->refresh();
    return(getApp()->runModalFor(this));
}


// Change text color
long Preferences::onCmdTextForeColor(FXObject*, FXSelector, void* ptr)
{
    editor->setTextColor((FXColor)(FXuval)ptr);
    return(1);
}


// Update text color
long Preferences::onUpdTextForeColor(FXObject* sender, FXSelector, void*)
{
    FXColor color = editor->getTextColor();

    sender->handle(this, FXSEL(SEL_COMMAND, ID_SETINTVALUE), (void*)&color);
    return(1);
}


// Change text background color
long Preferences::onCmdTextBackColor(FXObject*, FXSelector, void* ptr)
{
    editor->setBackColor((FXColor)(FXuval)ptr);
    return(1);
}


// Update background color
long Preferences::onUpdTextBackColor(FXObject* sender, FXSelector, void*)
{
    FXColor color = editor->getBackColor();

    sender->handle(this, FXSEL(SEL_COMMAND, ID_SETINTVALUE), (void*)&color);
    return(1);
}


// Change selected text foreground color
long Preferences::onCmdTextSelForeColor(FXObject*, FXSelector, void* ptr)
{
    editor->setSelTextColor((FXColor)(FXuval)ptr);
    return(1);
}


// Update selected text foregoround color
long Preferences::onUpdTextSelForeColor(FXObject* sender, FXSelector, void*)
{
    FXColor color = editor->getSelTextColor();

    sender->handle(this, FXSEL(SEL_COMMAND, ID_SETINTVALUE), (void*)&color);
    return(1);
}


// Change selected text background color
long Preferences::onCmdTextSelBackColor(FXObject*, FXSelector, void* ptr)
{
    editor->setSelBackColor((FXColor)(FXuval)ptr);
    return(1);
}


// Update selected text background color
long Preferences::onUpdTextSelBackColor(FXObject* sender, FXSelector, void*)
{
    FXColor color = editor->getSelBackColor();

    sender->handle(this, FXSEL(SEL_COMMAND, ID_SETINTVALUE), (void*)&color);
    return(1);
}


// Change hilight text color
long Preferences::onCmdTextHiliteForeColor(FXObject*, FXSelector, void* ptr)
{
    editor->setHiliteTextColor((FXColor)(FXuval)ptr);
    return(1);
}


// Update hilight text color
long Preferences::onUpdTextHiliteForeColor(FXObject* sender, FXSelector, void*)
{
    FXColor color = editor->getHiliteTextColor();

    sender->handle(this, FXSEL(SEL_COMMAND, ID_SETINTVALUE), (void*)&color);
    return(1);
}


// Change hilight text background color
long Preferences::onCmdTextHiliteBackColor(FXObject*, FXSelector, void* ptr)
{
    editor->setHiliteBackColor((FXColor)(FXuval)ptr);
    return(1);
}


// Update hilight text background color
long Preferences::onUpdTextHiliteBackColor(FXObject* sender, FXSelector, void*)
{
    FXColor color = editor->getHiliteBackColor();

    sender->handle(this, FXSEL(SEL_COMMAND, ID_SETINTVALUE), (void*)&color);
    return(1);
}


// Change cursor color
long Preferences::onCmdTextCursorColor(FXObject*, FXSelector, void* ptr)
{
    editor->setCursorColor((FXColor)(FXuval)ptr);
    return(1);
}


// Update cursor color
long Preferences::onUpdTextCursorColor(FXObject* sender, FXSelector, void*)
{
    FXColor color = editor->getCursorColor();

    sender->handle(sender, FXSEL(SEL_COMMAND, FXWindow::ID_SETINTVALUE), (void*)&color);
    return(1);
}


// Change line numbers background color
long Preferences::onCmdTextBarColor(FXObject*, FXSelector, void* ptr)
{
    editor->setBarColor((FXColor)(FXuval)ptr);
    return(1);
}


// Update line numbers background color
long Preferences::onUpdTextBarColor(FXObject* sender, FXSelector, void*)
{
    FXColor color = editor->getBarColor();

    sender->handle(this, FXSEL(SEL_COMMAND, ID_SETINTVALUE), (void*)&color);
    return(1);
}


// Change line numbers color
long Preferences::onCmdTextNumberColor(FXObject*, FXSelector, void* ptr)
{
    editor->setNumberColor((FXColor)(FXuval)ptr);
    return(1);
}


// Update line numbers color
long Preferences::onUpdTextNumberColor(FXObject* sender, FXSelector, void*)
{
    FXColor color = editor->getNumberColor();

    sender->handle(this, FXSEL(SEL_COMMAND, ID_SETINTVALUE), (void*)&color);
    return(1);
}


// WriteWindow class


// Map
/* FXDEFMAP(FXText) FXTextMap[] =
{
    FXMAPFUNC(SEL_COMMAND, FXText::ID_CURSOR_ROW, WriteWindow::onCmdRow),
    FXMAPFUNC(SEL_UPDATE, FXText::ID_CURSOR_ROW, WriteWindow::onCmdRow),
    FXMAPFUNC(SEL_VERIFY, FXText::ID_CURSOR_ROW, WriteWindow::onCmdRow),
}; */

FXDEFMAP(WriteWindow) WriteWindowMap[] =
{
    FXMAPFUNC(SEL_UPDATE, 0, WriteWindow::onUpdateTitle),
    FXMAPFUNC(SEL_FOCUSIN, 0, WriteWindow::onFocusIn),
    FXMAPFUNC(SEL_COMMAND, WriteWindow::ID_ABOUT, WriteWindow::onCmdAbout),
    FXMAPFUNC(SEL_SIGNAL, WriteWindow::ID_HARVEST, WriteWindow::onSigHarvest),
    FXMAPFUNC(SEL_COMMAND, WriteWindow::ID_NEW, WriteWindow::onCmdNew),
    FXMAPFUNC(SEL_COMMAND, WriteWindow::ID_OPEN, WriteWindow::onCmdOpen),
    FXMAPFUNC(SEL_COMMAND, WriteWindow::ID_OPEN_RECENT, WriteWindow::onCmdOpenRecent),
    FXMAPFUNC(SEL_COMMAND, WriteWindow::ID_SAVE, WriteWindow::onCmdSave),
    FXMAPFUNC(SEL_COMMAND, WriteWindow::ID_SAVEAS, WriteWindow::onCmdSaveAs),
    FXMAPFUNC(SEL_COMMAND, WriteWindow::ID_FONT, WriteWindow::onCmdFont),
    FXMAPFUNC(SEL_COMMAND, WriteWindow::ID_PRINT, WriteWindow::onCmdPrint),
    FXMAPFUNC(SEL_UPDATE, WriteWindow::ID_TOGGLE_WRAP, WriteWindow::onUpdWrap),
    FXMAPFUNC(SEL_COMMAND, WriteWindow::ID_TOGGLE_WRAP, WriteWindow::onCmdWrap),
    FXMAPFUNC(SEL_COMMAND, WriteWindow::ID_TOGGLE_LINES_NUM, WriteWindow::onCmdLinesNum),
    FXMAPFUNC(SEL_UPDATE, WriteWindow::ID_TOGGLE_LINES_NUM, WriteWindow::onUpdLinesNum),
    FXMAPFUNC(SEL_INSERTED, WriteWindow::ID_TEXT, WriteWindow::onTextInserted),
    FXMAPFUNC(SEL_REPLACED, WriteWindow::ID_TEXT, WriteWindow::onTextReplaced),
    FXMAPFUNC(SEL_DELETED, WriteWindow::ID_TEXT, WriteWindow::onTextDeleted),
    FXMAPFUNC(SEL_RIGHTBUTTONRELEASE, WriteWindow::ID_TEXT, WriteWindow::onTextRightMouse),
    FXMAPFUNC(SEL_DND_MOTION, WriteWindow::ID_TEXT, WriteWindow::onEditDNDMotion),
    FXMAPFUNC(SEL_DND_DROP, WriteWindow::ID_TEXT, WriteWindow::onEditDNDDrop),
    FXMAPFUNC(SEL_UPDATE, WriteWindow::ID_OVERSTRIKE, WriteWindow::onUpdOverstrike),
    FXMAPFUNC(SEL_UPDATE, WriteWindow::ID_NUM_ROWS, WriteWindow::onUpdNumRows),
    FXMAPFUNC(SEL_COMMAND, WriteWindow::ID_PREFERENCES, WriteWindow::onCmdMorePrefs),
    FXMAPFUNC(SEL_COMMAND, WriteWindow::ID_SEARCH, WriteWindow::onCmdSearch),
    FXMAPFUNC(SEL_COMMAND, WriteWindow::ID_REPLACE, WriteWindow::onCmdReplace),
    FXMAPFUNC(SEL_COMMAND, WriteWindow::ID_SEARCH_FORW_SEL, WriteWindow::onCmdSearchSel),
    FXMAPFUNC(SEL_COMMAND, WriteWindow::ID_SEARCH_BACK_SEL, WriteWindow::onCmdSearchSel),
    FXMAPFUNC(SEL_COMMAND, WriteWindow::ID_GOTO_LINE, WriteWindow::onCmdGotoLine),
    FXMAPFUNCS(SEL_UPDATE, WriteWindow::ID_WINDOW_1, WriteWindow::ID_WINDOW_50, WriteWindow::onUpdWindow),
    FXMAPFUNCS(SEL_COMMAND, WriteWindow::ID_WINDOW_1, WriteWindow::ID_WINDOW_50, WriteWindow::onCmdWindow),
    FXMAPFUNC(SEL_UPDATE, WriteWindow::ID_SAVE, WriteWindow::onUpdSave),
    FXMAPFUNC(SEL_UPDATE, WriteWindow::ID_SAVEAS, WriteWindow::onUpdReadOnly),
    FXMAPFUNC(SEL_UPDATE, WriteWindow::ID_REPLACE, WriteWindow::onUpdReadOnly),
    FXMAPFUNC(SEL_COMMAND, FXText::ID_CURSOR_ROW, WriteWindow::onCmdRow),
    FXMAPFUNC(SEL_UPDATE, FXText::ID_CURSOR_ROW, WriteWindow::onCmdRow),
    FXMAPFUNC(SEL_VERIFY, FXText::ID_CURSOR_ROW, WriteWindow::onCmdRow),
    // FXMAPFUNC(SEL_CHANGED, FXText::ID_CURSOR_ROW, WriteWindow::onCmdRow),
    // FXMAPFUNC(SEL_VERIFY, FXText::ID_CURSOR_ROW, WriteWindow::onCmdRow),
    // FXMAPFUNC(SEL_INSERTED, FXText::ID_CURSOR_ROW, WriteWindow::onCmdRow),
    // FXMAPFUNC(SEL_REPLACED, FXText::ID_CURSOR_ROW, WriteWindow::onCmdRow),
    // FXMAPFUNC(SEL_DELETED, FXText::ID_CURSOR_ROW, WriteWindow::onCmdRow), */
};


// Object implementation
FXIMPLEMENT(WriteWindow, FXMainWindow, WriteWindowMap, ARRAYNUMBER(WriteWindowMap))

// Make some windows
WriteWindow::WriteWindow(XFileWrite* a, const FXString& file, const FXbool _readonly) : FXMainWindow(a, "XFileWrite", NULL, NULL, DECOR_ALL), mrufiles(a)
{
    FXHotKey hotkey;
    FXString key;

    // Add to list of windows
    getApp()->windowlist.append(this);

    // Default font
    font = NULL;

    // Application icons
    setIcon(xfwicon);

    // Make menu bar
    menubar = new FXMenuBar(this, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X,0,0,0,0,0,0,0,0,0,0);
    new FXLabel(this, _(""), NULL, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FIX_HEIGHT,0,0,0,1,0,0,0,0);
    // new FXLabel(statusbar, _(""), NULL, LAYOUT_RIGHT|LAYOUT_CENTER_Y|LAYOUT_FIX_WIDTH, 0, 0, 4, 0); // Spacer

    // Sites where to dock
    FXDockSite* topdock = new FXDockSite(this, LAYOUT_SIDE_TOP|LAYOUT_FILL_X);
    new FXDockSite(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X);
    new FXDockSite(this, LAYOUT_SIDE_LEFT|LAYOUT_FILL_Y);
    new FXDockSite(this, LAYOUT_SIDE_RIGHT|LAYOUT_FILL_Y);

    // Toolbar
    dragshell = new FXToolBarShell(this, FRAME_RAISED);
    toolbar = new FXToolBar(topdock, dragshell, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_THICK);
    new FXToolBarGrip(toolbar, toolbar, FXToolBar::ID_TOOLBARGRIP, TOOLBARGRIP_SINGLE);

    // Status bar
    // statusbar = new FXStatusBar(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|STATUSBAR_WITH_DRAGCORNER,0,0,0,0,0,0,2,0,0,0);
    statusbarcont = new FXHorizontalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    //FXPacker* corner = new FXPacker(statusbarcont, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_RIGHT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT|LAYOUT_SIDE_RIGHT|LAYOUT_BOTTOM, 0, 0, 13, 13, 0, 0, 0, 0, 0, 0);
    statusbar = new FXStatusBar(statusbarcont, LAYOUT_SIDE_LEFT|LAYOUT_FILL_X,0,0,0,0,0,0,2,0,0,0);
    // FXDragCorner* realcorner = new FXDragCorner(statusbarcont);
    FXDragCorner* realcorner = new FXDragCorner(statusbar);
    // statusbar = new FXHorizontalFrame(statusbarcont, LAYOUT_SIDE_RIGHT|LAYOUT_FILL_Y|FRAME_SUNKEN, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // File menu
    filemenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&File"), NULL, filemenu);

    // Edit Menu
    editmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&Edit"), NULL, editmenu);

    // Format menu
    prefsmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("F&ormat"), NULL, prefsmenu);

    // View menu
    viewmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&View"), NULL, viewmenu);

    // Search Menu
    //searchmenu = new FXMenuPane(this);
    //new FXMenuTitle(menubar, _("&Search"), NULL, searchmenu);

    // Window menu
    // windowmenu = new FXMenuPane(this);
    // new FXMenuTitle(menubar, _("&Window"), NULL, windowmenu);

    // Help menu
    helpmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&Help"), NULL, helpmenu, LAYOUT_LEFT);
    //wraplbl = new FXLabel(this, "M", NULL, LABEL_NORMAL, 0, 0, 0, 0, 0, 0, 0, 0);
    //FXString fontlbl = getApp()->reg().readStringEntry("OPTIONS", "textfont", "");
    //FXFont* monofont = new FXFont(getApp(), fontlbl);
    //wraplbl->setFont(monofont);
    //printf("%d\n", wraplbl->getDefaultWidth());
    // printf("%s\n", getApp()->reg().readStringEntry("OPTIONS", "textfont", ""));

    // Make editor window
    FXHorizontalFrame* textbox = new FXHorizontalFrame(this, FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0);
    editor = new FXText(textbox, this, ID_TEXT, LAYOUT_FILL_X|LAYOUT_FILL_Y|TEXT_SHOWACTIVE|FRAME_NONE);
    //printf("%s\n", editor->getFont()->getFont().text());
    editor->setHiliteMatchTime(2000);
    //editor->setTextStyle(editor->getTextStyle()|TEXT_FIXEDWRAP);
    editor->setTextStyle(editor->getTextStyle()&~TEXT_NO_TABS);
    editor->setScrollStyle(editor->getScrollStyle()&~SCROLLERS_DONT_TRACK);
    editor->setTextStyle(editor->getTextStyle()&~TEXT_SHOWACTIVE);
    // editor->setMarginLeft(10);
    editor->setMarginLeft(2);
    editor->setMarginTop(0);
    editor->setMarginRight(2);
    editor->setMarginBottom(1);

    // Status bar container
    // FXHorizontalFrame* statusbarcont = new FXHorizontalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X, 0, 0, 0, 0, 0, 0, 0, 0);
    // FXDragCorner* corner = new FXDragCorner(statusbarcont);

    new FXLabel(statusbar, _(""), NULL, LAYOUT_RIGHT|LAYOUT_CENTER_Y|LAYOUT_FIX_WIDTH, 0, 0, 4, 0); // Spacer

    // Read only
    readonly = _readonly;
    if (readonly)
    {
        editor->setTextStyle(editor->getTextStyle()|TEXT_READONLY);
    }

    // Status bar container
    // FXHorizontalFrame* statusbarcont = new FXHorizontalFrame(statusbar, FRAME_SUNKEN|LAYOUT_FILL_X, 0, 0, 0, 0, 0, 0, 0, 0);

    // Show insert mode in status bar
    FXLabel* overstrike = new FXLabel(statusbar, FXString::null, NULL, LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 2, 2, 1, 1);
    overstrike->setTarget(this);
    overstrike->setSelector(ID_OVERSTRIKE);

    new FXLabel(statusbar, _(""), NULL, LAYOUT_RIGHT|LAYOUT_CENTER_Y|LAYOUT_FIX_WIDTH, 0, 0, 2, 0); // Spacer

    // Show size of text in status bar
    FXTextField* numchars = new FXTextField(statusbar, 7, this, ID_NUM_ROWS, FRAME_SUNKEN|TEXTFIELD_READONLY|JUSTIFY_RIGHT|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 2, 2, 1, 1);
    numchars->setBackColor(statusbar->getBackColor());

    // Caption before number
    new FXLabel(statusbar, _("  Lines:"), NULL, LAYOUT_RIGHT|LAYOUT_CENTER_Y);

    // Show column number in status bar
    FXTextField* columnno = new FXTextField(statusbar, 7, editor, FXText::ID_CURSOR_COLUMN, FRAME_SUNKEN|JUSTIFY_RIGHT|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 2, 2, 1, 1);
    columnno->setBackColor(statusbar->getBackColor());

    // Caption before number
    new FXLabel(statusbar, _("  Col:"), NULL, LAYOUT_RIGHT|LAYOUT_CENTER_Y);

    // Show line number in status bar
    FXTextField* rowno = new FXTextField(statusbar, 7, editor, FXText::ID_CURSOR_ROW, FRAME_SUNKEN|JUSTIFY_RIGHT|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 2, 2, 1, 1);
    rowno->setBackColor(statusbar->getBackColor());

    // Caption before number
    new FXLabel(statusbar, _("  Line:"), NULL, LAYOUT_RIGHT|LAYOUT_CENTER_Y);



    // Spacer
    // new FXSeparator(statusbar, SEPARATOR_GROOVE);

    // Toolbar buttons: File manipulation
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new", "Ctrl-N");
    new FXButton(toolbar, TAB+_("New")+PARS(key)+TAB+_("Create new document.")+PARS(key), newfileicon, this, ID_NEW, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "open", "Ctrl-O");
    new FXButton(toolbar, TAB+_("Open")+PARS(key)+TAB+_("Open document file.")+PARS(key), fileopenicon, this, ID_OPEN, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "save", "Ctrl-S");
    new FXButton(toolbar, TAB+_("Save")+PARS(key)+TAB+_("Save document.")+PARS(key), savefileicon, this, ID_SAVE, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "close", "Ctrl-W");
    new FXButton(toolbar, TAB+_("Close")+PARS(key)+TAB+_("Close document file.")+PARS(key), closefileicon, this, ID_CLOSE, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    // Spacer
    new FXSeparator(toolbar, SEPARATOR_GROOVE);

    // Toolbar buttons: Print and Quit
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "print", "Ctrl-P");
    new FXButton(toolbar, TAB+_("Print")+PARS(key)+TAB+_("Print document.")+PARS(key), printicon, this, ID_PRINT, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "quit", "Ctrl-Q");
    new FXButton(toolbar, TAB+_("Quit")+PARS(key)+TAB+_("Quit X File Write.")+PARS(key), quiticon, getApp(), XFileWrite::ID_CLOSEALL, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    // Spacer
    new FXSeparator(toolbar, SEPARATOR_GROOVE);

    // Toolbar buttons: Editing
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "copy", "Ctrl-C");
    new FXButton(toolbar, TAB+_("Copy")+PARS(key)+TAB+_("Copy selection to clipboard.")+PARS(key), copy_clpicon, editor, FXText::ID_COPY_SEL, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "cut", "Ctrl-X");
    cut = new FXButton(toolbar, TAB+_("Cut")+PARS(key)+TAB+_("Cut selection to clipboard.")+PARS(key), cut_clpicon, editor, FXText::ID_CUT_SEL, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "paste", "Ctrl-V");
    paste = new FXButton(toolbar, TAB+_("Paste")+PARS(key)+TAB+_("Paste clipboard.")+PARS(key), paste_clpicon, editor, FXText::ID_PASTE_SEL, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    // Spacer
    new FXSeparator(toolbar, SEPARATOR_GROOVE);

    // Goto line
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "goto_line", "Ctrl-L");
    new FXButton(toolbar, TAB+_("Goto line")+PARS(key)+TAB+_("Goto line number."), gotolineicon, this, WriteWindow::ID_GOTO_LINE, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    // Spacer
    new FXSeparator(toolbar, SEPARATOR_GROOVE);

    // Undo/redo
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "undo", "Ctrl-Z");
    new FXButton(toolbar, TAB+_("Undo")+PARS(key)+TAB+_("Undo last change.")+PARS(key), undoicon, &undolist, FXUndoList::ID_UNDO, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "redo", "Ctrl-Y");
    new FXButton(toolbar, TAB+_("Redo")+PARS(key)+TAB+_("Redo last undo.")+PARS(key), redoicon, &undolist, FXUndoList::ID_REDO, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    // Spacer
    new FXSeparator(toolbar, SEPARATOR_GROOVE);

    // Search
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "search", "Ctrl-F");
    new FXButton(toolbar, TAB+_("Search")+PARS(key)+TAB+_("Search text.")+PARS(key), searchicon, this, WriteWindow::ID_SEARCH, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "search_prev", "Ctrl-Shift-G");
    new FXButton(toolbar, TAB+_("Search selection backward")+PARS(key)+TAB+_("Search backward for selected text.")+PARS(key), searchprevicon, this, WriteWindow::ID_SEARCH_BACK_SEL, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "search_next", "Ctrl-G");
    new FXButton(toolbar, TAB+_("Search selection forward")+PARS(key)+TAB+_("Search forward for selected text.")+PARS(key), searchnexticon, this, WriteWindow::ID_SEARCH_FORW_SEL, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    // Spacer
    new FXSeparator(toolbar, SEPARATOR_GROOVE);

    // Preferences
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "word_wrap", "Ctrl-K");
    new FXToggleButton(toolbar, TAB+_("Word wrap on")+PARS(key)+TAB+_("Set word wrap on.")+PARS(key), TAB+_("Word wrap off")+PARS(key)+TAB+_("Set word wrap off.")+PARS(key), wrapofficon, wraponicon, this, ID_TOGGLE_WRAP, BUTTON_TOOLBAR|LAYOUT_LEFT|ICON_BEFORE_TEXT);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "line_numbers", "Ctrl-T");
    new FXToggleButton(toolbar, TAB+_("Show line numbers")+PARS(key)+TAB+_("Show line numbers.")+PARS(key), TAB+_("Hide line numbers")+PARS(key)+TAB+_("Hide line numbers.")+PARS(key), hidenumbersicon, shownumbersicon, this, ID_TOGGLE_LINES_NUM, BUTTON_TOOLBAR|LAYOUT_LEFT|ICON_BEFORE_TEXT);


    // File Menu entries
    FXMenuCommand* mc = NULL;
    FXString       text;

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new", "Ctrl-N");
    text = _("&New")+TABS(key)+_("Create new document.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, NULL, this, ID_NEW);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "open", "Ctrl-O");
    text = _("&Open...")+TABS(key)+_("Open document file.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, NULL, this, ID_OPEN);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "save", "Ctrl-S");
    text = _("&Save")+TABS(key)+_("Save changes to file.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, NULL, this, ID_SAVE);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuCommand(filemenu, _("Save &As...")+TAB2+_("Save document to another file."), NULL, this, ID_SAVEAS);

    new FXMenuSeparator(filemenu);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "print", "Ctrl-P");
    text = _("&Print...")+TABS(key)+_("Print document.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, NULL, this, ID_PRINT);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    // Recent file menu; this automatically hides if there are no files
    FXMenuSeparator* sep1 = new FXMenuSeparator(filemenu);
    sep1->setTarget(&mrufiles);
    sep1->setSelector(FXRecentFiles::ID_ANYFILES);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_1);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_2);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_3);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_4);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_5);
    new FXMenuCommand(filemenu, _("&Clear Recent Files"), NULL, &mrufiles, FXRecentFiles::ID_CLEAR);
    FXMenuSeparator* sep2 = new FXMenuSeparator(filemenu);
    sep2->setTarget(&mrufiles);
    sep2->setSelector(FXRecentFiles::ID_ANYFILES);

//    key = getApp()->reg().readStringEntry("KEYBINDINGS", "quit", "Ctrl-Q");
//    text = _("&Quit")+TABS(key)+_("Quit X File Write.")+PARS(key);
//    mc = new FXMenuCommand(filemenu, text, quiticon, getApp(), XFileWrite::ID_CLOSEALL);
//    hotkey = _parseAccel(key);
//    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

//    key = getApp()->reg().readStringEntry("KEYBINDINGS", "close", "Ctrl-W");
    text = _("E&xit")+TABS(key)+_("Close document.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, NULL, this, ID_CLOSE);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    // Edit Menu entries
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "undo", "Ctrl-Z");
    text = _("&Undo")+TABS(key)+_("Undo last change.")+PARS(key);
    mc = new FXMenuCommand(editmenu, text, NULL, &undolist, FXUndoList::ID_UNDO);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "redo", "Ctrl-Y");
    text = _("&Redo")+TABS(key)+_("Redo last undo.")+PARS(key);
    mc = new FXMenuCommand(editmenu, text, NULL, &undolist, FXUndoList::ID_REDO);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    //new FXMenuCommand(editmenu, _("Revert to &saved")+TAB2+_("Revert to saved document."), dirbackicon, undolist, FXUndoList::ID_REVERT);
    new FXMenuCommand(editmenu, _("Revert to &saved")+TAB2+_("Revert to saved document."), NULL, &undolist, FXUndoList::ID_REVERT);

    new FXMenuSeparator(editmenu);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "copy", "Ctrl-C");
    text = _("&Copy")+TABS(key)+_("Copy selection to clipboard.")+PARS(key);
    mc = new FXMenuCommand(editmenu, text, NULL, editor, FXText::ID_COPY_SEL);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "cut", "Ctrl-X");
    text = _("Cu&t")+TABS(key)+_("Cut selection to clipboard.")+PARS(key);
    cutmc = new FXMenuCommand(editmenu, text, NULL, editor, FXText::ID_CUT_SEL);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "paste", "Ctrl-V");
    text = _("&Paste")+TABS(key)+_("Paste from clipboard.")+PARS(key);
    pastemc = new FXMenuCommand(editmenu, text, NULL, editor, FXText::ID_PASTE_SEL);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuSeparator(editmenu);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "lower_case", "Ctrl-U");
    text = _("Lo&wer-case")+TABS(key)+_("Change to lower case.")+PARS(key);
    mc = new FXMenuCommand(editmenu, text, NULL, editor, FXText::ID_LOWER_CASE);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "upper_case", "Ctrl-Shift-U");
    text = _("Upp&er-case")+TABS(key)+_("Change to upper case.")+PARS(key);
    mc = new FXMenuCommand(editmenu, text, NULL, editor, FXText::ID_UPPER_CASE);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));


    new FXMenuSeparator(editmenu);

    // Search Menu entries
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "search", "Ctrl-F");
    text = _("&Find...")+TABS(key)+_("Search for a string.")+PARS(key);
    mc = new FXMenuCommand(editmenu, text, NULL, this, WriteWindow::ID_SEARCH);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));


    key = getApp()->reg().readStringEntry("KEYBINDINGS", "search_next", "Ctrl-G");
    text = _("Find &Next")+TABS(key)+_("Search forward for selected text.")+PARS(key);
    mc = new FXMenuCommand(editmenu, text, NULL, this, WriteWindow::ID_SEARCH_FORW_SEL);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));


    key = getApp()->reg().readStringEntry("KEYBINDINGS", "replace", "Ctrl-R");
    text = _("&Replace...")+TABS(key)+_("Search for a string and replace with another.")+PARS(key);
    mc = new FXMenuCommand(editmenu, text, NULL, this, WriteWindow::ID_REPLACE);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "goto_line", "Ctrl-L");
    text = _("&Goto line...")+TABS(key)+_("Goto line number.")+PARS(key);
    mc = new FXMenuCommand(editmenu, text, NULL, this, WriteWindow::ID_GOTO_LINE);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));


    key = getApp()->reg().readStringEntry("KEYBINDINGS", "search_prev", "Ctrl-Shift-G");
    text = _("Search sel. &backward")+TABS(key)+_("Search backward for selected text.")+PARS(key);
    mc = new FXMenuCommand(editmenu, text, NULL, this, WriteWindow::ID_SEARCH_BACK_SEL);
    mc->hide();
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));
    // Preferences menu
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "word_wrap", "Ctrl-K");
    text = _("&Word wrap")+TABS(key)+_("Toggle word wrap mode.")+PARS(key);
    mc = new FXMenuCheck(prefsmenu, text, this, ID_TOGGLE_WRAP);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "line_numbers", "Ctrl-T");
    text = _("&Line numbers")+TABS(key)+_("Toggle line numbers mode.")+PARS(key);
    mc = new FXMenuCheck(prefsmenu, text, this, ID_TOGGLE_LINES_NUM);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuCheck(prefsmenu, _("&Overstrike")+TAB2+_("Toggle overstrike mode."), editor, FXText::ID_TOGGLE_OVERSTRIKE);
    new FXMenuSeparator(prefsmenu);
    new FXMenuCommand(prefsmenu, _("&Font...")+TAB2+_("Change text font."), NULL, this, ID_FONT);
    new FXMenuCommand(prefsmenu, _("&More preferences...")+TAB2+_("Change other options."), NULL, this, ID_PREFERENCES);

    // Right mouse popup
    popupmenu = new FXMenuPane(this);
    new FXMenuCommand(popupmenu, _("&Undo"), undoicon, &undolist, FXUndoList::ID_UNDO);
    new FXMenuCommand(popupmenu, _("&Redo"), redoicon, &undolist, FXUndoList::ID_REDO);
    new FXMenuSeparator(popupmenu);
    new FXMenuCommand(popupmenu, _("&Copy"), copy_clpicon, editor, FXText::ID_COPY_SEL);
    new FXMenuCommand(popupmenu, _("Cu&t"), cut_clpicon, editor, FXText::ID_CUT_SEL);
    new FXMenuCommand(popupmenu, _("&Paste"), paste_clpicon, editor, FXText::ID_PASTE_SEL);
    new FXMenuCommand(popupmenu, _("Select &All"), NULL, editor, FXText::ID_SELECT_ALL);
    new FXMenuSeparator(popupmenu);

    // View Menu entries
    new FXMenuCheck(viewmenu, _("&Toolbar")+TAB2+_("Display toolbar."), toolbar, FXWindow::ID_TOGGLESHOWN);
    new FXMenuCheck(viewmenu, _("&Status line")+TAB2+_("Display status line."), statusbar, FXWindow::ID_TOGGLESHOWN);


    // Window menu
/*    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_1);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_2);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_3);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_4);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_5);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_6);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_7);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_8);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_9);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_10);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_11);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_12);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_13);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_14);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_15);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_16);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_17);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_18);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_19);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_20);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_21);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_22);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_23);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_24);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_25);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_26);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_27);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_28);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_29);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_30);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_31);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_32);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_33);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_34);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_35);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_36);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_37);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_38);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_39);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_40);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_41);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_42);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_43);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_44);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_45);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_46);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_47);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_48);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_49);
    new FXMenuRadio(windowmenu, FXString::null, this, ID_WINDOW_50); */

    // Help Menu entries
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "help", "F1");
    text = _("&About X File Write")+TABS(key)+_("About X File Write.")+PARS(key);
    mc = new FXMenuCommand(helpmenu, text, NULL, this, ID_ABOUT, 0);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    // Dialogs
    printdialog = NULL;
    prefsdialog = NULL;
    searchdialog = NULL;
    replacedialog = NULL;

    // Recent files
    mrufiles.setTarget(this);
    mrufiles.setSelector(ID_OPEN_RECENT);

    // Initialize file name
    filename = file;
    filenameset = false;
    filetime = 0;

    // Initialize other stuff
    stripcr = false;
    linesnum = false;
    undolist.mark();
    undoredoblock = NULL;
    smoothscroll = true;

    // Initialize window position and size
    fromreg = true;
    ww = 0;
    hh = 0;
    xx = 0;
    yy = 0;
}


// Create and show window
void WriteWindow::create()
{
    loadConfig();
    FXMainWindow::create();
    //wraplbl->create();
    //mwidth = wraplbl->getWidth();
    //printf("%d\n", mwidth);
    dragshell->create();
    filemenu->create();
    editmenu->create();
    //searchmenu->create();
    prefsmenu->create();
    viewmenu->create();
    // windowmenu->create();
    helpmenu->create();
    popupmenu->create();
    if (!urilistType)
    {
        urilistType = getApp()->registerDragType(urilistTypeName);
    }
    show(PLACEMENT_DEFAULT);
    editor->setFocus();

#ifdef STARTUP_NOTIFICATION
    startup_completed();
#endif
}


// Detach window
void WriteWindow::detach()
{
    FXMainWindow::detach();
    dragshell->detach();
    urilistType = 0;
}


// Clean up
WriteWindow::~WriteWindow()
{
    getApp()->windowlist.remove(this);
    delete font;
    delete toolbar;
    delete menubar;
    delete dragshell;
    delete filemenu;
    delete editmenu;
    // delete searchmenu;
    delete prefsmenu;
    delete viewmenu;
    // delete windowmenu;
    delete helpmenu;
    delete popupmenu;
    delete editor;
    delete printdialog;
    delete prefsdialog;
    delete searchdialog;
    delete replacedialog;
}


// Is it modified
FXbool WriteWindow::isModified() const
{
    return(!undolist.marked());
}


// Load file
FXbool WriteWindow::loadFile(const FXString& file)
{
    FXFile textfile(file, FXFile::Reading);
    int    size, n, i, j, c;
    char*  text;

    // Opened file?
    if (!textfile.isOpen())
    {
        MessageBox::error(this, BOX_OK, _("Error Loading File"), _("Unable to open file: %s"), file.text());
        return(false);
    }

    // Get file size
    size = textfile.size();

    // Make buffer to load file
    if (!FXMALLOC(&text, char, size))
    {
        MessageBox::error(this, BOX_OK, _("Error Loading File"), _("File is too big: %s (%d bytes)"), file.text(), size);
        return(false);
    }

    // Set wait cursor
    getApp()->beginWaitCursor();

    // Read the file
    n = textfile.readBlock(text, size);
    if (n < 0)
    {
        FXFREE(&text);
        MessageBox::error(this, BOX_OK, _("Error Loading File"), _("Unable to read file: %s"), file.text());
        getApp()->endWaitCursor();
        return(false);
    }

    // Strip carriage returns
    if (stripcr)
    {
        for (i = j = 0; j < n; j++)
        {
            c = text[j];
            if (c != '\r')
            {
                text[i++] = c;
            }
        }
        n = i;
    }

    // Set text
    editor->setText(text, n);
    FXFREE(&text);

    // Lines numbering
    if (linesnum)
    {
        FXuint size = editor->getNumRows();
        FXuint cols = (FXuint)ceil(log10(size));
        editor->setBarColumns(cols);
        editor->setMarginLeft(10);
    }
    else
    {
        editor->setBarColumns(0);
        editor->setMarginLeft(2);
    }

    // Kill wait cursor
    getApp()->endWaitCursor();

    mrufiles.appendFile(file);
    filetime = FXStat::modified(file);
    filenameset = true;
    filename = file;

    // Clear undo records
    undolist.clear();

    // Mark undo state as clean (saved)
    undolist.mark();

    return(true);
}


// Save file
FXbool WriteWindow::saveFile(const FXString& file)
{
    FXFile textfile(file, FXFile::Writing);
    int    size, n;
    char*  text;

    // Opened file?
    if (!textfile.isOpen())
    {
        MessageBox::error(this, BOX_OK, _("Error Saving File"), _("Unable to open file: %s"), file.text());
        return(false);
    }

    // Get size
    size = editor->getLength();

    // Alloc buffer
    if (!FXMALLOC(&text, char, size+1))
    {
        MessageBox::error(this, BOX_OK, _("Error Saving File"), _("File is too big: %s"), file.text());
        return(false);
    }

    // Set wait cursor
    getApp()->beginWaitCursor();

    // Get text from editor
    editor->getText(text, size);

    // Write the file
    n = textfile.writeBlock(text, size);

    // Ditch buffer
    FXFREE(&text);

    // Kill wait cursor
    getApp()->endWaitCursor();

    // Were we able to write it all?
    if (n != size)
    {
        MessageBox::error(this, BOX_OK, _("Error Saving File"), _("File: %s truncated."), file.text());
        return(false);
    }

    mrufiles.appendFile(file);
    filetime = FXStat::modified(file);
    filenameset = true;
    filename = file;
    undolist.mark();
    return(true);
}


// Generate unique name for a new window
FXString WriteWindow::unique() const
{
    FXString name = _("Untitled");

    for (int i = 1; i < 2147483647; i++)
    {
        if (!findWindow(name))
        {
            break;
        }
        name.format(_("Untitled (%d)"), i);
    }
    return(name);
}


// Find an as yet untitled, unedited window
WriteWindow* WriteWindow::findUnused() const
{
    for (int w = 0; w < getApp()->windowlist.no(); w++)
    {
        if (!getApp()->windowlist[w]->isFilenameSet() && !getApp()->windowlist[w]->isModified())
        {
            return(getApp()->windowlist[w]);
        }
    }
    return(NULL);
}


// Find window, if any, currently editing the given file
WriteWindow* WriteWindow::findWindow(const FXString& file) const
{
    for (int w = 0; w < getApp()->windowlist.no(); w++)
    {
        if (getApp()->windowlist[w]->getFilename() == file)
        {
            return(getApp()->windowlist[w]);
        }
    }
    return(NULL);
}


// Visit given line
void WriteWindow::visitLine(int line)
{
    int pos = editor->nextLine(0, line-1);

    editor->setCursorPos(pos);
    editor->setCenterLine(pos);
}


// Read configuration from registry
void WriteWindow::loadConfig()
{
    FXColor  textback, textfore, textselback, textselfore, textcursor, texthilitefore, texthiliteback;
    FXColor  textbar, textnumber;
    int      wrapping, wrapcols, tabcols;
    int      hidestatus, hidetoolbar, hilitematchtime;
    FXString fontspec;

    // Text colors
    textback = getApp()->reg().readColorEntry("OPTIONS", "textbackground", editor->getBackColor());
    textfore = getApp()->reg().readColorEntry("OPTIONS", "textforeground", editor->getTextColor());
    textselback = getApp()->reg().readColorEntry("OPTIONS", "textselbackground", editor->getSelBackColor());
    textselfore = getApp()->reg().readColorEntry("OPTIONS", "textselforeground", editor->getSelTextColor());
    textcursor = getApp()->reg().readColorEntry("OPTIONS", "textcursor", editor->getCursorColor());
    texthiliteback = getApp()->reg().readColorEntry("OPTIONS", "texthilitebackground", editor->getHiliteBackColor());
    texthilitefore = getApp()->reg().readColorEntry("OPTIONS", "texthiliteforeground", editor->getHiliteTextColor());
    textbar = getApp()->reg().readColorEntry("OPTIONS", "textnumberbackground", editor->getBarColor());
    textnumber = getApp()->reg().readColorEntry("OPTIONS", "textnumberforeground", editor->getNumberColor());

    // Font
    fontspec = getApp()->reg().readStringEntry("OPTIONS", "textfont", "");
    if (!fontspec.empty())
    {
        font = new FXFont(getApp(), fontspec);
        font->create();
        editor->setFont(font);
    }

    // Read the Xfe registry
    FXRegistry* reg_xfe = new FXRegistry(XFEAPPNAME, "");
    reg_xfe->read();

    // Get value of the retain window position flag
    save_win_pos = reg_xfe->readUnsignedEntry("SETTINGS", "save_win_pos", false);

    delete reg_xfe;

    // Get size and position from registry
    if (fromreg)
    {
        ww = getApp()->reg().readUnsignedEntry("OPTIONS", "width", DEFAULT_WINDOW_WIDTH);
        hh = getApp()->reg().readUnsignedEntry("OPTIONS", "height", DEFAULT_WINDOW_HEIGHT);
    }

    // Showing the status line?
    hidestatus = getApp()->reg().readIntEntry("OPTIONS", "hidestatus", false);

    // Showing the tool bar?
    hidetoolbar = getApp()->reg().readIntEntry("OPTIONS", "hidetoolbar", false);

    // Highlight match time
    hilitematchtime = getApp()->reg().readIntEntry("OPTIONS", "hilitematchtime", 3000);

    // Word wrapping
    wrapping = getApp()->reg().readIntEntry("OPTIONS", "wordwrap", 0);
    wrapcols = getApp()->reg().readIntEntry("OPTIONS", "wrapcols", 80);

    // Tab settings
    tabcols = getApp()->reg().readIntEntry("OPTIONS", "tabcols", 8);

    // Various flags
    stripcr = getApp()->reg().readIntEntry("OPTIONS", "stripreturn", false);
    linesnum = getApp()->reg().readIntEntry("OPTIONS", "linesnum", false);

    // Change the colors
    editor->setTextColor(textfore);
    editor->setBackColor(textback);
    editor->setSelBackColor(textselback);
    editor->setSelTextColor(textselfore);
    editor->setCursorColor(textcursor);
    editor->setHiliteBackColor(texthiliteback);
    editor->setHiliteTextColor(texthilitefore);
    editor->setBarColor(textbar);
    editor->setNumberColor(textnumber);


    // Hide statusline
    if (hidestatus)
    {
        statusbar->hide();
        //statusbar->hide();
	//statusbarcont->hide();
    }

    // Hide toolbar
    if (hidetoolbar)
    {
        toolbar->hide();
    }

    // Wrap mode
    if (wrapping)
    {
        editor->setTextStyle(editor->getTextStyle()|TEXT_WORDWRAP);
    }
    else
    {
        editor->setTextStyle(editor->getTextStyle()&~TEXT_WORDWRAP);
    }

    // Wrap and tab columns
    editor->setWrapColumns(wrapcols);
    editor->setTabColumns(tabcols);

    // Highlight match time
    editor->setHiliteMatchTime(hilitematchtime);

    // Get position and position window
    if (save_win_pos && fromreg)
    {
        int xpos = getApp()->reg().readIntEntry("OPTIONS", "xpos", DEFAULT_WINDOW_XPOS);
        int ypos = getApp()->reg().readIntEntry("OPTIONS", "ypos", DEFAULT_WINDOW_YPOS);
        position(xpos, ypos, ww, hh);
    }
    else
    {
        position(getX(), getY(), ww, hh);
    }
}


// Save configuration to registry
void WriteWindow::saveConfig()
{
    FXString fontspec;

    // Colors of text
    getApp()->reg().writeColorEntry("OPTIONS", "textbackground", editor->getBackColor());
    getApp()->reg().writeColorEntry("OPTIONS", "textforeground", editor->getTextColor());
    getApp()->reg().writeColorEntry("OPTIONS", "textselbackground", editor->getSelBackColor());
    getApp()->reg().writeColorEntry("OPTIONS", "textselforeground", editor->getSelTextColor());
    getApp()->reg().writeColorEntry("OPTIONS", "textcursor", editor->getCursorColor());
    getApp()->reg().writeColorEntry("OPTIONS", "texthilitebackground", editor->getHiliteBackColor());
    getApp()->reg().writeColorEntry("OPTIONS", "texthiliteforeground", editor->getHiliteTextColor());
    getApp()->reg().writeColorEntry("OPTIONS", "textnumberbackground", editor->getBarColor());
    getApp()->reg().writeColorEntry("OPTIONS", "textnumberforeground", editor->getNumberColor());


    // Write new window size back to registry
    getApp()->reg().writeUnsignedEntry("OPTIONS", "width", getWidth());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "height", getHeight());
    if (save_win_pos)
    {
        // Account for the Window Manager border size
        XWindowAttributes xwattr;
        if (XGetWindowAttributes((Display*)getApp()->getDisplay(), this->id(), &xwattr))
        {
            getApp()->reg().writeIntEntry("OPTIONS", "xpos", getX()-xwattr.x);
            getApp()->reg().writeIntEntry("OPTIONS", "ypos", getY()-xwattr.y);
        }
        else
        {
            getApp()->reg().writeIntEntry("OPTIONS", "xpos", getX());
            getApp()->reg().writeIntEntry("OPTIONS", "ypos", getY());
        }
    }

    // Was status line shown
    getApp()->reg().writeIntEntry("OPTIONS", "hidestatus", !statusbar->shown());

    // Was toolbar shown
    getApp()->reg().writeIntEntry("OPTIONS", "hidetoolbar", !toolbar->shown());

    // Highlight match time
    getApp()->reg().writeIntEntry("OPTIONS", "hilitematchtime", editor->getHiliteMatchTime());

    // Wrap mode
    getApp()->reg().writeIntEntry("OPTIONS", "wordwrap", (editor->getTextStyle()&TEXT_WORDWRAP) != 0);
    getApp()->reg().writeIntEntry("OPTIONS", "wrapcols", editor->getWrapColumns());

    // Tab settings
    getApp()->reg().writeIntEntry("OPTIONS", "tabcols", editor->getTabColumns());

    // Strip returns
    getApp()->reg().writeIntEntry("OPTIONS", "stripreturn", stripcr);
    getApp()->reg().writeIntEntry("OPTIONS", "linesnum", linesnum);

    // Search path
    getApp()->reg().writeStringEntry("OPTIONS", "searchpath", searchpath.text());

    // Font
    fontspec = editor->getFont()->getFont();
    getApp()->reg().writeStringEntry("OPTIONS", "textfont", fontspec.text());

    // Write registry options
    getApp()->reg().write();
}


// Harvest the zombies
long WriteWindow::onSigHarvest(FXObject*, FXSelector, void*)
{
    while (waitpid(-1, NULL, WNOHANG) > 0)
    {
    }
    return(1);
}


// About box
long WriteWindow::onCmdAbout(FXObject*, FXSelector, void*)
{
    FXString msg;

    msg.format(_("X File Write Version %s is a simple text editor.\n\n"), VERSION);
    msg += COPYRIGHT;
    MessageBox about(this, _("About X File Write"), msg.text(), xfwicon, BOX_OK|DECOR_TITLE|DECOR_BORDER,
                     JUSTIFY_CENTER_X|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    about.execute(PLACEMENT_OWNER);
    return(1);
}


// Show preferences dialog
long WriteWindow::onCmdMorePrefs(FXObject*, FXSelector, void*)
{
    if (prefsdialog == NULL)
    {
        prefsdialog = new Preferences(this);
    }
    prefsdialog->execute(PLACEMENT_OWNER);
    return(1);
}


// Change text font
long WriteWindow::onCmdFont(FXObject*, FXSelector, void*)
{
    FontDialog fontdlg(this, _("Change Font"), DECOR_BORDER|DECOR_TITLE);
    FXFontDesc fontdesc;

    editor->getFont()->getFontDesc(fontdesc);
    fontdlg.setFontSelection(fontdesc);
    if (fontdlg.execute())
    {
        FXFont* oldfont = font;
        fontdlg.getFontSelection(fontdesc);
        font = new FXFont(getApp(), fontdesc);
        font->create();
        editor->setFont(font);
        delete oldfont;
    }
    saveConfig();
    return(1);
}


// New
long WriteWindow::onCmdNew(FXObject*, FXSelector, void*)
{
    WriteWindow* window = new WriteWindow(getApp(), unique(), readonly);

    // Smooth scrolling
    window->setSmoothScroll(smoothscroll);

    window->create();
    window->raise();
    window->setFocus();
    return(1);
}


// Open
long WriteWindow::onCmdOpen(FXObject*, FXSelector, void*)
{
    const char* patterns[] =
    {
        _("All Files"), "*",
        _("Text Files"), "*.txt",
        _("C Source Files"), "*.c",
        _("C++ Source Files"), "*.cpp",
        _("C++ Source Files"), "*.cc",
        _("C++ Source Files"), "*.cxx",
        _("C/C++ Header Files"), "*.h",
        _("HTML Files"), "*.html",
        _("HTML Files"), "*.htm",
        _("PHP Files"), "*.php", NULL
    };

    FileDialog opendialog(this, _("Open Document"));

//    std::string patternstr;
    //FXString(patterns);

    opendialog.setSelectMode(SELECTFILE_MULTIPLE);
    opendialog.setPatternList(patterns);
    opendialog.setDirectory(FXPath::directory(filename));
    if (opendialog.execute())
    {
        FXString* files = opendialog.getFilenames();
        FXuint    i = 0;
        while (files[i] != FXString::null)
        {
            WriteWindow* window = findWindow(files[i]);
            if (!window)
            {
                window = findUnused();
                if (!window)
                {
                    // New window
                    window = new WriteWindow(getApp(), unique(), readonly);

                    // Smooth scrolling
                    window->setSmoothScroll(smoothscroll);

                    // Set the size and position of the new window
                    window->fromreg = false;
                    window->ww = getWidth();
                    window->hh = getHeight();
                    window->xx = getX();
                    window->yy = getY();

                    // Create window
                    window->create();
                }
                window->loadFile(files[i]);
            }
            window->raise();
            window->setFocus();
            i++;
        }
        delete[] files;
    }

    return(1);
}


// Open recent file
long WriteWindow::onCmdOpenRecent(FXObject*, FXSelector, void* ptr)
{
    FXString     file = (const char*)ptr;
    WriteWindow* window = findWindow(file);

    if (!window)
    {
        window = findUnused();
        if (!window)
        {
            window = new WriteWindow(getApp(), unique(), readonly);

            // Smooth scrolling
            window->setSmoothScroll(smoothscroll);

            window->create();
        }
        window->loadFile(file);
    }
    window->raise();
    window->setFocus();
    return(1);
}


// See if we can get it as a filename
long WriteWindow::onEditDNDDrop(FXObject*, FXSelector, void*)
{
    FXuchar*  data;
    FXuint len;

    if (getDNDData(FROM_DRAGNDROP, urilistType, data, len))
    {
        FXString urilist((FXchar*)data, len);
        FXString file = FXURL::fileFromURL(urilist.before('\r'));
        FXFREE(&data);
        if (file.empty())
        {
            return(1);
        }
        if (!saveChanges())
        {
            return(1);
        }
        loadFile(file);
        return(1);
    }
    return(0);
}


// See if a filename is being dragged over the window
long WriteWindow::onEditDNDMotion(FXObject*, FXSelector, void*)
{
    if (offeredDNDType(FROM_DRAGNDROP, urilistType))
    {
        acceptDrop(DRAG_COPY);
        return(1);
    }
    return(0);
}


// Save changes, prompt for new filename
FXbool WriteWindow::saveChanges()
{
    FXuint   answer;
    FXString file;

    if (isModified())
    {
        answer = MessageBox::question(this, BOX_YES_NO_CANCEL, _("Unsaved Document"), _("Save %s to file?"), FXPath::name(filename).text());
        if (answer == BOX_CLICKED_CANCEL)
        {
            return(false);
        }
        if (answer == BOX_CLICKED_YES)
        {
            file = filename;
            if (!filenameset)
            {
                FileDialog savedialog(this, _("Save Document"));
                savedialog.setSelectMode(SELECTFILE_ANY);
                savedialog.setFilename(file);
                if (!savedialog.execute())
                {
                    return(false);
                }
                file = savedialog.getFilename();
                if (FXStat::exists(file))
                {
                    if (BOX_CLICKED_NO == MessageBox::question(this, BOX_YES_NO, _("Overwrite Document"), _("Overwrite existing document: %s?"), file.text()))
                    {
                        return(false);
                    }
                }
            }
            saveFile(file);
        }
        if (answer == BOX_CLICKED_NO)
        {
            file = filename;
            return(true);
        }
    }
    return(true);
}


// Save
long WriteWindow::onCmdSave(FXObject* sender, FXSelector sel, void* ptr)
{
    if (!filenameset)
    {
        return(onCmdSaveAs(sender, sel, ptr));
    }
    saveFile(filename);
    return(1);
}


// Save Update
long WriteWindow::onUpdSave(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, isModified() ? FXSEL(SEL_COMMAND, ID_ENABLE) : FXSEL(SEL_COMMAND, ID_DISABLE), NULL);
    return(1);
}


// Disable menus and buttons when read only
long WriteWindow::onUpdReadOnly(FXObject* sender, FXSelector, void*)
{
    sender->handle(this, readonly ? FXSEL(SEL_COMMAND, ID_DISABLE) : FXSEL(SEL_COMMAND, ID_ENABLE), NULL);

    // Disable cut and paste commands
    // (note: it seems that the context menu commands can't be disabled)
    //paste->disable();
    //pastemc->disable();
    //cut->disable();
    //cutmc->disable();

    return(1);
}


// Save As
long WriteWindow::onCmdSaveAs(FXObject*, FXSelector, void*)
{
    FileDialog savedialog(this, _("Save Document"));
    FXString   file = filename;

    savedialog.setSelectMode(SELECTFILE_ANY);
    savedialog.setFilename(file);
    if (savedialog.execute())
    {
        file = savedialog.getFilename();
        if (FXStat::exists(file))
        {
            if (BOX_CLICKED_NO == MessageBox::question(this, BOX_YES_NO, _("Overwrite Document"), _("Overwrite existing document: %s?"), file.text()))
            {
                return(1);
            }
        }
        saveFile(file);
    }

    return(1);
}


// Close window
FXbool WriteWindow::close(FXbool notify)
{
    // Prompt to save changes
    if (!saveChanges())
    {
        return(false);
    }

    // Save settings
    saveConfig();

    // Perform normal close stuff
    return(FXMainWindow::close(notify));
}


// User clicks on one of the window menus
long WriteWindow::onCmdWindow(FXObject*, FXSelector sel, void*)
{
    int which = FXSELID(sel)-ID_WINDOW_1;

    if (which < getApp()->windowlist.no())
    {
        getApp()->windowlist[which]->raise();
        getApp()->windowlist[which]->setFocus();
    }
    return(1);
}


// Update handler for window menus
long WriteWindow::onUpdWindow(FXObject* sender, FXSelector sel, void*)
{
    int which = FXSELID(sel)-ID_WINDOW_1;

    if (which < getApp()->windowlist.no())
    {
        WriteWindow* window = getApp()->windowlist[which];
        FXString     string;
        if (which < 49)
        {
            string.format("&%d %s", which+1, window->getTitle().text());
        }
        else
        {
            string.format("5&0 %s", window->getTitle().text());
        }

        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_SETSTRINGVALUE), (void*)&string);

        if (window == getApp()->getActiveWindow())
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_CHECK), NULL);
        }

        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_UNCHECK), NULL);
        }
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_SHOW), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_HIDE), NULL);
    }
    return(1);
}


// Update title from current filename
long WriteWindow::onUpdateTitle(FXObject* sender, FXSelector sel, void* ptr)
{
    FXMainWindow::onUpdate(sender, sel, ptr);
    FXString title = FXPath::name(getFilename());
    FXString directory = FXPath::directory(getFilename());
    if (!directory.empty())
    {
        title = directory + _("/") + title;
    }
    if (isModified())
    {
        title += _("*");
    }

    if (readonly)
    {
        title += _(" (read only)");
    }

    title += _(" - Notepad");

    setTitle(title);
    return(1);
}


// Print the text
long WriteWindow::onCmdPrint(FXObject*, FXSelector, void*)
{
    // Read the current print command from the registry
    FXString printcommand, command;

    printcommand = getApp()->reg().readStringEntry("OPTIONS", "print_command", "lpr -P printer");

    // Open print dialog filled with the current print command
    int rc = 1;
    if (printdialog == NULL)
    {
        printdialog = new InputDialog(this, printcommand, _("Print command: \n(ex: lpr -P <printer>)"), _("Print"), "", printbigicon);
    }
    printdialog->setText(printcommand);
    printdialog->CursorEnd();
    rc = printdialog->execute(PLACEMENT_CURSOR);
    printcommand = printdialog->getText();

    // If cancel was pressed, exit
    if (!rc)
    {
        return(0);
    }

    // Write the new print command to the registry
    getApp()->reg().writeStringEntry("OPTIONS", "print_command", printcommand.text());

    // Perform the print command
    command = "cat " + filename + " |" + printcommand + " &";
    int ret = system(command.text());
    if (ret < 0)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Can't execute command %s"), command.text());
        return(0);
    }

    return(1);
}


// Toggle wrap mode
long WriteWindow::onCmdWrap(FXObject*, FXSelector, void*)
{
    editor->setTextStyle(editor->getTextStyle()^TEXT_WORDWRAP);
    //editor->setTextStyle(editor->getTextStyle()^HSCROLLER_ALWAYS);
    return(1);
}


// Update toggle wrap mode
long WriteWindow::onUpdWrap(FXObject* sender, FXSelector, void*)
{
    if (editor->getTextStyle()&TEXT_WORDWRAP)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


// Toggle lines numbering
long WriteWindow::onCmdLinesNum(FXObject*, FXSelector, void*)
{
    linesnum = !linesnum;
    if (linesnum)
    {
        FXuint size = editor->getNumRows();
        FXuint cols = (FXuint)ceil(log10(size));
        editor->setBarColumns(cols);
    }
    else
    {
        editor->setBarColumns(0);
    }

    return(1);
}


// Update toggle line numbers
long WriteWindow::onUpdLinesNum(FXObject* sender, FXSelector, void*)
{
    if (linesnum)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


// Update box for overstrike mode display
long WriteWindow::onUpdOverstrike(FXObject* sender, FXSelector, void*)
{
    if (readonly)
    {
        FXString mode(_("READ ONLY"));
        sender->handle(this, FXSEL(SEL_COMMAND, ID_SETSTRINGVALUE), (void*)&mode);
    }
    else
    {
        FXString mode((editor->getTextStyle()&TEXT_OVERSTRIKE) ? _("OVR") : _("INS"));
        sender->handle(this, FXSEL(SEL_COMMAND, ID_SETSTRINGVALUE), (void*)&mode);
    }

    return(1);
}


// Update box for size display
long WriteWindow::onUpdNumRows(FXObject* sender, FXSelector, void*)
{
    FXuint size = editor->getNumRows();

    sender->handle(this, FXSEL(SEL_COMMAND, ID_SETINTVALUE), (void*)&size);
    return(1);
}


// Text inserted; callback has [pos nins]
long WriteWindow::onTextInserted(FXObject*, FXSelector, void* ptr)
{
    const FXTextChange* change = (const FXTextChange*)ptr;

    // Log undo record
    if (!undolist.busy())
    {
        undolist.add(new FXTextInsert(editor, change->pos, change->nins, change->ins));
        if (undolist.size() > MAXUNDOSIZE)
        {
            undolist.trimSize(KEEPUNDOSIZE);
        }
    }


    return(1);
}


// Text deleted; callback has [pos ndel]
long WriteWindow::onTextDeleted(FXObject*, FXSelector, void* ptr)
{
    const FXTextChange* change = (const FXTextChange*)ptr;

    // Log undo record
    if (!undolist.busy())
    {
        undolist.add(new FXTextDelete(editor, change->pos, change->ndel, change->del));
        if (undolist.size() > MAXUNDOSIZE)
        {
            undolist.trimSize(KEEPUNDOSIZE);
        }
    }

    return(1);
}


// Text replaced; callback has [pos ndel nins]
long WriteWindow::onTextReplaced(FXObject*, FXSelector, void* ptr)
{
    const FXTextChange* change = (const FXTextChange*)ptr;

    // Log undo record
    if (!undolist.busy())
    {
        undolist.add(new FXTextReplace(editor, change->pos, change->ndel, change->nins, change->del, change->ins));
        if (undolist.size() > MAXUNDOSIZE)
        {
            undolist.trimSize(KEEPUNDOSIZE);
        }
    }

    return(1);
}


// Released right button
long WriteWindow::onTextRightMouse(FXObject*, FXSelector, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    if (!event->moved)
    {
        allowPopupScroll = true; // Allow keyboard scrolling
        popupmenu->popup(NULL, event->root_x, event->root_y);
        getApp()->runModalWhileShown(popupmenu);
        allowPopupScroll = false;
    }
    return(1);
}


// Check file when focus moves in
long WriteWindow::onFocusIn(FXObject* sender, FXSelector sel, void* ptr)
{
    register FXTime t;

    FXMainWindow::onFocusIn(sender, sel, ptr);
    if (filetime != 0)
    {
        t = FXStat::modified(filename);
        if (t && (t != filetime))
        {
            filetime = t;
            if (BOX_CLICKED_OK == MessageBox::warning(this, BOX_OK_CANCEL, _("File Was Changed"), _("%s\nwas changed by another program. Reload this file from disk?"), filename.text()))
            {
                int top = editor->getTopLine();
                int pos = editor->getCursorPos();
                loadFile(filename);
                editor->setTopLine(top);
                editor->setCursorPos(pos);
            }
        }
    }
    return(1);
}


// Search text
long WriteWindow::onCmdSearch(FXObject*, FXSelector, void*)
{
    if (searchdialog == NULL)
    {
        searchdialog = new FXSearchDialog(this, _("Search"), searchicon, options|DECOR_CLOSE);
    }
    searchdialog->setSearchMode(SEARCH_IGNORECASE);

    int      beg[10];
    int      end[10];
    int      pos;
    FXuint   code;
    FXString searchstring;
    FXuint   searchflags;
    do
    {
        code = searchdialog->execute();
        if (code == FXSearchDialog::DONE)
        {
            return(1);
        }
        searchstring = searchdialog->getSearchText();
        searchflags = searchdialog->getSearchMode();
        pos = editor->isPosSelected(editor->getCursorPos()) ? (searchflags&SEARCH_BACKWARD) ? editor->getSelStartPos()-1 : editor->getSelEndPos() : editor->getCursorPos();
        if (editor->findText(searchstring, beg, end, pos, searchflags|SEARCH_WRAP, 10))
        {
            editor->setAnchorPos(beg[0]);
            editor->extendSelection(end[0], SELECT_CHARS, true);
            editor->setCursorPos(end[0], true);
            editor->makePositionVisible(beg[0]);
            editor->makePositionVisible(end[0]);
        }
        else
        {
            getApp()->beep();
        }
    } while (code == FXSearchDialog::SEARCH_NEXT);
    return(1);
}


// Replace text; we assume that findText has called squeezegap()!
long WriteWindow::onCmdReplace(FXObject*, FXSelector, void*)
{
    if (replacedialog == NULL)
    {
        replacedialog = new FXReplaceDialog(this, _("Replace"), replaceicon, options|DECOR_CLOSE);
    }
    replacedialog->setSearchMode(SEARCH_IGNORECASE);

    int      beg[10], end[10], fm, to, len, pos;
    FXuint   searchflags, code;
    FXString searchstring;
    FXString replacestring;
    FXString replacevalue;

    // Get text into buffer
    char* buffer;
    int   length = editor->getLength();
    FXMALLOC(&buffer, char, length);
    editor->getText(buffer, length);

    do
    {
        code = replacedialog->execute();
        if (code == FXReplaceDialog::DONE)
        {
            goto ret;
        }
        searchflags = replacedialog->getSearchMode();
        searchstring = replacedialog->getSearchText();
        replacestring = replacedialog->getReplaceText();
        replacevalue = FXString::null;
        fm = -1;
        to = -1;
        if (code == FXReplaceDialog::REPLACE_ALL)
        {
            searchflags &= ~SEARCH_BACKWARD;
            pos = 0;
            while (editor->findText(searchstring, beg, end, pos, searchflags, 10))
            {
                if (0 <= fm)
                {
                    replacevalue.append(&buffer[pos], beg[0]-pos);
                }
                replacevalue.append(FXRex::substitute(buffer, length, beg, end, replacestring, 10));
                if (fm < 0)
                {
                    fm = beg[0];
                }
                to = end[0];
                pos = end[0];
                if (beg[0] == end[0])
                {
                    pos++;
                }
            }
        }
        else
        {
            pos = editor->isPosSelected(editor->getCursorPos()) ? (searchflags&SEARCH_BACKWARD) ? editor->getSelStartPos()-1 : editor->getSelEndPos() : editor->getCursorPos();
            if (editor->findText(searchstring, beg, end, pos, searchflags|SEARCH_WRAP, 10))
            {
                replacevalue = FXRex::substitute(buffer, length, beg, end, replacestring, 10);
                fm = beg[0];
                to = end[0];
            }
        }
        if (0 <= fm)
        {
            len = replacevalue.length();
            editor->replaceText(fm, to-fm, replacevalue.text(), len, true);
            editor->setCursorPos(fm+len, true);
            editor->makePositionVisible(editor->getCursorPos());
            editor->setModified(true);
        }
        else
        {
            getApp()->beep();
        }
    } while (code == FXReplaceDialog::REPLACE_NEXT);

ret:
    FXFREE(&buffer);
    return(1);
}


// Search for selected text
long WriteWindow::onCmdSearchSel(FXObject*, FXSelector sel, void*)
{
    FXString string;
    FXuint   searchflags;
    FXString searchstring;
    int      pos = editor->getCursorPos();
    int      beg, end;

    // First, try UTF-8
    if (getDNDData(FROM_SELECTION, utf8Type, string))
    {
        searchstring = string;
    }

    // Next, try UTF-16
    else if (getDNDData(FROM_SELECTION, utf16Type, string))
    {
        FXUTF16LECodec unicode;                 // FIXME maybe other endianness for unix
        searchstring = unicode.mb2utf(string);
    }

    // Finally, try good old 8859-1
    else if (getDNDData(FROM_SELECTION, stringType, string))
    {
        FX88591Codec ascii;
        searchstring = ascii.mb2utf(string);
    }

    // No dice!
    else
    {
        goto x;
    }

    // Search direction
    if (FXSELID(sel) == ID_SEARCH_FORW_SEL)
    {
        if (editor->isPosSelected(pos))
        {
            pos = editor->getSelEndPos();
        }
        searchflags = SEARCH_EXACT|SEARCH_FORWARD;
    }
    else
    {
        if (editor->isPosSelected(pos))
        {
            pos = editor->getSelStartPos()-1;
        }
        searchflags = SEARCH_EXACT|SEARCH_BACKWARD;
    }

    // Perform search
    if (editor->findText(searchstring, &beg, &end, pos, searchflags|SEARCH_WRAP))
    {
        if ((beg != editor->getSelStartPos()) || (end != editor->getSelEndPos()))
        {
            editor->setAnchorPos(beg);
            editor->extendSelection(end, SELECT_CHARS, true);
            editor->setCursorPos(end);
            editor->makePositionVisible(beg);
            editor->makePositionVisible(end);
            return(1);
        }
    }

    // Beep
x:
    getApp()->beep();
    return(1);
}


// Go to line number
long WriteWindow::onCmdGotoLine(FXObject*, FXSelector, void*)
{
    int row = editor->getCursorRow()+1;

    if (FXInputDialog::getInteger(row, this, _("Goto Line"), _("&Goto line number:"), gotobigicon, 1, 2147483647))
    {
        update();
        editor->setCursorRow(row-1, true);
        editor->makePositionVisible(editor->getCursorPos());
    }
    return(1);
}

long WriteWindow::onCmdRow(FXObject*, FXSelector, void*)
{
    printf("test\n");
    return(1);
}


#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <iostream>

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "startupnotification.h"
#include "File.h"
#include "FileList.h"
#include "FileDict.h"
#include "Preferences.h"
#include "FilePanel.h"
#include "InputDialog.h"
#include "HistInputDialog.h"
#include "DirPanel.h"
#include "MessageBox.h"
#include "TextWindow.h"
#include "CommandWindow.h"
#include "Bookmarks.h"
#include "FileDialog.h"
#include "help.h"
#include "DirHistBox.h"
#include "SearchWindow.h"
#include "XFileExplorer.h"

// Size of the location bar
#define LOCATION_BAR_LENGTH    70
#define LOCATION_BAR_HEIGHT    6


// Global variables
FXString clipboard = "";
char     OpenHistory[OPEN_HIST_SIZE][MAX_COMMAND_SIZE];
int      OpenNum;
char     FilterHistory[FILTER_HIST_SIZE][MAX_PATTERN_SIZE];
int      FilterNum;


FXbool allowPopupScroll = false;
FXuint single_click;
FXbool file_tooltips;
FXbool relative_resize;
extern FXMainWindow* mainWindow;


int g_grip_r;
int xp;

int btn_rpad;
int btn_lpad;

// External global variables
extern char**   args;
extern int      panel_mode;
extern FXString homedir;
extern FXString xdgdatahome;
extern FXString xdgconfighome;

// Global options
#if defined(linux)
extern FXStringDict* fsdevices;
extern FXStringDict* updevices;
#endif


// Helper function to draw a toolbar separator
static void toolbarSeparator(FXToolBar* tb)
{
#define SEP_SPACE    1
    new FXFrame(tb, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH, 0, 0, SEP_SPACE,0,0,0,0,0);
    new FXVerticalSeparator(tb, LAYOUT_SIDE_TOP|LAYOUT_CENTER_Y|SEPARATOR_GROOVE|LAYOUT_FILL_Y, 0, 0, 0, 0, 1, 2, 2, 2);
    new FXFrame(tb, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH, 0, 0, SEP_SPACE,0,0,0,0,0);
}


// Map
FXDEFMAP(XFileExplorer) XFileExplorerMap[] =
{
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_TOGGLE_STATUS, XFileExplorer::onCmdToggleStatus),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_RUN, XFileExplorer::onCmdRun),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_SU, XFileExplorer::onCmdSu),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_FILE_COPY, XFileExplorer::onCmdFileCopyClp),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_FILE_CUT, XFileExplorer::onCmdFileCutClp),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_FILE_ADDCOPY, XFileExplorer::onCmdFileAddCopyClp),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_FILE_ADDCUT, XFileExplorer::onCmdFileAddCutClp),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_FILE_PASTE, XFileExplorer::onCmdFilePasteClp),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_FILE_RENAME, XFileExplorer::onCmdFileRename),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_FILE_COPYTO, XFileExplorer::onCmdFileCopyto),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_FILE_MOVETO, XFileExplorer::onCmdFileMoveto),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_FILE_SYMLINK, XFileExplorer::onCmdFileSymlink),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_FILE_PROPERTIES, XFileExplorer::onCmdFileProperties),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_FILE_DELETE, XFileExplorer::onCmdFileDelete),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_FILE_TRASH, XFileExplorer::onCmdFileTrash),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_FILE_RESTORE, XFileExplorer::onCmdFileRestore),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_QUIT, XFileExplorer::onQuit),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_HELP, XFileExplorer::onCmdHelp),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_ABOUT, XFileExplorer::onCmdAbout),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_FILE_ASSOC, XFileExplorer::onCmdFileAssoc),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_REFRESH, XFileExplorer::onCmdRefresh),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_EMPTY_TRASH, XFileExplorer::onCmdEmptyTrash),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_TRASH_SIZE, XFileExplorer::onCmdTrashSize),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_XTERM, XFileExplorer::onCmdXTerm),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_CLEAR_LOCATION, XFileExplorer::onCmdClearLocation),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_GOTO_LOCATION, XFileExplorer::onCmdGotoLocation),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_PREFS, XFileExplorer::onCmdPrefs),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_HORZ_PANELS, XFileExplorer::onCmdHorzVertPanels),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_VERT_PANELS, XFileExplorer::onCmdHorzVertPanels),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_SHOW_ONE_PANEL, XFileExplorer::onCmdShowPanels),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_SHOW_TWO_PANELS, XFileExplorer::onCmdShowPanels),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_SHOW_TREE_PANEL, XFileExplorer::onCmdShowPanels),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_SHOW_TREE_TWO_PANELS, XFileExplorer::onCmdShowPanels),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_SWITCH_TREE, XFileExplorer::onCmdSwitchTree),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_SYNCHRONIZE_PANELS, XFileExplorer::onCmdSynchronizePanels),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_SWITCH_PANELS, XFileExplorer::onCmdSwitchPanels),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_RESTART, XFileExplorer::onCmdRestart),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_NEW_WIN, XFileExplorer::onCmdNewWindow),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_BOOKMARK, XFileExplorer::onCmdBookmark),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_DIR_UP, XFileExplorer::onCmdDirUp),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_ADD_BOOKMARK, XFileExplorer::onCmdBookmark),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_DIR_BACK, XFileExplorer::onCmdDirBack),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_DIR_FORWARD, XFileExplorer::onCmdDirForward),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_DIR_BACK_HIST, XFileExplorer::onCmdDirBackHist),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_DIR_FORWARD_HIST, XFileExplorer::onCmdDirForwardHist),
    FXMAPFUNC(SEL_KEYPRESS, 0, XFileExplorer::onKeyPress),
    FXMAPFUNC(SEL_KEYRELEASE, 0, XFileExplorer::onKeyRelease),
    FXMAPFUNC(SEL_SIGNAL, XFileExplorer::ID_HARVEST, XFileExplorer::onSigHarvest),
    FXMAPFUNC(SEL_SIGNAL, XFileExplorer::ID_QUIT, XFileExplorer::onQuit),
    FXMAPFUNC(SEL_CLOSE, 0, XFileExplorer::onQuit),
    FXMAPFUNC(SEL_COMMAND, XFileExplorer::ID_FILE_SEARCH, XFileExplorer::onCmdFileSearch),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_DIR_FORWARD_HIST, XFileExplorer::onUpdDirForwardHist),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_DIR_BACK_HIST, XFileExplorer::onUpdDirBackHist),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_DIR_BACK, XFileExplorer::onUpdDirBack),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_DIR_FORWARD, XFileExplorer::onUpdDirForward),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_TOGGLE_STATUS, XFileExplorer::onUpdToggleStatus),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_HORZ_PANELS, XFileExplorer::onUpdHorzVertPanels),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_VERT_PANELS, XFileExplorer::onUpdHorzVertPanels),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_SHOW_ONE_PANEL, XFileExplorer::onUpdShowPanels),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_SHOW_TWO_PANELS, XFileExplorer::onUpdShowPanels),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_SHOW_TREE_PANEL, XFileExplorer::onUpdShowPanels),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_SHOW_TREE_TWO_PANELS, XFileExplorer::onUpdShowPanels),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_GOTO_LOCATION, XFileExplorer::onUpdFileLocation),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_EMPTY_TRASH, XFileExplorer::onUpdEmptyTrash),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_EMPTY_TRASH, XFileExplorer::onUpdTrashSize),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_FILE_DELETE, XFileExplorer::onUpdFileDelete),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_FILE_TRASH, XFileExplorer::onUpdFileTrash),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_FILE_RESTORE, XFileExplorer::onUpdFileRestore),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_FILE_RENAME, XFileExplorer::onUpdFileRename),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_FILE_PROPERTIES, XFileExplorer::onUpdFileMan),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_FILE_COPYTO, XFileExplorer::onUpdFileMan),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_FILE_MOVETO, XFileExplorer::onUpdFileMan),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_FILE_SYMLINK, XFileExplorer::onUpdFileMan),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_FILE_COPY, XFileExplorer::onUpdFileMan),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_FILE_CUT, XFileExplorer::onUpdFileMan),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_FILE_PASTE, XFileExplorer::onUpdFilePaste),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_SYNCHRONIZE_PANELS, XFileExplorer::onUpdSynchronizePanels),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_SWITCH_PANELS, XFileExplorer::onUpdSwitchPanels),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_SU, XFileExplorer::onUpdSu),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_QUIT, XFileExplorer::onUpdQuit),
    FXMAPFUNC(SEL_UPDATE, XFileExplorer::ID_FILE_SEARCH, XFileExplorer::onUpdFileSearch),
    FXMAPFUNC(SEL_TIMEOUT, XFileExplorer::ID_ANIMTHROB, XFileExplorer::onCmdAnimateThrobber),
    FXMAPFUNC(SEL_TIMEOUT, XFileExplorer::ID_ACTTHROB, XFileExplorer::onCmdActivateThrobber),
    FXMAPFUNC(SEL_TIMEOUT, XFileExplorer::ID_STOPANIMTHROB, XFileExplorer::onCmdStopAnimateThrobber),
};


// Object implementation
FXIMPLEMENT(XFileExplorer, FXMainWindow, XFileExplorerMap, ARRAYNUMBER(XFileExplorerMap))

int throbymax;


// Make some windows
XFileExplorer::XFileExplorer(FXApp* app, vector_FXString URIs, const FXbool iconic, const FXbool maximized, const char* title, FXIcon* bigicon, FXIcon* miniicon) :
    FXMainWindow(app, title, bigicon, miniicon, DECOR_ALL)
{
    bookmarks = new Bookmarks("bookmarks", this, ID_BOOKMARK);
    throbymax = -throbanimicon->getHeight()+22;

    // Menu bar
    // menubar = new FXMenuBar(this, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_RAISED|FRAME_SUNKEN);

    // Site where to dock (for toolbars)

    FXPacker* dockcont = new FXPacker(this, LAYOUT_FILL_X, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0);

    FXPacker* dockcont2 = new FXPacker(dockcont, LAYOUT_FILL_X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    FXHorizontalFrame* rebarbordertop = new FXHorizontalFrame(dockcont, LAYOUT_SIDE_TOP|LAYOUT_TOP|LAYOUT_FILL_X|LAYOUT_FIX_HEIGHT|LAYOUT_FIX_Y, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0);
    rebarbordertop->setBackColor(getApp()->getShadowColor());


    FXPacker* rebarborderbottom2 = new FXPacker(dockcont, LAYOUT_SIDE_BOTTOM|LAYOUT_BOTTOM|LAYOUT_FILL_X|LAYOUT_FIX_HEIGHT, 0, 0, 0, 1, 0, 0, 0, 0);
    rebarborderbottom2->setBackColor(getApp()->getHiliteColor());

    FXHorizontalFrame* rebarborderbottom = new FXHorizontalFrame(dockcont, LAYOUT_SIDE_BOTTOM|LAYOUT_BOTTOM|LAYOUT_FILL_X|LAYOUT_FIX_HEIGHT, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0);
    rebarborderbottom->setBackColor(getApp()->getShadowColor());

    FXFrame* rebarborderbottomright = new FXFrame(rebarborderbottom, LAYOUT_SIDE_RIGHT|LAYOUT_RIGHT|LAYOUT_FIX_HEIGHT|LAYOUT_FIX_WIDTH, 0, 0, 1, 1, 0, 0, 0, 0);
    rebarborderbottomright->setBackColor(getApp()->getHiliteColor());



    FXFrame* rebarbordertop1 = new FXFrame(rebarbordertop, LAYOUT_SIDE_RIGHT|LAYOUT_RIGHT|LAYOUT_FIX_HEIGHT|LAYOUT_FIX_WIDTH, 0, 0, 1, 1, 0, 0, 0, 0);
    rebarbordertop1->setBackColor(getApp()->getHiliteColor());

    FXFrame* rebarborderleft = new FXFrame(dockcont2, LAYOUT_SIDE_LEFT|LAYOUT_LEFT|LAYOUT_FILL_Y|LAYOUT_FIX_WIDTH, 0, 0, 1, 0, 0, 0, 0, 0);
    rebarborderleft->setBackColor(getApp()->getShadowColor());

    FXHorizontalFrame* rebarborderright = new FXHorizontalFrame(dockcont2, LAYOUT_SIDE_RIGHT|LAYOUT_RIGHT|LAYOUT_FILL_Y|LAYOUT_FIX_WIDTH, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0);
    FXDockSite* topdock = new FXDockSite(dockcont2, LAYOUT_SIDE_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|FRAME_SUNKEN,0,0,0,0,-1,-2,0,-2,0);

    FXFrame* rebarborderright1 = new FXFrame(rebarborderright, LAYOUT_SIDE_RIGHT|LAYOUT_RIGHT|LAYOUT_FILL_Y|LAYOUT_FIX_WIDTH, 0, 0, 1, 0, 0, 0, 0, 0);
    rebarborderright1->setBackColor(getApp()->getHiliteColor());

    FXFrame* rebarborderright2 = new FXFrame(rebarborderright, LAYOUT_SIDE_RIGHT|LAYOUT_RIGHT|LAYOUT_FILL_Y|LAYOUT_FIX_WIDTH, 0, 0, 1, 0, 0, 0, 0, 0);
    rebarborderright2->setBackColor(getApp()->getShadowColor());



    // New menu bar
    FXToolBarShell* dragshell0 = new FXToolBarShell(this, FRAME_RAISED,0,0,0,0,0,0);
    //FXHorizontalFrame* menubarcont = new FXHorizontalFrame(this, FRAME_RAISED|LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    FXToolBar* menubarcont = new FXToolBar(topdock, dragshell0, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|FRAME_RAISED|LAYOUT_FILL_X|LAYOUT_FILL_Y,0,0,0,0,0,0,0,0,0,0);
    new FXToolBarGrip(menubarcont, menubarcont, FXToolBar::ID_TOOLBARGRIP, TOOLBARGRIP_SINGLE,0,0,0,0,2,6,2,2);
    menubar = new FXMenuBar(menubarcont, menubarcont, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_CENTER_Y,0,0,0,0,0,0,0,0,4,4);

    // Tools toolbar
    FXToolBarShell* dragshell5 = new FXToolBarShell(this, FRAME_RAISED,0,0,0,0,0,0);
    throbbertoolbar = new FXToolBar(topdock, dragshell5, LAYOUT_DOCK_SAME|LAYOUT_SIDE_TOP|FRAME_RAISED|LAYOUT_FILL_Y|LAYOUT_CENTER_Y, 0, 0, 0, 0, 0, 0, 0, 0);

    // General toolbar
    FXToolBarShell* dragshell1 = new FXToolBarShell(this, FRAME_RAISED,0,0,0,0,0,0);
    generaltoolbar = new FXToolBar(topdock, dragshell1, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|FRAME_RAISED|LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // xp mode
    if ( tbdirbackicon->getWidth() == 24 ) {
      xp = 1;
      g_grip_r = 3;
    } else {
      xp = 0;
      g_grip_r = 5;
    }

    new FXToolBarGrip(generaltoolbar, generaltoolbar, FXToolBar::ID_TOOLBARGRIP, TOOLBARGRIP_SINGLE,0,0,0,0,2,g_grip_r,2,2);

    // Tools toolbar
    FXToolBarShell* dragshell2 = new FXToolBarShell(this, FRAME_RAISED,0,0,0,0,0,0);
    toolstoolbar = new FXToolBar(topdock, dragshell2, LAYOUT_DOCK_SAME|LAYOUT_SIDE_TOP|FRAME_RAISED|LAYOUT_FILL_Y);
    new FXToolBarGrip(toolstoolbar, toolstoolbar, FXToolBar::ID_TOOLBARGRIP, TOOLBARGRIP_SINGLE,0,0,0,0,2,3);

    // Panel toolbar
    FXToolBarShell* dragshell3 = new FXToolBarShell(this, FRAME_RAISED,0,0,0,0,0,0);
    paneltoolbar = new FXToolBar(topdock, dragshell3, LAYOUT_DOCK_SAME|LAYOUT_SIDE_TOP|FRAME_RAISED|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    new FXToolBarGrip(paneltoolbar, paneltoolbar, FXToolBar::ID_TOOLBARGRIP, TOOLBARGRIP_SINGLE,0,0,0,0,2,3);

    // Location bar
    FXToolBarShell* dragshell4 = new FXToolBarShell(this, FRAME_RAISED,0,0,0,0,0,0);
    locationbar = new FXToolBar(topdock, dragshell4, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|FRAME_RAISED|LAYOUT_FILL_X|LAYOUT_FILL_Y,0,0,0,0,0,0,0,0,0,0);
    new FXToolBarGrip(locationbar, locationbar, FXToolBar::ID_TOOLBARGRIP, TOOLBARGRIP_SINGLE,0,0,0,0,2,3,2,2);

    // Main splitter
    FXHorizontalFrame* hframe = new FXHorizontalFrame(this, LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    FXSplitter*        mainsplit = new FXSplitter(hframe, LAYOUT_SIDE_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y|SPLITTER_TRACKING|FRAME_NONE);

    // File list background, foreground, highlight, progress bar and attention colors
    listbackcolor = getApp()->reg().readColorEntry("SETTINGS", "listbackcolor", FXRGB(255, 255, 255));
    listforecolor = getApp()->reg().readColorEntry("SETTINGS", "listforecolor", FXRGB(0, 0, 0));
    highlightcolor = getApp()->reg().readColorEntry("SETTINGS", "highlightcolor", FXRGB(238, 238, 238));
    pbarcolor = getApp()->reg().readColorEntry("SETTINGS", "pbarcolor", FXRGB(0, 0, 255));
    attentioncolor = getApp()->reg().readColorEntry("SETTINGS", "attentioncolor", FXRGB(255, 0, 0));
    scrollbarcolor = getApp()->reg().readColorEntry("SETTINGS", "scrollbarcolor", FXRGB(237, 233, 227));

    // Smooth scrolling
    smoothscroll = getApp()->reg().readUnsignedEntry("SETTINGS", "smooth_scroll", true);

    // Directory panel on the left (with minimum size)
    dirpanel = new DirPanel(this, mainsplit, listbackcolor, listforecolor, smoothscroll, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_NONE, 0, 0, 0, 0);

    // Splitter containing the two panels
    panelsplit = new FXSplitter(mainsplit, LAYOUT_SIDE_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y|SPLITTER_TRACKING|FRAME_NONE);

    // Stack file panels horizontally or vertically	(directory panel is always vertical)
    vertpanels = getApp()->reg().readUnsignedEntry("OPTIONS", "vert_panels", true);
    if (vertpanels)
    {
        panelsplit->setSplitterStyle(panelsplit->getSplitterStyle()&~SPLITTER_VERTICAL);
    }
    else
    {
        panelsplit->setSplitterStyle(panelsplit->getSplitterStyle()|SPLITTER_VERTICAL);
    }

    // File panels on the right : remembers size of each field
    lpanel = new FilePanel(this, "LEFT PANEL", panelsplit, dirpanel,
                           getApp()->reg().readUnsignedEntry("LEFT PANEL", "name_size", 200),
                           getApp()->reg().readUnsignedEntry("LEFT PANEL", "size_size", 60),
                           getApp()->reg().readUnsignedEntry("LEFT PANEL", "type_size", 100),
                           getApp()->reg().readUnsignedEntry("LEFT PANEL", "ext_size", 100),
                           getApp()->reg().readUnsignedEntry("LEFT PANEL", "modd_size", 150),
                           getApp()->reg().readUnsignedEntry("LEFT PANEL", "user_size", 50),
                           getApp()->reg().readUnsignedEntry("LEFT PANEL", "grou_size", 50),
                           getApp()->reg().readUnsignedEntry("LEFT PANEL", "attr_size", 100),
                           getApp()->reg().readUnsignedEntry("LEFT PANEL", "deldate_size", 150),
                           getApp()->reg().readUnsignedEntry("LEFT PANEL", "origpath_size", 200),
                           getApp()->reg().readUnsignedEntry("LEFT PANEL", "showthumbnails", 0),
                           listbackcolor, listforecolor, attentioncolor, smoothscroll,
                           LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_NONE, 0, 0, 0, 0);

    rpanel = new FilePanel(this, "RIGHT PANEL", panelsplit, dirpanel,
                           getApp()->reg().readUnsignedEntry("RIGHT PANEL", "name_size", 200),
                           getApp()->reg().readUnsignedEntry("RIGHT PANEL", "size_size", 60),
                           getApp()->reg().readUnsignedEntry("RIGHT PANEL", "type_size", 100),
                           getApp()->reg().readUnsignedEntry("RIGHT PANEL", "ext_size", 100),
                           getApp()->reg().readUnsignedEntry("RIGHT PANEL", "modd_size", 150),
                           getApp()->reg().readUnsignedEntry("RIGHT PANEL", "user_size", 50),
                           getApp()->reg().readUnsignedEntry("RIGHT PANEL", "grou_size", 50),
                           getApp()->reg().readUnsignedEntry("RIGHT PANEL", "attr_size", 100),
                           getApp()->reg().readUnsignedEntry("RIGHT PANEL", "deldate_size", 150),
                           getApp()->reg().readUnsignedEntry("RIGHT PANEL", "origpath_size", 200),
                           getApp()->reg().readUnsignedEntry("RIGHT PANEL", "showthumbnails", 0),
                           listbackcolor, listforecolor, attentioncolor, smoothscroll,
                           LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_NONE, 0, 0, 0, 0);

    lpanel->Next(rpanel);
    rpanel->Next(lpanel);
    lpanel->setActive();

    FXString sort_func;
    // char sort_func;

    // Dir panel options

    //std::map<FXString, int> sort_map = {
    sort_func = getApp()->reg().readStringEntry("DIR PANEL", "sort_func", "ascendingCase");

    // wtf?
    /* if (sort_func == "ascendingCase")
    {
        dirpanel->setSortFunc(DirList::ascendingCase);
    }
    else if (sort_func == "descendingCase")
    {
        dirpanel->setSortFunc(DirList::descendingCase);
    }
    else if (sort_func == "ascending")
    {
        dirpanel->setSortFunc(DirList::ascending);
    }
    else if (sort_func == "descending")
    {
        dirpanel->setSortFunc(DirList::descending);
    } */


    // std::map my beloved
    std::map<FXString, int> sort_map;
        sort_map["ascendingCase"] = 1;
        sort_map["descendingCase"] = 2;

        sort_map["ascending"] = 3;
        sort_map["descending"] = 4;

        sort_map["ascendingCaseMix"] = 5;
        sort_map["descendingCaseMix"] = 6;

        sort_map["ascendingMix"] = 7;
        sort_map["descendingMix"] = 8;

        sort_map["ascendingSize"] = 9;
        sort_map["descendingSize"] = 10;

        sort_map["ascendingSizeMix"] = 11;
        sort_map["descendingSizeMix"] = 12;

        sort_map["ascendingType"] = 13;
        sort_map["descendingType"] = 14;

        sort_map["ascendingTypeMix"] = 15;
        sort_map["descendingTypeMix"] = 16;

        sort_map["ascendingExt"] = 17;
        sort_map["descendingExt"] = 18;

        sort_map["ascendingExtMix"] = 19;
        sort_map["descendingExtMix"] = 20;

        sort_map["ascendingTime"] = 21;
        sort_map["descendingTime"] = 22;

        sort_map["ascendingTimeMix"] = 23;
        sort_map["descendingTimeMix"] = 24;

        sort_map["ascendingUser"] = 25;
        sort_map["descendingUser"] = 26;

        sort_map["ascendingUserMix"] = 27;
        sort_map["descendingUserMix"] = 28;

        sort_map["ascendingGroup"] = 29;
        sort_map["descendingGroup"] = 30;

        sort_map["ascendingGroupMix"] = 31;
        sort_map["descendingGroupMix"] = 32;

        sort_map["ascendingPerm"] = 33;
        sort_map["descendingPerm"] = 34;

        sort_map["ascendingPermMix"] = 35;
        sort_map["descendingPermMix"] = 36;
    // those who switch:
    switch (sort_map[sort_func]) {
        case  1: dirpanel->setSortFunc(DirList::ascendingCase); break;
        case  2: dirpanel->setSortFunc(DirList::descendingCase); break;

        case  3: dirpanel->setSortFunc(DirList::ascending); break;
        case  4: dirpanel->setSortFunc(DirList::descending); break;
    }

    // Left panel options
    sort_func = getApp()->reg().readStringEntry("LEFT PANEL", "sort_func", "ascendingCase");

    switch (sort_map[sort_func]) {
        case  1: lpanel->setSortFunc(FileList::ascendingCase); break;
        case  2: lpanel->setSortFunc(FileList::descendingCase); break;

        case  3: lpanel->setSortFunc(FileList::ascending); break;
        case  4: lpanel->setSortFunc(FileList::descending); break;

        case  5: lpanel->setSortFunc(FileList::ascendingCaseMix); break;
        case  6: lpanel->setSortFunc(FileList::descendingCaseMix); break;

        case  7: lpanel->setSortFunc(FileList::ascendingMix); break;
        case  8: lpanel->setSortFunc(FileList::descendingMix); break;

        case  9: lpanel->setSortFunc(FileList::ascendingSize); break;
        case 10: lpanel->setSortFunc(FileList::descendingSize); break;

        case 11: lpanel->setSortFunc(FileList::ascendingSizeMix); break;
        case 12: lpanel->setSortFunc(FileList::descendingSizeMix); break;

        case 13: lpanel->setSortFunc(FileList::ascendingType); break;
        case 14: lpanel->setSortFunc(FileList::descendingType); break;

        case 15: lpanel->setSortFunc(FileList::ascendingTypeMix); break;
        case 16: lpanel->setSortFunc(FileList::descendingTypeMix); break;

        case 17: lpanel->setSortFunc(FileList::ascendingExt); break;
        case 18: lpanel->setSortFunc(FileList::descendingExt); break;

        case 19: lpanel->setSortFunc(FileList::ascendingExtMix); break;
        case 20: lpanel->setSortFunc(FileList::descendingExtMix); break;

        case 21: lpanel->setSortFunc(FileList::ascendingTime); break;
        case 22: lpanel->setSortFunc(FileList::descendingTime); break;

        case 23: lpanel->setSortFunc(FileList::ascendingTimeMix); break;
        case 24: lpanel->setSortFunc(FileList::descendingTimeMix); break;

        case 25: lpanel->setSortFunc(FileList::ascendingUser); break;
        case 26: lpanel->setSortFunc(FileList::descendingUser); break;

        case 27: lpanel->setSortFunc(FileList::ascendingUserMix); break;
        case 28: lpanel->setSortFunc(FileList::descendingUserMix); break;

        case 29: lpanel->setSortFunc(FileList::ascendingGroup); break;
        case 30: lpanel->setSortFunc(FileList::descendingGroup); break;

        case 31: lpanel->setSortFunc(FileList::ascendingGroupMix); break;
        case 32: lpanel->setSortFunc(FileList::descendingGroupMix); break;

        case 33: lpanel->setSortFunc(FileList::ascendingPerm); break;
        case 34: lpanel->setSortFunc(FileList::descendingPerm); break;

        case 35: lpanel->setSortFunc(FileList::ascendingPermMix); break;
        case 36: lpanel->setSortFunc(FileList::descendingPermMix); break;
    }
    // wtf
    /* if (sort_func == "ascendingCase")
    {
        lpanel->setSortFunc(FileList::ascendingCase);
    }

    else if (sort_func == "descendingCase")
    {
        lpanel->setSortFunc(FileList::descendingCase);
    }

    else if (sort_func == "ascending")
    {
        lpanel->setSortFunc(FileList::ascending);
    }

    else if (sort_func == "descending")
    {
        lpanel->setSortFunc(FileList::descending);
    }

    else if (sort_func == "ascendingCaseMix")
    {
        lpanel->setSortFunc(FileList::ascendingCaseMix);
    }
    else if (sort_func == "descendingCaseMix")
    {
        lpanel->setSortFunc(FileList::descendingCaseMix);
    }
    else if (sort_func == "ascendingMix")
    {
        lpanel->setSortFunc(FileList::ascendingMix);
    }
    else if (sort_func == "descendingMix")
    {
        lpanel->setSortFunc(FileList::descendingMix);
    }
    else if (sort_func == "ascendingSize")
    {
        lpanel->setSortFunc(FileList::ascendingSize);
    }
    else if (sort_func == "ascendingSizeMix")
    {
        lpanel->setSortFunc(FileList::ascendingSizeMix);
    }
    else if (sort_func == "descendingSize")
    {
        lpanel->setSortFunc(FileList::descendingSize);
    }
    else if (sort_func == "descendingSizeMix")
    {
        lpanel->setSortFunc(FileList::descendingSizeMix);
    }
    else if (sort_func == "ascendingType")
    {
        lpanel->setSortFunc(FileList::ascendingType);
    }
    else if (sort_func == "ascendingTypeMix")
    {
        lpanel->setSortFunc(FileList::ascendingTypeMix);
    }
    else if (sort_func == "descendingType")
    {
        lpanel->setSortFunc(FileList::descendingType);
    }
    else if (sort_func == "descendingTypeMix")
    {
        lpanel->setSortFunc(FileList::descendingTypeMix);
    }
    else if (sort_func == "ascendingExt")
    {
        lpanel->setSortFunc(FileList::ascendingExt);
    }
    else if (sort_func == "ascendingExtMix")
    {
        lpanel->setSortFunc(FileList::ascendingExtMix);
    }
    else if (sort_func == "descendingExt")
    {
        lpanel->setSortFunc(FileList::descendingExt);
    }
    else if (sort_func == "descendingExtMix")
    {
        lpanel->setSortFunc(FileList::descendingExtMix);
    }
    else if (sort_func == "ascendingTime")
    {
        lpanel->setSortFunc(FileList::ascendingTime);
    }
    else if (sort_func == "ascendingTimeMix")
    {
        lpanel->setSortFunc(FileList::ascendingTimeMix);
    }
    else if (sort_func == "descendingTime")
    {
        lpanel->setSortFunc(FileList::descendingTime);
    }
    else if (sort_func == "descendingTimeMix")
    {
        lpanel->setSortFunc(FileList::descendingTimeMix);
    }
    else if (sort_func == "ascendingUser")
    {
        lpanel->setSortFunc(FileList::ascendingUser);
    }
    else if (sort_func == "ascendingUserMix")
    {
        lpanel->setSortFunc(FileList::ascendingUserMix);
    }
    else if (sort_func == "descendingUser")
    {
        lpanel->setSortFunc(FileList::descendingUser);
    }
    else if (sort_func == "descendingUserMix")
    {
        lpanel->setSortFunc(FileList::descendingUserMix);
    }
    else if (sort_func == "ascendingGroup")
    {
        lpanel->setSortFunc(FileList::ascendingGroup);
    }
    else if (sort_func == "ascendingGroupMix")
    {
        lpanel->setSortFunc(FileList::ascendingGroupMix);
    }
    else if (sort_func == "descendingGroup")
    {
        lpanel->setSortFunc(FileList::descendingGroup);
    }
    else if (sort_func == "descendingGroupMix")
    {
        lpanel->setSortFunc(FileList::descendingGroupMix);
    }
    else if (sort_func == "ascendingPerm")
    {
        lpanel->setSortFunc(FileList::ascendingPerm);
    }
    else if (sort_func == "ascendingPermMix")
    {
        lpanel->setSortFunc(FileList::ascendingPermMix);
    }
    else if (sort_func == "descendingPerm")
    {
        lpanel->setSortFunc(FileList::descendingPerm);
    }
    else if (sort_func == "descendingPermMix")
    {
        lpanel->setSortFunc(FileList::descendingPermMix);
    } */
    FXuint ignore_case = getApp()->reg().readUnsignedEntry("LEFT PANEL", "ignore_case", 1);
    lpanel->setIgnoreCase(ignore_case);
    FXuint dirs_first = getApp()->reg().readUnsignedEntry("LEFT PANEL", "dirs_first", 1);
    lpanel->setDirsFirst(dirs_first);

    // Right panel options
    sort_func = getApp()->reg().readStringEntry("RIGHT PANEL", "sort_func", "ascendingCase");

    switch (sort_map[sort_func]) {
        case  1: rpanel->setSortFunc(FileList::ascendingCase); break;
        case  2: rpanel->setSortFunc(FileList::descendingCase); break;

        case  3: rpanel->setSortFunc(FileList::ascending); break;
        case  4: rpanel->setSortFunc(FileList::descending); break;

        case  5: rpanel->setSortFunc(FileList::ascendingCaseMix); break;
        case  6: rpanel->setSortFunc(FileList::descendingCaseMix); break;

        case  7: rpanel->setSortFunc(FileList::ascendingMix); break;
        case  8: rpanel->setSortFunc(FileList::descendingMix); break;

        case  9: rpanel->setSortFunc(FileList::ascendingSize); break;
        case 10: rpanel->setSortFunc(FileList::descendingSize); break;

        case 11: rpanel->setSortFunc(FileList::ascendingSizeMix); break;
        case 12: rpanel->setSortFunc(FileList::descendingSizeMix); break;

        case 13: rpanel->setSortFunc(FileList::ascendingType); break;
        case 14: rpanel->setSortFunc(FileList::descendingType); break;

        case 15: rpanel->setSortFunc(FileList::ascendingTypeMix); break;
        case 16: rpanel->setSortFunc(FileList::descendingTypeMix); break;

        case 17: rpanel->setSortFunc(FileList::ascendingExt); break;
        case 18: rpanel->setSortFunc(FileList::descendingExt); break;

        case 19: rpanel->setSortFunc(FileList::ascendingExtMix); break;
        case 20: rpanel->setSortFunc(FileList::descendingExtMix); break;

        case 21: rpanel->setSortFunc(FileList::ascendingTime); break;
        case 22: rpanel->setSortFunc(FileList::descendingTime); break;

        case 23: rpanel->setSortFunc(FileList::ascendingTimeMix); break;
        case 24: rpanel->setSortFunc(FileList::descendingTimeMix); break;

        case 25: rpanel->setSortFunc(FileList::ascendingUser); break;
        case 26: rpanel->setSortFunc(FileList::descendingUser); break;

        case 27: rpanel->setSortFunc(FileList::ascendingUserMix); break;
        case 28: rpanel->setSortFunc(FileList::descendingUserMix); break;

        case 29: rpanel->setSortFunc(FileList::ascendingGroup); break;
        case 30: rpanel->setSortFunc(FileList::descendingGroup); break;

        case 31: rpanel->setSortFunc(FileList::ascendingGroupMix); break;
        case 32: rpanel->setSortFunc(FileList::descendingGroupMix); break;

        case 33: rpanel->setSortFunc(FileList::ascendingPerm); break;
        case 34: rpanel->setSortFunc(FileList::descendingPerm); break;

        case 35: rpanel->setSortFunc(FileList::ascendingPermMix); break;
        case 36: rpanel->setSortFunc(FileList::descendingPermMix); break;
    }


    /* if (sort_func == "ascendingCase")
    {
        rpanel->setSortFunc(FileList::ascendingCase);
    }
    else if (sort_func == "ascendingCaseMix")
    {
        rpanel->setSortFunc(FileList::ascendingCaseMix);
    }
    else if (sort_func == "descendingCase")
    {
        rpanel->setSortFunc(FileList::descendingCase);
    }
    else if (sort_func == "descendingCaseMix")
    {
        rpanel->setSortFunc(FileList::descendingCaseMix);
    }
    else if (sort_func == "ascending")
    {
        rpanel->setSortFunc(FileList::ascending);
    }
    else if (sort_func == "ascendingMix")
    {
        rpanel->setSortFunc(FileList::ascendingMix);
    }
    else if (sort_func == "descending")
    {
        rpanel->setSortFunc(FileList::descending);
    }
    else if (sort_func == "descendingMix")
    {
        rpanel->setSortFunc(FileList::descendingMix);
    }
    else if (sort_func == "ascendingSize")
    {
        rpanel->setSortFunc(FileList::ascendingSize);
    }
    else if (sort_func == "ascendingSizeMix")
    {
        rpanel->setSortFunc(FileList::ascendingSizeMix);
    }
    else if (sort_func == "descendingSize")
    {
        rpanel->setSortFunc(FileList::descendingSize);
    }
    else if (sort_func == "descendingSizeMix")
    {
        rpanel->setSortFunc(FileList::descendingSizeMix);
    }
    else if (sort_func == "ascendingType")
    {
        rpanel->setSortFunc(FileList::ascendingType);
    }
    else if (sort_func == "ascendingTypeMix")
    {
        rpanel->setSortFunc(FileList::ascendingTypeMix);
    }
    else if (sort_func == "descendingType")
    {
        rpanel->setSortFunc(FileList::descendingType);
    }
    else if (sort_func == "descendingTypeMix")
    {
        rpanel->setSortFunc(FileList::descendingTypeMix);
    }
    else if (sort_func == "ascendingExt")
    {
        rpanel->setSortFunc(FileList::ascendingExt);
    }
    else if (sort_func == "ascendingExtMix")
    {
        rpanel->setSortFunc(FileList::ascendingExtMix);
    }
    else if (sort_func == "descendingExt")
    {
        rpanel->setSortFunc(FileList::descendingExt);
    }
    else if (sort_func == "descendingExtMix")
    {
        rpanel->setSortFunc(FileList::descendingExtMix);
    }
    else if (sort_func == "ascendingTime")
    {
        rpanel->setSortFunc(FileList::ascendingTime);
    }
    else if (sort_func == "ascendingTimeMix")
    {
        rpanel->setSortFunc(FileList::ascendingTimeMix);
    }
    else if (sort_func == "descendingTime")
    {
        rpanel->setSortFunc(FileList::descendingTime);
    }
    else if (sort_func == "descendingTimeMix")
    {
        rpanel->setSortFunc(FileList::descendingTimeMix);
    }
    else if (sort_func == "ascendingUser")
    {
        rpanel->setSortFunc(FileList::ascendingUser);
    }
    else if (sort_func == "ascendingUserMix")
    {
        rpanel->setSortFunc(FileList::ascendingUserMix);
    }
    else if (sort_func == "descendingUser")
    {
        rpanel->setSortFunc(FileList::descendingUser);
    }
    else if (sort_func == "descendingUserMix")
    {
        rpanel->setSortFunc(FileList::descendingUserMix);
    }
    else if (sort_func == "ascendingGroup")
    {
        rpanel->setSortFunc(FileList::ascendingGroup);
    }
    else if (sort_func == "ascendingGroupMix")
    {
        rpanel->setSortFunc(FileList::ascendingGroupMix);
    }
    else if (sort_func == "descendingGroup")
    {
        rpanel->setSortFunc(FileList::descendingGroup);
    }
    else if (sort_func == "descendingGroupMix")
    {
        rpanel->setSortFunc(FileList::descendingGroupMix);
    }
    else if (sort_func == "ascendingPerm")
    {
        rpanel->setSortFunc(FileList::ascendingPerm);
    }
    else if (sort_func == "ascendingPermMix")
    {
        rpanel->setSortFunc(FileList::ascendingPermMix);
    }
    else if (sort_func == "descendingPerm")
    {
        rpanel->setSortFunc(FileList::descendingPerm);
    }
    else if (sort_func == "descendingPermMix")
    {
        rpanel->setSortFunc(FileList::descendingPermMix);
    } */
    ignore_case = getApp()->reg().readUnsignedEntry("RIGHT PANEL", "ignore_case", 1);
    rpanel->setIgnoreCase(ignore_case);
    dirs_first = getApp()->reg().readUnsignedEntry("RIGHT PANEL", "dirs_first", 1);
    rpanel->setDirsFirst(dirs_first);

    FXButton* btn = NULL;
    FXHotKey  hotkey;
    FXString  key;

    // Throbber
    //btn = new FXButton(throbbertoolbar, NULL, throbicon, this,  XFileExplorer::ID_DIR_BACK, 0);

    FXPacker* throbbg = new FXPacker(throbbertoolbar, LAYOUT_FILL_Y|LAYOUT_CENTER_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    throbbg->setBackColor(FXRGB(0, 0, 0));
    //throbbg->setBackColor(FXRGB(255, 255, 255));
    //throbbg->setBackColor(col);

    FXPacker* throbcont = new FXPacker(throbbg, LAYOUT_CENTER_Y|LAYOUT_FIX_HEIGHT|LAYOUT_FIX_WIDTH, 0, 0, 38, 22, 0, 0, 0, 0, 0, 0);
    throbcont->setBackColor(FXRGB(0, 0, 0));
    //throbcont->setBackColor(FXRGB(255, 255, 255));

    throbber = new FXLabel(throbcont, "", throbanimicon, LAYOUT_FIX_Y|LAYOUT_CENTER_X|LAYOUT_FILL_X|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT, 0, 0, 0, 0, 0, 0, 0, 0);
    throbber->setBackColor(FXRGB(0, 0, 0));
    ///throbanimicon->render();
    //throbanimicon->create();
    //FXColor col = throbanimicon->getPixel(2,2);
    //FXColor col = throbanimicon->getPixel(2,2);
    //printf("%d", col);


    //getApp()->addTimeout(this,ID_ANIMTHROB,10);


    //getApp()->addTimeout(this,ID_STOPANIMTHROB,2500);


    // General toolbar
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_back", "Ctrl-Backspace");

    if (xp = 1) {
      btn_rpad = 1;
    }


    btn = new FXButton(generaltoolbar, _("Back")+TAB+_("Go to previous folder")+PARS(key), tbdirbackicon, this, XFileExplorer::ID_DIR_BACK, BUTTON_TOOLBAR|ICON_BEFORE_TEXT|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_Y,0,0,0,0,5,3,2,2);

    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // btnbackhist = new FXArrowButton(generaltoolbar, this, XFileExplorer::ID_DIR_BACK_HIST, LAYOUT_FILL_Y|FRAME_RAISED|ARROW_DOWN|ARROW_TOOLBAR,0,0,0,0,0,0,0,0);
    btnbackhist = new FXButton(generaltoolbar, "", arrowicon, this, XFileExplorer::ID_DIR_BACK_HIST, LAYOUT_FILL_Y|BUTTON_TOOLBAR|FRAME_RAISED,0,0,0,0,4,3,2,0);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_forward", "Shift-Backspace");
    btn = new FXButton(generaltoolbar, TAB+_("Go to next folder")+PARS(key), tbdirforwardicon, this, XFileExplorer::ID_DIR_FORWARD, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_Y,0,0,0,0,3,2,0,0);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    btnforwardhist = new FXButton(generaltoolbar, "", arrowicon, this, XFileExplorer::ID_DIR_FORWARD_HIST, LAYOUT_FILL_Y|BUTTON_TOOLBAR|FRAME_RAISED,0,0,0,0,4,3,2,0);
    //btnforwardhist = new FXArrowButton(generaltoolbar, this, XFileExplorer::ID_DIR_FORWARD_HIST, LAYOUT_FILL_Y|FRAME_RAISED|ARROW_DOWN|ARROW_TOOLBAR,0,0,0,0,0,0,0,0);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_up", "Backspace");
    btn = new FXButton(generaltoolbar, TAB+_("Go to parent folder")+PARS(key), tbdirupicon, this, XFileExplorer::ID_DIR_UP, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_Y,0,0,0,0,3,3,0,0);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    toolbarSeparator(generaltoolbar);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "search", "Ctrl-F");
    new FXButton(generaltoolbar, _("Search")+TAB+_("Search files and folders...")+PARS(key), tbsearchicon, this, XFileExplorer::ID_FILE_SEARCH, BUTTON_TOOLBAR|ICON_BEFORE_TEXT|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_Y,0,0,0,0,3,3,0,0);

    // Show one panel
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "one_panel", "Ctrl-F1");
    btn = new FXButton(generaltoolbar, TAB+_("Show one panel")+PARS(key), tbonepanelicon, this, XFileExplorer::ID_SHOW_ONE_PANEL, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|LAYOUT_FILL_Y,0,0,0,0,3,3,0,0);
    btn->hide();


    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Show tree and panel
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "tree_panel", "Ctrl-F2");
    btn = new FXButton(generaltoolbar, TAB+_("Show tree and panel")+PARS(key), tbtreeonepanelicon, this, XFileExplorer::ID_SHOW_TREE_PANEL, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|LAYOUT_FILL_Y,0,0,0,0,3,3,0,0);
    btn->hide();

    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);


    // Show folders pane
    foldersbtn = new FXButton(generaltoolbar, "Folders", tbtreeonepanelicon, this, XFileExplorer::ID_SWITCH_TREE, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|LAYOUT_FILL_Y,0,0,0,0,3,3,0,0);


    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_file", "Ctrl-N");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_folder", "F7");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_symlink", "Ctrl-J");

    toolbarSeparator(generaltoolbar);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "copy", "Ctrl-C");
    new FXButton(generaltoolbar, TAB+_("Copy to...")+PARS(key), tbcopy_clpicon, this, XFileExplorer::ID_FILE_COPYTO, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|LAYOUT_FILL_Y,0,0,0,0,3,3,0,0);

    // Shift + copy key binding can be used to add files to the copy clipboard
    // but this feature is disabled if the key binding already uses the Shift key
    if (key.lower().find("shift") < 0)
    {
        key = "Shift-" + key;
        hotkey = _parseAccel(key);
        getAccelTable()->addAccel(hotkey, this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ADDCOPY));
    }

    // Shift + cut key binding can be used to add files to the cut clipboard
    // but this feature is disabled if the key binding already uses the Shift key
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "cut", "Ctrl-X");
    new FXButton(generaltoolbar, TAB+_("Move to...")+PARS(key), tbmoveiticon, this, XFileExplorer::ID_FILE_MOVETO, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|LAYOUT_FILL_Y,0,0,0,0,3,3,0,0);

    if (key.lower().find("shift") < 0)
    {
        key = "Shift-" + key;
        hotkey = _parseAccel(key);
        getAccelTable()->addAccel(hotkey, this, FXSEL(SEL_COMMAND, XFileExplorer::ID_FILE_ADDCUT));
    }

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "move_to_trash", "Del");
    new FXButton(generaltoolbar, TAB+_("Move selected files to trash can")+PARS(key), tbfiledeleteicon, this, XFileExplorer::ID_FILE_TRASH, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|LAYOUT_FILL_Y,0,0,0,0,3,3,0,0);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "paste", "Ctrl-V");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "properties", "F9");
    new FXButton(generaltoolbar, TAB+_("Show properties of selected files")+PARS(key), tbattribicon, this, XFileExplorer::ID_FILE_PROPERTIES, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|LAYOUT_FILL_Y,0,0,0,0,3,3,0,0);

    toolbarSeparator(generaltoolbar);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "restore_from_trash", "Alt-Del");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "delete", "Shift-Del");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_window", "F3");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_root_window", "Shift-F3");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "execute_command", "Ctrl-E");

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "terminal", "Ctrl-T");
    new FXButton(generaltoolbar, TAB+_("Launch terminal")+PARS(key), tbshellicon, this, XFileExplorer::ID_XTERM, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_Y,0,0,0,0,3,3,0,0);

    // Panel toolbar
    toolbarSeparator(generaltoolbar);
    // Switch display modes
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "big_icons", "F10");
    btn = new FXButton(generaltoolbar, TAB+_("Big icon list")+PARS(key), tbbigiconsicon, lpanel, FilePanel::ID_SHOW_BIG_ICONS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED|LAYOUT_FILL_Y,0,0,0,0,3,3,0,0);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);
    btn->hide();

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "small_icons", "F11");
    btn = new FXButton(generaltoolbar, TAB+_("Small icon list")+PARS(key), tbsmalliconsicon, lpanel, FilePanel::ID_SHOW_MINI_ICONS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED|LAYOUT_FILL_Y,0,0,0,0,3,3,0,0);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);
    btn->hide();

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "detailed_file_list", "F12");
    btn = new FXButton(generaltoolbar, TAB+_("Detailed file list")+PARS(key), tbdetailsicon, lpanel, FilePanel::ID_SHOW_DETAILS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED|LAYOUT_FILL_Y,0,0,0,0,3,3,0,0);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);
    btn->hide();

    // view menu
    FXMenuPane* viewtoolbarmenu = new FXMenuPane(this);
    new FXMenuRadio(viewtoolbarmenu, _("Ico&ns"), lpanel, FilePanel::ID_SHOW_BIG_ICONS);
    new FXMenuRadio(viewtoolbarmenu, _("&Small Icons"), lpanel, FilePanel::ID_SHOW_MINI_ICONS);
    new FXMenuRadio(viewtoolbarmenu, _("&Details"), lpanel, FilePanel::ID_SHOW_DETAILS);

    viewbutton = new FXMenuButton(generaltoolbar, "", tbiconsmenuicon, viewtoolbarmenu, MENUBUTTON_TOOLBAR|FRAME_SUNKEN|LAYOUT_FILL_Y,0,0,0,0,3,3,0,0);

#if defined(linux)

    // Mount and unmount buttons
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mount", "Ctrl-M");
    btn = new FXButton(toolstoolbar, TAB+_("Mount (Linux only)")+PARS(key), maphosticon, lpanel, FilePanel::ID_MOUNT, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "unmount", "Ctrl-U");
    btn = new FXButton(toolstoolbar, TAB+_("Unmount (Linux only)")+PARS(key), unmaphosticon, lpanel, FilePanel::ID_UMOUNT, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);
#endif

    // Panel toolbar

    // Switch display modes
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "big_icons", "F10");
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "small_icons", "F11");
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "detailed_file_list", "F12");
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "refresh", "Ctrl-R");

    // Location bar
    new FXLabel(locationbar, _("A&ddress"),NULL,LAYOUT_CENTER_Y,0,0,0,0,1,4,0,0);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "clear_location", "Ctrl-L");
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    FXPacker* addresscont = new FXHorizontalFrame(locationbar, LAYOUT_FILL_X|LAYOUT_CENTER_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);


    address = new ComboBox(addresscont, 10, this, ID_GOTO_LOCATION, 0x01000000|COMBOBOX_INSERT_LAST|JUSTIFY_LEFT|LAYOUT_FILL_X|LAYOUT_CENTER_Y);
    address->setNumVisible(5);

    addressicon = new FXLabel(addresscont, "", minifoldericon, LAYOUT_FIX_X|LAYOUT_FIX_WIDTH|LAYOUT_CENTER_Y|LAYOUT_FIX_HEIGHT, 3, 3, 16, 16, 0, 0, 0, 0);
    addressicon->setBackColor(getApp()->getBackColor());

    //addressicon->setBackColor(FXRGB(50, 50, 50));

    int entericonsize = tbentericon->getWidth();

    // printf("%d\n", entericonsize);

    if (entericonsize == 20) {
       go_lpad = 4;
       go_rpad = 14;
       go_tpad = 0;
       go_bpad = 0;
    } else {
       go_lpad = 2;
       go_rpad = 6;
       go_tpad = 0;
       go_bpad = 0;
    }

    new FXButton(locationbar, _("Go")+TAB+_("Go to location"), tbentericon, this, ID_GOTO_LOCATION, BUTTON_TOOLBAR|LAYOUT_FILL_Y|LAYOUT_CENTER_Y|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED, 0, 0, 0, 0, go_lpad, go_rpad, go_tpad, go_bpad);
    // FXButton* gobutton = new FXButton(locationbar, _("Go")+TAB+_("Go to location"), tbentericon, this, ID_GOTO_LOCATION, BUTTON_TOOLBAR|LAYOUT_FILL_Y|LAYOUT_CENTER_Y|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED, 0, 0, 0, 0, 0, 0, go_tpad, go_bpad);
    //gobutton->detach();
    //gobutton->create();
    //printf("%d\n", gobutton->getWidth());
    //printf("%d\n", gobutton->getHeight());



    // Menus

    // File menu
    filemenu = new FXMenuPane(this);
    FXMenuCommand* mc = NULL;

    mc = new FXMenuCommand(filemenu, _("New &file..."), NULL, lpanel, FilePanel::ID_NEW_FILE);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_file", "Ctrl-N");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(filemenu, _("New fo&lder..."), NULL, lpanel, FilePanel::ID_NEW_DIR);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_folder", "F7");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(filemenu, _("New s&ymlink..."), NULL, lpanel, FilePanel::ID_NEW_SYMLINK);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_symlink", "Ctrl-J");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(filemenu, _("Go &home"), NULL, lpanel, FilePanel::ID_GO_HOME);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_home", "Ctrl-H");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(filemenu, _("&Refresh"), NULL, this, XFileExplorer::ID_REFRESH);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "refresh", "Ctrl-R");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuSeparator(filemenu);

    mc = new FXMenuCommand(filemenu, _("&Open"), NULL, lpanel, FilePanel::ID_OPEN);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "open", "Ctrl-O");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(filemenu, _("Re&name..."), NULL, this, XFileExplorer::ID_FILE_RENAME);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rename", "F2");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(filemenu, _("&Copy to..."), NULL, this, XFileExplorer::ID_FILE_COPYTO);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "copy_to", "F5");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(filemenu, _("&Move to..."), NULL, this, XFileExplorer::ID_FILE_MOVETO);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "move_to", "F6");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(filemenu, _("&Symlink to..."), NULL, this, XFileExplorer::ID_FILE_SYMLINK);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "symlink_to", "Ctrl-S");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(filemenu, _("Mo&ve to trash"), NULL, this, XFileExplorer::ID_FILE_TRASH);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "move_to_trash", "Del");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(filemenu, _("R&estore from trash"), NULL, this, XFileExplorer::ID_FILE_RESTORE);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "restore_from_trash", "Alt-Del");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(filemenu, _("&Delete"), NULL, this, XFileExplorer::ID_FILE_DELETE);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "delete", "Shift-Del");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(filemenu, _("&Properties"), NULL, this, XFileExplorer::ID_FILE_PROPERTIES);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "properties", "F9");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuSeparator(filemenu);

    mc = new FXMenuCommand(filemenu, _("&Quit"), NULL, this, XFileExplorer::ID_QUIT);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "quit", "Ctrl-Q");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    filemenutitle = new FXMenuTitle(menubar, _("&File"), NULL, filemenu);
    //filemenutitle2 = new FXMenuTitle(menubar, _("&File"), NULL, generaltoolbar);

    // Edit menu
    editmenu = new FXMenuPane(this);

    mc = new FXMenuCommand(editmenu, _("&Copy"), NULL, this, XFileExplorer::ID_FILE_COPY);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "copy", "Ctrl-C");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(editmenu, _("C&ut"), NULL, this, XFileExplorer::ID_FILE_CUT);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "cut", "Ctrl-X");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(editmenu, _("&Paste"), NULL, this, XFileExplorer::ID_FILE_PASTE);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "paste", "Ctrl-V");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuSeparator(editmenu);

    mc = new FXMenuCommand(editmenu, _("&Select all"), NULL, lpanel, FilePanel::ID_SELECT_ALL);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "select_all", "Ctrl-A");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(editmenu, _("&Deselect all"), NULL, lpanel, FilePanel::ID_DESELECT_ALL);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "deselect_all", "Ctrl-Z");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(editmenu, _("&Invert selection"), NULL, lpanel, FilePanel::ID_SELECT_INVERSE);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "invert_selection", "Ctrl-I");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuSeparator(editmenu);
    new FXMenuCommand(editmenu, _("P&references"), NULL, this, XFileExplorer::ID_PREFS);

    editmenutitle = new FXMenuTitle(menubar, _("&Edit"), NULL, editmenu);

    // View menu
    viewmenu = new FXMenuPane(this);

    // Left Panel Menu
    lpanelmenu = new FXMenuPane(this);
    new FXMenuCommand(lpanelmenu, _("&Filter..."), NULL, lpanel, FilePanel::ID_FILTER);
    new FXMenuCheck(lpanelmenu, _("&Hidden files"), lpanel->getList(), FileList::ID_TOGGLE_HIDDEN);
    new FXMenuCheck(lpanelmenu, _("&Thumbnails"), lpanel->getList(), FileList::ID_TOGGLE_THUMBNAILS);
    new FXMenuSeparator(lpanelmenu);
    new FXMenuRadio(lpanelmenu, _("&Big icons"), lpanel->getList(), IconList::ID_SHOW_BIG_ICONS);
    new FXMenuRadio(lpanelmenu, _("&Small icons"), lpanel->getList(), IconList::ID_SHOW_MINI_ICONS);
    new FXMenuRadio(lpanelmenu, _("F&ull file list"), lpanel->getList(), IconList::ID_SHOW_DETAILS);
    new FXMenuSeparator(lpanelmenu);
    new FXMenuRadio(lpanelmenu, _("&Rows"), lpanel->getList(), FileList::ID_ARRANGE_BY_ROWS);
    new FXMenuRadio(lpanelmenu, _("&Columns"), lpanel->getList(), FileList::ID_ARRANGE_BY_COLUMNS);
    new FXMenuCheck(lpanelmenu, _("Autosize"), lpanel->getList(), FileList::ID_AUTOSIZE);
    new FXMenuSeparator(lpanelmenu);
    new FXMenuRadio(lpanelmenu, _("&Name"), lpanel->getList(), FileList::ID_SORT_BY_NAME);
    new FXMenuRadio(lpanelmenu, _("Si&ze"), lpanel->getList(), FileList::ID_SORT_BY_SIZE);
    new FXMenuRadio(lpanelmenu, _("T&ype"), lpanel->getList(), FileList::ID_SORT_BY_TYPE);
    new FXMenuRadio(lpanelmenu, _("E&xtension"), lpanel->getList(), FileList::ID_SORT_BY_EXT);
    new FXMenuRadio(lpanelmenu, _("D&ate"), lpanel->getList(), FileList::ID_SORT_BY_TIME);
    new FXMenuRadio(lpanelmenu, _("Us&er"), lpanel->getList(), FileList::ID_SORT_BY_USER);
    new FXMenuRadio(lpanelmenu, _("Gr&oup"), lpanel->getList(), FileList::ID_SORT_BY_GROUP);
    new FXMenuRadio(lpanelmenu, _("&Permissions"), lpanel->getList(), FileList::ID_SORT_BY_PERM);
    new FXMenuRadio(lpanelmenu, _("Deletion date"), lpanel->getList(), FileList::ID_SORT_BY_DELTIME);
    new FXMenuRadio(lpanelmenu, _("Original path"), lpanel->getList(), FileList::ID_SORT_BY_ORIGPATH);
    new FXMenuSeparator(lpanelmenu);
    new FXMenuCheck(lpanelmenu, _("I&gnore case"), lpanel->getList(), FileList::ID_SORT_CASE);
    new FXMenuCheck(lpanelmenu, _("Fol&ders first"), lpanel->getList(), FileList::ID_DIRS_FIRST);
    new FXMenuCheck(lpanelmenu, _("Re&verse order"), lpanel->getList(), FileList::ID_SORT_REVERSE);
    lpanelmenutitle = new FXMenuCascade(viewmenu, _("&Left panel"), NULL, lpanelmenu);

    // Right Panel Menu
    rpanelmenu = new FXMenuPane(this);
    new FXMenuCommand(rpanelmenu, _("&Filter"), NULL, rpanel, FilePanel::ID_FILTER);
    new FXMenuCheck(rpanelmenu, _("&Hidden files"), rpanel->getList(), FileList::ID_TOGGLE_HIDDEN);
    new FXMenuCheck(rpanelmenu, _("&Thumbnails"), rpanel->getList(), FileList::ID_TOGGLE_THUMBNAILS);
    new FXMenuSeparator(rpanelmenu);
    new FXMenuRadio(rpanelmenu, _("&Big icons"), rpanel->getList(), IconList::ID_SHOW_BIG_ICONS);
    new FXMenuRadio(rpanelmenu, _("&Small icons"), rpanel->getList(), IconList::ID_SHOW_MINI_ICONS);
    new FXMenuRadio(rpanelmenu, _("F&ull file list"), rpanel->getList(), IconList::ID_SHOW_DETAILS);
    new FXMenuSeparator(rpanelmenu);
    new FXMenuRadio(rpanelmenu, _("&Rows"), rpanel->getList(), FileList::ID_ARRANGE_BY_ROWS);
    new FXMenuRadio(rpanelmenu, _("&Columns"), rpanel->getList(), FileList::ID_ARRANGE_BY_COLUMNS);
    new FXMenuCheck(rpanelmenu, _("Autosize"), rpanel->getList(), FileList::ID_AUTOSIZE);
    new FXMenuSeparator(rpanelmenu);
    new FXMenuRadio(rpanelmenu, _("&Name"), rpanel->getList(), FileList::ID_SORT_BY_NAME);
    new FXMenuRadio(rpanelmenu, _("Si&ze"), rpanel->getList(), FileList::ID_SORT_BY_SIZE);
    new FXMenuRadio(rpanelmenu, _("T&ype"), rpanel->getList(), FileList::ID_SORT_BY_TYPE);
    new FXMenuRadio(rpanelmenu, _("E&xtension"), rpanel->getList(), FileList::ID_SORT_BY_EXT);
    new FXMenuRadio(rpanelmenu, _("D&ate"), rpanel->getList(), FileList::ID_SORT_BY_TIME);
    new FXMenuRadio(rpanelmenu, _("Us&er"), rpanel->getList(), FileList::ID_SORT_BY_USER);
    new FXMenuRadio(rpanelmenu, _("Gr&oup"), rpanel->getList(), FileList::ID_SORT_BY_GROUP);
    new FXMenuRadio(rpanelmenu, _("&Permissions"), rpanel->getList(), FileList::ID_SORT_BY_PERM);
    new FXMenuRadio(rpanelmenu, _("Deletion date"), rpanel->getList(), FileList::ID_SORT_BY_DELTIME);
    new FXMenuRadio(rpanelmenu, _("Original path"), rpanel->getList(), FileList::ID_SORT_BY_ORIGPATH);
    new FXMenuSeparator(rpanelmenu);
    new FXMenuCheck(rpanelmenu, _("I&gnore case"), rpanel->getList(), FileList::ID_SORT_CASE);
    new FXMenuCheck(rpanelmenu, _("&Folders first"), rpanel->getList(), FileList::ID_DIRS_FIRST);
    new FXMenuCheck(rpanelmenu, _("Re&verse order"), rpanel->getList(), FileList::ID_SORT_REVERSE);
    rpanelmenutitle = new FXMenuCascade(viewmenu, _("&Right panel"), NULL, rpanelmenu);

    new FXMenuSeparator(viewmenu);

    new FXMenuCheck(viewmenu, _("&General toolbar"), generaltoolbar, FXWindow::ID_TOGGLESHOWN);
    new FXMenuCheck(viewmenu, _("&Tools toolbar"), toolstoolbar, FXWindow::ID_TOGGLESHOWN);
    new FXMenuCheck(viewmenu, _("&Panel toolbar"), paneltoolbar, FXWindow::ID_TOGGLESHOWN);
    new FXMenuCheck(viewmenu, _("&Location bar"), locationbar, FXWindow::ID_TOGGLESHOWN);
    new FXMenuCheck(viewmenu, _("&Status bar"), this, XFileExplorer::ID_TOGGLE_STATUS);

    new FXMenuSeparator(viewmenu);

    mc = new FXMenuRadio(viewmenu, _("&One panel"), this, XFileExplorer::ID_SHOW_ONE_PANEL);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "one_panel", "Ctrl-F1");
    mc->setAccelText(key);

    mc = new FXMenuRadio(viewmenu, _("T&ree and panel"), this, XFileExplorer::ID_SHOW_TREE_PANEL);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "tree_panel", "Ctrl-F2");
    mc->setAccelText(key);

    mc = new FXMenuRadio(viewmenu, _("Two &panels"), this, XFileExplorer::ID_SHOW_TWO_PANELS);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "two_panels", "Ctrl-F3");
    mc->setAccelText(key);

    mc = new FXMenuRadio(viewmenu, _("Tr&ee and two panels"), this, XFileExplorer::ID_SHOW_TREE_TWO_PANELS);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "tree_two_panels", "Ctrl-F4");
    mc->setAccelText(key);

    new FXMenuSeparator(viewmenu);

    mc = new FXMenuRadio(viewmenu, _("&Vertical panels"), this, XFileExplorer::ID_VERT_PANELS);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "vert_panels", "Ctrl-Shift-F1");
    mc->setAccelText(key);

    mc = new FXMenuRadio(viewmenu, _("&Horizontal panels"), this, XFileExplorer::ID_HORZ_PANELS);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "horz_panels", "Ctrl-Shift-F2");
    mc->setAccelText(key);

    viewmenutitle = new FXMenuTitle(menubar, _("&View"), NULL, viewmenu);

    // Favorites menu
    bookmarksmenu = new FXMenuPane(this);
    mc = new FXMenuCommand(bookmarksmenu, _("&Add favorite"), NULL, this, ID_ADD_BOOKMARK);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "add_bookmark", "Ctrl-B");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuSeparator(bookmarksmenu);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_1);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_2);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_3);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_4);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_5);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_6);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_7);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_8);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_9);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_10);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_11);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_12);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_13);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_14);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_15);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_16);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_17);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_18);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_19);
    new FXMenuCommand(bookmarksmenu, FXString::null, NULL, bookmarks, Bookmarks::ID_BOOKMARK_20);
    new FXMenuSeparator(bookmarksmenu);
    new FXMenuCommand(bookmarksmenu, _("&Clear favorites"), NULL, bookmarks, Bookmarks::ID_CLEAR);

    bookmarksmenutitle = new FXMenuTitle(menubar, _("F&avorites"), NULL, bookmarksmenu);

    // Tools menu
    toolsmenu = new FXMenuPane(this);

    // Recycle Bin menu
    trashmenu = new FXMenuPane(this);

    mc = new FXMenuCommand(trashmenu, _("&Go to Recycle Bin"), NULL, lpanel, FilePanel::ID_GO_TRASH);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_to_trash", "Ctrl-F8");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(trashmenu, _("&Recycle Bin size"), NULL, this, XFileExplorer::ID_TRASH_SIZE);

    mc = new FXMenuCommand(trashmenu, _("&Empty Recycle Bin"), NULL, this, XFileExplorer::ID_EMPTY_TRASH);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "empty_trash_can", "Ctrl-Del");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));


    //trashmenutitle = new FXMenuTitle(menubar, _("&Recycle Bin"), NULL, trashmenu);
    trashmenutitle = new FXMenuCascade(toolsmenu, _("&Recycle Bin"), NULL, trashmenu);
    new FXMenuSeparator(toolsmenu);


    mc = new FXMenuCommand(toolsmenu, _("New &window"), NULL, this, XFileExplorer::ID_NEW_WIN);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_window", "F3");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(toolsmenu, _("New &root window"), NULL, this, XFileExplorer::ID_SU);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "new_root_window", "Shift-F3");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuSeparator(toolsmenu);

    mc = new FXMenuCommand(toolsmenu, _("E&xecute command..."), NULL, this, ID_RUN);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "execute_command", "Ctrl-E");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(toolsmenu, _("&Terminal"), NULL, this, XFileExplorer::ID_XTERM);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "terminal", "Ctrl-T");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(toolsmenu, _("&Synchronize panels"), NULL, this, XFileExplorer::ID_SYNCHRONIZE_PANELS);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "synchronize_panels", "Ctrl-Y");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(toolsmenu, _("Sw&itch panels"), NULL, this, XFileExplorer::ID_SWITCH_PANELS);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "switch_panels", "Ctrl-K");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(toolsmenu, _("Go to script folder"), NULL, lpanel, FilePanel::ID_GO_SCRIPTDIR);

    mc = new FXMenuCommand(toolsmenu, _("&Search files..."), NULL, this, XFileExplorer::ID_FILE_SEARCH);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "search", "Ctrl-F");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

#if defined(linux)
    new FXMenuSeparator(toolsmenu);

    mc = new FXMenuCommand(toolsmenu, _("&Mount"), NULL, lpanel, FilePanel::ID_MOUNT);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mount", "Ctrl-M");
    mc->setAccelText(key);

    mc = new FXMenuCommand(toolsmenu, _("&Unmount"), NULL, lpanel, FilePanel::ID_UMOUNT);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "unmount", "Ctrl-U");
    mc->setAccelText(key);
#endif
    toolsmenutitle = new FXMenuTitle(menubar, _("&Tools"), NULL, toolsmenu);

    // Help menu
    helpmenu = new FXMenuPane(this);

    mc = new FXMenuCommand(helpmenu, _("&Help"), NULL, this, ID_HELP);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "help", "F1");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuCommand(helpmenu, _("&About X File Explorer"), NULL, this, ID_ABOUT);
    helpmenutitle = new FXMenuTitle(menubar, _("&Help"), NULL, helpmenu);

    // Other accelerators

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "edit", "F4");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, lpanel, FXSEL(SEL_COMMAND, FilePanel::ID_EDIT));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "view", "Shift-F4");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, lpanel, FXSEL(SEL_COMMAND, FilePanel::ID_VIEW));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "compare", "F8");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, lpanel, FXSEL(SEL_COMMAND, FilePanel::ID_COMPARE));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_dirs", "Ctrl-F5");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, dirpanel, FXSEL(SEL_COMMAND, DirPanel::ID_TOGGLE_HIDDEN));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "filter", "Ctrl-D");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, lpanel, FXSEL(SEL_COMMAND, FilePanel::ID_FILTER_CURRENT));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, lpanel, FXSEL(SEL_COMMAND, FilePanel::ID_TOGGLE_HIDDEN));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, lpanel, FXSEL(SEL_COMMAND, FilePanel::ID_TOGGLE_THUMBNAILS));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "close", "Ctrl-W");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, this, FXSEL(SEL_COMMAND, XFileExplorer::ID_QUIT));

    // Escape key
    getAccelTable()->addAccel(KEY_Escape, lpanel, FXSEL(SEL_COMMAND, FilePanel::ID_DESELECT_ALL));

    // Make a tool tip
    new FXToolTip(app, 0);

    // File operations dialog
    rundialog = NULL;
    prefsdialog = NULL;
    helpwindow = NULL;
    searchwindow = NULL;

    // Initial focus is on (left) file panel
    panelfocus = FILEPANEL_FOCUS;

    // Trahscan locations
    trashfileslocation = xdgdatahome + PATHSEPSTRING TRASHFILESPATH;
    trashinfolocation = xdgdatahome + PATHSEPSTRING TRASHINFOPATH;

    // Start location (we return to the start location after each chdir)
    startlocation = FXSystem::getCurrentDirectory();

    // Other initializations
    starticonic = iconic;
    startmaximized = maximized;
    startdir1 = "";
    startdir2 = "";
    startURIs = URIs;
    nbstartfiles = 0;
    stop = false;

    // Class variables initializations
    panel_view = 0;
    RunHistSize = 0;
    liststyle = 0;
    twopanels_lpanel_pct = 0.0;
    treepanel_tree_pct = 0.0;
    treetwopanels_tree_pct = 0.0;
    treetwopanels_lpanel_pct = 0.0;
    search_xpos = 0;
    search_ypos = 0;
    search_width = 0;
    search_height = 0;
    winshow = true;

    // Read URIs to open on startup
    // Find if startdir1 and startdir2 are specified
    // Get the number of files to open, if any
    for (FXuint n = 0; n < startURIs.size(); n++)
    {
        if (::isDirectory(startURIs[n]))
        {
            if (startdir1 == "")
            {
                startdir1 = startURIs[n];
                continue;
            }
            if (startdir2 == "")
            {
                startdir2 = startURIs[n];
                continue;
            }
        }
        if (::isFile(startURIs[n]))
        {
            nbstartfiles++;
        }
    }

    prevdir = FXString::null;
    prev_width = getWidth();
}


// Save configuration when quitting
void XFileExplorer::saveConfig()
{
    // Get autosave flag
    FXbool auto_save_layout = getApp()->reg().readUnsignedEntry("OPTIONS", "auto_save_layout", true);

    if (auto_save_layout == true)
    {
        FXString sort_func;

        // Dir panel options
        if (dirpanel->getSortFunc() == DirList::ascendingCase)
        {
            sort_func = "ascendingCase";
        }
        else if (dirpanel->getSortFunc() == DirList::descendingCase)
        {
            sort_func = "descendingCase";
        }
        else if (dirpanel->getSortFunc() == DirList::ascending)
        {
            sort_func = "ascending";
        }
        else if (dirpanel->getSortFunc() == DirList::descending)
        {
            sort_func = "descending";
        }
        else
        {
            sort_func = "ascendingCase";
        }
        getApp()->reg().writeStringEntry("DIR PANEL", "sort_func", sort_func.text());
        getApp()->reg().writeUnsignedEntry("DIR PANEL", "hidden_dir", dirpanel->shownHiddenFiles());

        // Search panel options
        if (searchwindow)
        {
            // Search dialog properties
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "search_xpos", (FXuint)searchwindow->getX());
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "search_ypos", (FXuint)searchwindow->getY());
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "search_width", (FXuint)searchwindow->getWidth());
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "search_height", (FXuint)searchwindow->getHeight());
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "name_size", (FXuint)searchwindow->getHeaderSize(0));
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "dir_size", (FXuint)searchwindow->getHeaderSize(1));
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "size_size", (FXuint)searchwindow->getHeaderSize(2));
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "type_size", (FXuint)searchwindow->getHeaderSize(3));
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "ext_size", (FXuint)searchwindow->getHeaderSize(4));
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "modd_size", (FXuint)searchwindow->getHeaderSize(5));
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "user_size", (FXuint)searchwindow->getHeaderSize(6));
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "grou_size", (FXuint)searchwindow->getHeaderSize(7));
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "attr_size", (FXuint)searchwindow->getHeaderSize(8));
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "showthumbnails", (FXuint)searchwindow->shownThumbnails());
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "find_ignorecase", (FXuint)searchwindow->getFindIgnoreCase());
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "find_hidden", (FXuint)searchwindow->getFindHidden());
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "grep_ignorecase", (FXuint)searchwindow->getGrepIgnoreCase());
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "moreoptions", (FXuint)searchwindow->shownMoreOptions());
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "liststyle", (FXuint)searchwindow->getListStyle());
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "dirs_first", (FXuint)searchwindow->getDirsFirst());
            getApp()->reg().writeUnsignedEntry("SEARCH PANEL", "ignore_case", (FXuint)searchwindow->getIgnoreCase());

            // Get and write sort function for search window
            if (searchwindow->getSortFunc() == FileList::ascendingCase)
            {
                sort_func = "ascendingCase";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingCaseMix)
            {
                sort_func = "ascendingCaseMix";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingCase)
            {
                sort_func = "descendingCase";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingCaseMix)
            {
                sort_func = "descendingCaseMix";
            }
            else if (searchwindow->getSortFunc() == FileList::ascending)
            {
                sort_func = "ascending";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingMix)
            {
                sort_func = "ascendingMix";
            }
            else if (searchwindow->getSortFunc() == FileList::descending)
            {
                sort_func = "descending";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingMix)
            {
                sort_func = "descendingMix";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingDirCase)
            {
                sort_func = "ascendingDirCase";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingDirCaseMix)
            {
                sort_func = "ascendingDirCaseMix";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingDirCase)
            {
                sort_func = "descendingDirCase";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingDirCaseMix)
            {
                sort_func = "descendingDirCaseMix";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingDir)
            {
                sort_func = "ascendingDir";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingDirMix)
            {
                sort_func = "ascendingDirMix";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingDir)
            {
                sort_func = "descendingDir";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingDirMix)
            {
                sort_func = "descendingDirMix";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingSize)
            {
                sort_func = "ascendingSize";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingSizeMix)
            {
                sort_func = "ascendingSizeMix";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingSize)
            {
                sort_func = "descendingSize";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingSizeMix)
            {
                sort_func = "descendingSizeMix";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingType)
            {
                sort_func = "ascendingType";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingTypeMix)
            {
                sort_func = "ascendingTypeMix";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingType)
            {
                sort_func = "descendingType";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingTypeMix)
            {
                sort_func = "descendingTypeMix";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingExt)
            {
                sort_func = "ascendingExt";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingExtMix)
            {
                sort_func = "ascendingExtMix";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingExt)
            {
                sort_func = "descendingExt";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingExtMix)
            {
                sort_func = "descendingExtMix";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingTime)
            {
                sort_func = "ascendingTime";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingTimeMix)
            {
                sort_func = "ascendingTimeMix";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingTime)
            {
                sort_func = "descendingTime";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingTimeMix)
            {
                sort_func = "descendingTimeMix";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingUser)
            {
                sort_func = "ascendingUser";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingUserMix)
            {
                sort_func = "ascendingUserMix";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingUser)
            {
                sort_func = "descendingUser";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingUserMix)
            {
                sort_func = "descendingUserMix";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingGroup)
            {
                sort_func = "ascendingGroup";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingGroupMix)
            {
                sort_func = "ascendingGroupMix";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingGroup)
            {
                sort_func = "descendingGroup";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingGroupMix)
            {
                sort_func = "descendingGroupMix";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingPerm)
            {
                sort_func = "ascendingPerm";
            }
            else if (searchwindow->getSortFunc() == FileList::ascendingPermMix)
            {
                sort_func = "ascendingPermMix";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingPerm)
            {
                sort_func = "descendingPerm";
            }
            else if (searchwindow->getSortFunc() == FileList::descendingPermMix)
            {
                sort_func = "descendingPermMix";
            }
            else
            {
                sort_func = "ascendingCase";
            }
            getApp()->reg().writeStringEntry("SEARCH PANEL", "sort_func", sort_func.text());
        }

        // Left panel options
        getApp()->reg().writeUnsignedEntry("LEFT PANEL", "name_size", lpanel->getHeaderSize(0));
        getApp()->reg().writeUnsignedEntry("LEFT PANEL", "size_size", lpanel->getHeaderSize(1));
        getApp()->reg().writeUnsignedEntry("LEFT PANEL", "type_size", lpanel->getHeaderSize(2));
        getApp()->reg().writeUnsignedEntry("LEFT PANEL", "ext_size", lpanel->getHeaderSize(3));
        getApp()->reg().writeUnsignedEntry("LEFT PANEL", "modd_size", lpanel->getHeaderSize(4));
        getApp()->reg().writeUnsignedEntry("LEFT PANEL", "user_size", lpanel->getHeaderSize(5));
        getApp()->reg().writeUnsignedEntry("LEFT PANEL", "grou_size", lpanel->getHeaderSize(6));
        getApp()->reg().writeUnsignedEntry("LEFT PANEL", "attr_size", lpanel->getHeaderSize(7));
        getApp()->reg().writeUnsignedEntry("LEFT PANEL", "deldate_size", lpanel->getHeaderSize(8));
        getApp()->reg().writeUnsignedEntry("LEFT PANEL", "origpath_size", lpanel->getHeaderSize(9));
        getApp()->reg().writeUnsignedEntry("LEFT PANEL", "liststyle", lpanel->getListStyle());
        getApp()->reg().writeUnsignedEntry("LEFT PANEL", "hiddenfiles", lpanel->shownHiddenFiles());
        getApp()->reg().writeUnsignedEntry("LEFT PANEL", "showthumbnails", lpanel->shownThumbnails());

        // Get and write sort function for left panel
        if (lpanel->getSortFunc() == FileList::ascendingCase)
        {
            sort_func = "ascendingCase";
        }
        else if (lpanel->getSortFunc() == FileList::ascendingCaseMix)
        {
            sort_func = "ascendingCaseMix";
        }
        else if (lpanel->getSortFunc() == FileList::descendingCase)
        {
            sort_func = "descendingCase";
        }
        else if (lpanel->getSortFunc() == FileList::descendingCaseMix)
        {
            sort_func = "descendingCaseMix";
        }
        else if (lpanel->getSortFunc() == FileList::ascending)
        {
            sort_func = "ascending";
        }
        else if (lpanel->getSortFunc() == FileList::ascendingMix)
        {
            sort_func = "ascendingMix";
        }
        else if (lpanel->getSortFunc() == FileList::descending)
        {
            sort_func = "descending";
        }
        else if (lpanel->getSortFunc() == FileList::descendingMix)
        {
            sort_func = "descendingMix";
        }
        else if (lpanel->getSortFunc() == FileList::ascendingSize)
        {
            sort_func = "ascendingSize";
        }
        else if (lpanel->getSortFunc() == FileList::ascendingSizeMix)
        {
            sort_func = "ascendingSizeMix";
        }
        else if (lpanel->getSortFunc() == FileList::descendingSize)
        {
            sort_func = "descendingSize";
        }
        else if (lpanel->getSortFunc() == FileList::descendingSizeMix)
        {
            sort_func = "descendingSizeMix";
        }
        else if (lpanel->getSortFunc() == FileList::ascendingType)
        {
            sort_func = "ascendingType";
        }
        else if (lpanel->getSortFunc() == FileList::ascendingTypeMix)
        {
            sort_func = "ascendingTypeMix";
        }
        else if (lpanel->getSortFunc() == FileList::descendingType)
        {
            sort_func = "descendingType";
        }
        else if (lpanel->getSortFunc() == FileList::descendingTypeMix)
        {
            sort_func = "descendingTypeMix";
        }
        else if (lpanel->getSortFunc() == FileList::ascendingExt)
        {
            sort_func = "ascendingExt";
        }
        else if (lpanel->getSortFunc() == FileList::ascendingExtMix)
        {
            sort_func = "ascendingExtMix";
        }
        else if (lpanel->getSortFunc() == FileList::descendingExt)
        {
            sort_func = "descendingExt";
        }
        else if (lpanel->getSortFunc() == FileList::descendingExtMix)
        {
            sort_func = "descendingExtMix";
        }
        else if (lpanel->getSortFunc() == FileList::ascendingTime)
        {
            sort_func = "ascendingTime";
        }
        else if (lpanel->getSortFunc() == FileList::ascendingTimeMix)
        {
            sort_func = "ascendingTimeMix";
        }
        else if (lpanel->getSortFunc() == FileList::descendingTime)
        {
            sort_func = "descendingTime";
        }
        else if (lpanel->getSortFunc() == FileList::descendingTimeMix)
        {
            sort_func = "descendingTimeMix";
        }
        else if (lpanel->getSortFunc() == FileList::ascendingUser)
        {
            sort_func = "ascendingUser";
        }
        else if (lpanel->getSortFunc() == FileList::ascendingUserMix)
        {
            sort_func = "ascendingUserMix";
        }
        else if (lpanel->getSortFunc() == FileList::descendingUser)
        {
            sort_func = "descendingUser";
        }
        else if (lpanel->getSortFunc() == FileList::descendingUserMix)
        {
            sort_func = "descendingUserMix";
        }
        else if (lpanel->getSortFunc() == FileList::ascendingGroup)
        {
            sort_func = "ascendingGroup";
        }
        else if (lpanel->getSortFunc() == FileList::ascendingGroupMix)
        {
            sort_func = "ascendingGroupMix";
        }
        else if (lpanel->getSortFunc() == FileList::descendingGroup)
        {
            sort_func = "descendingGroup";
        }
        else if (lpanel->getSortFunc() == FileList::descendingGroupMix)
        {
            sort_func = "descendingGroupMix";
        }
        else if (lpanel->getSortFunc() == FileList::ascendingPerm)
        {
            sort_func = "ascendingPerm";
        }
        else if (lpanel->getSortFunc() == FileList::ascendingPermMix)
        {
            sort_func = "ascendingPermMix";
        }
        else if (lpanel->getSortFunc() == FileList::descendingPerm)
        {
            sort_func = "descendingPerm";
        }
        else if (lpanel->getSortFunc() == FileList::descendingPermMix)
        {
            sort_func = "descendingPermMix";
        }
        else
        {
            sort_func = "ascendingCase";
        }
        getApp()->reg().writeStringEntry("LEFT PANEL", "sort_func", sort_func.text());
        getApp()->reg().writeUnsignedEntry("LEFT PANEL", "ignore_case", lpanel->getIgnoreCase());
        getApp()->reg().writeUnsignedEntry("LEFT PANEL", "dirs_first", lpanel->getDirsFirst());

        // Right panel options
        getApp()->reg().writeUnsignedEntry("RIGHT PANEL", "name_size", rpanel->getHeaderSize(0));
        getApp()->reg().writeUnsignedEntry("RIGHT PANEL", "size_size", rpanel->getHeaderSize(1));
        getApp()->reg().writeUnsignedEntry("RIGHT PANEL", "type_size", rpanel->getHeaderSize(2));
        getApp()->reg().writeUnsignedEntry("RIGHT PANEL", "ext_size", rpanel->getHeaderSize(3));
        getApp()->reg().writeUnsignedEntry("RIGHT PANEL", "modd_size", rpanel->getHeaderSize(4));
        getApp()->reg().writeUnsignedEntry("RIGHT PANEL", "user_size", rpanel->getHeaderSize(5));
        getApp()->reg().writeUnsignedEntry("RIGHT PANEL", "grou_size", rpanel->getHeaderSize(6));
        getApp()->reg().writeUnsignedEntry("RIGHT PANEL", "attr_size", rpanel->getHeaderSize(7));
        getApp()->reg().writeUnsignedEntry("RIGHT PANEL", "deldate_size", rpanel->getHeaderSize(8));
        getApp()->reg().writeUnsignedEntry("RIGHT PANEL", "origpath_size", rpanel->getHeaderSize(9));
        getApp()->reg().writeUnsignedEntry("RIGHT PANEL", "liststyle", rpanel->getListStyle());
        getApp()->reg().writeUnsignedEntry("RIGHT PANEL", "hiddenfiles", rpanel->shownHiddenFiles());
        getApp()->reg().writeUnsignedEntry("RIGHT PANEL", "showthumbnails", rpanel->shownThumbnails());

        // Get and write sort function for right panel
        if (rpanel->getSortFunc() == FileList::ascendingCase)
        {
            sort_func = "ascendingCase";
        }
        else if (rpanel->getSortFunc() == FileList::ascendingCaseMix)
        {
            sort_func = "ascendingCaseMix";
        }
        else if (rpanel->getSortFunc() == FileList::descendingCase)
        {
            sort_func = "descendingCase";
        }
        else if (rpanel->getSortFunc() == FileList::descendingCaseMix)
        {
            sort_func = "descendingCaseMix";
        }
        else if (rpanel->getSortFunc() == FileList::ascending)
        {
            sort_func = "ascending";
        }
        else if (rpanel->getSortFunc() == FileList::ascendingMix)
        {
            sort_func = "ascendingMix";
        }
        else if (rpanel->getSortFunc() == FileList::descending)
        {
            sort_func = "descending";
        }
        else if (rpanel->getSortFunc() == FileList::descendingMix)
        {
            sort_func = "descendingMix";
        }
        else if (rpanel->getSortFunc() == FileList::ascendingSize)
        {
            sort_func = "ascendingSize";
        }
        else if (rpanel->getSortFunc() == FileList::ascendingSizeMix)
        {
            sort_func = "ascendingSizeMix";
        }
        else if (rpanel->getSortFunc() == FileList::descendingSize)
        {
            sort_func = "descendingSize";
        }
        else if (rpanel->getSortFunc() == FileList::descendingSizeMix)
        {
            sort_func = "descendingSizeMix";
        }
        else if (rpanel->getSortFunc() == FileList::ascendingType)
        {
            sort_func = "ascendingType";
        }
        else if (rpanel->getSortFunc() == FileList::ascendingTypeMix)
        {
            sort_func = "ascendingTypeMix";
        }
        else if (rpanel->getSortFunc() == FileList::descendingType)
        {
            sort_func = "descendingType";
        }
        else if (rpanel->getSortFunc() == FileList::descendingTypeMix)
        {
            sort_func = "descendingTypeMix";
        }
        else if (rpanel->getSortFunc() == FileList::ascendingExt)
        {
            sort_func = "ascendingExt";
        }
        else if (rpanel->getSortFunc() == FileList::ascendingExtMix)
        {
            sort_func = "ascendingExtMix";
        }
        else if (rpanel->getSortFunc() == FileList::descendingExt)
        {
            sort_func = "descendingExt";
        }
        else if (rpanel->getSortFunc() == FileList::descendingExtMix)
        {
            sort_func = "descendingExtMix";
        }
        else if (rpanel->getSortFunc() == FileList::ascendingTime)
        {
            sort_func = "ascendingTime";
        }
        else if (rpanel->getSortFunc() == FileList::ascendingTimeMix)
        {
            sort_func = "ascendingTimeMix";
        }
        else if (rpanel->getSortFunc() == FileList::descendingTime)
        {
            sort_func = "descendingTime";
        }
        else if (rpanel->getSortFunc() == FileList::descendingTimeMix)
        {
            sort_func = "descendingTimeMix";
        }
        else if (rpanel->getSortFunc() == FileList::ascendingUser)
        {
            sort_func = "ascendingUser";
        }
        else if (rpanel->getSortFunc() == FileList::ascendingUserMix)
        {
            sort_func = "ascendingUserMix";
        }
        else if (rpanel->getSortFunc() == FileList::descendingUser)
        {
            sort_func = "descendingUser";
        }
        else if (rpanel->getSortFunc() == FileList::descendingUserMix)
        {
            sort_func = "descendingUserMix";
        }
        else if (rpanel->getSortFunc() == FileList::ascendingGroup)
        {
            sort_func = "ascendingGroup";
        }
        else if (rpanel->getSortFunc() == FileList::ascendingGroupMix)
        {
            sort_func = "ascendingGroupMix";
        }
        else if (rpanel->getSortFunc() == FileList::descendingGroup)
        {
            sort_func = "descendingGroup";
        }
        else if (rpanel->getSortFunc() == FileList::descendingGroupMix)
        {
            sort_func = "descendingGroupMix";
        }
        else if (rpanel->getSortFunc() == FileList::ascendingPerm)
        {
            sort_func = "ascendingPerm";
        }
        else if (rpanel->getSortFunc() == FileList::ascendingPermMix)
        {
            sort_func = "ascendingPermMix";
        }
        else if (rpanel->getSortFunc() == FileList::descendingPerm)
        {
            sort_func = "descendingPerm";
        }
        else if (rpanel->getSortFunc() == FileList::descendingPermMix)
        {
            sort_func = "descendingPermMix";
        }
        else
        {
            sort_func = "ascendingCase";
        }
        getApp()->reg().writeStringEntry("RIGHT PANEL", "sort_func", sort_func.text());
        getApp()->reg().writeUnsignedEntry("RIGHT PANEL", "ignore_case", rpanel->getIgnoreCase());
        getApp()->reg().writeUnsignedEntry("RIGHT PANEL", "dirs_first", rpanel->getDirsFirst());

        // Global options
        getApp()->reg().writeUnsignedEntry("OPTIONS", "width", (FXuint)getWidth());
        getApp()->reg().writeUnsignedEntry("OPTIONS", "height", (FXuint)getHeight());

        // Get value of window position flag and position the window
        FXbool save_win_pos = getApp()->reg().readUnsignedEntry("SETTINGS", "save_win_pos", false);
        if (save_win_pos)
        {
            // Account for the Window Manager border size
            XWindowAttributes xwattr;
            if (XGetWindowAttributes((Display*)getApp()->getDisplay(), this->id(), &xwattr))
            {
                getApp()->reg().writeIntEntry("OPTIONS", "xpos", getX()-xwattr.x);
                getApp()->reg().writeIntEntry("OPTIONS", "ypos", getY()-xwattr.y);
            }
            else
            {
                getApp()->reg().writeIntEntry("OPTIONS", "xpos", getX());
                getApp()->reg().writeIntEntry("OPTIONS", "ypos", getY());
            }
        }
        getApp()->reg().writeUnsignedEntry("OPTIONS", "generaltoolbar", (FXuint)generaltoolbar->shown());
        getApp()->reg().writeUnsignedEntry("OPTIONS", "toolstoolbar", (FXuint)toolstoolbar->shown());
        getApp()->reg().writeUnsignedEntry("OPTIONS", "paneltoolbar", (FXuint)paneltoolbar->shown());
        getApp()->reg().writeUnsignedEntry("OPTIONS", "locationbar", (FXuint)locationbar->shown());
        getApp()->reg().writeUnsignedEntry("OPTIONS", "status", (FXuint)lpanel->statusbarShown());
        getApp()->reg().writeUnsignedEntry("SETTINGS", "file_tooltips", (FXuint)file_tooltips);
        getApp()->reg().writeUnsignedEntry("SETTINGS", "relative_resize", (FXuint)relative_resize);
        getApp()->reg().writeRealEntry("OPTIONS", "treepanel_tree_pct", (int)(treepanel_tree_pct*1000)/1000.0);
        getApp()->reg().writeRealEntry("OPTIONS", "twopanels_lpanel_pct", (int)(twopanels_lpanel_pct*1000)/1000.0);
        getApp()->reg().writeRealEntry("OPTIONS", "treetwopanels_tree_pct", (int)(treetwopanels_tree_pct*1000)/1000.0);
        getApp()->reg().writeRealEntry("OPTIONS", "treetwopanels_lpanel_pct", (int)(treetwopanels_lpanel_pct*1000)/1000.0);

        // Panel stacking
        getApp()->reg().writeUnsignedEntry("OPTIONS", "vert_panels", vertpanels);

        // Save panel view only if not given from command line
        if (panel_mode == -1)
        {
            getApp()->reg().writeUnsignedEntry("OPTIONS", "panel_view", (FXuint)panel_view);
        }

        getApp()->reg().writeUnsignedEntry("SETTINGS", "single_click", single_click);

        FXString history = "";
        for (int i = 0; i < RunHistSize; i++)
        {
            history += RunHistory[i];
            history += ":";
        }
        if (RunHistSize)
        {
            getApp()->reg().writeStringEntry("HISTORY", "run", history.text());
        }

        history = "";
        for (int i = 0; i < OpenNum; i++)
        {
            history += OpenHistory[i];
            history += ":";
        }
        if (OpenNum)
        {
            getApp()->reg().writeStringEntry("HISTORY", "open", history.text());
        }

        history = "";
        for (int i = 0; i < FilterNum; i++)
        {
            history += FilterHistory[i];
            history += ":";
        }
        if (FilterNum)
        {
            getApp()->reg().writeStringEntry("HISTORY", "filter", history.text());
        }
    }

    // Last visited directories
    getApp()->reg().writeStringEntry("LEFT PANEL", "lastdir", lpanel->getDirectory().text());
    getApp()->reg().writeStringEntry("RIGHT PANEL", "lastdir", rpanel->getDirectory().text());

    getApp()->reg().write();
}



// Make application
void XFileExplorer::create()
{
    // Switch to two panels mode if startdir2 was specified
    // and no particular panel mode was selected
    if ((startdir2 != "") && (panel_mode == -1))
    {
        panel_mode = 2;
    }

    // Eventually select panel mode from the command line option
    // or revert to last saved panel view
    switch (panel_mode)
    {
    case 0:
        panel_view = TREE_PANEL;
        break;

    case 1:
        panel_view = ONE_PANEL;
        break;

    case 2:
        panel_view = TWO_PANELS;
        break;

    case 3:
        panel_view = TREE_TWO_PANELS;
        break;

    default:
        panel_view = getApp()->reg().readUnsignedEntry("OPTIONS", "panel_view", TREE_PANEL);
    }

    int width = getApp()->reg().readUnsignedEntry("OPTIONS", "width", DEFAULT_WINDOW_WIDTH);
    int height = getApp()->reg().readUnsignedEntry("OPTIONS", "height", DEFAULT_WINDOW_HEIGHT);
    int save_win_pos = getApp()->reg().readUnsignedEntry("SETTINGS", "save_win_pos", false);
    if (save_win_pos)
    {
        int xpos = getApp()->reg().readIntEntry("OPTIONS", "xpos", DEFAULT_WINDOW_XPOS);
        int ypos = getApp()->reg().readIntEntry("OPTIONS", "ypos", DEFAULT_WINDOW_YPOS);
        position(xpos, ypos, width, height);
    }
    else
    {
        position(getX(), getY(), width, height);
    }

    // Search dialog geometry
    search_xpos = getApp()->reg().readUnsignedEntry("SEARCH PANEL", "search_xpos", 200);
    search_ypos = getApp()->reg().readUnsignedEntry("SEARCH PANEL", "search_ypos", 200);
    search_width = getApp()->reg().readUnsignedEntry("SEARCH PANEL", "search_width", 650);
    search_height = getApp()->reg().readUnsignedEntry("SEARCH PANEL", "search_height", 480);

    FXMainWindow::create();

    twopanels_lpanel_pct = getApp()->reg().readRealEntry("OPTIONS", "twopanels_lpanel_pct", 0.50);
    treepanel_tree_pct = getApp()->reg().readRealEntry("OPTIONS", "treepanel_tree_pct", 0.20);
    treetwopanels_tree_pct = getApp()->reg().readRealEntry("OPTIONS", "treetwopanels_tree_pct", 0.20);
    treetwopanels_lpanel_pct = getApp()->reg().readRealEntry("OPTIONS", "treetwopanels_lpanel_pct", 0.40);

    int window_width = getWidth();
    int window_height = getHeight();

    switch (panel_view)
    {
    case ONE_PANEL:
        rpanel->hide();
        dirpanel->hide();
        // Handle drag corner
        rpanel->showCorner(false);
        lpanel->showCorner(true);
        // Handle active icon
        lpanel->showActiveIcon(false);
        lpanel->setWidth((int)round(1.0*window_width));
        break;

    case TWO_PANELS:
        dirpanel->hide();
        if (vertpanels)
        {
            lpanel->setWidth((int)round(twopanels_lpanel_pct*window_width));
        }
        else
        {
            lpanel->setHeight((int)round(twopanels_lpanel_pct*window_height));
        }
        // Handle drag corner
        rpanel->showCorner(true);
        lpanel->showCorner(false);
        // Handle active icon
        lpanel->showActiveIcon(true);
        break;

    case TREE_PANEL:
        rpanel->hide();
        dirpanel->setWidth((int)round(treepanel_tree_pct*window_width));
        lpanel->setWidth((int)round((1.0-treepanel_tree_pct)*window_width));
        // Handle drag corner
        rpanel->showCorner(false);
        lpanel->showCorner(true);
        // Handle active icon
        lpanel->showActiveIcon(true);
        break;

    case TREE_TWO_PANELS:
        dirpanel->setWidth((int)round(treetwopanels_tree_pct*window_width));
        if (vertpanels)
        {
            lpanel->setWidth((int)round(treetwopanels_lpanel_pct*window_width));
        }
        else
        {
            lpanel->setHeight((int)round(treetwopanels_lpanel_pct*window_height));
        }
        // Handle drag corner
        rpanel->showCorner(true);
        lpanel->showCorner(false);
        // Handle active icon
        lpanel->showActiveIcon(true);
        break;
    }

    if (!getApp()->reg().readUnsignedEntry("OPTIONS", "generaltoolbar", true))
    {
        generaltoolbar->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_TOGGLESHOWN), NULL);
    }
    if (!getApp()->reg().readUnsignedEntry("OPTIONS", "toolstoolbar", true))
    {
        toolstoolbar->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_TOGGLESHOWN), NULL);
    }
    if (!getApp()->reg().readUnsignedEntry("OPTIONS", "paneltoolbar", true))
    {
        paneltoolbar->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_TOGGLESHOWN), NULL);
    }
    if (!getApp()->reg().readUnsignedEntry("OPTIONS", "locationbar", true))
    {
        locationbar->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_TOGGLESHOWN), NULL);
    }
    if (!getApp()->reg().readUnsignedEntry("OPTIONS", "status", true))
    {
        handle(this, FXSEL(SEL_COMMAND, XFileExplorer::ID_TOGGLE_STATUS), NULL);
    }
    file_tooltips = getApp()->reg().readUnsignedEntry("SETTINGS", "file_tooltips", 1);
    relative_resize = getApp()->reg().readUnsignedEntry("SETTINGS", "relative_resize", 1);

    // Wheel scrolling
    int wheellines = getApp()->reg().readUnsignedEntry("SETTINGS", "wheellines", 5);
    getApp()->setWheelLines(wheellines);

    // Scrollbar size
    int barsize = getApp()->reg().readUnsignedEntry("SETTINGS", "scrollbarsize", 15);
    getApp()->setScrollBarSize(barsize);

    // If there are only files to open, tell Xfe not to show its window
    winshow = true;
    if ((startdir1 == "") && (startdir2 == "") && (nbstartfiles > 0))
    {
        winshow = false;
    }

    // Read start directory mode
    int startdirmode = getApp()->reg().readUnsignedEntry("OPTIONS", "startdir_mode", START_HOMEDIR);

    // Open left and right panels in starting directories (if specified) or in home / current or last directory
    if (startdir1 == "")
    {
        switch (startdirmode)
        {
        case START_HOMEDIR:
            startdir1 = FXSystem::getHomeDirectory();
            break;

        case START_CURRENTDIR:
            startdir1 = FXSystem::getCurrentDirectory();
            break;

        case START_LASTDIR:
            startdir1 = getApp()->reg().readStringEntry("LEFT PANEL", "lastdir", ROOTDIR);
            break;
        }
    }
    if (startdir2 == "")
    {
        switch (startdirmode)
        {
        case START_HOMEDIR:
            startdir2 = FXSystem::getHomeDirectory();
            break;

        case START_CURRENTDIR:
            startdir2 = FXSystem::getCurrentDirectory();
            break;

        case START_LASTDIR:
            startdir2 = getApp()->reg().readStringEntry("RIGHT PANEL", "lastdir", ROOTDIR);
            break;
        }
    }

    lpanel->setDirectory(startdir1, true);
    lpanel->setPathLink(startdir1);
    lpanel->setPathText(startdir1);
    rpanel->setDirectory(startdir2, true);
    rpanel->setPathLink(startdir2);
    rpanel->setPathText(startdir2);
    dirpanel->setDirectory(startdir1, true);

    // Open file on startup, if any
    if (nbstartfiles > 0)
    {
        openFiles(startURIs);
    }

    // Show window
    if (winshow)
    {
        show();
    }

    // Set file panels list style
    liststyle = getApp()->reg().readUnsignedEntry("LEFT PANEL", "liststyle", _ICONLIST_DETAILED );
    lpanel->setListStyle(liststyle);
    liststyle = getApp()->reg().readUnsignedEntry("RIGHT PANEL", "liststyle", _ICONLIST_DETAILED );
    rpanel->setListStyle(liststyle);

    // Show or hide hidden files listed in panels
    FXbool hiddenfiles = getApp()->reg().readUnsignedEntry("LEFT PANEL", "hiddenfiles", 0);
    lpanel->showHiddenFiles(hiddenfiles);
    hiddenfiles = getApp()->reg().readUnsignedEntry("RIGHT PANEL", "hiddenfiles", 0);
    rpanel->showHiddenFiles(hiddenfiles);

    // Show or hide hidden directories listed in dirpanel
    FXbool hidden_dir = getApp()->reg().readUnsignedEntry("DIR PANEL", "hidden_dir", 0);
    dirpanel->showHiddenFiles(hidden_dir);

    // History
    FXString history = getApp()->reg().readStringEntry("HISTORY", "run", "");
    int      i;
    FXString histent;
    RunHistSize = 0;
    if (history != "")
    {
        for (i = 0; ; i++)
        {
            histent = history.section(':', i);
            if (streq(histent.text(), ""))
            {
                break;
            }
            strlcpy(RunHistory[i], histent.text(), histent.length()+1);
        }
        RunHistSize = i;
    }

    history = getApp()->reg().readStringEntry("HISTORY", "open", "");
    histent = "";
    OpenNum = 0;
    if (history != "")
    {
        for (i = 0; ; i++)
        {
            histent = history.section(':', i);
            if (streq(histent.text(), ""))
            {
                break;
            }
            strlcpy(OpenHistory[i], histent.text(), histent.length()+1);
        }
        OpenNum = i;
    }

    history = getApp()->reg().readStringEntry("HISTORY", "filter", "");
    histent = "";
    FilterNum = 0;
    if (history != "")
    {
        for (i = 0; ; i++)
        {
            histent = history.section(':', i);
            if (streq(histent.text(), ""))
            {
                break;
            }
            strlcpy(FilterHistory[i], histent.text(), histent.length()+1);
        }
        FilterNum = i;
    }

    getApp()->forceRefresh();

    // Running as root?
    FXbool root_warn = getApp()->reg().readUnsignedEntry("OPTIONS", "root_warn", true);
    if ((getuid() == 0) && root_warn)
    {
        MessageBox::information(this, BOX_OK, _("Warning"), _("Running Xfe as root!"));
    }

    // Initial focus is always on the left panel
    lpanel->setFocusOnList();

#if defined(linux)
    // Warning message if a mount point is down
    FXbool mount_warn = getApp()->reg().readUnsignedEntry("OPTIONS", "mount_warn", true);
    if (mount_warn)
    {
        int d;
        for (d = updevices->first(); d < updevices->size(); d = updevices->next(d))
        {
            if (streq(updevices->data(d), "down"))
            {
                MessageBox::warning(this, BOX_OK, _("Warning"), _("Mount point %s is not responding..."), updevices->key(d));
            }
        }
    }
#endif

    // If no Xfe local configuration exists (i.e. at first call or after a purge of the configuration files),
    // copy the global xferc file to the local configuration directory, and read / write the registry
    int      mask;
    FXString configlocation = xdgconfighome + PATHSEPSTRING XFECONFIGPATH;
    FXString configpath = configlocation + PATHSEPSTRING XFECONFIGNAME;
    if (!::exists(configpath))
    {
        // If old configuration path (i.e. ~/.xfe) exists then warn the user about the new configuration scheme
        FXString oldconfigpath = homedir + PATHSEPSTRING ".xfe";
        if (::exists(oldconfigpath))
        {
            // Display warning message
            FXString message;
            message.format(_("Starting from Xfe 1.32, the location of the configuration files has changed to '%s'.\nNote you can manually edit the new configuration files to import your old customizations..."), configlocation.text());
            MessageBox::warning(this, BOX_OK, _("Warning"), "%s", message.text());
        }

        // Create ~/.config/xfe directory if it doesn't exist
        if (!::exists(configlocation))
        {
            // Create the ~/.config/xfe directory according to the umask
            mask = umask(0);
            umask(mask);
            errno = 0;
            int ret = mkpath(configlocation.text(), 511 & ~mask);
            int errcode = errno;
            if (ret == -1)
            {
                if (errcode)
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't create Xfe config folder %s: %s"), configlocation.text(), strerror(errcode));
                }
                else
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _("Can't create Xfe config folder %s"), configlocation.text());
                }
            }
        }

        // Copy the global xfrec file (three possible locations) to the local configuration file
        if (::exists("/usr/share/xfe/xferc"))
        {
            FXFile::copy("/usr/share/xfe/xferc", configpath, false);
        }
        else if (::exists("/usr/local/share/xfe/xferc"))
        {
            FXFile::copy("/usr/local/share/xfe/xferc", configpath, false);
        }
        else if (::exists("/opt/local/share/xfe/xferc"))
        {
            FXFile::copy("/opt/local/share/xfe/xferc", configpath, false);
        }

        // If nothing is found, display a file dialog to let the user choose the right place
        else
        {
            FileDialog browse(this, _("No global xferc file found! Please select a configuration file..."));

            const char* patterns[] =
            {
                _("XFE configuration file"), "*xferc*", NULL
            };
            browse.setFilename(ROOTDIR);
            browse.setPatternList(patterns);
            if (browse.execute())
            {
                FXString path = browse.getFilename();
                FXFile::copy(path, configpath, false);
            }
        }

        // Read and write the registry
        getApp()->reg().read();
        getApp()->reg().write();
    }

    // Create trash can files directory if it doesn't exist
    if (!::exists(trashfileslocation))
    {
        // Create the trash can files directory according to the umask
        mask = umask(0);
        umask(mask);
        errno = 0;
        int ret = mkpath(trashfileslocation.text(), 511 & ~mask);
        int errcode = errno;
        if (ret == -1)
        {
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create trash can 'files' folder %s: %s"), trashfileslocation.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create trash can 'files' folder %s"), trashfileslocation.text());
            }
        }
    }

    // Create trash can info directory if it doesn't exist
    if (!::exists(trashinfolocation))
    {
        // Create the trash can info directory according to the umask
        mask = umask(0);
        umask(mask);
        errno = 0;
        int ret = mkpath(trashinfolocation.text(), 511 & ~mask);
        int errcode = errno;
        if (ret == -1)
        {
            if (errcode)
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create trash can 'info' folder %s: %s"), trashinfolocation.text(), strerror(errcode));
            }
            else
            {
                MessageBox::error(this, BOX_OK, _("Error"), _("Can't create trash can 'info' folder %s"), trashinfolocation.text());
            }
        }
    }

    // If necessary, replace the old default view command "xfv" with the new one
    if (getApp()->reg().readUnsignedEntry("OPTIONS", "xfv_replaced", false) == false)
    {
        FXStringDict* strdict = getApp()->reg().find("FILETYPES");
        FileDict*     assoc = new FileDict(getApp());

        FXString key, value, newvalue;
        FXString strtmp, open, view, edit, command;
        for (int i = strdict->first(); i < strdict->size(); i = strdict->next(i))
        {
            // Read key and value of each filetype
            key = strdict->key(i);
            value = strdict->data(i);

            // Replace the old txtviewer string with the new one
            if (value.contains("xfv"))
            {
                // Obtain the open, view, edit and command strings
                strtmp = value.before(';', 1);
                command = value.after(';', 1);
                open = strtmp.section(',', 0);
                view = strtmp.section(',', 1);
                edit = strtmp.section(',', 2);

                // Replace the view command with the new value
                value = open + "," + DEFAULT_TXTVIEWER + "," + edit + ";" + command;
                assoc->replace(key.text(), value.text());
            }
        }

        // Wrire registry
        getApp()->reg().write();
        getApp()->reg().writeUnsignedEntry("OPTIONS", "xfv_replaced", true);
    }

    // Eventually start iconic or maximized
    if (starticonic)
    {
        minimize();
    }
    if (startmaximized)
    {
        maximize();
    }

#ifdef STARTUP_NOTIFICATION
    startup_completed();
#endif

    // Tell Xfe to stop, if we didn't show its window
    if (!winshow)
    {
        stop = true;
    }
}


// Destructor
XFileExplorer::~XFileExplorer()
{
    delete menubar;
    delete locationbar;
    delete address;
    delete filemenu;
    delete toolsmenu;
    delete trashmenu;
    delete editmenu;
    delete bookmarksmenu;
    delete viewmenu;
    delete lpanelmenu;
    delete rpanelmenu;
    delete helpmenu;
    delete filemenutitle;
    delete trashmenutitle;
    delete editmenutitle;
    delete bookmarksmenutitle;
    delete viewmenutitle;
    delete lpanelmenutitle;
    delete rpanelmenutitle;
    delete helpmenutitle;
    delete generaltoolbar;
    delete paneltoolbar;
    delete toolstoolbar;
    delete dirpanel;
    delete lpanel;
    delete rpanel;
    delete bookmarks;
    delete btnbackhist;
    delete btnforwardhist;
    delete rundialog;
    delete prefsdialog;
    delete helpwindow;
    delete searchwindow;
}


// If Tab pressed, cycle through the panels
long XFileExplorer::onKeyPress(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;
    int      current;

    // Tab was pressed : cycle through the panels from left to right
    if (event->code == KEY_Tab)
    {
        if (dirpanel->shown())
        {
            if (dirpanel->isActive())
            {
                lpanel->setFocusOnList();
                current = lpanel->getCurrentItem();
                if (current < 0)
                {
                    current = 0;
                }
                lpanel->setCurrentItem(current);
                lpanel->selectItem(current);
            }
            else if ((rpanel->shown()) && (lpanel->isActive()))
            {
                rpanel->setFocusOnList();
                current = rpanel->getCurrentItem();
                if (current < 0)
                {
                    current = 0;
                }
                rpanel->setCurrentItem(current);
                rpanel->selectItem(current);
            }
            else
            {
                dirpanel->setFocusOnList();
                current = lpanel->getCurrentItem();
                if (current < 0)
                {
                    current = 0;
                }
                lpanel->deselectItem(current);
            }
        }
        else if (rpanel->shown())
        {
            if (lpanel->getCurrent() == rpanel)
            {
                lpanel->setActive();
                current = lpanel->getCurrentItem();
                if (current < 0)
                {
                    current = 0;
                }
                lpanel->setCurrentItem(current);
                lpanel->selectItem(current);
            }
            else
            {
                rpanel->setActive();
                current = rpanel->getCurrentItem();
                if (current < 0)
                {
                    current = 0;
                }
                rpanel->setCurrentItem(current);
                rpanel->selectItem(current);
            }
        }
        return(1);
    }

    // Shift-Tab was pressed : cycle through the panels from right to left
    else if (((event->state&SHIFTMASK) && (event->code == KEY_Tab)) ||
             ((event->state&SHIFTMASK) && (event->code == KEY_ISO_Left_Tab)))
    {
        if (rpanel->shown())
        {
            if (rpanel->isActive())
            {
                lpanel->setFocusOnList();
                current = lpanel->getCurrentItem();
                if (current < 0)
                {
                    current = 0;
                }
                lpanel->setCurrentItem(current);
                lpanel->selectItem(current);
            }
            else if (dirpanel->shown() && dirpanel->isActive())
            {
                rpanel->setFocusOnList();
                current = rpanel->getCurrentItem();
                if (current < 0)
                {
                    current = 0;
                }
                rpanel->setCurrentItem(current);
                rpanel->selectItem(current);
            }
            else if (lpanel->isActive())
            {
                if (dirpanel->shown())
                {
                    dirpanel->setFocusOnList();
                    current = lpanel->getCurrentItem();
                    if (current < 0)
                    {
                        current = 0;
                    }
                    lpanel->deselectItem(current);
                }
                else
                {
                    rpanel->setFocusOnList();
                    current = rpanel->getCurrentItem();
                    if (current < 0)
                    {
                        current = 0;
                    }
                    rpanel->setCurrentItem(current);
                    rpanel->selectItem(current);
                }
            }
        }
        else
        {
            if (dirpanel->isActive() && dirpanel->shown())
            {
                lpanel->setFocusOnList();
                current = lpanel->getCurrentItem();
                if (current < 0)
                {
                    current = 0;
                }
                lpanel->setCurrentItem(current);
                lpanel->selectItem(current);
            }
            else if (dirpanel->shown())
            {
                dirpanel->setFocusOnList();
                current = lpanel->getCurrentItem();
                if (current < 0)
                {
                    current = 0;
                }
                lpanel->deselectItem(current);
            }
        }

        return(1);
    }

    // Shift-F10 or Menu was pressed : open popup menu
   	else if ((event->state&SHIFTMASK && event->code == KEY_F10) || event->code == KEY_Menu)
    {
        lpanel->getCurrent()->handle(sender, FXSEL(SEL_COMMAND, FilePanel::ID_POPUP_MENU), ptr);
        return(1);
    }

    // Any other key was pressed : handle the pressed key in the usual way
    else
    {
        if (FXTopWindow::onKeyPress(sender, sel, ptr))
        {
            return(1);
        }
    }

    return(0);
}


long XFileExplorer::onKeyRelease(FXObject* sender, FXSelector sel, void* ptr)
{
    if (FXTopWindow::onKeyRelease(sender, sel, ptr))
    {
        return(1);
    }

    return(0);
}


// Harvest the zombies
long XFileExplorer::onSigHarvest(FXObject*, FXSelector, void*)
{
    while (waitpid(-1, NULL, WNOHANG) > 0)
    {
    }
    return(1);
}


// Handle quitting
long XFileExplorer::onQuit(FXObject*, FXSelector, void*)
{
    saveConfig();

    getApp()->exit(EXIT_SUCCESS);
    return(1);
}


// Directory up
long XFileExplorer::onCmdDirUp(FXObject* sender, FXSelector, void*)
{
    lpanel->getCurrent()->handle(sender, FXSEL(SEL_COMMAND, FilePanel::ID_DIRECTORY_UP), NULL);

    // Set focus on dirpanel or filepanel
    if (panelfocus == DIRPANEL_FOCUS)
    {
        dirpanel->setFocusOnList();
    }
    else
    {
        lpanel->getCurrent()->setFocusOnList();
    }

    return(1);
}


// Directory back
long XFileExplorer::onCmdDirBack(FXObject*, FXSelector, void*)
{
    StringItem* item;
    FXString    pathname;
    FilePanel*  filepanel = lpanel->getCurrent();

    // Get the previous directory
    item = filepanel->backhistGetFirst();
    if (item)
    {
        pathname = filepanel->backhistGetString(item);
    }

    // Update the history
    filepanel->backhistRemoveFirstItem();
    filepanel->forwardhistInsertFirstItem(filepanel->getDirectory());

    // Go to the previous directory
    filepanel->setDirectory(pathname, false);
    filepanel->updatePath();
    dirpanel->setDirectory(pathname, false);

    // Set focus on dirpanel or filepanel
    if (panelfocus == DIRPANEL_FOCUS)
    {
        dirpanel->setFocusOnList();
    }
    else
    {
        filepanel->setFocusOnList();
    }

    return(1);
}


// Update directory back
long XFileExplorer::onUpdDirBack(FXObject* sender, FXSelector, void* ptr)
{
    FXString   pathname;
    FilePanel* filepanel = lpanel->getCurrent();

    // Gray out the button if no item in history
    if (filepanel->backhistGetNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory forward
long XFileExplorer::onCmdDirForward(FXObject*, FXSelector, void*)
{
    StringItem* item;
    FXString    pathname;
    FilePanel*  filepanel = lpanel->getCurrent();

    // Get the next directory
    item = filepanel->forwardhistGetFirst();
    if (item)
    {
        pathname = filepanel->forwardhistGetString(item);
    }

    // Update the history
    filepanel->forwardhistRemoveFirstItem();
    filepanel->backhistInsertFirstItem(lpanel->getCurrent()->getDirectory());

    // Go to the next directory
    filepanel->setDirectory(pathname, false);
    filepanel->updatePath();
    dirpanel->setDirectory(pathname, true);

    // Set focus on dirpanel or filepanel
    if (panelfocus == DIRPANEL_FOCUS)
    {
        dirpanel->setFocusOnList();
    }
    else
    {
        filepanel->setFocusOnList();
    }

    return(1);
}


// Update directory forward
long XFileExplorer::onUpdDirForward(FXObject* sender, FXSelector sel, void* ptr)
{
    FXString   pathname;
    FilePanel* filepanel = lpanel->getCurrent();

    // Gray out the button if no item in history
    if (filepanel->forwardhistGetNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory back history
long XFileExplorer::onCmdDirBackHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringItem* item;
    FXString    pathname;
    FilePanel*  filepanel = lpanel->getCurrent();

    // Get all string items and display them in a list box
    int num = filepanel->backhistGetNumItems();

    if (num > 0)
    {
        FXString* dirs = new FXString[num];
        FXString  strlist = "";

        // Get string items
        item = filepanel->backhistGetFirst();
        int nb = 0;
        for (int i = 0; i <= num-1; i++)
        {
            if (item)
            {
                FXString str = filepanel->backhistGetString(item);
                FXbool   flag = true;
                for (int j = 0; j <= nb-1; j++)
                {
                    if (str == dirs[j])
                    {
                        flag = false;
                        break;
                    }
                }
                if (flag)
                {
                    dirs[nb] = str;
                    strlist = strlist+str+"\n";
                    nb++;
                }
                item = filepanel->backhistGetNext(item);
            }
        }

        // Display list box
        int pos = DirHistBox::box(btnbackhist, DECOR_NONE, strlist, getX()+40, getY()+60);

        // If an item was selected
        if (pos != -1)
        {
            // Update back history
            if (pos == num-1)
            {
                filepanel->backhistRemoveAllItems();
            }
            else
            {
                item = filepanel->backhistGetItemAtPos(pos+1);
                filepanel->backhistRemoveAllItemsBefore(item);
            }

            // Update forward history
            filepanel->forwardhistInsertFirstItem(filepanel->getDirectory());
            if (pos > 0)
            {
                for (int i = 0; i <= pos-1; i++)
                {
                    filepanel->forwardhistInsertFirstItem(dirs[i]);
                }
            }

            // Go to to the selected directory
            pathname = dirs[pos];
            filepanel->setDirectory(pathname, false);
            filepanel->updatePath();
            dirpanel->setDirectory(pathname, true);
        }
        delete[]dirs;
    }

    return(1);
}


// Update directory back
long XFileExplorer::onUpdDirBackHist(FXObject* sender, FXSelector sel, void* ptr)
{
    FXString   pathname;
    FilePanel* filepanel = lpanel->getCurrent();

    // Gray out the button if no item in history
    if (filepanel->backhistGetNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory forward history
long XFileExplorer::onCmdDirForwardHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringItem* item;
    FXString    pathname;
    FilePanel*  filepanel = lpanel->getCurrent();

    // Get all string items and display them in a list box
    int num = filepanel->forwardhistGetNumItems();

    if (num > 0)
    {
        FXString* dirs = new FXString[num];
        FXString  strlist = "";

        // Get string items
        item = filepanel->forwardhistGetFirst();
        int nb = 0;
        for (int i = 0; i <= num-1; i++)
        {
            if (item)
            {
                FXString str = filepanel->forwardhistGetString(item);
                FXbool   flag = true;
                for (int j = 0; j <= nb-1; j++)
                {
                    if (str == dirs[j])
                    {
                        flag = false;
                        break;
                    }
                }
                if (flag)
                {
                    dirs[nb] = str;
                    strlist = strlist+str+"\n";
                    nb++;
                }
                item = filepanel->forwardhistGetNext(item);
            }
        }

        // Display list box
        int pos = DirHistBox::box(btnforwardhist, DECOR_NONE, strlist, getX()+85, getY()+60);

        // If an item was selected
        if (pos != -1)
        {
            // Update forward history
            if (pos == num-1)
            {
                filepanel->forwardhistRemoveAllItems();
            }
            else
            {
                item = filepanel->forwardhistGetItemAtPos(pos+1);
                filepanel->forwardhistRemoveAllItemsBefore(item);
            }

            // Update back history
            filepanel->backhistInsertFirstItem(filepanel->getDirectory());
            if (pos > 0)
            {
                for (int i = 0; i <= pos-1; i++)
                {
                    filepanel->backhistInsertFirstItem(dirs[i]);
                }
            }

            // Go to to the selected directory
            pathname = dirs[pos];
            filepanel->setDirectory(pathname, false);
            filepanel->updatePath();
            dirpanel->setDirectory(pathname, true);
        }
        delete[]dirs;
    }

    return(1);
}


// Update directory forward
long XFileExplorer::onUpdDirForwardHist(FXObject* sender, FXSelector sel, void* ptr)
{
    FXString   pathname;
    FilePanel* filepanel = lpanel->getCurrent();

    // Gray out the button if no item in history
    if (filepanel->forwardhistGetNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Handle bookmarks
long XFileExplorer::onCmdBookmark(FXObject*, FXSelector s, void* p)
{
    if (FXSELID(s) == ID_ADD_BOOKMARK)
    {
        bookmarks->appendBookmark(lpanel->getCurrent()->getDirectory());
        saveConfig();
    }

    // Handle location address fields
    else if (FXSELID(s) == ID_BOOKMARK)
    {
        lpanel->getCurrent()->setDirectory((char*)p);
        lpanel->getCurrent()->updatePath();
        dirpanel->setDirectory((char*)p, true);
        FXString item;
        int      i = 0;
        int      count = address->getNumItems();
        if (!count)
        {
            count++;
            address->insertItem(0, address->getText());
        }
        while (i < count)
        {
            item = address->getItem(i++);
            if (streq((char*)p, (const char*)&item[0]))
            {
                i--;
                break;
            }
        }
        if (i == count)
        {
            address->insertItem(0, (char*)p);
        }

        // Set focus to the active panel
        lpanel->getCurrent()->setFocusOnList();
    }
    return(1);
}


// Goto location entered into the text field;
long XFileExplorer::onCmdGotoLocation(FXObject*, FXSelector, void*)
{
    // Location where we want to go
    FXString location = address->getText();

    // In case location is given in URI form, convert it
    location = ::fileFromURI(location);

    // Get complete path
    FXString path = FXPath::absolute(lpanel->getCurrent()->getDirectory(), location);
    FXString dir = path;

    // Go up to the lowest directory which still exists
    while (!FXPath::isTopDirectory(dir) && !::isDirectory(dir))
    {
        dir = FXPath::upLevel(dir);
    }

    // Move to this existing directory
    lpanel->getCurrent()->setDirectory(dir);
    lpanel->getCurrent()->updatePath();
    dirpanel->setDirectory(dir, true);
    address->setText(dir);

    return(1);
}


// Clear location bar
long XFileExplorer::onCmdClearLocation(FXObject*, FXSelector, void*)
{
    address->setText(FXString::null);
    address->CursorEnd();
    return(1);
}


// Restart the application when required
long XFileExplorer::onCmdRestart(FXObject*, FXSelector, void*)
{
    saveConfig();

    if (fork() == 0) // Child
    {
        execvp("xfe", args);
    }
    else // Parent
    {
        exit(EXIT_SUCCESS);
    }
    return(1);
}


// Start a new Xfe session
long XFileExplorer::onCmdNewWindow(FXObject*, FXSelector, void*)
{
    FXString cmd = "xfe " + homedir + " &";

    int ret = system(cmd.text());

    if (ret < 0)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Can't execute command %s"), cmd.text());
        return(0);
    }

    return(1);
}


// Run Terminal
long XFileExplorer::onCmdXTerm(FXObject*, FXSelector, void*)
{
    int ret;
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);
    getApp()->beginWaitCursor();
    FXString xterm = getApp()->reg().readStringEntry("PROGS", "xterm", "xterm -sb");

    ret = chdir(lpanel->getCurrent()->getDirectory().text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), lpanel->getCurrent()->getDirectory().text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), lpanel->getCurrent()->getDirectory().text());
        }

        return(0);
    }

    FXString cmd = xterm;
    cmd += " &";

    ret = system(cmd.text());
    if (ret < 0)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Can't execute command %s"), cmd.text());
        return(0);
    }

    lpanel->getCurrent()->setFocusOnList();
    ret = chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s: %s"), startlocation.text(), strerror(errcode));
        }
        else
        {
            MessageBox::error(this, BOX_OK, _("Error"), _("Can't enter folder %s"), startlocation.text());
        }

        return(0);
    }

    getApp()->endWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);
    return(1);
}


// Help menu
long XFileExplorer::onCmdHelp(FXObject*, FXSelector, void*)
{
    // Display help window
    if (helpwindow == NULL)
    {
        helpwindow = new TextWindow(getApp(), _("Help"), 40, 120);
    }
    helpwindow->setIcon(helpicon);

    // Set text font
    FXString fontspec;
    fontspec = getApp()->reg().readStringEntry("SETTINGS", "textfont", DEFAULT_TEXT_FONT);
    if (!fontspec.empty())
    {
        FXFont* font = new FXFont(getApp(), fontspec);
        font->create();
        helpwindow->setFont(font);
    }

    // NB: The HELP_TEXT macro is defined in help.h
    FXString str = (FXString)"                         "+COPYRIGHT+HELP_TEXT;
    helpwindow->setText(str.text());
    // Non modal window
    helpwindow->create();
    helpwindow->show(PLACEMENT_OWNER);
    lpanel->getCurrent()->setFocusOnList();
    return(1);
}


// About menu
long XFileExplorer::onCmdAbout(FXObject*, FXSelector, void*)
{
    FXString msg;

    msg.format(_("X File Explorer Version %s"), VERSION);
    FXString copyright = (FXString)"\n\n" + COPYRIGHT + "\n\n" + _("Based on X WinCommander by Maxim Baranov\n");
    FXString translators =
        _ ("\nTranslators\n\
-------------\n\
Argentinian Spanish: Bruno Gilberto Luciani\n\
Brazilian Portuguese: Eduardo R.B.S., Jose Carlos Medeiros,\n\
Phantom X, Tomas Acauan Schertel\n\
Bosnian: Samir Ribi, Bajrami Emran, Balagija Jasmina,\n\
Bilalovi, Omar Cogo Emir\n\
Catalan: muzzol\n\
Chinese: Xin Li\n\
Chinese (Tawan): Wei-Lun Chao\n\
Colombian Spanish: Vladimir Tmara (Pasos de Jess)\n\
Czech: David Vachulka\n\
Danish: Jonas Bardino, Vidar Jon Bauge\n\
Dutch: Hans Strijards\n\
Finnish: Kimmo Siira\n\
French: Claude Leo Mercier, Roland Baudin\n\
German: Bastian Kleineidam, Joachim Wiedorn, Tim Benke, Jens Krner\n\
Greek: Nikos Papadopoulos\n\
Hungarian: Attila Szervac, Sandor Sipos\n\
Italian: Claudio Fontana, Giorgio Moscardi\n\
Japanese: Karl Skewes\n\
Norwegian: Vidar Jon Bauge\n\
Polish: Jacek Dziura, Franciszek Janowski\n\
Portuguese: Miguel Santinho\n\
Russian: Dimitri Sertolov, Vad Vad\n\
Spanish: Felix Medrano Sanz, Lucas 'Basurero' Vieites,\n\
Martin Carr\n\
Swedish: Anders F. Bjorklund\n\
Turkish: erkaN\n\
");

    msg = msg + copyright + translators;
    MessageBox about(this,_("About X File Explorer"),msg.text(),xfeicon,BOX_OK|DECOR_TITLE|DECOR_BORDER,
                     JUSTIFY_CENTER_X|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    about.execute(PLACEMENT_OWNER);
    lpanel->getCurrent()->setFocusOnList();
    return 1;
}


// Handle file association (called by Properties.cpp and FilePanel.cpp)
long XFileExplorer::onCmdFileAssoc(FXObject*,FXSelector s,void* p)
{
    char** str=(char**)p;
    char* ext=str[0];
    char* cmd=str[1];

    // ext=extension, cmd=associated command
    // replace : to allow immediate association in Xfe
    FileDict* associations=lpanel->getAssociations();
    associations->replace(ext,cmd);
    associations=rpanel->getAssociations();
    associations->replace(ext,cmd);

    saveConfig();

    return 1;
}


// FilePanel and DirPanel refresh
long XFileExplorer::onCmdRefresh(FXObject*,FXSelector,void*)
{
    getApp()->beginWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_ANIMTHROB), NULL);

#if defined(linux)
    dirpanel->forceDevicesRefresh();
#endif

	lpanel->onCmdRefresh(0,0,0);
	rpanel->onCmdRefresh(0,0,0);
	dirpanel->forceRefresh();
    getApp()->endWaitCursor();
    mainWindow->handle(this, FXSEL(SEL_TIMEOUT,XFileExplorer::ID_STOPANIMTHROB), NULL);

    return 1;
}


// Update file location
long XFileExplorer::onUpdFileLocation(FXObject* sender,FXSelector,void*)
{
    FXString currentdir=lpanel->getCurrent()->getDirectory();
    if (currentdir != prevdir)
    {
        address->setText(::cleanPath(currentdir));
        prevdir=currentdir;
    }
    
    return 1;
}


// Switch between vertical and horizontal panels
long XFileExplorer::onCmdHorzVertPanels(FXObject* sender,FXSelector sel,void* ptr)
{
    switch(FXSELID(sel))
    {
    case ID_VERT_PANELS:
        panelsplit->setSplitterStyle(panelsplit->getSplitterStyle()&~SPLITTER_VERTICAL);
        vertpanels=true;
        break;

    case ID_HORZ_PANELS:
        panelsplit->setSplitterStyle(panelsplit->getSplitterStyle()|SPLITTER_VERTICAL);
        vertpanels=false;
        break;
    }

    return 1;
}


long XFileExplorer::onCmdSwitchTree(FXObject* sender, FXSelector sel, void* ptr)
{
    // Get window width and height
    int window_width=getWidth();
    int window_height=getHeight();

       if ( rpanel->shown() ) {
       if ( dirpanel->shown() ) {
        panel_view=TWO_PANELS;
        //foldersbtn->setButtonStyle(BUTTON_TOOLBAR);
        //foldersbtn->setFrameStyle(FRAME_RAISED);

        if (vertpanels)
            lpanel->setWidth((int)round(twopanels_lpanel_pct*window_width));
        else
            lpanel->setHeight((int)round(twopanels_lpanel_pct*window_height));
        if (dirpanel->shown())
            dirpanel->handle(sender,FXSEL(SEL_COMMAND,DirPanel::ID_TOGGLE_TREE),ptr);
        if (!rpanel->shown())
            rpanel->handle(sender,FXSEL(SEL_COMMAND,FXWindow::ID_TOGGLESHOWN),ptr);
        // Handle drag corner
        rpanel->showCorner(true);
        lpanel->showCorner(false);
        // Handle active icon
        lpanel->showActiveIcon(true);

        //sender->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_UNCHECK),ptr);

        } else {
        panel_view=TREE_TWO_PANELS;
        //foldersbtn->setButtonStyle(0);
        //foldersbtn->setFrameStyle(FRAME_RAISED);
        dirpanel->setWidth((int)round(treetwopanels_tree_pct*window_width) );
        if (vertpanels)
            lpanel->setWidth((int)round(treetwopanels_lpanel_pct*window_width));
        else
            lpanel->setHeight((int)round(treetwopanels_lpanel_pct*window_height));
        if (!dirpanel->shown())
            dirpanel->handle(sender,FXSEL(SEL_COMMAND,DirPanel::ID_TOGGLE_TREE),ptr);
        if (!rpanel->shown())
            rpanel->handle(sender,FXSEL(SEL_COMMAND,FXWindow::ID_TOGGLESHOWN),ptr);
        // Handle drag corner
        lpanel->showCorner(false);
        rpanel->showCorner(true);
        // Handle active icon
        lpanel->showActiveIcon(true);
        //sender->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_CHECK),ptr);
        }

       } else {
       if ( dirpanel->shown() ) {
           panel_view=ONE_PANEL;

           //foldersbtn->setButtonStyle(BUTTON_TOOLBAR);
           //foldersbtn->setFrameStyle(FRAME_RAISED);

           // foldersbtn->setButtonStyle(BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|LAYOUT_FILL_Y);
           if (dirpanel->shown())
               dirpanel->handle(sender,FXSEL(SEL_COMMAND,DirPanel::ID_TOGGLE_TREE),ptr);
           if (rpanel->shown())
               rpanel->handle(sender,FXSEL(SEL_COMMAND,FXWindow::ID_TOGGLESHOWN),ptr);
            // Handle drag corner
            rpanel->showCorner(false);
            lpanel->showCorner(true);
            // Handle active icon
            lpanel->showActiveIcon(false);

            //sender->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_UNCHECK),ptr);
        } else {
           panel_view=TREE_PANEL;
           //foldersbtn->setButtonStyle(FRAME_NONE);
           //foldersbtn->setFrameStyle(FRAME_SUNKEN);

           // foldersbtn->setButtonStyle(FRAME_SUNKEN|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|LAYOUT_FILL_Y);
           dirpanel->setWidth((int)round(treepanel_tree_pct*window_width) );
           if (!dirpanel->shown())
               dirpanel->handle(sender,FXSEL(SEL_COMMAND,DirPanel::ID_TOGGLE_TREE),ptr);
           if (rpanel->shown())
               rpanel->handle(sender,FXSEL(SEL_COMMAND,FXWindow::ID_TOGGLESHOWN),ptr);
           // Handle drag corner
           rpanel->showCorner(false);
           lpanel->showCorner(true);
           // Handle active icon
           lpanel->showActiveIcon(true);

           //sender->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_CHECK),ptr);
        }

       }

        return 1;
}



// Switch between the four possible panel views
long XFileExplorer::onCmdShowPanels(FXObject* sender,FXSelector sel,void* ptr)
{
    // Get window width and height
    int window_width=getWidth();
    int window_height=getHeight();

    switch(FXSELID(sel))
    {
    case ID_SHOW_ONE_PANEL:
        panel_view=ONE_PANEL;
        if (dirpanel->shown())
            dirpanel->handle(sender,FXSEL(SEL_COMMAND,DirPanel::ID_TOGGLE_TREE),ptr);
        if (rpanel->shown())
            rpanel->handle(sender,FXSEL(SEL_COMMAND,FXWindow::ID_TOGGLESHOWN),ptr);
        // Handle drag corner
        rpanel->showCorner(false);
        lpanel->showCorner(true);
        // Handle active icon
        lpanel->showActiveIcon(false);

        break;

    case ID_SHOW_TWO_PANELS:
        panel_view=TWO_PANELS;
        if (vertpanels)
            lpanel->setWidth((int)round(twopanels_lpanel_pct*window_width));
        else
            lpanel->setHeight((int)round(twopanels_lpanel_pct*window_height));
        if (dirpanel->shown())
            dirpanel->handle(sender,FXSEL(SEL_COMMAND,DirPanel::ID_TOGGLE_TREE),ptr);
        if (!rpanel->shown())
            rpanel->handle(sender,FXSEL(SEL_COMMAND,FXWindow::ID_TOGGLESHOWN),ptr);
        // Handle drag corner
        rpanel->showCorner(true);
        lpanel->showCorner(false);
        // Handle active icon
        lpanel->showActiveIcon(true);
        break;

    case ID_SHOW_TREE_PANEL:
        panel_view=TREE_PANEL;
        dirpanel->setWidth((int)round(treepanel_tree_pct*window_width) );
        if (!dirpanel->shown())
            dirpanel->handle(sender,FXSEL(SEL_COMMAND,DirPanel::ID_TOGGLE_TREE),ptr);
        if (rpanel->shown())
            rpanel->handle(sender,FXSEL(SEL_COMMAND,FXWindow::ID_TOGGLESHOWN),ptr);
        // Handle drag corner
        rpanel->showCorner(false);
        lpanel->showCorner(true);
        // Handle active icon
        lpanel->showActiveIcon(true);
        break;

    case ID_SHOW_TREE_TWO_PANELS:
        panel_view=TREE_TWO_PANELS;
        dirpanel->setWidth((int)round(treetwopanels_tree_pct*window_width) );
        if (vertpanels)
            lpanel->setWidth((int)round(treetwopanels_lpanel_pct*window_width));
        else
            lpanel->setHeight((int)round(treetwopanels_lpanel_pct*window_height));
        if (!dirpanel->shown())
            dirpanel->handle(sender,FXSEL(SEL_COMMAND,DirPanel::ID_TOGGLE_TREE),ptr);
        if (!rpanel->shown())
            rpanel->handle(sender,FXSEL(SEL_COMMAND,FXWindow::ID_TOGGLESHOWN),ptr);
        // Handle drag corner
        lpanel->showCorner(false);
        rpanel->showCorner(true);
        // Handle active icon
        lpanel->showActiveIcon(true);
        break;
    }

    // Set focus on current panel
    lpanel->getCurrent()->setFocusOnList();

    return 1;
}

// Switch between the four possible panel views
/*long XFileExplorer::switchView(FXObject* sender,FXSelector sel,void* ptr)
{
    // Get window width and height
    int window_width=getWidth();
    int window_height=getHeight();

    switch(FXSELID(sel))
    {
    case ID_SHOW_ONE_PANEL:
        panel_view=ONE_PANEL;
        if (dirpanel->shown())
            dirpanel->handle(sender,FXSEL(SEL_COMMAND,DirPanel::ID_TOGGLE_TREE),ptr);
        if (rpanel->shown())
            rpanel->handle(sender,FXSEL(SEL_COMMAND,FXWindow::ID_TOGGLESHOWN),ptr);
        // Handle drag corner
        rpanel->showCorner(false);
        lpanel->showCorner(true);
        // Handle active icon
        lpanel->showActiveIcon(false);

        break;

    case ID_SHOW_TWO_PANELS:
        panel_view=TWO_PANELS;
        if (vertpanels)
            lpanel->setWidth((int)round(twopanels_lpanel_pct*window_width));
        else
            lpanel->setHeight((int)round(twopanels_lpanel_pct*window_height));
        if (dirpanel->shown())
            dirpanel->handle(sender,FXSEL(SEL_COMMAND,DirPanel::ID_TOGGLE_TREE),ptr);
        if (!rpanel->shown())
            rpanel->handle(sender,FXSEL(SEL_COMMAND,FXWindow::ID_TOGGLESHOWN),ptr);
        // Handle drag corner
        rpanel->showCorner(true);
        lpanel->showCorner(false);
        // Handle active icon
        lpanel->showActiveIcon(true);
        break;

    case ID_SHOW_TREE_PANEL:
        panel_view=TREE_PANEL;
        dirpanel->setWidth((int)round(treepanel_tree_pct*window_width) );
        if (!dirpanel->shown())
            dirpanel->handle(sender,FXSEL(SEL_COMMAND,DirPanel::ID_TOGGLE_TREE),ptr);
        if (rpanel->shown())
            rpanel->handle(sender,FXSEL(SEL_COMMAND,FXWindow::ID_TOGGLESHOWN),ptr);
        // Handle drag corner
        rpanel->showCorner(false);
        lpanel->showCorner(true);
        // Handle active icon
        lpanel->showActiveIcon(true);
        break;

    case ID_SHOW_TREE_TWO_PANELS:
        panel_view=TREE_TWO_PANELS;
        dirpanel->setWidth((int)round(treetwopanels_tree_pct*window_width) );
        if (vertpanels)
            lpanel->setWidth((int)round(treetwopanels_lpanel_pct*window_width));
        else
            lpanel->setHeight((int)round(treetwopanels_lpanel_pct*window_height));
        if (!dirpanel->shown())
            dirpanel->handle(sender,FXSEL(SEL_COMMAND,DirPanel::ID_TOGGLE_TREE),ptr);
        if (!rpanel->shown())
            rpanel->handle(sender,FXSEL(SEL_COMMAND,FXWindow::ID_TOGGLESHOWN),ptr);
        // Handle drag corner
        lpanel->showCorner(false);
        rpanel->showCorner(true);
        // Handle active icon
        lpanel->showActiveIcon(true);
        break;
    }

    // Set focus on current panel
    lpanel->getCurrent()->setFocusOnList();

    return 1;
}*/

// Update the horizontal / vertical panel radio menus
long XFileExplorer::onUpdHorzVertPanels(FXObject* sender,FXSelector sel,void* ptr)
{
    if (rpanel->shown())
    {
        sender->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_ENABLE),ptr);

        if (vertpanels)
        {
            lpanel->hidePanelSeparator();
            rpanel->hidePanelSeparator();

            if ( FXSELID(sel) == ID_HORZ_PANELS )
                sender->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_UNCHECK),ptr);
            else
                sender->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_CHECK),ptr);
        }
        else
        {
            lpanel->showPanelSeparator();
            rpanel->hidePanelSeparator();

            if ( FXSELID(sel) == ID_VERT_PANELS )
                sender->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_UNCHECK),ptr);
            else
                sender->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_CHECK),ptr);
        }
    }
    else
    {
        lpanel->hidePanelSeparator();
        rpanel->hidePanelSeparator();

        sender->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_DISABLE),ptr);
    }

    return 1;
}


// Update the panels
long XFileExplorer::onUpdShowPanels(FXObject* sender,FXSelector sel,void* ptr)
{
    // Keep the panel sizes relative to the window width or height (if option enabled)

    register int width;
    register int height;

    // Get the current window width and height
    width=getWidth();
    height=getHeight();

    // If width has changed and relative resizing option is enabled
    if (relative_resize && prev_width!=width)
    {
        // One panel mode not relevant

        // Two panels mode
        if (!dirpanel->shown() && rpanel->shown())
        {
            // Set left panel width / height to the new value
            if (vertpanels)
                lpanel->setWidth((int)round(twopanels_lpanel_pct*width));
            else
                lpanel->setHeight((int)round(twopanels_lpanel_pct*height));
        }

        // Tree panel mode
        else if (dirpanel->shown() && !rpanel->shown())
        {
            // Set dirpanel width to the new value
            dirpanel->setWidth((int)round(treepanel_tree_pct * width) );
        }

        // Tree and two panels mode
        else if (dirpanel->shown() && rpanel->shown())
        {
            // Set dirpanel width to the new value
            dirpanel->setWidth((int)round(treetwopanels_tree_pct * width) );

            // Set left panel width / height to the new value
            if (vertpanels)
                lpanel->setWidth((int)round(treetwopanels_lpanel_pct*width));
            else
                lpanel->setHeight((int)round(treetwopanels_lpanel_pct*height));
        }
    }

    // Update previous window width
    prev_width=width;

    // Update the panel menus and the panel display
    FXuint msg=FXWindow::ID_UNCHECK;
    switch(FXSELID(sel))
    {
    case ID_SHOW_ONE_PANEL:
        if (!dirpanel->shown() && !rpanel->shown())
        {
            msg = FXWindow::ID_CHECK;
            if (rpanelmenutitle->shown())
            {
                rpanelmenutitle->hide();
                rpanelmenutitle->disable();
                lpanelmenutitle->setText(_("&Panel"));
                lpanel->show();
                //lpanel->repaint();
                lpanel->setActive();
            }
        }
        break;

    case ID_SHOW_TWO_PANELS:
        if (!dirpanel->shown() && rpanel->shown())
        {
            // Update the left panel relative size (only if the window size is sufficient)
            if (vertpanels)
            {
                if (getWidth()>10)
                    twopanels_lpanel_pct=(double)(lpanel->getWidth())/(double)(getWidth());
            }
            else
            {
                if (getHeight()>10)
                    twopanels_lpanel_pct=(double)(lpanel->getHeight())/(double)(getHeight());
            }

            msg=FXWindow::ID_CHECK;
            if (!rpanelmenutitle->shown())
            {
                rpanelmenutitle->enable();
                rpanelmenutitle->show();
                rpanelmenutitle->setText(_("&Right panel"));
                lpanelmenutitle->setText(_("&Left panel"));
                //lpanel->repaint();
                lpanel->setActive();
            }
        }
        break;

    case ID_SHOW_TREE_PANEL:
        if (dirpanel->shown() && !rpanel->shown())
        {
            // Update the tree panel relative size (only if the window size is sufficient)
            if (getWidth()>10)
                treepanel_tree_pct=(double)(dirpanel->getWidth())/(double)(getWidth());

            msg=FXWindow::ID_CHECK;
            if (rpanelmenutitle->shown())
            {
                rpanelmenutitle->hide();
                rpanelmenutitle->disable();
                lpanelmenutitle->setText(_("&Panel"));
                //lpanel->repaint();
                lpanel->setActive();
            }
        }
        break;

    case ID_SHOW_TREE_TWO_PANELS:
        if (dirpanel->shown() && rpanel->shown())
        {
            // Update the tree panel relative size (only if the window size is sufficient)
            if (getWidth()>10)
                treetwopanels_tree_pct=(double)(dirpanel->getWidth())/(double)(getWidth());

            // Update the left panel relative size (only if the window size is sufficient)
            if (vertpanels)
            {
                if (getWidth()>10)
                    treetwopanels_lpanel_pct=(double)(lpanel->getWidth())/(double)(getWidth());
            }
            else
            {
                if (getHeight()>10)
                    treetwopanels_lpanel_pct=(double)(lpanel->getHeight())/(double)(getHeight());
            }

            msg = FXWindow::ID_CHECK;
            if (!rpanelmenutitle->shown())
            {
                rpanelmenutitle->enable();
                rpanelmenutitle->show();
                rpanelmenutitle->setText(_("&Right panel"));
                lpanelmenutitle->setText(_("&Left panel"));
                //lpanel->repaint();
                lpanel->setActive();
            }
        }
        break;
    }
    sender->handle(this,FXSEL(SEL_COMMAND,msg),ptr);

    return 1;
}


// Synchronize the panels to the same directory
long XFileExplorer::onCmdSynchronizePanels(FXObject* sender,FXSelector sel,void*)
{
    FXString dir;

    // Left panel is active
    if (lpanel->getCurrent() == lpanel)
    {
        dir=lpanel->getDirectory();
        rpanel->setDirectory(dir);
        rpanel->updatePath();
    }

    // Right panel is active
    else
    {
        dir=rpanel->getDirectory();
        lpanel->setDirectory(dir);
        lpanel->updatePath();

    }
    return 1;
}


// Update the synchronize panels menu item
long XFileExplorer::onUpdSynchronizePanels(FXObject* o,FXSelector,void*)
{
    if (rpanel->shown())
        o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_ENABLE),NULL);
    else
        o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_DISABLE),NULL);

    return 1;
}


// Switch the panels
long XFileExplorer::onCmdSwitchPanels(FXObject* sender,FXSelector sel,void*)
{
    FXString leftdir, rightdir;

    leftdir=lpanel->getDirectory();
    rightdir=rpanel->getDirectory();
    lpanel->setDirectory(rightdir);
    lpanel->updatePath();
    rpanel->setDirectory(leftdir);
    rpanel->updatePath();

    return 1;
}


// Update the switch panels menu item
long XFileExplorer::onUpdSwitchPanels(FXObject* o,FXSelector,void*)
{
    if (rpanel->shown())
        o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_ENABLE),NULL);
    else
        o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_DISABLE),NULL);

    return 1;
}


// Preferences
long XFileExplorer::onCmdPrefs(FXObject*,FXSelector s,void* p)
{
    if (prefsdialog==NULL)
        prefsdialog=new PreferencesBox(this,listbackcolor,listforecolor,highlightcolor,pbarcolor,attentioncolor,scrollbarcolor);
    prefsdialog->execute(PLACEMENT_OWNER);
    lpanel->getCurrent()->setFocusOnList();
    return 1;
}


// Toggle status bar
long XFileExplorer::onCmdToggleStatus(FXObject*,FXSelector s,void* p)
{
    dirpanel->toggleStatusbar();
    lpanel->toggleStatusbar();
    rpanel->toggleStatusbar();
    return 1;
}


long XFileExplorer::onUpdToggleStatus(FXObject* o,FXSelector s,void* p)
{
    FXMenuCheck* cmd =(FXMenuCheck*)o;
    if (lpanel->statusbarShown())
        cmd->setCheck(true);
    else
        cmd->setCheck(false);
    return 1;
}


// Run shell command or X program
long XFileExplorer::onCmdRun(FXObject*,FXSelector,void*)
{
    int ret;

    ret=chdir(lpanel->getCurrent()->getDirectory().text());
    if (ret < 0)
    {
        int errcode=errno;
        if (errcode)
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s: %s"),lpanel->getCurrent()->getDirectory().text(),strerror(errcode));
        else
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s"),lpanel->getCurrent()->getDirectory().text());

        return 0;
    }

    FXString command=" ";
    if (rundialog==NULL)
        rundialog=new HistInputDialog(this,"",_("Execute the command:"),_("Execute command"),"", bigexecicon,HIST_INPUT_EXECUTABLE_FILE,true,_("Console mode"));
    rundialog->create();
    rundialog->setText(command);
    rundialog->CursorEnd();
    rundialog->selectAll();
    rundialog->clearItems();
    for (int i=0; i<RunHistSize; i++)
        rundialog->appendItem(RunHistory[i]);
    rundialog->sortItems();

    rundialog->setDirectory(ROOTDIR);
    if (rundialog->execute())
    {
        command=rundialog->getText();
        if (command != " ")
        {
            // Execute command in command window
            if (rundialog->getOption())
            {
                // Make and show command window
                CommandWindow* cmdwin=new CommandWindow(getApp(),_("Command log"),command,30,80);
                cmdwin->create();
                cmdwin->setIcon(runicon);

                // The CommandWindow object will delete itself when closed!
            }

            // Execute silently in background
            else
            {
                command+=" &";
                ret=system(command.text());
                if (ret < 0)
                {
                    MessageBox::error(this,BOX_OK,_("Error"),_("Can't execute command %s"),command.text());
                    return 0;
                }
            }
        }
        // Update history list
        RunHistSize=rundialog->getHistorySize();
        command=rundialog->getText();

        // Check if cmd is a new string, i.e. is not already in history
        FXbool newstr=true;
        for (int i=0; i<RunHistSize-1; i++)
        {
            if (streq(RunHistory[i],command.text()))
            {
                newstr=false;
                break;
            }
        }

        // No new string or history limit reached
        if (!newstr || RunHistSize>RUN_HIST_SIZE)
            RunHistSize--;

        // Restore original history order
        rundialog->clearItems();
        for (int i = 0; i < RunHistSize; i++)
        {
            rundialog->appendItem(RunHistory[i]);
		}

        // New string
        if (newstr)
        {
            // FIFO
            strlcpy(RunHistory[0],command.text(),command.length()+1);
            for (int i=1; i<RunHistSize; i++)
                strlcpy(RunHistory[i],rundialog->getHistoryItem(i-1).text(),rundialog->getHistoryItem(i-1).length()+1);
        }
    }
    ret=chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode=errno;
        if (errcode)
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s: %s"),startlocation.text(),strerror(errcode));
        else
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s"),startlocation.text());

        return 0;
    }

    lpanel->getCurrent()->setFocusOnList();
    return 1;
}


// Run an Xfe as root
long XFileExplorer::onCmdSu(FXObject*,FXSelector,void*)
{
    int ret;

    // Wait cursor
    getApp()->beginWaitCursor();

    // Obtain preferred root mode
    FXbool use_sudo=getApp()->reg().readUnsignedEntry("OPTIONS","use_sudo",false);

    // Select sudo or su to launch xfe as root
    ret=chdir(lpanel->getCurrent()->getDirectory().text());
    if (ret < 0)
    {
        int errcode=errno;
        if (errcode)
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s: %s"),lpanel->getCurrent()->getDirectory().text(),strerror(errcode));
        else
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s"),lpanel->getCurrent()->getDirectory().text());

        return 0;
    }

    FXString title, sucmd, command;
    if (use_sudo)
    {
        title = _("Enter the user password:");
        sucmd = SUDOCMD;
    }
    else
    {
        title = _("Enter the root password:");
        sucmd = SUCMD;
    }

    // Get text font
    FXString fontspec = getApp()->reg().readStringEntry("SETTINGS", "textfont", DEFAULT_TEXT_FONT);
    if (fontspec.empty())
    {
		command = "st -t " + ::quote(title) + sucmd;
	}
	else
	{
		FXchar fontsize[32];
        FXFont* font = new FXFont(getApp(), fontspec);
        font->create();
		snprintf(fontsize, sizeof(fontsize), "%d",(int)(font->getSize()/10)); // Size is in deci-points, thus divide by 10
		command = "st -t " + ::quote(title) + " -f '" + (font->getFamily()).text() + ":pixelsize=" + fontsize + "'" + sucmd;
    }

    // Execute su or sudo command in an internal st terminal
    int status = runst(command);

    // If error
    ret=chdir(startlocation.text());
    if (ret < 0)
    {
        int errcode=errno;
        if (errcode)
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s: %s"),startlocation.text(),strerror(errcode));
        else
            MessageBox::error(this,BOX_OK,_("Error"),_("Can't enter folder %s"),startlocation.text());

        return 0;
    }

    if (status<0)
    {
        MessageBox::error(getApp(),BOX_OK,_("Error"),_("An error has occurred!"));
        getApp()->endWaitCursor();
        return 0;
    }

    // Wait cursor
    getApp()->endWaitCursor();
    return 1;
}


// File search dialog
long XFileExplorer::onCmdFileSearch(FXObject* o,FXSelector sel,void*)
{
    // Display search box
    if (searchwindow==NULL)
        searchwindow=new SearchWindow(getApp(),_("Search files and folders"),
                                      DECOR_ALL,search_xpos,search_ypos,search_width,search_height,0,0,0,0,0,0);

    // Non modal window
    searchwindow->create();
    searchwindow->show(PLACEMENT_DEFAULT);

    // Set search path in search window
    searchwindow->setSearchPath(lpanel->getCurrent()->getDirectory());

    return 1;
}


// Update file search button
long XFileExplorer::onUpdFileSearch(FXObject* o,FXSelector,void*)
{

    if (searchwindow != NULL && searchwindow->shown())
        o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_DISABLE),NULL);
    else
        o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_ENABLE),NULL);

    return 1;
}


// Empty trash can
long XFileExplorer::onCmdEmptyTrash(FXObject*,FXSelector sel,void* ptr)
{
    // Wait cursor
    getApp()->beginWaitCursor();

    // Compute trash directory size
    char buf[MAXPATHLEN+1];
    char size[64];
    FXString hsize;
    FXulong dirsize;
    FXuint nbfiles=0, nbsubfolders=0;
    FXulong totalsize=0;

    FXString dirpath=trashfileslocation;
    strlcpy(buf,dirpath.text(),dirpath.length()+1);
    dirsize=pathsize(buf,&nbfiles,&nbsubfolders,&totalsize);

#if __WORDSIZE == 64
    snprintf(size,sizeof(size)-1,"%lu",dirsize);
#else
    snprintf(size,sizeof(size)-1,"%llu",dirsize);
#endif
    hsize=::hSize(size);
#if __WORDSIZE == 64
    snprintf(size,sizeof(size)-1,_("%s (%lu bytes)"),hsize.text(),dirsize);
#else
    snprintf(size,sizeof(size)-1,_("%s (%llu bytes)"),hsize.text(),dirsize);
#endif
    snprintf(size,sizeof(size)-1,_("%u files, %u subfolders"),nbfiles-nbsubfolders,nbsubfolders-1);

    // Wait cursor
    getApp()->endWaitCursor();

    // Confirmation message
    FXString message=_("Do you really want to empty the trash can?") + FXString(" (") + hsize + _(" in ") + FXString(size) + FXString(")")
                     + _("\n\nAll items will be definitively lost!");

    MessageBox box(this,_("Empty trash can"),message,trash_full_bigicon,BOX_OK_CANCEL|DECOR_TITLE|DECOR_BORDER);
    if (box.execute(PLACEMENT_CURSOR) != BOX_CLICKED_OK)
        return 0;

    // Wait cursor
    getApp()->beginWaitCursor();

    // Delete trash can files folder
    File* f;
    f=new File(this,_("File delete"),DELETE);
    f->create();
    f->remove(trashfileslocation);
    delete f;

    // Delete trash can info folder
    f=new File(this,_("File delete"),DELETE);
    f->create();
    f->remove(trashinfolocation);
    delete f;

    // Re-create the trash can files directory
    if (!::exists(trashfileslocation))
    {
        errno=0;
        int ret=mkpath(trashfileslocation.text(),0755);
        int errcode=errno;
        if (ret==-1)
        {
            if (errcode)
                MessageBox::error(this,BOX_OK,_("Error"),_("Can't create trash can 'files' folder %s: %s"),trashfileslocation.text(),strerror(errcode));
            else
                MessageBox::error(this,BOX_OK,_("Error"),_("Can't create trash can 'files' folder %s"),trashfileslocation.text());
        }
    }

    // Re-create the trash can info directory
    if (!::exists(trashinfolocation))
    {
        errno=0;
        int ret=mkpath(trashinfolocation.text(),0755);
        int errcode=errno;
        if (ret==-1)
        {
            if (errcode)
                MessageBox::error(this,BOX_OK,_("Error"),_("Can't create trash can 'info' folder %s: %s"),trashinfolocation.text(),strerror(errcode));
            else
                MessageBox::error(this,BOX_OK,_("Error"),_("Can't create trash can 'info' folder %s"),trashinfolocation.text());
        }
    }

    // Wait cursor
    getApp()->endWaitCursor();

    onCmdRefresh(0,0,0);

    return 1;
}


// Display trash size
long XFileExplorer::onCmdTrashSize(FXObject*,FXSelector sel,void*)
{
    struct stat linfo;
    FXString trashsize, trashmtime, trashnbfiles, trashnbfolders;
    if (lstatrep(trashfileslocation.text(),&linfo)==0)
    {
        // Read time format
        FXString timeformat=getApp()->reg().readStringEntry("SETTINGS","time_format",DEFAULT_TIME_FORMAT);

        // Trash files size
        trashmtime=FXSystem::time(timeformat.text(),linfo.st_mtime);
        char buf[MAXPATHLEN];
        FXulong dirsize=0;
        FXuint nbfiles=0, nbsubfolders=0;
        FXulong totalsize=0;
        strlcpy(buf,trashfileslocation.text(),trashfileslocation.length()+1);
        dirsize=pathsize(buf,&nbfiles,&nbsubfolders,&totalsize);
#if __WORDSIZE == 64
        snprintf(buf,sizeof(buf),"%lu",dirsize);
#else
        snprintf(buf,sizeof(buf),"%llu",dirsize);
#endif
        trashsize=::hSize(buf);
        trashnbfiles=FXStringVal(nbfiles-nbsubfolders);
        trashnbfolders=FXStringVal(nbsubfolders-1);

        // Dialog box
        FXString msg;
        msg.format(_("Trash size: %s (%s files, %s subfolders)\n\nModified date: %s"),
                   trashsize.text(),trashnbfiles.text(),trashnbfolders.text(),trashmtime.text());
        MessageBox dialog(this,_("Trash size"),msg.text(),delete_bigicon,BOX_OK|DECOR_TITLE|DECOR_BORDER,
                          JUSTIFY_LEFT|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);
        dialog.execute(PLACEMENT_CURSOR);
    }
    else
    {
        // Error
        MessageBox::error(this,BOX_OK,_("Error"),_("Trash can 'files' folder %s is not readable!"),trashfileslocation.text());
        return 0;
    }

    return 1;
}


// File copy to clipboard
long XFileExplorer::onCmdFileCopyClp(FXObject* o, FXSelector sel, void*)
{
    if (dirpanel->isActive())
        dirpanel->handle(o,FXSEL(SEL_COMMAND,DirPanel::ID_COPY_CLIPBOARD),NULL);

    else
        lpanel->getCurrent()->handle(o,FXSEL(SEL_COMMAND,FilePanel::ID_COPY_CLIPBOARD),NULL);

    return 1;
}


// File cut to clipboard
long XFileExplorer::onCmdFileCutClp(FXObject* o, FXSelector sel, void*)
{
    if (dirpanel->isActive())
        dirpanel->handle(o,FXSEL(SEL_COMMAND,DirPanel::ID_CUT_CLIPBOARD),NULL);

    else
        lpanel->getCurrent()->handle(o,FXSEL(SEL_COMMAND,FilePanel::ID_CUT_CLIPBOARD),NULL);

    return 1;
}


// File add copy to clipboard
long XFileExplorer::onCmdFileAddCopyClp(FXObject* o, FXSelector sel, void*)
{
    if (dirpanel->isActive())
        dirpanel->handle(o,FXSEL(SEL_COMMAND,DirPanel::ID_ADDCOPY_CLIPBOARD),NULL);

    else
        lpanel->getCurrent()->handle(o,FXSEL(SEL_COMMAND,FilePanel::ID_ADDCOPY_CLIPBOARD),NULL);

    return 1;
}


// File add cut to clipboard
long XFileExplorer::onCmdFileAddCutClp(FXObject* o, FXSelector sel, void*)
{
    if (dirpanel->isActive())
        dirpanel->handle(o,FXSEL(SEL_COMMAND,DirPanel::ID_ADDCUT_CLIPBOARD),NULL);

    else
        lpanel->getCurrent()->handle(o,FXSEL(SEL_COMMAND,FilePanel::ID_ADDCUT_CLIPBOARD),NULL);

    return 1;
}


// File paste from clipboard
long XFileExplorer::onCmdFilePasteClp(FXObject* o, FXSelector sel, void*)
{
    if (dirpanel->isActive())
        dirpanel->handle(o,FXSEL(SEL_COMMAND,DirPanel::ID_PASTE_CLIPBOARD),NULL);

    else
        lpanel->getCurrent()->handle(o,FXSEL(SEL_COMMAND,FilePanel::ID_PASTE_CLIPBOARD),NULL);
    return 1;
}


// File rename
long XFileExplorer::onCmdFileRename(FXObject* o, FXSelector sel, void*)
{
    lpanel->getCurrent()->handle(o,FXSEL(SEL_COMMAND,FilePanel::ID_FILE_RENAME),NULL);
    return 1;
}


// File move
long XFileExplorer::onCmdFileMoveto(FXObject* o, FXSelector sel, void* ptr)
{
    if (dirpanel->isActive())
        dirpanel->handle(o,FXSEL(SEL_COMMAND,DirPanel::ID_DIR_MOVETO),ptr);

    else
        lpanel->getCurrent()->handle(o,FXSEL(SEL_COMMAND,FilePanel::ID_FILE_MOVETO),NULL);
    return 1;
}


// File copy to
long XFileExplorer::onCmdFileCopyto(FXObject* o, FXSelector sel, void* ptr)
{
    if (dirpanel->isActive())
        dirpanel->handle(o,FXSEL(SEL_COMMAND,DirPanel::ID_DIR_COPYTO),ptr);

    else
        lpanel->getCurrent()->handle(o,FXSEL(SEL_COMMAND,FilePanel::ID_FILE_COPYTO),NULL);

    return 1;
}


// File symlink
long XFileExplorer::onCmdFileSymlink(FXObject* o, FXSelector sel, void* ptr)
{
    if (dirpanel->isActive())
        dirpanel->handle(o,FXSEL(SEL_COMMAND,DirPanel::ID_DIR_SYMLINK),ptr);

    else
        lpanel->getCurrent()->handle(o,FXSEL(SEL_COMMAND,FilePanel::ID_FILE_SYMLINK),NULL);

    return 1;
}


// File trash
long XFileExplorer::onCmdFileTrash(FXObject* o, FXSelector sel, void* ptr)
{
    if (dirpanel->isActive())
        dirpanel->handle(o,FXSEL(SEL_COMMAND,DirPanel::ID_DIR_TRASH),ptr);

    else
        lpanel->getCurrent()->handle(o,FXSEL(SEL_COMMAND,FilePanel::ID_FILE_TRASH),ptr);

    return 1;
}


// File restore
long XFileExplorer::onCmdFileRestore(FXObject* o,FXSelector sel,void* ptr)
{
    if (dirpanel->isActive())
        dirpanel->handle(o,FXSEL(SEL_COMMAND,DirPanel::ID_DIR_RESTORE),ptr);

    else
        lpanel->getCurrent()->handle(o,FXSEL(SEL_COMMAND,FilePanel::ID_FILE_RESTORE),ptr);

    return 1;
}


// File delete
long XFileExplorer::onCmdFileDelete(FXObject* o,FXSelector sel,void* ptr)
{
    if (dirpanel->isActive())
        dirpanel->handle(o,FXSEL(SEL_COMMAND,DirPanel::ID_DIR_DELETE),ptr);

    else
        lpanel->getCurrent()->handle(o,FXSEL(SEL_COMMAND,FilePanel::ID_FILE_DELETE),ptr);

    return 1;
}


// File properties
long XFileExplorer::onCmdFileProperties(FXObject* o,FXSelector sel,void*)
{
    if (dirpanel->isActive())
        dirpanel->handle(o,FXSEL(SEL_COMMAND,DirPanel::ID_PROPERTIES),NULL);

    else
        lpanel->getCurrent()->handle(o,FXSEL(SEL_COMMAND,FilePanel::ID_PROPERTIES),NULL);

    return 1;
}


// Update the empty trash can and trash menus
long XFileExplorer::onUpdEmptyTrash(FXObject* o,FXSelector,void* ptr)
{

    FXbool use_trash_can=getApp()->reg().readUnsignedEntry("OPTIONS","use_trash_can",true);
    if (use_trash_can)
    {
        // Update the empty trash can menu
        o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_ENABLE),NULL);

        // Update the trash menu title
        helpmenutitle->setText("");
        trashmenutitle->setText(_("&Recycle Bin"));
        trashmenutitle->enable();
        trashmenutitle->show();
        helpmenutitle->setText(_("&Help"));
    }
    else
    {
        // Update the empty trash can menu
        o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_DISABLE),NULL);

        // Update the trash menu title
        trashmenutitle->hide();
        trashmenutitle->disable();
        helpmenutitle->setText("");
        helpmenutitle->setText(_("&Help"));
    }

    return 1;
}


// Update the trash size menu
long XFileExplorer::onUpdTrashSize(FXObject* o,FXSelector,void*)
{
    FXbool use_trash_can=getApp()->reg().readUnsignedEntry("OPTIONS","use_trash_can",true);
    if (use_trash_can)
        o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_ENABLE),NULL);
    else
        o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_DISABLE),NULL);

    return 1;
}


// Update the file delete menu item
long XFileExplorer::onUpdFileDelete(FXObject* o,FXSelector,void* ptr)
{
    if (dirpanel->isActive())
        dirpanel->handle(o,FXSEL(SEL_UPDATE,DirPanel::ID_DIR_DELETE),ptr);

    else
        lpanel->getCurrent()->handle(o,FXSEL(SEL_UPDATE,FilePanel::ID_FILE_DELETE),ptr);

    return 1;
}


// Update the move to trash menu item
long XFileExplorer::onUpdFileTrash(FXObject* o,FXSelector,void* ptr)
{
    if (dirpanel->isActive())
        dirpanel->handle(o,FXSEL(SEL_UPDATE,DirPanel::ID_DIR_TRASH),ptr);

    else
        lpanel->getCurrent()->handle(o,FXSEL(SEL_UPDATE,FilePanel::ID_FILE_TRASH),ptr);

    return 1;
}


// Update the restore from trash menu item
long XFileExplorer::onUpdFileRestore(FXObject* o,FXSelector,void* ptr)
{
    if (dirpanel->isActive())
        dirpanel->handle(o,FXSEL(SEL_UPDATE,DirPanel::ID_DIR_RESTORE),ptr);

    else
        lpanel->getCurrent()->handle(o,FXSEL(SEL_UPDATE,FilePanel::ID_FILE_RESTORE),ptr);

    return 1;
}


// Update the file operation menu items
inline long XFileExplorer::onUpdFileMan(FXObject* o,FXSelector,void*)
{
    // Update the panelfocus variable
    if (lpanel->getCurrent()->isActive())
        panelfocus=FILEPANEL_FOCUS;
    if (dirpanel->isActive())
        panelfocus=DIRPANEL_FOCUS;

    // Update the file operation menu items
    if (dirpanel->isActive())
    {
        o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_ENABLE),NULL);
    }
    else
    {
        int num=lpanel->getCurrent()->getNumSelectedItems();
        if (num==0)
            o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_DISABLE),NULL);
        //else if (num==1)
        else if (num==1 && lpanel->getCurrent()->isItemSelected(0))
            o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_DISABLE),NULL);
        else
            o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_ENABLE),NULL);
    }

    return 1;
}


// Update the file rename menu items
inline long XFileExplorer::onUpdFileRename(FXObject* o,FXSelector,void*)
{
    int num=lpanel->getCurrent()->getNumSelectedItems();
    if (num==1)
    {
        if (lpanel->getCurrent()->isItemSelected(0))
            o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_DISABLE),NULL);
        else
            o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_ENABLE),NULL);
    }
    else
        o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_DISABLE),NULL);
    return 1;
}


// Update the paste menu and button
inline long XFileExplorer::onUpdFilePaste(FXObject* o,FXSelector sel,void*)
{
    lpanel->getCurrent()->handle(o,FXSEL(SEL_UPDATE,FilePanel::ID_PASTE_CLIPBOARD),NULL);
    return 1;
}


// Update the root menu items
inline long XFileExplorer::onUpdSu(FXObject* o,FXSelector,void*)
{
    FXbool root_mode=getApp()->reg().readUnsignedEntry("OPTIONS","root_mode",true);

    if (!root_mode || getuid()==0)
        o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_DISABLE),NULL);
    else
        o->handle(this,FXSEL(SEL_COMMAND,FXWindow::ID_ENABLE),NULL);

    return 1;
}



// Open files URIS
void XFileExplorer::openFiles(vector_FXString startURIs)
{
    FXString pathname, samecmd, cmd, cmdname, itemslist=" ";
    FileAssoc* association;
    FXbool same=true;
    FXbool first=true;

    // Default programs
    FXString txtviewer=getApp()->reg().readStringEntry("PROGS","txtviewer",DEFAULT_TXTVIEWER);
    FXString txteditor=getApp()->reg().readStringEntry("PROGS","txteditor",DEFAULT_TXTEDITOR);
    FXString imgviewer=getApp()->reg().readStringEntry("PROGS","imgviewer",DEFAULT_IMGVIEWER);
    FXString imgeditor=getApp()->reg().readStringEntry("PROGS","imgeditor",DEFAULT_IMGEDITOR);
    FXString pdfviewer=getApp()->reg().readStringEntry("PROGS","pdfviewer",DEFAULT_PDFVIEWER);
    FXString audioplayer=getApp()->reg().readStringEntry("PROGS","audioplayer",DEFAULT_AUDIOPLAYER);
    FXString videoplayer=getApp()->reg().readStringEntry("PROGS","videoplayer",DEFAULT_VIDEOPLAYER);
    FXString archiver=getApp()->reg().readStringEntry("PROGS","archiver",DEFAULT_ARCHIVER);

    // Update associations dictionary
    FileDict* assocdict=new FileDict(getApp());

    // Check if all files have the same association
    for (FXuint u=0; u<startURIs.size(); u++)
    {
        if (::isFile(startURIs[u]))
        {
            // Increment number of selected items
            pathname=startURIs[u];
            association=assocdict->findFileBinding(pathname.text());

            if (association)
            {
                cmd = association->command.section(',',0);

                // Use a default program if possible
                switch (progs[cmd])
                {
                case TXTVIEWER:
                    cmd=txtviewer;
                    break;

                case TXTEDITOR:
                    cmd=txteditor;
                    break;

                case IMGVIEWER:
                    cmd=imgviewer;
                    break;

                case IMGEDITOR:
                    cmd=imgeditor;
                    break;

                case PDFVIEWER:
                    cmd=pdfviewer;
                    break;

                case AUDIOPLAYER:
                    cmd=audioplayer;
                    break;

                case VIDEOPLAYER:
                    cmd=videoplayer;
                    break;

                case ARCHIVER:
                    cmd=archiver;
                    break;

                case NONE: // No program found
                    ;
                    break;
                }

                if (cmd != "")
                {
                    // First item
                    if (first)
                    {
                        samecmd = cmd;
                        first=false;
                    }

                    if (samecmd != cmd)
                    {
                        same=false;
                        break;
                    }

                    // List of items
                    itemslist += ::quote(pathname) + " ";
                }
                else
                {
                    same=false;
                    break;
                }
            }
            else
            {
                same=false;
                break;
            }
        }
    }

#ifdef STARTUP_NOTIFICATION
    // Startup notification option and exceptions (if any)
    FXbool usesn=getApp()->reg().readUnsignedEntry("OPTIONS","use_startup_notification",true);
    FXString snexcepts=getApp()->reg().readStringEntry("OPTIONS","startup_notification_exceptions","");
#endif

    // Same command for all files: open them
    if (same)
    {
        cmdname=samecmd;

        // If command exists, run it
        if (::existCommand(cmdname))
        {
            cmd=samecmd+itemslist;
#ifdef STARTUP_NOTIFICATION
            runcmd(cmd,cmdname,lpanel->getDirectory(),startlocation,usesn,snexcepts);
#else
            runcmd(cmd,lpanel->getDirectory(),startlocation);
#endif
        }

        // Command does not exist
        else
            MessageBox::error(this,BOX_OK,_("Error"),_("Command not found: %s"),cmd.text());
    }

    // Files have different commands: handle them separately
    else
    {
        for (FXuint u=0; u<startURIs.size(); u++)
        {
            if (::isFile(startURIs[u]))
            {
                pathname=startURIs[u];
                association=assocdict->findFileBinding(pathname.text());
                if (association)
                {
                    // Use it to open the file
                    cmd = association->command.section(',',0);

                    // Use a default program if possible
                    switch (progs[cmd])
                    {
                    case TXTVIEWER:
                        cmd=txtviewer;
                        break;

                    case TXTEDITOR:
                        cmd=txteditor;
                        break;

                    case IMGVIEWER:
                        cmd=imgviewer;
                        break;

                    case IMGEDITOR:
                        cmd=imgeditor;
                        break;

                    case PDFVIEWER:
                        cmd=pdfviewer;
                        break;

                    case AUDIOPLAYER:
                        cmd=audioplayer;
                        break;

                    case VIDEOPLAYER:
                        cmd=videoplayer;
                        break;

                    case ARCHIVER:
                        cmd=archiver;
                        break;

                    case NONE: // No program found
                        ;
                        break;
                    }

                    if (cmd != "")
                    {
                        cmdname=cmd;

                        // If command exists, run it
                        if (::existCommand(cmdname))
                        {
                            cmd=cmdname+" "+::quote(pathname);
#ifdef STARTUP_NOTIFICATION
                            runcmd(cmd,cmdname,lpanel->getDirectory(),startlocation,usesn,snexcepts);
#else
                            runcmd(cmd,lpanel->getDirectory(),startlocation);
#endif
                        }

                        // Command does not exist
                        else
                            MessageBox::error(this,BOX_OK,_("Error"),_("Command not found: %s"),cmdname.text());
                    }

                    // Command string is void
                    else
                        MessageBox::error(this,BOX_OK,_("Error"),_("Invalid file association: %s"),FXPath::extension(pathname).text());
                }

                // Other cases
                else
                    MessageBox::error(this,BOX_OK,_("Error"),_("File association not found: %s"),FXPath::extension(pathname).text());
            }
        }
    }
}


// Quit immediately and properly, if asked
inline long XFileExplorer::onUpdQuit(FXObject* o,FXSelector,void*)
{
    if (stop)
        onQuit(0,0,0);

    return 1;
}


//const int throby = 5;
int throby = 0;
/*long XFileExplorer::onCmdAnimateThrobber(FXObject* sender,FXSelector sel,void*)
{
    FXLabel* throbber = getThrobber();

    throbber->move(0, throby);
    throby = throby + 22;

    return 1;
}*/


inline long XFileExplorer::onCmdAnimateThrobber(FXObject* sender,FXSelector sel,void*) {
	if ( throby == throbymax ) {
		throby = 0;
	} else {
	        throby = throby - 22;
	}
	throbber->move(0, throby);
	//printf("%i\n", throby);
	getApp()->addTimeout(this,ID_ANIMTHROB,50);
	return 1;
}

inline long XFileExplorer::onCmdStopAnimateThrobber(FXObject* sender,FXSelector sel,void*) {
	getApp()->removeTimeout(this,ID_ANIMTHROB);
	throby = 0;
	throbber->move(0, 0);
	return 1;
}

inline long XFileExplorer::onCmdActivateThrobber(FXObject* sender,FXSelector sel,void*) {
	//printf("%d\n", throbymax);
	//printf("%d\n", throbanimicon->getHeight());
	//throbymax = - throbanimicon->getHeight();
	getApp()->addTimeout(this,ID_ANIMTHROB,0);
}

// This code is adapted from 'imageviewer', a demo image viewer found
// in the FOX library and written by Jeroen van der Zijp.

#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGImage.h>
#include <FXJPGImage.h>
#include <FXTIFImage.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "startupnotification.h"
#include "FileDialog.h"
#include "InputDialog.h"
#include "DirHistBox.h"
#include "MessageBox.h"
#include "FileList.h"
#include "XFileImage.h"

// Add FOX hacks
#include "foxhacks.cpp"
#include "clearlooks.cpp"

// Global variables
char**   args;
FXColor  listbackcolor, listforecolor;
FXColor  highlightcolor;
FXbool   allowPopupScroll = false;
FXuint   single_click;
FXbool   file_tooltips;
FXbool   relative_resize;
FXbool   show_pathlink;
FXbool   save_win_pos;
FXString homedir;
FXString xdgconfighome;
FXString xdgdatahome;
FXbool   xim_used = false;

// Hand cursor replacement
#define hand_width     32
#define hand_height    32
#define hand_x_hot     6
#define hand_y_hot     1
static const FXuchar hand_bits[] =
{
    0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00,
    0x90, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x90, 0x07, 0x00, 0x00,
    0x97, 0x1a, 0x00, 0x00, 0x99, 0x2a, 0x00, 0x00, 0x11, 0x28, 0x00, 0x00,
    0x12, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00,
    0x04, 0x20, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00,
    0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const FXuchar hand_mask_bits[] =
{
    0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
    0xf0, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00,
    0xf7, 0x1f, 0x00, 0x00, 0xff, 0x3f, 0x00, 0x00, 0xff, 0x3f, 0x00, 0x00,
    0xfe, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00,
    0xfc, 0x3f, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00,
    0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// Predefined zoom factors
#define NB_ZOOM    24
double zoomtab[NB_ZOOM] =
{
    0.01, 0.025, 0.05, 0.075, 0.10, 0.15, 0.20, 0.30, 0.50, 0.75, 1, \
    1.5, 2, 3, 4, 5, 7.5, 10, 15, 20, 30, 50, 75, 100
};
#define ZOOM_100       10

// Maximum image size (in pixels) for zooming in
#define MAX_IMGSIZE    5120

// Patterns for supported image formats
const char* patterns[] =
{
    _("All Files"), "*",
    _("GIF Image"), "*.gif",
    _("BMP Image"), "*.bmp",
    _("XPM Image"), "*.xpm",
    _("PCX Image"), "*.pcx",
    _("ICO Image"), "*.ico",
    _("RGB Image"), "*.rgb",
    _("XBM Image"), "*.xbm",
    _("TARGA Image"), "*.tga",
    _("PPM Image"), "*.ppm",
    _("PNG Image"), "*.png",
    _("JPEG Image"), "*.jpg",
    _("JPEG Image"), "*.jpeg",
    _("TIFF Image"), "*.tif",
    _("TIFF Image"), "*.tiff",
    NULL
};


const FXString imgpatterns = "*.gif,*.bmp,*.xpm,*.pcx,*.ico,*.rgb,*.xbm,*.tga,*.ppm,*.png,*.jpg,*.jpeg,*.tif,*.tiff";

int zoomwin = 0;

// Helper function to draw a toolbar separator
void toolbarSeparator(FXToolBar* tb)
{
#define SEP_SPACE_TB    1
    new FXFrame(tb, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE_TB);
    new FXVerticalSeparator(tb, LAYOUT_SIDE_TOP|LAYOUT_CENTER_Y|SEPARATOR_GROOVE|LAYOUT_FILL_Y);
    new FXFrame(tb, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE_TB);
}


// Helper function to draw a separator in an horizontal frame
void hframeSeparator(FXHorizontalFrame* hframe)
{
#define SEP_SPACE_HF    5
    new FXFrame(hframe, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE_HF);
    new FXVerticalSeparator(hframe, LAYOUT_SIDE_TOP|LAYOUT_CENTER_Y|SEPARATOR_GROOVE|LAYOUT_FILL_Y);
    new FXFrame(hframe, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE_HF);
}


// Map
FXDEFMAP(XFileImage) XFileImageMap[] =
{
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ABOUT, XFileImage::onCmdAbout),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_OPEN, XFileImage::onCmdOpen),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TITLE, XFileImage::onUpdTitle),
    FXMAPFUNC(SEL_SIGNAL, XFileImage::ID_HARVEST, XFileImage::onSigHarvest),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_QUIT, XFileImage::onCmdQuit),
    FXMAPFUNC(SEL_SIGNAL, XFileImage::ID_QUIT, XFileImage::onCmdQuit),
    FXMAPFUNC(SEL_CLOSE, XFileImage::ID_TITLE, XFileImage::onCmdQuit),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_RESTART, XFileImage::onCmdRestart),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_FILELIST_BEFORE, XFileImage::onCmdToggleFileListBefore),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_HORZ_PANELS, XFileImage::onCmdHorzVertPanels),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_VERT_PANELS, XFileImage::onCmdHorzVertPanels),
    FXMAPFUNC(SEL_DOUBLECLICKED, XFileImage::ID_FILELIST, XFileImage::onCmdItemDoubleClicked),
    FXMAPFUNC(SEL_CLICKED, XFileImage::ID_FILELIST, XFileImage::onCmdItemClicked),
    FXMAPFUNC(SEL_KEYPRESS, 0, XFileImage::onKeyPress),
    FXMAPFUNC(SEL_KEYRELEASE, 0, XFileImage::onKeyRelease),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_RECENTFILE, XFileImage::onCmdRecentFile),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_HIDDEN, XFileImage::onCmdToggleHidden),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_THUMBNAILS, XFileImage::onCmdToggleThumbnails),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_SHOW_DETAILS, XFileImage::onCmdShowDetails),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_SHOW_MINI_ICONS, XFileImage::onCmdShowMini),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_SHOW_BIG_ICONS, XFileImage::onCmdShowBig),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ROTATE_90, XFileImage::onCmdRotate),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ROTATE_270, XFileImage::onCmdRotate),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_MIRROR_HOR, XFileImage::onCmdMirror),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_MIRROR_VER, XFileImage::onCmdMirror),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ZOOM_IN, XFileImage::onCmdZoomIn),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ZOOM_OUT, XFileImage::onCmdZoomOut),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ZOOM_100, XFileImage::onCmdZoom100),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ZOOM_WIN, XFileImage::onCmdZoomWin),
    FXMAPFUNC(SEL_TIMEOUT, XFileImage::ID_ZOOM_WIN, XFileImage::onCmdZoomWin),
    // FXMAPFUNC(SEL_CONFIGURE, XFileImage::ID_ZOOM_WIN, XFileImage::onConfigureZoomWin),
    FXMAPFUNC(SEL_CONFIGURE, 0, XFileImage::onConfigureZoomWin),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_PRINT, XFileImage::onCmdPrint),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_UP, XFileImage::onCmdDirUp),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_UP, XFileImage::onUpdDirUp),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_BACK, XFileImage::onCmdDirBack),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_BACK, XFileImage::onUpdDirBack),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_FORWARD, XFileImage::onCmdDirForward),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_FORWARD, XFileImage::onUpdDirForward),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_BACK_HIST, XFileImage::onCmdDirBackHist),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_BACK_HIST, XFileImage::onUpdDirBackHist),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_FORWARD_HIST, XFileImage::onCmdDirForwardHist),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_FORWARD_HIST, XFileImage::onUpdDirForwardHist),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_GO_HOME, XFileImage::onCmdHome),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_PRINT, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ROTATE_90, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ROTATE_270, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_MIRROR_HOR, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_MIRROR_VER, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ZOOM_IN, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ZOOM_OUT, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ZOOM_100, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ZOOM_WIN, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_SHOW_BIG_ICONS, XFileImage::onUpdFileView),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_SHOW_MINI_ICONS, XFileImage::onUpdFileView),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_SHOW_DETAILS, XFileImage::onUpdFileView),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_HIDDEN, XFileImage::onUpdToggleHidden),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_FILELIST_BEFORE, XFileImage::onUpdToggleFileListBefore),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_THUMBNAILS, XFileImage::onUpdToggleThumbnails),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_FIT_WIN, XFileImage::onCmdToggleFitWin),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_FILTER_IMAGES, XFileImage::onCmdToggleFilterImages),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_FIT_WIN, XFileImage::onUpdToggleFitWin),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_FILTER_IMAGES, XFileImage::onUpdToggleFilterImages),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_HORZ_PANELS, XFileImage::onUpdHorzVertPanels),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_VERT_PANELS, XFileImage::onUpdHorzVertPanels),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_GO_HOME, XFileImage::onCmdHome),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_GO_WORK, XFileImage::onCmdWork),
    FXMAPFUNC(SEL_RIGHTBUTTONRELEASE, XFileImage::ID_FILELIST, XFileImage::onCmdPopupMenu),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_POPUP_MENU, XFileImage::onCmdPopupMenu),
};


// Object implementation
FXIMPLEMENT(XFileImage, FXMainWindow, XFileImageMap, ARRAYNUMBER(XFileImageMap))

// zoomwin = 0;

// Helper function to draw a horizontal separator
// im a dumbass and didnt realize fxhorizontalseparator is a thing

/* static void horSeparator(FXToolBar* tb)
{
#define SEP_SPACE    1
    FXHorizontalFrame* sepcont = new FXHorizontalFrame(filebox, LAYOUT_FILL_X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    new FXFrame(tb, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X, 0, 0, 0,0,0,0,0,0);
    new FXVerticalSeparator(tb, LAYOUT_SIDE_TOP|LAYOUT_CENTER_Y|SEPARATOR_GROOVE|LAYOUT_FILL_Y, 0, 0, 0, 0, 1, 2, 2, 2);
    new FXFrame(tb, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH, 0, 0, SEP_SPACE,0,0,0,0,0);
}*/


// Make some windows
XFileImage::XFileImage(FXApp* a, FXbool smoothscroll) : FXMainWindow(a, "Xfi ", NULL, NULL, DECOR_ALL)
{
    setIcon(xfiicon);

    FXButton* btn = NULL;
    FXHotKey  hotkey;
    FXString  key;

    setTarget(this);
    setSelector(ID_TITLE);

    // Make menu bar
    menubar = new FXMenuBar(this, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X,0,0,0,0,0,0,0,0,0,0);

    //new FXFrame(this, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FIX_HEIGHT, 0, 0, 0, 1, 0, 0, 0, 0);
    //new FXHorizontalSeparator(this, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|SEPARATOR_GROOVE|LAYOUT_FILL_X|LAYOUT_FIX_HEIGHT, 0, 0, 0, 2, 0, 0, 0, 0);
    new FXFrame(this, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FIX_HEIGHT, 0, 0, 0, 1, 0, 0, 0, 0);


    // Sites where to dock
    //FXDockSite* topdock = new FXDockSite(this, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_SUNKEN);
    FXDockSite* topdock = new FXDockSite(this, LAYOUT_SIDE_TOP|LAYOUT_FILL_X);
    new FXDockSite(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X);
    new FXDockSite(this, LAYOUT_SIDE_LEFT|LAYOUT_FILL_Y);
    new FXDockSite(this, LAYOUT_SIDE_RIGHT|LAYOUT_FILL_Y);

    // New menu bar
    // FXToolBarShell* dragshell0 = new FXToolBarShell(this, FRAME_RAISED);
    // menubar = new FXMenuBar(topdock, dragshell0, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_RAISED);
    // new FXToolBarGrip(menubar, menubar, FXToolBar::ID_TOOLBARGRIP, TOOLBARGRIP_SINGLE);

    // Tool bar
    FXToolBarShell* dragshell1 = new FXToolBarShell(this, FRAME_RAISED);
    //toolbar = new FXToolBar(topdock, dragshell1, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_RAISED);
    toolbarcont = new FXVerticalFrame(this, LAYOUT_FILL_X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    new FXHorizontalSeparator(toolbarcont, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_TOP|SEPARATOR_GROOVE|LAYOUT_FILL_X|LAYOUT_FIX_HEIGHT, 0, 0, 0, 2, 0, 0, 0, 0);
    toolbar = new FXToolBar(toolbarcont, dragshell1, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y,0,0,0,0,0,0,0,0,0,0);
    // new FXToolBarGrip(toolbar, toolbar, FXToolBar::ID_TOOLBARGRIP, TOOLBARGRIP_SINGLE);

    // File menu
    filemenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&File"), NULL, filemenu);

    // Image Menu
    imagemenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&Image"), NULL, imagemenu);

    // View menu
    viewmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&View"), NULL, viewmenu);

    // Preferences Menu
    prefsmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&Preferences"), NULL, prefsmenu);

    // Help menu
    helpmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&Help"), NULL, helpmenu);

    // Splitter
    FXVerticalFrame* vframe = new FXVerticalFrame(this, LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // Set order of the file list and image widgets
    filelistbefore = getApp()->reg().readUnsignedEntry("OPTIONS", "filelist_before", false);
    if (filelistbefore)
    {
        splitter = new FXSplitter(vframe, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|SPLITTER_TRACKING|SPLITTER_VERTICAL);
        filebox = new FXVerticalFrame(splitter, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	imageviewcontainer = new FXVerticalFrame(splitter, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_THICK|FRAME_SUNKEN, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        imageview = new FXImageView(imageviewcontainer, NULL, NULL, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    }
    else
    {
        splitter = new FXSplitter(vframe, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|SPLITTER_TRACKING|SPLITTER_VERTICAL|SPLITTER_REVERSED);
	imageviewcontainer = new FXVerticalFrame(splitter, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_THICK|FRAME_SUNKEN, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        imageview = new FXImageView(imageviewcontainer, NULL, NULL, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y);
        filebox = new FXVerticalFrame(splitter, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }

    // Stack panels horizontally or vertically
    vertpanels = getApp()->reg().readUnsignedEntry("OPTIONS", "vert_panels", false);
    if (vertpanels)
    {
        splitter->setSplitterStyle(splitter->getSplitterStyle()&~SPLITTER_VERTICAL);
    }
    else
    {
        splitter->setSplitterStyle(splitter->getSplitterStyle()|SPLITTER_VERTICAL);
    }

    // Container for the action buttons
    FXHorizontalFrame* buttons = new FXHorizontalFrame(filebox, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_RAISED, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0);

    // Container for the path linker
    FXHorizontalFrame* pathframe = new FXHorizontalFrame(filebox, LAYOUT_FILL_X|FRAME_RAISED, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // File list
    FXuint options;
    if (smoothscroll)
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS|_ICONLIST_BROWSESELECT;
    }
    else
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS|_ICONLIST_BROWSESELECT|SCROLLERS_DONT_TRACK;
    }

    thumbnails = getApp()->reg().readUnsignedEntry("OPTIONS", "thumbnails", 0);
    filelist = new FileList(this, filebox, this, ID_FILELIST, thumbnails, options);
    filelist->setTextColor(listforecolor);
    filelist->setBackColor(listbackcolor);
    filelist->setHeaderSize(0, getApp()->reg().readUnsignedEntry("OPTIONS", "name_size", 200));
    filelist->setHeaderSize(1, getApp()->reg().readUnsignedEntry("OPTIONS", "size_size", 60));
    filelist->setHeaderSize(2, getApp()->reg().readUnsignedEntry("OPTIONS", "type_size", 100));
    filelist->setHeaderSize(3, getApp()->reg().readUnsignedEntry("OPTIONS", "ext_size", 100));
    filelist->setHeaderSize(4, getApp()->reg().readUnsignedEntry("OPTIONS", "modd_size", 150));
    filelist->setHeaderSize(5, getApp()->reg().readUnsignedEntry("OPTIONS", "user_size", 50));
    filelist->setHeaderSize(6, getApp()->reg().readUnsignedEntry("OPTIONS", "grou_size", 50));
    filelist->setHeaderSize(7, getApp()->reg().readUnsignedEntry("OPTIONS", "attr_size", 100));

    // Action buttons
    new FXFrame(buttons, LAYOUT_FIX_WIDTH, 0, 0, 4, 1);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_back", "Ctrl-Backspace");
    btn = new FXButton(buttons, TAB+_("Go to previous folder")+PARS(key), dirbackicon, this, ID_DIR_BACK, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);
    btnbackhist = new FXArrowButton(buttons, this, ID_DIR_BACK_HIST, LAYOUT_FILL_Y|FRAME_RAISED|FRAME_THICK|ARROW_DOWN|ARROW_TOOLBAR);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_forward", "Shift-Backspace");
    btn = new FXButton(buttons, TAB+_("Go to next folder")+PARS(key), dirforwardicon, this, ID_DIR_FORWARD, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);
    btnforwardhist = new FXArrowButton(buttons, this, ID_DIR_FORWARD_HIST, LAYOUT_FILL_Y|FRAME_RAISED|FRAME_THICK|ARROW_DOWN|ARROW_TOOLBAR);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_up", "Backspace");
    btn = new FXButton(buttons, TAB+_("Go to parent folder")+PARS(key), dirupicon, this, ID_DIR_UP, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Separator
    hframeSeparator(buttons);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_home", "Ctrl-H");
    new FXButton(buttons, TAB+_("Go to home folder")+PARS(key), homeicon, this, ID_GO_HOME, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_work", "Shift-F2");
    new FXButton(buttons, TAB+_("Go to working folder")+PARS(key), workicon, this, ID_GO_WORK, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Separator
    hframeSeparator(buttons);

    // Switch display modes
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "big_icons", "F10");
    btn = new FXButton(buttons, TAB+_("Big icon list")+PARS(key), bigiconsicon, this, ID_SHOW_BIG_ICONS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "small_icons", "F11");
    btn = new FXButton(buttons, TAB+_("Small icon list")+PARS(key), smalliconsicon, this, ID_SHOW_MINI_ICONS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "detailed_file_list", "F12");
    btn = new FXButton(buttons, TAB+_("Detailed file list")+PARS(key), detailsicon, this, ID_SHOW_DETAILS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Separator
    hframeSeparator(buttons);

    // Vertical panels
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "vert_panels", "Ctrl-Shift-F1");
    btn = new FXButton(buttons, TAB+_("Vertical panels")+PARS(key), vertpanelsicon, this, XFileImage::ID_VERT_PANELS, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Horizontal panels
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "horz_panels", "Ctrl-Shift-F2");
    btn = new FXButton(buttons, TAB+_("Horizontal panels")+PARS(key), horzpanelsicon, this, XFileImage::ID_HORZ_PANELS, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Panel title
    pathtext = new TextLabel(pathframe, 0, this, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    pathtext->setBackColor(getApp()->getBaseColor());

    // Path linker
    pathlink = new PathLinker(pathframe, filelist, NULL, LAYOUT_FILL_X);

    // Status bar
    //statusbar = new FXHorizontalFrame(vframe, JUSTIFY_LEFT|LAYOUT_FILL_X, 0, 0, 0, 0, 3, 3, 0, 0);
    FXPacker* statusbarcont = new FXPacker(vframe, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|LAYOUT_BOTTOM, 0, 0, 0, 0, 0, 0, 0, 0);
    // statusbar = new FXHorizontalFrame(statusbarcont, JUSTIFY_LEFT|LAYOUT_FILL_X, 0, 0, 0, 0, 0, 0, 0, 0);
    statusbar = new FXHorizontalFrame(statusbarcont, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_X|LAYOUT_SIDE_LEFT, 0, 0, 0, 0, 0, 0, 0, 0);

    // Read and set sort function for file list
    FXString sort_func = getApp()->reg().readStringEntry("OPTIONS", "sort_func", "ascendingCase");
    if (sort_func == "ascendingCase")
    {
        filelist->setSortFunc(filelist->ascendingCase);
    }
    if (sort_func == "ascendingCaseMix")
    {
        filelist->setSortFunc(filelist->ascendingCaseMix);
    }
    else if (sort_func == "descendingCase")
    {
        filelist->setSortFunc(filelist->descendingCase);
    }
    else if (sort_func == "descendingCaseMix")
    {
        filelist->setSortFunc(filelist->descendingCaseMix);
    }
    else if (sort_func == "ascending")
    {
        filelist->setSortFunc(filelist->ascending);
    }
    else if (sort_func == "ascendingMix")
    {
        filelist->setSortFunc(filelist->ascendingMix);
    }
    else if (sort_func == "descending")
    {
        filelist->setSortFunc(filelist->descending);
    }
    else if (sort_func == "descendingMix")
    {
        filelist->setSortFunc(filelist->descendingMix);
    }
    else if (sort_func == "ascendingSize")
    {
        filelist->setSortFunc(filelist->ascendingSize);
    }
    else if (sort_func == "ascendingSizeMix")
    {
        filelist->setSortFunc(filelist->ascendingSizeMix);
    }
    else if (sort_func == "descendingSize")
    {
        filelist->setSortFunc(filelist->descendingSize);
    }
    else if (sort_func == "descendingSizeMix")
    {
        filelist->setSortFunc(filelist->descendingSizeMix);
    }
    else if (sort_func == "ascendingType")
    {
        filelist->setSortFunc(filelist->ascendingType);
    }
    else if (sort_func == "ascendingTypeMix")
    {
        filelist->setSortFunc(filelist->ascendingTypeMix);
    }
    else if (sort_func == "descendingType")
    {
        filelist->setSortFunc(filelist->descendingType);
    }
    else if (sort_func == "descendingTypeMix")
    {
        filelist->setSortFunc(filelist->descendingTypeMix);
    }
    else if (sort_func == "ascendingExt")
    {
        filelist->setSortFunc(filelist->ascendingExt);
    }
    else if (sort_func == "ascendingExtMix")
    {
        filelist->setSortFunc(filelist->ascendingExtMix);
    }
    else if (sort_func == "descendingExt")
    {
        filelist->setSortFunc(filelist->descendingExt);
    }
    else if (sort_func == "descendingExtMix")
    {
        filelist->setSortFunc(filelist->descendingExtMix);
    }
    else if (sort_func == "ascendingTime")
    {
        filelist->setSortFunc(filelist->ascendingTime);
    }
    else if (sort_func == "ascendingTimeMix")
    {
        filelist->setSortFunc(filelist->ascendingTimeMix);
    }
    else if (sort_func == "descendingTime")
    {
        filelist->setSortFunc(filelist->descendingTime);
    }
    else if (sort_func == "descendingTimeMix")
    {
        filelist->setSortFunc(filelist->descendingTimeMix);
    }
    else if (sort_func == "ascendingUser")
    {
        filelist->setSortFunc(filelist->ascendingUser);
    }
    else if (sort_func == "ascendingUserMix")
    {
        filelist->setSortFunc(filelist->ascendingUserMix);
    }
    else if (sort_func == "descendingUser")
    {
        filelist->setSortFunc(filelist->descendingUser);
    }
    else if (sort_func == "descendingUserMix")
    {
        filelist->setSortFunc(filelist->descendingUserMix);
    }
    else if (sort_func == "ascendingGroup")
    {
        filelist->setSortFunc(filelist->ascendingGroup);
    }
    else if (sort_func == "ascendingGroupMix")
    {
        filelist->setSortFunc(filelist->ascendingGroupMix);
    }
    else if (sort_func == "descendingGroup")
    {
        filelist->setSortFunc(filelist->descendingGroup);
    }
    else if (sort_func == "descendingGroupMix")
    {
        filelist->setSortFunc(filelist->descendingGroupMix);
    }
    else if (sort_func == "ascendingPerm")
    {
        filelist->setSortFunc(filelist->ascendingPerm);
    }
    else if (sort_func == "ascendingPermMix")
    {
        filelist->setSortFunc(filelist->ascendingPermMix);
    }
    else if (sort_func == "descendingPerm")
    {
        filelist->setSortFunc(filelist->descendingPerm);
    }
    else if (sort_func == "descendingPermMix")
    {
        filelist->setSortFunc(filelist->descendingPermMix);
    }

    // Single click navigation
    if (single_click == SINGLE_CLICK_DIR_FILE)
    {
        filelist->setDefaultCursor(getApp()->getDefaultCursor(DEF_HAND_CURSOR));
    }

    // Status bar buttons
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");
    // new FXToggleButton(statusbar, TAB+_("Show hidden files")+PARS(key), TAB+_("Hide hidden files")+PARS(key), showhiddenicon, hidehiddenicon, this->filelist,
    //                    FileList::ID_TOGGLE_HIDDEN, BUTTON_TOOLBAR|LAYOUT_LEFT|ICON_BEFORE_TEXT);

    // key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");
    // new FXToggleButton(statusbar, TAB+_("Show thumbnails")+PARS(key), TAB+_("Hide thumbnails")+PARS(key), showthumbicon, hidethumbicon, this->filelist,
    //                    FileList::ID_TOGGLE_THUMBNAILS, BUTTON_TOOLBAR|LAYOUT_LEFT|ICON_BEFORE_TEXT);

    //new FXStatusBar(statusbar, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|FRAME_SUNKEN);
    new FXStatusBar(statusbar, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|FRAME_SUNKEN,0,0,0,0,0,0,0,0,0,0);
    corner = new FXPacker(statusbarcont, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_RIGHT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT|LAYOUT_SIDE_RIGHT|LAYOUT_BOTTOM, 0, 0, 13, 13, 0, 0, 0, 0, 0, 0);
    realcorner = new FXDragCorner(corner);

    // Toolbar button: Open file
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "open", "Ctrl-O");
    new FXButton(toolbar, TAB+_("Open")+PARS(key)+TAB+_("Open image file.")+PARS(key), fileopenicon, this, ID_OPEN, ICON_ABOVE_TEXT|FRAME_RAISED|FRAME_THICK,0,0,0,0,1,2,1,1);

    // Toolbar button: Print
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "print", "Ctrl-P");
    new FXButton(toolbar, TAB+_("Print")+PARS(key)+TAB+_("Print image file.")+PARS(key), printicon, this, ID_PRINT, BUTTON_TOOLBAR|FRAME_RAISED);

    // Separator
    toolbarSeparator(toolbar);

    // Note : Ctrl+ and Ctrl- cannot be changed from the registry!

    // Toolbar button: Zoom in
    btn = new FXButton(toolbar, TAB+_("Zoom in")+PARS("Ctrl+")+TAB+_("Zoom in image.")+PARS("Ctrl+"), zoominicon, this, ID_ZOOM_IN, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);
    hotkey = (CONTROLMASK<<16) |  KEY_KP_Add;
    btn->addHotKey(hotkey);

    // Toolbar button: Zoom out
    btn = new FXButton(toolbar, TAB+_("Zoom out")+PARS("Ctrl-")+TAB+_("Zoom out image.")+PARS("Ctrl-"), zoomouticon, this, ID_ZOOM_OUT, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);
    hotkey = (CONTROLMASK<<16) | KEY_KP_Subtract;
    btn->addHotKey(hotkey);

    // Toolbar button: Zoom 100%
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_100", "Ctrl-I");
    new FXButton(toolbar, TAB+_("Zoom 100%")+PARS(key)+TAB+_("Zoom image to 100%.")+PARS(key), zoom100icon, this, ID_ZOOM_100, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Toolbar button: Zoom to fit window
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_win", "Ctrl-F");
    new FXButton(toolbar, TAB+_("Zoom to fit")+PARS(key)+TAB+_("Zoom to fit window.")+PARS(key), zoomwinicon, this, ID_ZOOM_WIN, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Separator
    toolbarSeparator(toolbar);

    // Toolbar button: Rotate left
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_left", "Ctrl-L");
    new FXButton(toolbar, TAB+_("Rotate left")+PARS(key)+TAB+_("Rotate left image.")+PARS(key), rotatelefticon, this, ID_ROTATE_90, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Toolbar button: Rotate right
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_right", "Ctrl-R");
    new FXButton(toolbar, TAB+_("Rotate right")+PARS(key)+TAB+_("Rotate right image.")+PARS(key), rotaterighticon, this, ID_ROTATE_270, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Toolbar button: mirror horizontally
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_horizontally", "Ctrl-Shift-H");
    new FXButton(toolbar, TAB+_("Mirror horizontally")+PARS(key)+TAB+_("Mirror image horizontally.")+PARS(key), fliplricon, this, ID_MIRROR_HOR, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Toolbar button: mirror vertically
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_vertically", "Ctrl-Shift-V");
    new FXButton(toolbar, TAB+_("Mirror vertically")+PARS(key)+TAB+_("Mirror image vertically.")+PARS(key), flipudicon, this, ID_MIRROR_VER, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // File Menu entries
    FXMenuCommand* mc = NULL;
    FXString       text;

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "open", "Ctrl-O");
    text = _("&Open...")+TABS(key)+_("Open image file.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, fileopenicon, this, ID_OPEN);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "print", "Ctrl-P");
    text = _("&Print...")+TABS(key)+_("Print image file.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, printicon, this, ID_PRINT);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    // Recent file menu; this automatically hides if there are no files
    FXMenuSeparator* sep1 = new FXMenuSeparator(filemenu);
    sep1->setTarget(&mrufiles);
    sep1->setSelector(FXRecentFiles::ID_ANYFILES);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_1);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_2);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_3);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_4);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_5);
    new FXMenuCommand(filemenu, _("&Clear recent files")+TAB2+_("Clear recent file menu."), NULL, &mrufiles, FXRecentFiles::ID_CLEAR);
    FXMenuSeparator* sep2 = new FXMenuSeparator(filemenu);
    sep2->setTarget(&mrufiles);
    sep2->setSelector(FXRecentFiles::ID_ANYFILES);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "quit", "Ctrl-Q");
    text = _("&Quit")+TABS(key)+_("Quit Xfi.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, quiticon, this, ID_QUIT);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));
    getAccelTable()->addAccel(KEY_Escape, this, FXSEL(SEL_COMMAND, ID_QUIT));

    // Image Menu entries
    new FXMenuCommand(imagemenu, _("Zoom &in")+TAB+(FXString)"Ctrl+"+TAB+_("Zoom in image.")+PARS("Ctrl+"), zoominicon, this, ID_ZOOM_IN);
    new FXMenuCommand(imagemenu, _("Zoom &out")+TAB+(FXString)"Ctrl-"+TAB+_("Zoom out image.")+PARS("Ctrl-"), zoomouticon, this, ID_ZOOM_OUT);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_100", "Ctrl-I");
    text = _("Zoo&m 100%")+TABS(key)+_("Zoom image to 100%.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, zoom100icon, this, ID_ZOOM_100);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_win", "Ctrl-F");
    text = _("Zoom to fit &window")+TABS(key)+_("Zoom to fit window.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, zoomwinicon, this, ID_ZOOM_WIN);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_right", "Ctrl-R");
    text = _("Rotate &right")+TABS(key)+_("Rotate right.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, rotaterighticon, this, ID_ROTATE_270);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_left", "Ctrl-L");
    text = _("Rotate &left")+TABS(key)+_("Rotate left.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, rotatelefticon, this, ID_ROTATE_90);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_horizontally", "Ctrl-Shift-H");
    text = _("Mirror &horizontally")+TABS(key)+_("Mirror horizontally.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, fliplricon, this, ID_MIRROR_HOR);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_vertically", "Ctrl-Shift-V");
    text = _("Mirror &vertically")+TABS(key)+_("Mirror vertically.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, flipudicon, this, ID_MIRROR_VER);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    // View Menu entries
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");
    text = _("&Hidden files")+TABS(key)+_("Show hidden files and folders.")+PARS(key);
    mc = new FXMenuCheck(viewmenu, text, this, ID_TOGGLE_HIDDEN);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");
    text = _("&Thumbnails")+TABS(key)+_("Show image thumbnails.")+PARS(key);
    mc = new FXMenuCheck(viewmenu, text, this, ID_TOGGLE_THUMBNAILS);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuSeparator(viewmenu);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "big_icons", "F10");
    text = _("&Big icons")+TABS(key)+_("Display folders with big icons.")+PARS(key);
    mc = new FXMenuRadio(viewmenu, text, this, ID_SHOW_BIG_ICONS);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "small_icons", "F11");
    text = _("&Small icons")+TABS(key)+_("Display folders with small icons.")+PARS(key);
    mc = new FXMenuRadio(viewmenu, text, this, ID_SHOW_MINI_ICONS);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "detailed_file_list", "F12");
    text = _("&Detailed file list")+TABS(key)+_("Display detailed folder listing.")+PARS(key);
    mc = new FXMenuRadio(viewmenu, text, this, ID_SHOW_DETAILS);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuSeparator(viewmenu);

    mc = new FXMenuRadio(viewmenu, _("&Vertical panels"), this, XFileImage::ID_VERT_PANELS);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "vert_panels", "Ctrl-Shift-F1");
    mc->setAccelText(key);

    mc = new FXMenuRadio(viewmenu, _("&Horizontal panels"), this, XFileImage::ID_HORZ_PANELS);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "horz_panels", "Ctrl-Shift-F2");
    mc->setAccelText(key);

    new FXMenuSeparator(viewmenu);
    new FXMenuRadio(viewmenu, _("&Rows")+TAB2+_("View icons row-wise."), filelist, FileList::ID_ARRANGE_BY_ROWS);
    new FXMenuRadio(viewmenu, _("&Columns")+TAB2+_("View icons column-wise."), filelist, FileList::ID_ARRANGE_BY_COLUMNS);
    new FXMenuCheck(viewmenu, _("&Autosize")+TAB2+_("Autosize icon names."), filelist, FileList::ID_AUTOSIZE);

    // Preferences menu
    new FXMenuCheck(prefsmenu, _("&Toolbar")+TAB2+_("Display toolbar."), toolbarcont, FXWindow::ID_TOGGLESHOWN);
    new FXMenuCheck(prefsmenu, _("&File list")+TAB2+_("Display file list."), filebox, FXWindow::ID_TOGGLESHOWN);
    new FXMenuCheck(prefsmenu, _("File list &before")+TAB2+_("Display file list before image window."), this, ID_TOGGLE_FILELIST_BEFORE);
    new FXMenuCheck(prefsmenu, _("&Filter images")+TAB2+_("List only image files."), this, ID_TOGGLE_FILTER_IMAGES);
    new FXMenuCheck(prefsmenu, _("Fit &window when opening")+TAB2+_("Zoom to fit window when opening an image."), this, ID_TOGGLE_FIT_WIN);


    // Help Menu entries
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "help", "F1");
    text = _("&About X File Image")+TABS(key)+_("About X File Image.")+PARS(key);
    mc = new FXMenuCommand(helpmenu, text, NULL, this, ID_ABOUT, 0);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    // Close accelerator
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "close", "Ctrl-W");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, this, FXSEL(SEL_COMMAND, XFileImage::ID_QUIT));

    // Make a tool tip
    new FXToolTip(getApp(), TOOLTIP_NORMAL);

    // Images
    img = NULL;
    tmpimg = NULL;

    // Dialogs
    printdialog = NULL;

    // Recent files
    mrufiles.setTarget(this);
    mrufiles.setSelector(ID_RECENTFILE);

    // Initialize file name
    filename = "";

    // Initialize some flags
    fileview = ID_SHOW_MINI_ICONS;
    hiddenfiles = false;

    // Initialize zoom to 100%
    indZoom = ZOOM_100;
    zoomval = zoomtab[indZoom];
    fitwin = false;
    filterimgs = false;

    // Initialize previous window width / height
    prev_width = getWidth();
    prev_height = getHeight();
}


// Clean up
XFileImage::~XFileImage()
{
    delete toolbar;
    delete menubar;
    delete statusbar;
    delete filemenu;
    delete imagemenu;
    delete helpmenu;
    delete prefsmenu;
    delete viewmenu;
    delete dragshell1;
    delete pathlink;
    delete pathtext;
    delete filelist;
    delete img;
    delete tmpimg;
    delete printdialog;
    delete btnbackhist;
    delete btnforwardhist;
}


long XFileImage::onCmdPopupMenu(FXObject* o, FXSelector s, void* p)
{
    // Popup menu pane
    FXMenuPane menu(this);
    int        x, y;
    FXuint     state;

    getRoot()->getCursorPosition(x, y, state);

    new FXMenuCommand(&menu, _("Go ho&me"), homeicon, this, ID_GO_HOME);
    new FXMenuCommand(&menu, _("Go &work"), workicon, this, ID_GO_WORK);
    new FXMenuSeparator(&menu);
    new FXMenuCheck(&menu, _("&Hidden files"), this, ID_TOGGLE_HIDDEN);
    new FXMenuCheck(&menu, _("Thum&bnails"), this, ID_TOGGLE_THUMBNAILS);
    new FXMenuSeparator(&menu);
    new FXMenuRadio(&menu, _("B&ig icons"), this, ID_SHOW_BIG_ICONS);
    new FXMenuRadio(&menu, _("&Small icons"), this, ID_SHOW_MINI_ICONS);
    new FXMenuRadio(&menu, _("Fu&ll file list"), this, ID_SHOW_DETAILS);
    new FXMenuSeparator(&menu);
    new FXMenuRadio(&menu, _("&Rows"), filelist, FileList::ID_ARRANGE_BY_ROWS);
    new FXMenuRadio(&menu, _("&Columns"), filelist, FileList::ID_ARRANGE_BY_COLUMNS);
    new FXMenuCheck(&menu, _("Autosize"), filelist, FileList::ID_AUTOSIZE);
    new FXMenuSeparator(&menu);
    new FXMenuRadio(&menu, _("&Name"), filelist, FileList::ID_SORT_BY_NAME);
    new FXMenuRadio(&menu, _("Si&ze"), filelist, FileList::ID_SORT_BY_SIZE);
    new FXMenuRadio(&menu, _("&Type"), filelist, FileList::ID_SORT_BY_TYPE);
    new FXMenuRadio(&menu, _("E&xtension"), filelist, FileList::ID_SORT_BY_EXT);
    new FXMenuRadio(&menu, _("&Date"), filelist, FileList::ID_SORT_BY_TIME);
    new FXMenuRadio(&menu, _("&User"), filelist, FileList::ID_SORT_BY_USER);
    new FXMenuRadio(&menu, _("&Group"), filelist, FileList::ID_SORT_BY_GROUP);
    new FXMenuRadio(&menu, _("&Permissions"), filelist, FileList::ID_SORT_BY_PERM);
    new FXMenuSeparator(&menu);
    new FXMenuCheck(&menu, _("Ignore c&ase"), filelist, FileList::ID_SORT_CASE);
    new FXMenuCheck(&menu, _("Fold&ers first"), filelist, FileList::ID_DIRS_FIRST);
    new FXMenuCheck(&menu, _("Re&verse order"), filelist, FileList::ID_SORT_REVERSE);

    menu.create();
    allowPopupScroll = true;  // Allow keyboard scrolling
    menu.popup(NULL, x, y);
    getApp()->runModalWhileShown(&menu);
    allowPopupScroll = false;
    return(1);
}


// If Shift-F10 or Menu is pressed, opens the popup menu
long XFileImage::onKeyPress(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    // Shift-F10 or Menu was pressed : open popup menu
   	if ((event->state&SHIFTMASK && event->code == KEY_F10) || event->code == KEY_Menu)
    {
        this->handle(sender, FXSEL(SEL_COMMAND, XFileImage::ID_POPUP_MENU), ptr);
        return(1);
    }

    // Any other key was pressed : handle the pressed key in the usual way
    else
    {
        if (FXTopWindow::onKeyPress(sender, sel, ptr))
        {
            return(1);
        }
    }

    return(0);
}


long XFileImage::onKeyRelease(FXObject* sender, FXSelector sel, void* ptr)
{
    if (FXTopWindow::onKeyRelease(sender, sel, ptr))
    {
        return(1);
    }

    return(0);
}


// User clicked up directory button
long XFileImage::onCmdDirUp(FXObject*, FXSelector, void*)
{
    filelist->setDirectory(FXPath::upLevel(filelist->getDirectory()));
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());

    filelist->setFocus();

    return(1);
}


// Can we still go up
long XFileImage::onUpdDirUp(FXObject* sender, FXSelector, void*)
{
    if (FXPath::isTopDirectory(filelist->getDirectory()))
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), NULL);
    }
    return(1);
}


// Directory back
long XFileImage::onCmdDirBack(FXObject*, FXSelector s, void* p)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;
    forwardhist = filelist->forwardhist;

    // Get the previous directory
    item = backhist->getFirst();
    if (item)
    {
        pathname = backhist->getString(item);
    }

    // Update the history
    backhist->removeFirstItem();
    forwardhist->insertFirstItem(filelist->getDirectory());

    // Go to to the previous directory
    filelist->setDirectory(pathname, false);
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());

    filelist->setFocus();

    return(1);
}


// Update directory back
long XFileImage::onUpdDirBack(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;

    // Gray out the button if no item in history
    if (backhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory forward
long XFileImage::onCmdDirForward(FXObject*, FXSelector s, void* p)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;
    forwardhist = filelist->forwardhist;

    // Get the next directory
    item = forwardhist->getFirst();
    if (item)
    {
        pathname = forwardhist->getString(item);
    }

    // Update the history
    forwardhist->removeFirstItem();
    backhist->insertFirstItem(filelist->getDirectory());

    // Go to to the previous directory
    filelist->setDirectory(pathname, false);
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());

    filelist->setFocus();

    return(1);
}


// Update directory forward
long XFileImage::onUpdDirForward(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* forwardhist;
    FXString    pathname;

    // Get the filelist history
    forwardhist = filelist->forwardhist;

    // Gray out the button if no item in history
    if (forwardhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory back history
long XFileImage::onCmdDirBackHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;
    forwardhist = filelist->forwardhist;

    // Get all string items and display them in a list box
    int num = backhist->getNumItems();
    if (num > 0)
    {
        FXString* dirs = new FXString[num];
        FXString  strlist = "";

        // Get string items
        item = backhist->getFirst();
        for (int i = 0; i <= num-1; i++)
        {
            if (item)
            {
                FXString str = backhist->getString(item);
                dirs[i] = str;
                strlist = strlist+str+"\n";
                item = backhist->getNext(item);
            }
        }

        // Display list box
        int pos = DirHistBox::box(btnbackhist, DECOR_NONE, strlist, this->getX()+245, this->getY()+37);

        // If an item was selected
        if (pos != -1)
        {
            // Update back history
            if (pos == num-1)
            {
                backhist->removeAllItems();
            }
            else
            {
                item = backhist->getItemAtPos(pos+1);
                backhist->removeAllItemsBefore(item);
            }

            // Update forward history
            forwardhist->insertFirstItem(filelist->getDirectory());
            if (pos > 0)
            {
                for (int i = 0; i <= pos-1; i++)
                {
                    forwardhist->insertFirstItem(dirs[i]);
                }
            }

            // Go to to the selected directory
            pathname = dirs[pos];
            filelist->setDirectory(pathname, false);
            pathlink->setPath(filelist->getDirectory());
            pathtext->setText(filelist->getDirectory());
        }
        delete[]dirs;
    }

    return(1);
}


// Update directory back
long XFileImage::onUpdDirBackHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;

    // Gray out the button if no item in history
    if (backhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory forward history
long XFileImage::onCmdDirForwardHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;
    forwardhist = filelist->forwardhist;

    // Get all string items and display them in a list box
    int num = forwardhist->getNumItems();
    if (num > 0)
    {
        FXString* dirs = new FXString[num];
        FXString  strlist = "";

        // Get string items
        item = forwardhist->getFirst();
        for (int i = 0; i <= num-1; i++)
        {
            if (item)
            {
                FXString str = forwardhist->getString(item);
                dirs[i] = str;
                strlist = strlist+str+"\n";
                item = forwardhist->getNext(item);
            }
        }

        // Display list box
        int pos = DirHistBox::box(btnforwardhist, DECOR_NONE, strlist, this->getX()+285, this->getY()+37);

        // If an item was selected
        if (pos != -1)
        {
            // Update forward history
            if (pos == num-1)
            {
                forwardhist->removeAllItems();
            }
            else
            {
                item = forwardhist->getItemAtPos(pos+1);
                forwardhist->removeAllItemsBefore(item);
            }

            // Update back history
            backhist->insertFirstItem(filelist->getDirectory());
            if (pos > 0)
            {
                for (int i = 0; i <= pos-1; i++)
                {
                    backhist->insertFirstItem(dirs[i]);
                }
            }

            // Go to to the selected directory
            pathname = dirs[pos];
            filelist->setDirectory(pathname, false);
            pathlink->setPath(filelist->getDirectory());
            pathtext->setText(filelist->getDirectory());
        }
        delete[]dirs;
    }

    return(1);
}


// Update directory forward
long XFileImage::onUpdDirForwardHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* forwardhist;
    FXString    pathname;

    // Get the filelist history
    forwardhist = filelist->forwardhist;

    // Gray out the button if no item in history
    if (forwardhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Back to home directory
long XFileImage::onCmdHome(FXObject*, FXSelector, void*)
{
    filelist->setDirectory(FXSystem::getHomeDirectory());
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());
    filelist->setFocus();
    return(1);
}


// Back to current working directory
long XFileImage::onCmdWork(FXObject*, FXSelector, void*)
{
    filelist->setDirectory(FXSystem::getCurrentDirectory());
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());
    filelist->setFocus();
    return(1);
}


// About box
long XFileImage::onCmdAbout(FXObject*, FXSelector, void*)
{
    FXString msg;

    msg.format(_("X File Image Version %s is a simple image viewer.\n\n"), VERSION);
    msg += COPYRIGHT;
    MessageBox about(this, _("About X File Image"), msg.text(), xfiicon, BOX_OK|DECOR_TITLE|DECOR_BORDER,
                     JUSTIFY_CENTER_X|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    about.execute(PLACEMENT_OWNER);

    filelist->setFocus();

    return(1);
}


// Load file
FXbool XFileImage::loadimage(const FXString& file)
{
    FXString ext = FXPath::extension(file);

    FILE* fp = fopen(file.text(), "r");

    if (!fp)
    {
        MessageBox::error(this, BOX_OK, _("Error Loading File"), _("Unable to open file: %s"), file.text());
        return(false);
    }
    else
    {
        fclose(fp);
    }

    // Free old image if any, before loading a new one
    if (img)
    {
        delete img;
        img = NULL;
    }
    if (tmpimg)
    {
        delete tmpimg;
        tmpimg = NULL;
    }

    if (comparecase(ext, "gif") == 0)
    {
        img = new FXGIFImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXGIFImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "bmp") == 0)
    {
        img = new FXBMPImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXBMPImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "xpm") == 0)
    {
        img = new FXXPMImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXXPMImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "pcx") == 0)
    {
        img = new FXPCXImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXPCXImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if ((comparecase(ext, "ico") == 0) || (comparecase(ext, "cur") == 0))
    {
        img = new FXICOImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXICOImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "tga") == 0)
    {
        img = new FXTGAImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXTGAImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "rgb") == 0)
    {
        img = new FXRGBImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "xbm") == 0)
    {
        img = new FXXBMImage(getApp(), NULL, NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXXBMImage(getApp(), NULL, NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "ppm") == 0)
    {
        img = new FXPPMImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXPPMImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "png") == 0)
    {
        img = new FXPNGImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXPNGImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if ((comparecase(ext, "jpg") == 0) || (comparecase(ext, "jpeg") == 0))
    {
        img = new FXJPGImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXJPGImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if ((comparecase(ext, "tif") == 0) || (comparecase(ext, "tiff") == 0))
    {
        img = new FXTIFImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXTIFImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else
    {
        img = NULL;
        tmpimg = NULL;
    }

    // Perhaps failed
    if (img == NULL)
    {
        MessageBox::error(this, BOX_OK, _("Error Loading Image"), _("Unsupported type: %s"), ext.text());
        return(false);
    }

    if (tmpimg == NULL)
    {
        MessageBox::error(this, BOX_OK, _("Error Loading Image"), _("Unsupported type: %s"), ext.text());
        return(false);
    }

    // Load it
    FXFileStream stream;
    if (stream.open(file, FXStreamLoad))
    {
        getApp()->beginWaitCursor();
        FXbool res = img->loadPixels(stream);

        stream.close();

        // If failed
        if (!res)
        {
            MessageBox::error(this, BOX_OK, _("Error Loading Image"), _("Unable to load image, the file may be corrupted"));
            getApp()->endWaitCursor();
            return(false);
        }

        if (!FXMEMDUP(&tmpdata, img->getData(), FXColor, img->getWidth()*img->getHeight()))
        {
            throw FXMemoryException(_("Unable to load image"));
        }
        tmpimg->setData(tmpdata, IMAGE_OWNED, img->getWidth(), img->getHeight());

        img->blend(getApp()->getBackColor());
        tmpimg->blend(getApp()->getBackColor());

        img->create();
        tmpimg->create();

        imageview->setImage(tmpimg);

        // Initial zoom and image format
        indZoom = ZOOM_100;
        zoomval = zoomtab[indZoom];
        getApp()->endWaitCursor();

        // Zoom to fit window if asked
        if (fitwin)
        {
            handle(this, FXSEL(SEL_COMMAND, ID_ZOOM_WIN), NULL);
        }
    }
    filelist->setDirectory(FXPath::directory(file));
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());

    return(true);
}


// Toggle file list before image
long XFileImage::onCmdToggleFileListBefore(FXObject* sender, FXSelector, void*)
{
    filelistbefore = !filelistbefore;

    if (BOX_CLICKED_CANCEL != MessageBox::question(this, BOX_OK_CANCEL, _("Restart"), _("Change will be taken into account after restart.\nRestart X File Image now?")))
    {
        this->handle(this, FXSEL(SEL_COMMAND, XFileImage::ID_RESTART), NULL);
    }

    return(1);
}


// Update file list before image
long XFileImage::onUpdToggleFileListBefore(FXObject* sender, FXSelector, void*)
{
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), NULL);
        if (filelistbefore)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
        }
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), NULL);
    }

    return(1);
}


// Toggle zoom to fit window on startup
long XFileImage::onCmdToggleFitWin(FXObject*, FXSelector, void*)
{
    fitwin = !fitwin;
    filelist->setFocus();
    return(1);
}


// Update toggle wrap mode
long XFileImage::onUpdToggleFitWin(FXObject* sender, FXSelector, void*)
{
    if (fitwin)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


// Toggle filter image files
long XFileImage::onCmdToggleFilterImages(FXObject*, FXSelector, void*)
{
    filterimgs = !filterimgs;
    if (filterimgs)
    {
        filelist->setPattern(imgpatterns);
    }
    else
    {
        filelist->setPattern("*");
    }

    filelist->setFocus();

    return(1);
}


// Update filter image files
long XFileImage::onUpdToggleFilterImages(FXObject* sender, FXSelector, void*)
{
    // Disable menu item if the file list is not shown
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);

        // Update menu item
        if (filterimgs)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
        }
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);

        // Update menu item
        if (filterimgs)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
        }
    }
    return(1);
}


// Open
long XFileImage::onCmdOpen(FXObject*, FXSelector, void*)
{
    FileDialog opendialog(this, _("Open Image"));

    opendialog.setSelectMode(SELECTFILE_EXISTING);
    opendialog.setPatternList(patterns);
    opendialog.setDirectory(filelist->getDirectory());
    if (opendialog.execute())
    {
        filename = opendialog.getFilename();
        filelist->setCurrentFile(filename);
        mrufiles.appendFile(filename);
        loadimage(filename);
    }

    return(1);
}


// Print the text
long XFileImage::onCmdPrint(FXObject*, FXSelector, void*)
{
    // Read the current print command from the registry
    FXString printcommand, command;

    printcommand = getApp()->reg().readStringEntry("OPTIONS", "print_command", "lpr -P printer");

    // Open print dialog filled with the current print command
    int rc = 1;
    if (printdialog == NULL)
    {
        printdialog = new InputDialog(this, printcommand, _("Print command: \n(ex: lpr -P <printer>)"), _("Print"), "", printbigicon);
    }
    printdialog->setText(printcommand);
    printdialog->CursorEnd();
    rc = printdialog->execute(PLACEMENT_CURSOR);
    printcommand = printdialog->getText();

    // If cancel was pressed, exit
    if (!rc)
    {
        return(0);
    }

    // Write the new print command to the registry
    getApp()->reg().writeStringEntry("OPTIONS", "print_command", printcommand.text());

    // Perform the print command
    command = "cat " + filename + " |" + printcommand + " &";
    int ret = system(command.text());
    if (ret < 0)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Can't execute command %s"), command.text());
        return(0);
    }

    return(1);
}


// Handle toggle hidden command
long XFileImage::onCmdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    filelist->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_HIDDEN), ptr);
    filelist->setFocus();

    return(1);
}


// Update toggle hidden command
long XFileImage::onUpdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;

    hiddenfiles = filelist->shownHiddenFiles();

    if (hiddenfiles == true)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);

    // Disable menu item if the file list is not shown
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Handle toggle hidden command
long XFileImage::onCmdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    filelist->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_THUMBNAILS), ptr);
    filelist->setFocus();

    return(1);
}


// Update toggle hidden command
long XFileImage::onUpdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;

    thumbnails = filelist->shownThumbnails();

    if (thumbnails == true)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);

    // Disable menu item if the file list is not shown
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Show mini icons in file list
long XFileImage::onCmdShowMini(FXObject*, FXSelector, void*)
{
    fileview = ID_SHOW_MINI_ICONS;
    filelist->handle(this, FXSEL(SEL_COMMAND, FileList::ID_SHOW_MINI_ICONS), NULL);
    filelist->setFocus();

    return(1);
}


// Show big icons in file list
long XFileImage::onCmdShowBig(FXObject*, FXSelector, void*)
{
    fileview = ID_SHOW_BIG_ICONS;
    filelist->handle(this, FXSEL(SEL_COMMAND, FileList::ID_SHOW_BIG_ICONS), NULL);
    filelist->setFocus();

    return(1);
}


// Show details in file list
long XFileImage::onCmdShowDetails(FXObject*, FXSelector, void*)
{
    fileview = ID_SHOW_DETAILS;
    filelist->handle(this, FXSEL(SEL_COMMAND, FileList::ID_SHOW_DETAILS), NULL);
    filelist->setFocus();

    return(1);
}


// Update filelist
long XFileImage::onUpdFileView(FXObject* sender, FXSelector sel, void* ptr)
{
    // Keep the filebox width / height relative to the window width / height

    // Get the current width and height
    int width = getWidth();
    int height = getHeight();

    // Panel stacked horizontally
    if (vertpanels)
    {
        if (relative_resize && (prev_width != width))
        {
            // File box shown
            if (filebox->shown())
            {
                filebox->setWidth((int)round(filewidth_pct*width));
            }
        }

        // Update the relative width (only if window width is sufficient)
        prev_width = width;
        if (getWidth() > 10)
        {
            filewidth_pct = (double)(filebox->getWidth())/(double)(getWidth());
        }
    }

    // Panel stacked vertically
    else
    {
        if (relative_resize && (prev_height != height))
        {
            // File box shown
            if (filebox->shown())
            {
                filebox->setHeight((int)round(fileheight_pct*height));
            }
        }

        // Update the relative height (only if window height is sufficient)
        prev_height = height;
        if (getHeight() > 10)
        {
            fileheight_pct = (double)(filebox->getHeight())/(double)(getHeight());
        }
    }

    // Update radio buttons
    FXuint msg = FXWindow::ID_UNCHECK;

    switch (FXSELID(sel))
    {
    case ID_SHOW_MINI_ICONS:
        if (fileview == ID_SHOW_MINI_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_BIG_ICONS:
        if (fileview == ID_SHOW_BIG_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_DETAILS:
        if (fileview == ID_SHOW_DETAILS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), NULL);

    // Disable menus items if the file list is not shown
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Harvest the zombies
long XFileImage::onSigHarvest(FXObject*, FXSelector, void*)
{
    while (waitpid(-1, NULL, WNOHANG) > 0)
    {
    }
    return(1);
}


// Quit
long XFileImage::onCmdQuit(FXObject*, FXSelector, void*)
{
    // Save settings
    saveConfig();

    // Quit
    getApp()->exit(EXIT_SUCCESS);
    return(1);
}


// Update title (display image size and actual zoom)
long XFileImage::onUpdTitle(FXObject* sender, FXSelector, void*)
{
    FXString title = "Xfi " + filename;
    FXImage* image = imageview->getImage();

    if (image && (img != NULL))
    {
        title += " (" + FXStringVal(img->getWidth()) + "x" + FXStringVal(img->getHeight()) + " - " + FXStringVal(zoomval*100) + "%" ")";
    }
    sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_SETSTRINGVALUE), (void*)&title);
    return(1);
}


// Open recent file
long XFileImage::onCmdRecentFile(FXObject*, FXSelector, void* ptr)
{
    filename = (char*)ptr;
    filelist->setCurrentFile(filename);
    loadimage(filename);
    return(1);
}


// Double clicked in the file list
long XFileImage::onCmdItemDoubleClicked(FXObject*, FXSelector, void* ptr)
{
    int index = (int)(FXival)ptr;

    if (0 <= index)
    {
        if (filelist->isItemDirectory(index))
        {
            FXString pathname = filelist->getItemPathname(index);

            // Does not have access
            if (!::isReadExecutable(pathname))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _(" Permission to: %s denied."), pathname.text());
                return(0);
            }
            filelist->setDirectory(pathname);
            pathlink->setPath(pathname);
            pathtext->setText(pathname);
        }
        else if (filelist->isItemFile(index))
        {
            filename = filelist->getItemPathname(index);
            mrufiles.appendFile(filename);
            loadimage(filename);
            filelist->setCurrentItem(index);
        }
    }
    return(1);
}


// Single clicked in the file list
long XFileImage::onCmdItemClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    if (single_click != SINGLE_CLICK_NONE)
    {
        // In detailed mode, avoid single click when cursor is not over the first column
        int    x, y;
        FXuint state;
        filelist->getCursorPosition(x, y, state);
        FXbool allow = true;
        if (!(filelist->getListStyle()&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS)) && ((x-filelist->getXPosition()) > filelist->getHeaderSize(0)))
        {
            allow = false;
        }

        int index = (int)(FXival)ptr;
        if (0 <= index)
        {
            if ((single_click != SINGLE_CLICK_NONE) && filelist->isItemDirectory(index) && allow)
            {
                FXString pathname = filelist->getItemPathname(index);

                // Does not have access
                if (!::isReadExecutable(pathname))
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _(" Permission to: %s denied."), pathname.text());
                    return(0);
                }
                filelist->setDirectory(pathname);
                pathlink->setPath(pathname);
                pathtext->setText(pathname);
            }
            else if ((single_click == SINGLE_CLICK_DIR_FILE) && filelist->isItemFile(index) && allow)
            {
                filename = filelist->getItemPathname(index);
                mrufiles.appendFile(filename);
                loadimage(filename);
                filelist->setCurrentItem(index);
            }
        }
    }
    return(1);
}


// Rotate image
long XFileImage::onCmdRotate(FXObject* sender, FXSelector sel, void* ptr)
{
    getApp()->beginWaitCursor();
    FXImage* image = imageview->getImage();
    switch (FXSELID(sel))
    {
    case ID_ROTATE_90:

        // Rotate the actual image
        image->rotate(90);

        // Need to also rotate the original image only if the actual size is different
        if ((image->getWidth() != img->getWidth()) || (image->getHeight() != img->getHeight()))
        {
            img->rotate(90);
        }

        break;

    case ID_ROTATE_270:

        // Rotate the actual image
        image->rotate(270);

        // Need to also rotate the original image only if the actual size is different
        if ((image->getWidth() != img->getWidth()) || (image->getHeight() != img->getHeight()))
        {
            img->rotate(270);
        }
        break;
    }
    imageview->setImage(image);
    if ( zoomwin == 1 ) {
        //this->handle(sender, FXSEL(SEL_COMMAND, XFileImage::ID_ZOOM_WIN), ptr);
        handle(this, FXSEL(SEL_COMMAND, ID_ZOOM_WIN), NULL);
        //getApp()->removeTimeout(this,ID_ZOOM_WIN);
        //getApp()->addTimeout(this,ID_ZOOM_WIN,75);
        //XFileImage::onCmdZoomWin(sender, sel, ptr);
        //printf("lol\n");
    }
    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Update image
long XFileImage::onUpdImage(FXObject* sender, FXSelector, void*)
{
    if (imageview->getImage())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    return(1);
}


// Mirror image
long XFileImage::onCmdMirror(FXObject*, FXSelector sel, void*)
{
    getApp()->beginWaitCursor();
    FXImage* image = imageview->getImage();
    switch (FXSELID(sel))
    {
    case ID_MIRROR_HOR:

        // Mirror the actual image
        image->mirror(true, false);

        // Need to also mirror the original image only if the actual size is different
        if ((image->getWidth() != img->getWidth()) || (image->getHeight() != img->getHeight()))
        {
            img->mirror(true, false);
        }
        break;

    case ID_MIRROR_VER:

        // Mirror the actual image
        image->mirror(false, true);

        // Need to also mirror the original image only if the actual size is different
        if ((image->getWidth() != img->getWidth()) || (image->getHeight() != img->getHeight()))
        {
            img->mirror(false, true);
        }
        break;
    }
    imageview->setImage(image);
    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Zoom in image
long XFileImage::onCmdZoomIn(FXObject*, FXSelector, void*)
{
    zoomwin = 0;

    imgvwidth = NULL;
    imgvheight = NULL;
    //getApp()->removeTimeout(this,ID_ZOOM_WIN);

    // getApp()->removeTimeout(this,ID_ZOOM_WIN);
    getApp()->beginWaitCursor();

    // Copy the original image into the actual one
    if (!FXMEMDUP(&tmpdata, img->getData(), FXColor, img->getWidth()*img->getHeight()))
    {
        throw FXMemoryException(_("Unable to load image"));
    }
    tmpimg->setData(tmpdata, IMAGE_OWNED, img->getWidth(), img->getHeight());

    // Resize the actual image according to the new zoom factor
    indZoom += 1;
    if (indZoom > NB_ZOOM-1)
    {
        indZoom = NB_ZOOM-1;
    }
    int sx = (int)(tmpimg->getWidth()*zoomtab[indZoom]);
    int sy = (int)(tmpimg->getHeight()*zoomtab[indZoom]);

    // Scale only if the actual image size is different
    if (indZoom == ZOOM_100)
    {
        imageview->setImage(img);
    }
    else
    {
        // Maximum zoom allowed
        if ((sx > MAX_IMGSIZE) || (sy > MAX_IMGSIZE))
        {
            indZoom -= 1;
            if (indZoom < 0)
            {
                indZoom = 0;
            }
            sx = (int)(tmpimg->getWidth()*zoomtab[indZoom]);
            sy = (int)(tmpimg->getHeight()*zoomtab[indZoom]);
        }

        // Scale image according to the new zoom factor
        tmpimg->scale(sx, sy, 1);
        imageview->setImage(tmpimg);
    }

    // Set zoom value for window title
    zoomval = zoomtab[indZoom];

    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Zoom out image
long XFileImage::onCmdZoomOut(FXObject*, FXSelector, void*)
{
    zoomwin = 0;

    imgvwidth = NULL;
    imgvheight = NULL;
    //getApp()->removeTimeout(this,ID_ZOOM_WIN);

    //getApp()->removeTimeout(this,ID_ZOOM_WIN);
    getApp()->beginWaitCursor();

    // Copy the original image into the actual one
    if (!FXMEMDUP(&tmpdata, img->getData(), FXColor, img->getWidth()*img->getHeight()))
    {
        throw FXMemoryException(_("Unable to load image"));
    }
    tmpimg->setData(tmpdata, IMAGE_OWNED, img->getWidth(), img->getHeight());

    // Resize the image according to the new zoom factor
    indZoom -= 1;
    if (indZoom < 0)
    {
        indZoom = 0;
    }
    int sx = (int)(tmpimg->getWidth()*zoomtab[indZoom]);
    int sy = (int)(tmpimg->getHeight()*zoomtab[indZoom]);

    // Scale only if the actual image size is different
    if (indZoom == ZOOM_100)
    {
        imageview->setImage(img);
    }
    else
    {
        // Scale image according to the new zoom factor
        tmpimg->scale(sx, sy, 1);
        imageview->setImage(tmpimg);
    }

    // Set zoom value for window title
    zoomval = zoomtab[indZoom];

    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Zoom to 100%
long XFileImage::onCmdZoom100(FXObject*, FXSelector, void*)
{
    zoomwin = 0;

    imgvwidth = NULL;
    imgvheight = NULL;
    //getApp()->removeTimeout(this,ID_ZOOM_WIN);

    getApp()->beginWaitCursor();
    indZoom = ZOOM_100;
    zoomval = zoomtab[indZoom];
    imageview->setImage(img);
    filelist->setFocus();
    getApp()->endWaitCursor();
    //getApp()->removeTimeout(this,ID_ZOOM_WIN);
    return(1);
}


// Zoom to fit window
long XFileImage::onCmdZoomWin(FXObject*, FXSelector, void*)
{
    //getApp()->addTimeout(this,ID_ZOOM_WIN,200);

    // set zoomwin as used
    zoomwin = 1;

    //printf("lol2\n");

    // Window and image sizes
    //int winw = (this->getShell())->getWidth();
    //int winh = (this->getShell())->getHeight();
    int winw = imageview->getWidth();
    int winh = imageview->getHeight();
    //if (winw != imgvwidth || winh != imgvheight) {
    //printf("hi\n");
    getApp()->beginWaitCursor();
    // imgvwidth = (this->getShell())->getWidth();
    // imgvheight = (this->getShell())->getHeight();

    imgvwidth = imageview->getWidth();
    imgvheight = imageview->getHeight();

    int w = img->getWidth();
    int h = img->getHeight();

    // Compute zoom factor
    double fitwin;
    if (double(w)/double(h) > double(winw)/double(winh))
    {
        fitwin = 0.98*(double)winw/(double)w;
    }
    else
    {
        fitwin = 0.98*(double)winh/(double)h;
    }

    // Find the most approaching predefined zoom
    // This is used in other zoom functions
    for (int k = 0; k < NB_ZOOM; k++)
    {
        if (zoomtab[k] > fitwin)
        {
            indZoom = k-1;
            break;
        }
    }
    if (indZoom < 0)
    {
        indZoom = 0;
    }
    if (indZoom >= NB_ZOOM)
    {
        indZoom = NB_ZOOM-1;
    }

    // Copy the original image into the actual one
    if (!FXMEMDUP(&tmpdata, img->getData(), FXColor, img->getWidth()*img->getHeight()))
    {
        throw FXMemoryException(_("Unable to load image"));
    }
    tmpimg->setData(tmpdata, IMAGE_OWNED, img->getWidth(), img->getHeight());

    // Resize the image according to the new zoom factor
    int sx = (int)(w*fitwin);
    int sy = (int)(h*fitwin);

    // Scale image according to the new zoom factor
    tmpimg->scale(sx, sy, 1);
    imageview->setImage(tmpimg);

    // Set zoom value for window title
    zoomval = fitwin;

    filelist->setFocus();
    getApp()->endWaitCursor();
    //}
    zoomwin = 1;
    return(1);
}


// Zoom to fit window
long XFileImage::onConfigureZoomWin(FXObject* sender, FXSelector sel, void* ptr)
{
    // this is skidded from fox toolkit src
    FXEvent *ev = (FXEvent*)ptr;
    FXComposite::onConfigure(sender, sel, ptr);
    xpos=ev->rect.x;
    ypos=ev->rect.y;
    if ( ( ev->rect.w != width ) || ( ev->rect.h != height ) ) {
        width = ev->rect.w;               // Record new size
        height = ev->rect.h;

        recalc();
    }


    //printf("test\n");
    //int winw = imageview->getWidth();
    //int winh = imageview->getHeight();

    int winw = imageview->getWidth();
    int winh = imageview->getHeight();

    //printf("test2\n");

    if ( zoomwin == 1 ) {
    	//printf("test3\n");
    	if (winw != imgvwidth || winh != imgvheight) {
   		if (imgvwidth != 0 || imgvheight != 0 || imgvwidth != NULL || imgvheight != NULL) {
    		    //printf("test\n");
		    getApp()->removeTimeout(this,ID_ZOOM_WIN);
		    getApp()->addTimeout(this,ID_ZOOM_WIN,75);
    		    //handle(this, FXSEL(SEL_COMMAND, ID_ZOOM_WIN), NULL);
 	   	}
	}
    }




    return(1);
}


// Restart the application when required
long XFileImage::onCmdRestart(FXObject*, FXSelector, void*)
{
    saveConfig();

    if (fork() == 0) // Child
    {
        execvp("xfi", args);
    }
    else // Parent
    {
        exit(EXIT_SUCCESS);
    }
    return(1);
}


// Start the ball rolling
void XFileImage::start(FXString startimage)
{
    filename = startimage;
    if (filename != "")
    {
        loadimage(filename);
    }
}


// Create and show window
void XFileImage::create()
{
    // Get size and position
    FXuint ww = getApp()->reg().readUnsignedEntry("OPTIONS", "width", DEFAULT_WINDOW_WIDTH);    // Workaround for a possible bug in some WMs
    FXuint hh = getApp()->reg().readUnsignedEntry("OPTIONS", "height", DEFAULT_WINDOW_HEIGHT);  // Workaround for a possible bug in some WMs

    filewidth_pct = getApp()->reg().readRealEntry("OPTIONS", "filewidth_pct", 0.25);
    fileheight_pct = getApp()->reg().readRealEntry("OPTIONS", "fileheight_pct", 0.25);
    FXuint fs = getApp()->reg().readIntEntry("OPTIONS", "filesshown", true);

    filelist->setDirectory(FXSystem::getCurrentDirectory());
    pathlink->setPath(FXSystem::getCurrentDirectory());
    pathtext->setText(FXSystem::getCurrentDirectory());

    // Display or hide path linker and path text
    if (show_pathlink)
    {
        pathtext->hide();
        pathlink->show();
    }
    else
    {
        pathlink->hide();
        pathtext->show();
    }

    // Hide tree if asked for
    if (!fs)
    {
        filebox->hide();
    }

    // Set toolbar status
    if (getApp()->reg().readUnsignedEntry("OPTIONS", "showtoolbar", true) == false)
    {
        toolbarcont->hide();
    }

    // Set status bar status
    if (getApp()->reg().readUnsignedEntry("OPTIONS", "showstatusbar", true) == false)
    {
        statusbar->hide();
    }

    // Set hidden file status
    hiddenfiles = getApp()->reg().readUnsignedEntry("OPTIONS", "hiddenfiles", 0);
    filelist->showHiddenFiles(hiddenfiles);

    // Set thumbnails status
    thumbnails = getApp()->reg().readUnsignedEntry("OPTIONS", "thumbnails", 0);
    filelist->showThumbnails(thumbnails);

    // Set list style
    liststyle = getApp()->reg().readUnsignedEntry("OPTIONS", "liststyle", _ICONLIST_MINI_ICONS);
    filelist->setListStyle(liststyle|_ICONLIST_BROWSESELECT);

    // Set file view
    fileview = getApp()->reg().readUnsignedEntry("OPTIONS", "fileview", ID_SHOW_MINI_ICONS);
    this->handle(this, FXSEL(SEL_COMMAND, fileview), NULL);

    // Set startup zoom
    fitwin = getApp()->reg().readUnsignedEntry("OPTIONS", "fitwin", 0);

    // Set filter images flag
    filterimgs = getApp()->reg().readUnsignedEntry("OPTIONS", "filterimgs", false);

    // Set position and position window
    if (save_win_pos)
    {
        int xpos = getApp()->reg().readIntEntry("OPTIONS", "xpos", DEFAULT_WINDOW_XPOS);
        int ypos = getApp()->reg().readIntEntry("OPTIONS", "ypos", DEFAULT_WINDOW_YPOS);
        position(xpos, ypos, ww, hh);
    }
    else
    {
        position(getX(), getY(), ww, hh);
    }

    FXMainWindow::create();

    if (filterimgs)
    {
        filelist->setPattern(imgpatterns);
    }

    // Set filebox width or height
    if (vertpanels)
    {
        filebox->setWidth((int)round(filewidth_pct*getWidth()));
    }
    else
    {
        filebox->setHeight((int)round(fileheight_pct*getHeight()));
    }

    // Set focus on file list
    filelist->setFocus();

    show();


#ifdef STARTUP_NOTIFICATION
    startup_completed();
#endif
}


// Switch between vertical and horizontal panels
long XFileImage::onCmdHorzVertPanels(FXObject* sender, FXSelector sel, void* ptr)
{
    switch (FXSELID(sel))
    {
    case ID_VERT_PANELS:
        splitter->setSplitterStyle(splitter->getSplitterStyle()&~SPLITTER_VERTICAL);
        vertpanels = true;
        break;

    case ID_HORZ_PANELS:
        splitter->setSplitterStyle(splitter->getSplitterStyle()|SPLITTER_VERTICAL);
        vertpanels = false;
        break;
    }

    filelist->setFocus();

    return(1);
}


// Update the horizontal / vertical panel radio menus
long XFileImage::onUpdHorzVertPanels(FXObject* sender, FXSelector sel, void* ptr)
{
    sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), ptr);

    if (vertpanels)
    {
        if (FXSELID(sel) == ID_HORZ_PANELS)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_UNCHECK), ptr);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_CHECK), ptr);
        }
    }
    else
    {
        if (FXSELID(sel) == ID_VERT_PANELS)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_UNCHECK), ptr);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_CHECK), ptr);
        }
    }

    return(1);
}


// Save configuration when quitting
void XFileImage::saveConfig()
{
    // Write new window size and position back to registry
    getApp()->reg().writeUnsignedEntry("OPTIONS", "width", (FXuint)getWidth());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "height", (FXuint)getHeight());

    if (save_win_pos)
    {
        // Account for the Window Manager border size
        XWindowAttributes xwattr;
        if (XGetWindowAttributes((Display*)getApp()->getDisplay(), this->id(), &xwattr))
        {
            getApp()->reg().writeIntEntry("OPTIONS", "xpos", getX()-xwattr.x);
            getApp()->reg().writeIntEntry("OPTIONS", "ypos", getY()-xwattr.y);
        }
        else
        {
            getApp()->reg().writeIntEntry("OPTIONS", "xpos", getX());
            getApp()->reg().writeIntEntry("OPTIONS", "ypos", getY());
        }
    }

    // Width and height of filebox
    getApp()->reg().writeRealEntry("OPTIONS", "filewidth_pct", (int)(filewidth_pct*100)/100.0);
    getApp()->reg().writeRealEntry("OPTIONS", "fileheight_pct", (int)(fileheight_pct*100)/100.0);

    // Was filebox shown
    getApp()->reg().writeIntEntry("OPTIONS", "filesshown", filebox->shown());

    // Toolbar status
    if (toolbarcont->shown())
    {
        getApp()->reg().writeUnsignedEntry("OPTIONS", "showtoolbar", true);
    }
    else
    {
        getApp()->reg().writeUnsignedEntry("OPTIONS", "showtoolbar", false);
    }

    // Hidden files status
    getApp()->reg().writeUnsignedEntry("OPTIONS", "hiddenfiles", hiddenfiles);

    // Thumbnails status
    getApp()->reg().writeUnsignedEntry("OPTIONS", "thumbnails", thumbnails);

    // File view
    getApp()->reg().writeUnsignedEntry("OPTIONS", "fileview", fileview);

    // List style
    getApp()->reg().writeUnsignedEntry("OPTIONS", "liststyle", filelist->getListStyle());

    // Startup zoom
    getApp()->reg().writeUnsignedEntry("OPTIONS", "fitwin", fitwin);

    // Filter images in file list
    getApp()->reg().writeUnsignedEntry("OPTIONS", "filterimgs", filterimgs);

    // Filelist columns sizes
    getApp()->reg().writeUnsignedEntry("OPTIONS", "name_size", filelist->getHeaderSize(0));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "size_size", filelist->getHeaderSize(1));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "type_size", filelist->getHeaderSize(2));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "ext_size", filelist->getHeaderSize(3));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "modd_size", filelist->getHeaderSize(4));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "user_size", filelist->getHeaderSize(5));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "grou_size", filelist->getHeaderSize(6));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "attr_size", filelist->getHeaderSize(7));

    // Panel stacking
    getApp()->reg().writeUnsignedEntry("OPTIONS", "filelist_before", filelistbefore);
    getApp()->reg().writeUnsignedEntry("OPTIONS", "vert_panels", vertpanels);

    // Get and write sort function for search window
    FXString sort_func;
    if (filelist->getSortFunc() == filelist->ascendingCase)
    {
        sort_func = "ascendingCase";
    }
    if (filelist->getSortFunc() == filelist->ascendingCaseMix)
    {
        sort_func = "ascendingCaseMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingCase)
    {
        sort_func = "descendingCase";
    }
    else if (filelist->getSortFunc() == filelist->descendingCaseMix)
    {
        sort_func = "descendingCaseMix";
    }
    else if (filelist->getSortFunc() == filelist->ascending)
    {
        sort_func = "ascending";
    }
    else if (filelist->getSortFunc() == filelist->ascendingMix)
    {
        sort_func = "ascendingMix";
    }
    else if (filelist->getSortFunc() == filelist->descending)
    {
        sort_func = "descending";
    }
    else if (filelist->getSortFunc() == filelist->descendingMix)
    {
        sort_func = "descendingMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingSize)
    {
        sort_func = "ascendingSize";
    }
    else if (filelist->getSortFunc() == filelist->ascendingSizeMix)
    {
        sort_func = "ascendingSizeMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingSize)
    {
        sort_func = "descendingSize";
    }
    else if (filelist->getSortFunc() == filelist->descendingSizeMix)
    {
        sort_func = "descendingSizeMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingType)
    {
        sort_func = "ascendingType";
    }
    else if (filelist->getSortFunc() == filelist->ascendingTypeMix)
    {
        sort_func = "ascendingTypeMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingType)
    {
        sort_func = "descendingType";
    }
    else if (filelist->getSortFunc() == filelist->descendingTypeMix)
    {
        sort_func = "descendingTypeMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingExt)
    {
        sort_func = "ascendingExt";
    }
    else if (filelist->getSortFunc() == filelist->ascendingExtMix)
    {
        sort_func = "ascendingExtMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingExt)
    {
        sort_func = "descendingExt";
    }
    else if (filelist->getSortFunc() == filelist->descendingExtMix)
    {
        sort_func = "descendingExtMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingTime)
    {
        sort_func = "ascendingTime";
    }
    else if (filelist->getSortFunc() == filelist->ascendingTimeMix)
    {
        sort_func = "ascendingTimeMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingTime)
    {
        sort_func = "descendingTime";
    }
    else if (filelist->getSortFunc() == filelist->descendingTimeMix)
    {
        sort_func = "descendingTimeMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingUser)
    {
        sort_func = "ascendingUser";
    }
    else if (filelist->getSortFunc() == filelist->ascendingUserMix)
    {
        sort_func = "ascendingUserMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingUser)
    {
        sort_func = "descendingUser";
    }
    else if (filelist->getSortFunc() == filelist->descendingUserMix)
    {
        sort_func = "descendingUserMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingGroup)
    {
        sort_func = "ascendingGroup";
    }
    else if (filelist->getSortFunc() == filelist->ascendingGroupMix)
    {
        sort_func = "ascendingGroupMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingGroup)
    {
        sort_func = "descendingGroup";
    }
    else if (filelist->getSortFunc() == filelist->descendingGroupMix)
    {
        sort_func = "descendingGroupMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingPerm)
    {
        sort_func = "ascendingPerm";
    }
    else if (filelist->getSortFunc() == filelist->ascendingPermMix)
    {
        sort_func = "ascendingPermMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingPerm)
    {
        sort_func = "descendingPerm";
    }
    else if (filelist->getSortFunc() == filelist->descendingPermMix)
    {
        sort_func = "descendingPermMix";
    }
    else
    {
        sort_func = "ascendingCase";
    }
    getApp()->reg().writeStringEntry("OPTIONS", "sort_func", sort_func.text());

    // Write registry settings
    getApp()->reg().write();
}


// Usage message
#define USAGE_MSG    _("\
\nUsage: xfi [options] [image] \n\
\n\
    [options] can be any of the following:\n\
\n\
        -h, --help         Print (this) help screen and exit.\n\
        -v, --version      Print version information and exit.\n\
\n\
    [image] is the path to the image file you want to open on start up.\n\
\n")



// Start the whole thing
int main(int argc, char* argv[])
{
    int         i;
    FXString    startimage = "";
    const char* appname = "xfi";
    const char* xfename = XFEAPPNAME;
    const char* vdrname = XFEVDRNAME;
    FXbool      loadicons;
    FXString    xmodifiers;

    // Get environment variables $HOME, $XDG_DATA_HOME and $XDG_CONFIG_HOME
    homedir = FXSystem::getHomeDirectory();
    if (homedir == "")
    {
        homedir = ROOTDIR;
    }
    xdgdatahome = getenv("XDG_DATA_HOME");
    if (xdgdatahome == "")
    {
        xdgdatahome = homedir + PATHSEPSTRING DATAPATH;
    }
    xdgconfighome = getenv("XDG_CONFIG_HOME");
    if (xdgconfighome == "")
    {
        xdgconfighome = homedir + PATHSEPSTRING CONFIGPATH;
    }

    // Detect if an X input method is used
    xmodifiers = getenv("XMODIFIERS");
    if ((xmodifiers == "") || (xmodifiers == "@im=none"))
    {
        xim_used = false;
    }
    else
    {
        xim_used = true;
    }

#ifdef HAVE_SETLOCALE
    // Set locale via LC_ALL.
    setlocale(LC_ALL, "");
#endif

#if ENABLE_NLS
    // Set the text message domain.
    bindtextdomain(PACKAGE, LOCALEDIR);
    bind_textdomain_codeset(PACKAGE, "utf-8");
    textdomain(PACKAGE);
#endif

    // Parse basic arguments
    for (i = 1; i < argc; ++i)
    {
        if ((compare(argv[i], "-v") == 0) || (compare(argv[i], "--version") == 0))
        {
            fprintf(stdout, "%s version %s\n", PACKAGE, VERSION);
            exit(EXIT_SUCCESS);
        }
        else if ((compare(argv[i], "-h") == 0) || (compare(argv[i], "--help") == 0))
        {
            fprintf(stdout, USAGE_MSG);
            exit(EXIT_SUCCESS);
        }
        else
        {
            // Start image, if any
            startimage = argv[i];
        }
    }

    args = argv;

    // Make application
    FXApp* application = new FXApp(appname, vdrname);

    // Open display
    application->init(argc, argv);

    // Redefine the default hand cursor
    FXCursor* hand = new FXCursor(application, hand_bits, hand_mask_bits, hand_width, hand_height, hand_x_hot, hand_y_hot);
    application->setDefaultCursor(DEF_HAND_CURSOR, hand);

    // Load all application icons
    loadicons = loadAppIcons(application);

    // Read the Xfe registry
    FXRegistry* reg_xfe = new FXRegistry(xfename, vdrname);
    reg_xfe->read();

    // Set base color (to change the default base color at first run)
    FXColor basecolor = reg_xfe->readColorEntry("SETTINGS", "basecolor", FXRGB(237, 233, 227));
    application->setBaseColor(basecolor);

    // Set Xfi normal font according to the Xfe registry
    FXString fontspec;
    fontspec = reg_xfe->readStringEntry("SETTINGS", "font", DEFAULT_NORMAL_FONT);
    if (!fontspec.empty())
    {
        FXFont* normalFont = new FXFont(application, fontspec);
        normalFont->create();
        application->setNormalFont(normalFont);
    }

    // Set Xfi file list colors according to the Xfe registry
    listbackcolor = reg_xfe->readColorEntry("SETTINGS", "listbackcolor", FXRGB(255, 255, 255));
    listforecolor = reg_xfe->readColorEntry("SETTINGS", "listforecolor", FXRGB(0, 0, 0));
    highlightcolor = reg_xfe->readColorEntry("SETTINGS", "highlightcolor", FXRGB(238, 238, 238));

    // Set single click navigation according to the Xfe registry
    single_click = reg_xfe->readUnsignedEntry("SETTINGS", "single_click", SINGLE_CLICK_NONE);

    // Set smooth scrolling according to the Xfe registry
    FXbool smoothscroll = reg_xfe->readUnsignedEntry("SETTINGS", "smooth_scroll", true);

    // Set file list tooltip flag according to the Xfe registry
    file_tooltips = reg_xfe->readUnsignedEntry("SETTINGS", "file_tooltips", true);

    // Set relative resizing flag according to the Xfe registry
    relative_resize = reg_xfe->readUnsignedEntry("SETTINGS", "relative_resize", true);

    // Set display pathlinker flag according to the Xfe registry
    show_pathlink = reg_xfe->readUnsignedEntry("SETTINGS", "show_pathlinker", true);

    // Get value of the window position flag
    save_win_pos = reg_xfe->readUnsignedEntry("SETTINGS", "save_win_pos", false);

    // Delete the Xfe registry
    delete reg_xfe;

    // Make window
    XFileImage* window = new XFileImage(application, smoothscroll);

    // Catch SIGCHLD to harvest zombie child processes
    application->addSignal(SIGCHLD, window, XFileImage::ID_HARVEST, true);

    // Handle interrupt to save stuff nicely
    application->addSignal(SIGINT, window, XFileImage::ID_QUIT);

    // Create it
    application->create();

    // Smooth scrolling
    window->setSmoothScroll(smoothscroll);

    if (!loadicons)
    {
        MessageBox::error(application, BOX_OK, _("Error loading icons"), _("Unable to load some icons. Please check your icons path!"));
    }

    // Tooltips setup time and duration
    application->setTooltipPause(TOOLTIP_PAUSE);
    application->setTooltipTime(TOOLTIP_TIME);

    // Start
    window->start(startimage);

    // Run
    return(application->run());
}
e// This code is adapted from 'imageviewer', a demo image viewer found
// in the FOX library and written by Jeroen van der Zijp.

#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGImage.h>
#include <FXJPGImage.h>
#include <FXTIFImage.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "startupnotification.h"
#include "FileDialog.h"
#include "InputDialog.h"
#include "DirHistBox.h"
#include "MessageBox.h"
#include "FileList.h"
#include "XFileImage.h"

// Add FOX hacks
#include "foxhacks.cpp"
#include "clearlooks.cpp"

// Global variables
char**   args;
FXColor  listbackcolor, listforecolor;
FXColor  highlightcolor;
FXbool   allowPopupScroll = false;
FXuint   single_click;
FXbool   file_tooltips;
FXbool   relative_resize;
FXbool   show_pathlink;
FXbool   save_win_pos;
FXString homedir;
FXString xdgconfighome;
FXString xdgdatahome;
FXbool   xim_used = false;

// Hand cursor replacement
#define hand_width     32
#define hand_height    32
#define hand_x_hot     6
#define hand_y_hot     1
static const FXuchar hand_bits[] =
{
    0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00,
    0x90, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x90, 0x07, 0x00, 0x00,
    0x97, 0x1a, 0x00, 0x00, 0x99, 0x2a, 0x00, 0x00, 0x11, 0x28, 0x00, 0x00,
    0x12, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00,
    0x04, 0x20, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00,
    0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const FXuchar hand_mask_bits[] =
{
    0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
    0xf0, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00,
    0xf7, 0x1f, 0x00, 0x00, 0xff, 0x3f, 0x00, 0x00, 0xff, 0x3f, 0x00, 0x00,
    0xfe, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00,
    0xfc, 0x3f, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00,
    0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// Predefined zoom factors
#define NB_ZOOM    24
double zoomtab[NB_ZOOM] =
{
    0.01, 0.025, 0.05, 0.075, 0.10, 0.15, 0.20, 0.30, 0.50, 0.75, 1, \
    1.5, 2, 3, 4, 5, 7.5, 10, 15, 20, 30, 50, 75, 100
};
#define ZOOM_100       10

// Maximum image size (in pixels) for zooming in
#define MAX_IMGSIZE    5120

// Patterns for supported image formats
const char* patterns[] =
{
    _("All Files"), "*",
    _("GIF Image"), "*.gif",
    _("BMP Image"), "*.bmp",
    _("XPM Image"), "*.xpm",
    _("PCX Image"), "*.pcx",
    _("ICO Image"), "*.ico",
    _("RGB Image"), "*.rgb",
    _("XBM Image"), "*.xbm",
    _("TARGA Image"), "*.tga",
    _("PPM Image"), "*.ppm",
    _("PNG Image"), "*.png",
    _("JPEG Image"), "*.jpg",
    _("JPEG Image"), "*.jpeg",
    _("TIFF Image"), "*.tif",
    _("TIFF Image"), "*.tiff",
    NULL
};


const FXString imgpatterns = "*.gif,*.bmp,*.xpm,*.pcx,*.ico,*.rgb,*.xbm,*.tga,*.ppm,*.png,*.jpg,*.jpeg,*.tif,*.tiff";


// Helper function to draw a toolbar separator
void toolbarSeparator(FXToolBar* tb)
{
#define SEP_SPACE_TB    1
    new FXFrame(tb, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE_TB);
    new FXVerticalSeparator(tb, LAYOUT_SIDE_TOP|LAYOUT_CENTER_Y|SEPARATOR_GROOVE|LAYOUT_FILL_Y);
    new FXFrame(tb, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE_TB);
}


// Helper function to draw a separator in an horizontal frame
void hframeSeparator(FXHorizontalFrame* hframe)
{
#define SEP_SPACE_HF    5
    new FXFrame(hframe, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE_HF);
    new FXVerticalSeparator(hframe, LAYOUT_SIDE_TOP|LAYOUT_CENTER_Y|SEPARATOR_GROOVE|LAYOUT_FILL_Y);
    new FXFrame(hframe, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE_HF);
}


// Map
FXDEFMAP(XFileImage) XFileImageMap[] =
{
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ABOUT, XFileImage::onCmdAbout),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_OPEN, XFileImage::onCmdOpen),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TITLE, XFileImage::onUpdTitle),
    FXMAPFUNC(SEL_SIGNAL, XFileImage::ID_HARVEST, XFileImage::onSigHarvest),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_QUIT, XFileImage::onCmdQuit),
    FXMAPFUNC(SEL_SIGNAL, XFileImage::ID_QUIT, XFileImage::onCmdQuit),
    FXMAPFUNC(SEL_CLOSE, XFileImage::ID_TITLE, XFileImage::onCmdQuit),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_RESTART, XFileImage::onCmdRestart),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_FILELIST_BEFORE, XFileImage::onCmdToggleFileListBefore),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_HORZ_PANELS, XFileImage::onCmdHorzVertPanels),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_VERT_PANELS, XFileImage::onCmdHorzVertPanels),
    FXMAPFUNC(SEL_DOUBLECLICKED, XFileImage::ID_FILELIST, XFileImage::onCmdItemDoubleClicked),
    FXMAPFUNC(SEL_CLICKED, XFileImage::ID_FILELIST, XFileImage::onCmdItemClicked),
    FXMAPFUNC(SEL_KEYPRESS, 0, XFileImage::onKeyPress),
    FXMAPFUNC(SEL_KEYRELEASE, 0, XFileImage::onKeyRelease),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_RECENTFILE, XFileImage::onCmdRecentFile),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_HIDDEN, XFileImage::onCmdToggleHidden),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_THUMBNAILS, XFileImage::onCmdToggleThumbnails),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_SHOW_DETAILS, XFileImage::onCmdShowDetails),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_SHOW_MINI_ICONS, XFileImage::onCmdShowMini),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_SHOW_BIG_ICONS, XFileImage::onCmdShowBig),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ROTATE_90, XFileImage::onCmdRotate),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ROTATE_270, XFileImage::onCmdRotate),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_MIRROR_HOR, XFileImage::onCmdMirror),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_MIRROR_VER, XFileImage::onCmdMirror),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ZOOM_IN, XFileImage::onCmdZoomIn),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ZOOM_OUT, XFileImage::onCmdZoomOut),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ZOOM_100, XFileImage::onCmdZoom100),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ZOOM_WIN, XFileImage::onCmdZoomWin),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_PRINT, XFileImage::onCmdPrint),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_UP, XFileImage::onCmdDirUp),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_UP, XFileImage::onUpdDirUp),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_BACK, XFileImage::onCmdDirBack),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_BACK, XFileImage::onUpdDirBack),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_FORWARD, XFileImage::onCmdDirForward),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_FORWARD, XFileImage::onUpdDirForward),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_BACK_HIST, XFileImage::onCmdDirBackHist),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_BACK_HIST, XFileImage::onUpdDirBackHist),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_FORWARD_HIST, XFileImage::onCmdDirForwardHist),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_FORWARD_HIST, XFileImage::onUpdDirForwardHist),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_GO_HOME, XFileImage::onCmdHome),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_PRINT, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ROTATE_90, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ROTATE_270, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_MIRROR_HOR, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_MIRROR_VER, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ZOOM_IN, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ZOOM_OUT, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ZOOM_100, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ZOOM_WIN, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_SHOW_BIG_ICONS, XFileImage::onUpdFileView),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_SHOW_MINI_ICONS, XFileImage::onUpdFileView),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_SHOW_DETAILS, XFileImage::onUpdFileView),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_HIDDEN, XFileImage::onUpdToggleHidden),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_FILELIST_BEFORE, XFileImage::onUpdToggleFileListBefore),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_THUMBNAILS, XFileImage::onUpdToggleThumbnails),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_FIT_WIN, XFileImage::onCmdToggleFitWin),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_FILTER_IMAGES, XFileImage::onCmdToggleFilterImages),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_FIT_WIN, XFileImage::onUpdToggleFitWin),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_FILTER_IMAGES, XFileImage::onUpdToggleFilterImages),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_HORZ_PANELS, XFileImage::onUpdHorzVertPanels),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_VERT_PANELS, XFileImage::onUpdHorzVertPanels),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_GO_HOME, XFileImage::onCmdHome),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_GO_WORK, XFileImage::onCmdWork),
    FXMAPFUNC(SEL_RIGHTBUTTONRELEASE, XFileImage::ID_FILELIST, XFileImage::onCmdPopupMenu),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_POPUP_MENU, XFileImage::onCmdPopupMenu),
};


// Object implementation
FXIMPLEMENT(XFileImage, FXMainWindow, XFileImageMap, ARRAYNUMBER(XFileImageMap))


// Make some windows
XFileImage::XFileImage(FXApp* a, FXbool smoothscroll) : FXMainWindow(a, "Xfi ", NULL, NULL, DECOR_ALL)
{
    setIcon(xfiicon);

    FXButton* btn = NULL;
    FXHotKey  hotkey;
    FXString  key;

    setTarget(this);
    setSelector(ID_TITLE);

    // Make menu bar
    // menubar = new FXMenuBar(this, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X,0,0,0,0,0,0,0,0,0,0,0);
    menubar = new FXMenuBar(this, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_RAISED);

    // Sites where to dock
    FXDockSite* topdock = new FXDockSite(this, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_SUNKEN);
    new FXDockSite(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X);
    new FXDockSite(this, LAYOUT_SIDE_LEFT|LAYOUT_FILL_Y);
    new FXDockSite(this, LAYOUT_SIDE_RIGHT|LAYOUT_FILL_Y);

    // New menu bar
    //FXToolBarShell* dragshell0 = new FXToolBarShell(this, FRAME_RAISED);
    //menubar = new FXMenuBar(topdock, dragshell0, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_RAISED);
    //new FXToolBarGrip(menubar, menubar, FXToolBar::ID_TOOLBARGRIP, TOOLBARGRIP_SINGLE);

    // Tool bar
    FXToolBarShell* dragshell1 = new FXToolBarShell(this, FRAME_RAISED);
    toolbar = new FXToolBar(topdock, dragshell1, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_RAISED);
    new FXToolBarGrip(toolbar, toolbar, FXToolBar::ID_TOOLBARGRIP, TOOLBARGRIP_SINGLE);

    // File menu
    filemenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&File"), NULL, filemenu);

    // Image Menu
    imagemenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&Image"), NULL, imagemenu);

    // View menu
    viewmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&View"), NULL, viewmenu);

    // Preferences Menu
    prefsmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&Preferences"), NULL, prefsmenu);

    // Help menu
    helpmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&Help"), NULL, helpmenu);

    // Splitter
    FXVerticalFrame* vframe = new FXVerticalFrame(this, LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // Set order of the file list and image widgets
    filelistbefore = getApp()->reg().readUnsignedEntry("OPTIONS", "filelist_before", false);
    if (filelistbefore)
    {
        splitter = new FXSplitter(vframe, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|SPLITTER_TRACKING|SPLITTER_VERTICAL);
        filebox = new FXVerticalFrame(splitter, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	imageviewcontainer = new FXVerticalFrame(splitter, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_THICK|FRAME_SUNKEN, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        imageview = new FXImageView(imageviewcontainer, NULL, NULL, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    }
    else
    {
        splitter = new FXSplitter(vframe, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|SPLITTER_TRACKING|SPLITTER_VERTICAL|SPLITTER_REVERSED);
	imageviewcontainer = new FXVerticalFrame(splitter, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_THICK|FRAME_SUNKEN, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        imageview = new FXImageView(imageviewcontainer, NULL, NULL, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y);
        filebox = new FXVerticalFrame(splitter, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }

    // Stack panels horizontally or vertically
    vertpanels = getApp()->reg().readUnsignedEntry("OPTIONS", "vert_panels", false);
    if (vertpanels)
    {
        splitter->setSplitterStyle(splitter->getSplitterStyle()&~SPLITTER_VERTICAL);
    }
    else
    {
        splitter->setSplitterStyle(splitter->getSplitterStyle()|SPLITTER_VERTICAL);
    }

    // Container for the action buttons
    FXHorizontalFrame* buttons = new FXHorizontalFrame(filebox, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_RAISED, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0);

    // Container for the path linker
    FXHorizontalFrame* pathframe = new FXHorizontalFrame(filebox, LAYOUT_FILL_X|FRAME_RAISED, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // File list
    FXuint options;
    if (smoothscroll)
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS|_ICONLIST_BROWSESELECT;
    }
    else
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS|_ICONLIST_BROWSESELECT|SCROLLERS_DONT_TRACK;
    }

    thumbnails = getApp()->reg().readUnsignedEntry("OPTIONS", "thumbnails", 0);
    filelist = new FileList(this, filebox, this, ID_FILELIST, thumbnails, options);
    filelist->setTextColor(listforecolor);
    filelist->setBackColor(listbackcolor);
    filelist->setHeaderSize(0, getApp()->reg().readUnsignedEntry("OPTIONS", "name_size", 200));
    filelist->setHeaderSize(1, getApp()->reg().readUnsignedEntry("OPTIONS", "size_size", 60));
    filelist->setHeaderSize(2, getApp()->reg().readUnsignedEntry("OPTIONS", "type_size", 100));
    filelist->setHeaderSize(3, getApp()->reg().readUnsignedEntry("OPTIONS", "ext_size", 100));
    filelist->setHeaderSize(4, getApp()->reg().readUnsignedEntry("OPTIONS", "modd_size", 150));
    filelist->setHeaderSize(5, getApp()->reg().readUnsignedEntry("OPTIONS", "user_size", 50));
    filelist->setHeaderSize(6, getApp()->reg().readUnsignedEntry("OPTIONS", "grou_size", 50));
    filelist->setHeaderSize(7, getApp()->reg().readUnsignedEntry("OPTIONS", "attr_size", 100));

    // Action buttons
    new FXFrame(buttons, LAYOUT_FIX_WIDTH, 0, 0, 4, 1);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_back", "Ctrl-Backspace");
    btn = new FXButton(buttons, TAB+_("Go to previous folder")+PARS(key), dirbackicon, this, ID_DIR_BACK, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);
    btnbackhist = new FXArrowButton(buttons, this, ID_DIR_BACK_HIST, LAYOUT_FILL_Y|FRAME_RAISED|FRAME_THICK|ARROW_DOWN|ARROW_TOOLBAR);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_forward", "Shift-Backspace");
    btn = new FXButton(buttons, TAB+_("Go to next folder")+PARS(key), dirforwardicon, this, ID_DIR_FORWARD, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);
    btnforwardhist = new FXArrowButton(buttons, this, ID_DIR_FORWARD_HIST, LAYOUT_FILL_Y|FRAME_RAISED|FRAME_THICK|ARROW_DOWN|ARROW_TOOLBAR);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_up", "Backspace");
    btn = new FXButton(buttons, TAB+_("Go to parent folder")+PARS(key), dirupicon, this, ID_DIR_UP, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Separator
    hframeSeparator(buttons);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_home", "Ctrl-H");
    new FXButton(buttons, TAB+_("Go to home folder")+PARS(key), homeicon, this, ID_GO_HOME, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_work", "Shift-F2");
    new FXButton(buttons, TAB+_("Go to working folder")+PARS(key), workicon, this, ID_GO_WORK, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Separator
    hframeSeparator(buttons);

    // Switch display modes
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "big_icons", "F10");
    btn = new FXButton(buttons, TAB+_("Big icon list")+PARS(key), bigiconsicon, this, ID_SHOW_BIG_ICONS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "small_icons", "F11");
    btn = new FXButton(buttons, TAB+_("Small icon list")+PARS(key), smalliconsicon, this, ID_SHOW_MINI_ICONS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "detailed_file_list", "F12");
    btn = new FXButton(buttons, TAB+_("Detailed file list")+PARS(key), detailsicon, this, ID_SHOW_DETAILS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Separator
    hframeSeparator(buttons);

    // Vertical panels
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "vert_panels", "Ctrl-Shift-F1");
    btn = new FXButton(buttons, TAB+_("Vertical panels")+PARS(key), vertpanelsicon, this, XFileImage::ID_VERT_PANELS, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Horizontal panels
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "horz_panels", "Ctrl-Shift-F2");
    btn = new FXButton(buttons, TAB+_("Horizontal panels")+PARS(key), horzpanelsicon, this, XFileImage::ID_HORZ_PANELS, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Panel title
    pathtext = new TextLabel(pathframe, 0, this, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    pathtext->setBackColor(getApp()->getBaseColor());

    // Path linker
    pathlink = new PathLinker(pathframe, filelist, NULL, LAYOUT_FILL_X);

    // Status bar
    statusbar = new FXHorizontalFrame(vframe, JUSTIFY_LEFT|LAYOUT_FILL_X, 0, 0, 0, 0, 3, 3, 0, 0);

    // Read and set sort function for file list
    FXString sort_func = getApp()->reg().readStringEntry("OPTIONS", "sort_func", "ascendingCase");
    if (sort_func == "ascendingCase")
    {
        filelist->setSortFunc(filelist->ascendingCase);
    }
    if (sort_func == "ascendingCaseMix")
    {
        filelist->setSortFunc(filelist->ascendingCaseMix);
    }
    else if (sort_func == "descendingCase")
    {
        filelist->setSortFunc(filelist->descendingCase);
    }
    else if (sort_func == "descendingCaseMix")
    {
        filelist->setSortFunc(filelist->descendingCaseMix);
    }
    else if (sort_func == "ascending")
    {
        filelist->setSortFunc(filelist->ascending);
    }
    else if (sort_func == "ascendingMix")
    {
        filelist->setSortFunc(filelist->ascendingMix);
    }
    else if (sort_func == "descending")
    {
        filelist->setSortFunc(filelist->descending);
    }
    else if (sort_func == "descendingMix")
    {
        filelist->setSortFunc(filelist->descendingMix);
    }
    else if (sort_func == "ascendingSize")
    {
        filelist->setSortFunc(filelist->ascendingSize);
    }
    else if (sort_func == "ascendingSizeMix")
    {
        filelist->setSortFunc(filelist->ascendingSizeMix);
    }
    else if (sort_func == "descendingSize")
    {
        filelist->setSortFunc(filelist->descendingSize);
    }
    else if (sort_func == "descendingSizeMix")
    {
        filelist->setSortFunc(filelist->descendingSizeMix);
    }
    else if (sort_func == "ascendingType")
    {
        filelist->setSortFunc(filelist->ascendingType);
    }
    else if (sort_func == "ascendingTypeMix")
    {
        filelist->setSortFunc(filelist->ascendingTypeMix);
    }
    else if (sort_func == "descendingType")
    {
        filelist->setSortFunc(filelist->descendingType);
    }
    else if (sort_func == "descendingTypeMix")
    {
        filelist->setSortFunc(filelist->descendingTypeMix);
    }
    else if (sort_func == "ascendingExt")
    {
        filelist->setSortFunc(filelist->ascendingExt);
    }
    else if (sort_func == "ascendingExtMix")
    {
        filelist->setSortFunc(filelist->ascendingExtMix);
    }
    else if (sort_func == "descendingExt")
    {
        filelist->setSortFunc(filelist->descendingExt);
    }
    else if (sort_func == "descendingExtMix")
    {
        filelist->setSortFunc(filelist->descendingExtMix);
    }
    else if (sort_func == "ascendingTime")
    {
        filelist->setSortFunc(filelist->ascendingTime);
    }
    else if (sort_func == "ascendingTimeMix")
    {
        filelist->setSortFunc(filelist->ascendingTimeMix);
    }
    else if (sort_func == "descendingTime")
    {
        filelist->setSortFunc(filelist->descendingTime);
    }
    else if (sort_func == "descendingTimeMix")
    {
        filelist->setSortFunc(filelist->descendingTimeMix);
    }
    else if (sort_func == "ascendingUser")
    {
        filelist->setSortFunc(filelist->ascendingUser);
    }
    else if (sort_func == "ascendingUserMix")
    {
        filelist->setSortFunc(filelist->ascendingUserMix);
    }
    else if (sort_func == "descendingUser")
    {
        filelist->setSortFunc(filelist->descendingUser);
    }
    else if (sort_func == "descendingUserMix")
    {
        filelist->setSortFunc(filelist->descendingUserMix);
    }
    else if (sort_func == "ascendingGroup")
    {
        filelist->setSortFunc(filelist->ascendingGroup);
    }
    else if (sort_func == "ascendingGroupMix")
    {
        filelist->setSortFunc(filelist->ascendingGroupMix);
    }
    else if (sort_func == "descendingGroup")
    {
        filelist->setSortFunc(filelist->descendingGroup);
    }
    else if (sort_func == "descendingGroupMix")
    {
        filelist->setSortFunc(filelist->descendingGroupMix);
    }
    else if (sort_func == "ascendingPerm")
    {
        filelist->setSortFunc(filelist->ascendingPerm);
    }
    else if (sort_func == "ascendingPermMix")
    {
        filelist->setSortFunc(filelist->ascendingPermMix);
    }
    else if (sort_func == "descendingPerm")
    {
        filelist->setSortFunc(filelist->descendingPerm);
    }
    else if (sort_func == "descendingPermMix")
    {
        filelist->setSortFunc(filelist->descendingPermMix);
    }

    // Single click navigation
    if (single_click == SINGLE_CLICK_DIR_FILE)
    {
        filelist->setDefaultCursor(getApp()->getDefaultCursor(DEF_HAND_CURSOR));
    }

    // Status bar buttons
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");
    // new FXToggleButton(statusbar, TAB+_("Show hidden files")+PARS(key), TAB+_("Hide hidden files")+PARS(key), showhiddenicon, hidehiddenicon, this->filelist,
    //                    FileList::ID_TOGGLE_HIDDEN, BUTTON_TOOLBAR|LAYOUT_LEFT|ICON_BEFORE_TEXT);

    // key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");
    // new FXToggleButton(statusbar, TAB+_("Show thumbnails")+PARS(key), TAB+_("Hide thumbnails")+PARS(key), showthumbicon, hidethumbicon, this->filelist,
    //                    FileList::ID_TOGGLE_THUMBNAILS, BUTTON_TOOLBAR|LAYOUT_LEFT|ICON_BEFORE_TEXT);

    new FXStatusBar(statusbar, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|FRAME_SUNKEN);
    //FXDragCorner* dragcorner = new FXDragCorner(statusbar);
    new FXDragCorner(statusbar);

    // Toolbar button: Open file
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "open", "Ctrl-O");
    new FXButton(toolbar, TAB+_("Open")+PARS(key)+TAB+_("Open image file.")+PARS(key), fileopenicon, this, ID_OPEN, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Toolbar button: Print
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "print", "Ctrl-P");
    new FXButton(toolbar, TAB+_("Print")+PARS(key)+TAB+_("Print image file.")+PARS(key), printicon, this, ID_PRINT, BUTTON_TOOLBAR|FRAME_RAISED);

    // Separator
    toolbarSeparator(toolbar);

    // Note : Ctrl+ and Ctrl- cannot be changed from the registry!

    // Toolbar button: Zoom in
    btn = new FXButton(toolbar, TAB+_("Zoom in")+PARS("Ctrl+")+TAB+_("Zoom in image.")+PARS("Ctrl+"), zoominicon, this, ID_ZOOM_IN, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);
    hotkey = (CONTROLMASK<<16) |  KEY_KP_Add;
    btn->addHotKey(hotkey);

    // Toolbar button: Zoom out
    btn = new FXButton(toolbar, TAB+_("Zoom out")+PARS("Ctrl-")+TAB+_("Zoom out image.")+PARS("Ctrl-"), zoomouticon, this, ID_ZOOM_OUT, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);
    hotkey = (CONTROLMASK<<16) | KEY_KP_Subtract;
    btn->addHotKey(hotkey);

    // Toolbar button: Zoom 100%
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_100", "Ctrl-I");
    new FXButton(toolbar, TAB+_("Zoom 100%")+PARS(key)+TAB+_("Zoom image to 100%.")+PARS(key), zoom100icon, this, ID_ZOOM_100, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Toolbar button: Zoom to fit window
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_win", "Ctrl-F");
    new FXButton(toolbar, TAB+_("Zoom to fit")+PARS(key)+TAB+_("Zoom to fit window.")+PARS(key), zoomwinicon, this, ID_ZOOM_WIN, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Separator
    toolbarSeparator(toolbar);

    // Toolbar button: Rotate left
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_left", "Ctrl-L");
    new FXButton(toolbar, TAB+_("Rotate left")+PARS(key)+TAB+_("Rotate left image.")+PARS(key), rotatelefticon, this, ID_ROTATE_90, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Toolbar button: Rotate right
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_right", "Ctrl-R");
    new FXButton(toolbar, TAB+_("Rotate right")+PARS(key)+TAB+_("Rotate right image.")+PARS(key), rotaterighticon, this, ID_ROTATE_270, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Toolbar button: mirror horizontally
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_horizontally", "Ctrl-Shift-H");
    new FXButton(toolbar, TAB+_("Mirror horizontally")+PARS(key)+TAB+_("Mirror image horizontally.")+PARS(key), fliplricon, this, ID_MIRROR_HOR, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Toolbar button: mirror vertically
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_vertically", "Ctrl-Shift-V");
    new FXButton(toolbar, TAB+_("Mirror vertically")+PARS(key)+TAB+_("Mirror image vertically.")+PARS(key), flipudicon, this, ID_MIRROR_VER, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // File Menu entries
    FXMenuCommand* mc = NULL;
    FXString       text;

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "open", "Ctrl-O");
    text = _("&Open...")+TABS(key)+_("Open image file.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, fileopenicon, this, ID_OPEN);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "print", "Ctrl-P");
    text = _("&Print...")+TABS(key)+_("Print image file.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, printicon, this, ID_PRINT);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    // Recent file menu; this automatically hides if there are no files
    FXMenuSeparator* sep1 = new FXMenuSeparator(filemenu);
    sep1->setTarget(&mrufiles);
    sep1->setSelector(FXRecentFiles::ID_ANYFILES);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_1);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_2);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_3);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_4);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_5);
    new FXMenuCommand(filemenu, _("&Clear recent files")+TAB2+_("Clear recent file menu."), NULL, &mrufiles, FXRecentFiles::ID_CLEAR);
    FXMenuSeparator* sep2 = new FXMenuSeparator(filemenu);
    sep2->setTarget(&mrufiles);
    sep2->setSelector(FXRecentFiles::ID_ANYFILES);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "quit", "Ctrl-Q");
    text = _("&Quit")+TABS(key)+_("Quit Xfi.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, quiticon, this, ID_QUIT);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));
    getAccelTable()->addAccel(KEY_Escape, this, FXSEL(SEL_COMMAND, ID_QUIT));

    // Image Menu entries
    new FXMenuCommand(imagemenu, _("Zoom &in")+TAB+(FXString)"Ctrl+"+TAB+_("Zoom in image.")+PARS("Ctrl+"), zoominicon, this, ID_ZOOM_IN);
    new FXMenuCommand(imagemenu, _("Zoom &out")+TAB+(FXString)"Ctrl-"+TAB+_("Zoom out image.")+PARS("Ctrl-"), zoomouticon, this, ID_ZOOM_OUT);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_100", "Ctrl-I");
    text = _("Zoo&m 100%")+TABS(key)+_("Zoom image to 100%.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, zoom100icon, this, ID_ZOOM_100);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_win", "Ctrl-F");
    text = _("Zoom to fit &window")+TABS(key)+_("Zoom to fit window.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, zoomwinicon, this, ID_ZOOM_WIN);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_right", "Ctrl-R");
    text = _("Rotate &right")+TABS(key)+_("Rotate right.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, rotaterighticon, this, ID_ROTATE_270);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_left", "Ctrl-L");
    text = _("Rotate &left")+TABS(key)+_("Rotate left.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, rotatelefticon, this, ID_ROTATE_90);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_horizontally", "Ctrl-Shift-H");
    text = _("Mirror &horizontally")+TABS(key)+_("Mirror horizontally.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, fliplricon, this, ID_MIRROR_HOR);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_vertically", "Ctrl-Shift-V");
    text = _("Mirror &vertically")+TABS(key)+_("Mirror vertically.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, flipudicon, this, ID_MIRROR_VER);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    // View Menu entries
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");
    text = _("&Hidden files")+TABS(key)+_("Show hidden files and folders.")+PARS(key);
    mc = new FXMenuCheck(viewmenu, text, this, ID_TOGGLE_HIDDEN);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");
    text = _("&Thumbnails")+TABS(key)+_("Show image thumbnails.")+PARS(key);
    mc = new FXMenuCheck(viewmenu, text, this, ID_TOGGLE_THUMBNAILS);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuSeparator(viewmenu);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "big_icons", "F10");
    text = _("&Big icons")+TABS(key)+_("Display folders with big icons.")+PARS(key);
    mc = new FXMenuRadio(viewmenu, text, this, ID_SHOW_BIG_ICONS);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "small_icons", "F11");
    text = _("&Small icons")+TABS(key)+_("Display folders with small icons.")+PARS(key);
    mc = new FXMenuRadio(viewmenu, text, this, ID_SHOW_MINI_ICONS);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "detailed_file_list", "F12");
    text = _("&Detailed file list")+TABS(key)+_("Display detailed folder listing.")+PARS(key);
    mc = new FXMenuRadio(viewmenu, text, this, ID_SHOW_DETAILS);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuSeparator(viewmenu);

    mc = new FXMenuRadio(viewmenu, _("&Vertical panels"), this, XFileImage::ID_VERT_PANELS);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "vert_panels", "Ctrl-Shift-F1");
    mc->setAccelText(key);

    mc = new FXMenuRadio(viewmenu, _("&Horizontal panels"), this, XFileImage::ID_HORZ_PANELS);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "horz_panels", "Ctrl-Shift-F2");
    mc->setAccelText(key);

    new FXMenuSeparator(viewmenu);
    new FXMenuRadio(viewmenu, _("&Rows")+TAB2+_("View icons row-wise."), filelist, FileList::ID_ARRANGE_BY_ROWS);
    new FXMenuRadio(viewmenu, _("&Columns")+TAB2+_("View icons column-wise."), filelist, FileList::ID_ARRANGE_BY_COLUMNS);
    new FXMenuCheck(viewmenu, _("&Autosize")+TAB2+_("Autosize icon names."), filelist, FileList::ID_AUTOSIZE);

    // Preferences menu
    new FXMenuCheck(prefsmenu, _("&Toolbar")+TAB2+_("Display toolbar."), toolbar, FXWindow::ID_TOGGLESHOWN);
    new FXMenuCheck(prefsmenu, _("&File list")+TAB2+_("Display file list."), filebox, FXWindow::ID_TOGGLESHOWN);
    new FXMenuCheck(prefsmenu, _("File list &before")+TAB2+_("Display file list before image window."), this, ID_TOGGLE_FILELIST_BEFORE);
    new FXMenuCheck(prefsmenu, _("&Filter images")+TAB2+_("List only image files."), this, ID_TOGGLE_FILTER_IMAGES);
    new FXMenuCheck(prefsmenu, _("Fit &window when opening")+TAB2+_("Zoom to fit window when opening an image."), this, ID_TOGGLE_FIT_WIN);


    // Help Menu entries
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "help", "F1");
    text = _("&About X File Image")+TABS(key)+_("About X File Image.")+PARS(key);
    mc = new FXMenuCommand(helpmenu, text, NULL, this, ID_ABOUT, 0);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    // Close accelerator
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "close", "Ctrl-W");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, this, FXSEL(SEL_COMMAND, XFileImage::ID_QUIT));

    // Make a tool tip
    new FXToolTip(getApp(), TOOLTIP_NORMAL);

    // Images
    img = NULL;
    tmpimg = NULL;

    // Dialogs
    printdialog = NULL;

    // Recent files
    mrufiles.setTarget(this);
    mrufiles.setSelector(ID_RECENTFILE);

    // Initialize file name
    filename = "";

    // Initialize some flags
    fileview = ID_SHOW_MINI_ICONS;
    hiddenfiles = false;

    // Initialize zoom to 100%
    indZoom = ZOOM_100;
    zoomval = zoomtab[indZoom];
    fitwin = false;
    filterimgs = false;

    // Initialize previous window width / height
    prev_width = getWidth();
    prev_height = getHeight();
}


// Clean up
XFileImage::~XFileImage()
{
    delete toolbar;
    delete menubar;
    delete statusbar;
    delete filemenu;
    delete imagemenu;
    delete helpmenu;
    delete prefsmenu;
    delete viewmenu;
    delete dragshell1;
    delete pathlink;
    delete pathtext;
    delete filelist;
    delete img;
    delete tmpimg;
    delete printdialog;
    delete btnbackhist;
    delete btnforwardhist;
}


long XFileImage::onCmdPopupMenu(FXObject* o, FXSelector s, void* p)
{
    // Popup menu pane
    FXMenuPane menu(this);
    int        x, y;
    FXuint     state;

    getRoot()->getCursorPosition(x, y, state);

    new FXMenuCommand(&menu, _("Go ho&me"), homeicon, this, ID_GO_HOME);
    new FXMenuCommand(&menu, _("Go &work"), workicon, this, ID_GO_WORK);
    new FXMenuSeparator(&menu);
    new FXMenuCheck(&menu, _("&Hidden files"), this, ID_TOGGLE_HIDDEN);
    new FXMenuCheck(&menu, _("Thum&bnails"), this, ID_TOGGLE_THUMBNAILS);
    new FXMenuSeparator(&menu);
    new FXMenuRadio(&menu, _("B&ig icons"), this, ID_SHOW_BIG_ICONS);
    new FXMenuRadio(&menu, _("&Small icons"), this, ID_SHOW_MINI_ICONS);
    new FXMenuRadio(&menu, _("Fu&ll file list"), this, ID_SHOW_DETAILS);
    new FXMenuSeparator(&menu);
    new FXMenuRadio(&menu, _("&Rows"), filelist, FileList::ID_ARRANGE_BY_ROWS);
    new FXMenuRadio(&menu, _("&Columns"), filelist, FileList::ID_ARRANGE_BY_COLUMNS);
    new FXMenuCheck(&menu, _("Autosize"), filelist, FileList::ID_AUTOSIZE);
    new FXMenuSeparator(&menu);
    new FXMenuRadio(&menu, _("&Name"), filelist, FileList::ID_SORT_BY_NAME);
    new FXMenuRadio(&menu, _("Si&ze"), filelist, FileList::ID_SORT_BY_SIZE);
    new FXMenuRadio(&menu, _("&Type"), filelist, FileList::ID_SORT_BY_TYPE);
    new FXMenuRadio(&menu, _("E&xtension"), filelist, FileList::ID_SORT_BY_EXT);
    new FXMenuRadio(&menu, _("&Date"), filelist, FileList::ID_SORT_BY_TIME);
    new FXMenuRadio(&menu, _("&User"), filelist, FileList::ID_SORT_BY_USER);
    new FXMenuRadio(&menu, _("&Group"), filelist, FileList::ID_SORT_BY_GROUP);
    new FXMenuRadio(&menu, _("&Permissions"), filelist, FileList::ID_SORT_BY_PERM);
    new FXMenuSeparator(&menu);
    new FXMenuCheck(&menu, _("Ignore c&ase"), filelist, FileList::ID_SORT_CASE);
    new FXMenuCheck(&menu, _("Fold&ers first"), filelist, FileList::ID_DIRS_FIRST);
    new FXMenuCheck(&menu, _("Re&verse order"), filelist, FileList::ID_SORT_REVERSE);

    menu.create();
    allowPopupScroll = true;  // Allow keyboard scrolling
    menu.popup(NULL, x, y);
    getApp()->runModalWhileShown(&menu);
    allowPopupScroll = false;
    return(1);
}


// If Shift-F10 or Menu is pressed, opens the popup menu
long XFileImage::onKeyPress(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    // Shift-F10 or Menu was pressed : open popup menu
   	if ((event->state&SHIFTMASK && event->code == KEY_F10) || event->code == KEY_Menu)
    {
        this->handle(sender, FXSEL(SEL_COMMAND, XFileImage::ID_POPUP_MENU), ptr);
        return(1);
    }

    // Any other key was pressed : handle the pressed key in the usual way
    else
    {
        if (FXTopWindow::onKeyPress(sender, sel, ptr))
        {
            return(1);
        }
    }

    return(0);
}


long XFileImage::onKeyRelease(FXObject* sender, FXSelector sel, void* ptr)
{
    if (FXTopWindow::onKeyRelease(sender, sel, ptr))
    {
        return(1);
    }

    return(0);
}


// User clicked up directory button
long XFileImage::onCmdDirUp(FXObject*, FXSelector, void*)
{
    filelist->setDirectory(FXPath::upLevel(filelist->getDirectory()));
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());

    filelist->setFocus();

    return(1);
}


// Can we still go up
long XFileImage::onUpdDirUp(FXObject* sender, FXSelector, void*)
{
    if (FXPath::isTopDirectory(filelist->getDirectory()))
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), NULL);
    }
    return(1);
}


// Directory back
long XFileImage::onCmdDirBack(FXObject*, FXSelector s, void* p)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;
    forwardhist = filelist->forwardhist;

    // Get the previous directory
    item = backhist->getFirst();
    if (item)
    {
        pathname = backhist->getString(item);
    }

    // Update the history
    backhist->removeFirstItem();
    forwardhist->insertFirstItem(filelist->getDirectory());

    // Go to to the previous directory
    filelist->setDirectory(pathname, false);
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());

    filelist->setFocus();

    return(1);
}


// Update directory back
long XFileImage::onUpdDirBack(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;

    // Gray out the button if no item in history
    if (backhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory forward
long XFileImage::onCmdDirForward(FXObject*, FXSelector s, void* p)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;
    forwardhist = filelist->forwardhist;

    // Get the next directory
    item = forwardhist->getFirst();
    if (item)
    {
        pathname = forwardhist->getString(item);
    }

    // Update the history
    forwardhist->removeFirstItem();
    backhist->insertFirstItem(filelist->getDirectory());

    // Go to to the previous directory
    filelist->setDirectory(pathname, false);
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());

    filelist->setFocus();

    return(1);
}


// Update directory forward
long XFileImage::onUpdDirForward(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* forwardhist;
    FXString    pathname;

    // Get the filelist history
    forwardhist = filelist->forwardhist;

    // Gray out the button if no item in history
    if (forwardhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory back history
long XFileImage::onCmdDirBackHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;
    forwardhist = filelist->forwardhist;

    // Get all string items and display them in a list box
    int num = backhist->getNumItems();
    if (num > 0)
    {
        FXString* dirs = new FXString[num];
        FXString  strlist = "";

        // Get string items
        item = backhist->getFirst();
        for (int i = 0; i <= num-1; i++)
        {
            if (item)
            {
                FXString str = backhist->getString(item);
                dirs[i] = str;
                strlist = strlist+str+"\n";
                item = backhist->getNext(item);
            }
        }

        // Display list box
        int pos = DirHistBox::box(btnbackhist, DECOR_NONE, strlist, this->getX()+245, this->getY()+37);

        // If an item was selected
        if (pos != -1)
        {
            // Update back history
            if (pos == num-1)
            {
                backhist->removeAllItems();
            }
            else
            {
                item = backhist->getItemAtPos(pos+1);
                backhist->removeAllItemsBefore(item);
            }

            // Update forward history
            forwardhist->insertFirstItem(filelist->getDirectory());
            if (pos > 0)
            {
                for (int i = 0; i <= pos-1; i++)
                {
                    forwardhist->insertFirstItem(dirs[i]);
                }
            }

            // Go to to the selected directory
            pathname = dirs[pos];
            filelist->setDirectory(pathname, false);
            pathlink->setPath(filelist->getDirectory());
            pathtext->setText(filelist->getDirectory());
        }
        delete[]dirs;
    }

    return(1);
}


// Update directory back
long XFileImage::onUpdDirBackHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;

    // Gray out the button if no item in history
    if (backhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory forward history
long XFileImage::onCmdDirForwardHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;
    forwardhist = filelist->forwardhist;

    // Get all string items and display them in a list box
    int num = forwardhist->getNumItems();
    if (num > 0)
    {
        FXString* dirs = new FXString[num];
        FXString  strlist = "";

        // Get string items
        item = forwardhist->getFirst();
        for (int i = 0; i <= num-1; i++)
        {
            if (item)
            {
                FXString str = forwardhist->getString(item);
                dirs[i] = str;
                strlist = strlist+str+"\n";
                item = forwardhist->getNext(item);
            }
        }

        // Display list box
        int pos = DirHistBox::box(btnforwardhist, DECOR_NONE, strlist, this->getX()+285, this->getY()+37);

        // If an item was selected
        if (pos != -1)
        {
            // Update forward history
            if (pos == num-1)
            {
                forwardhist->removeAllItems();
            }
            else
            {
                item = forwardhist->getItemAtPos(pos+1);
                forwardhist->removeAllItemsBefore(item);
            }

            // Update back history
            backhist->insertFirstItem(filelist->getDirectory());
            if (pos > 0)
            {
                for (int i = 0; i <= pos-1; i++)
                {
                    backhist->insertFirstItem(dirs[i]);
                }
            }

            // Go to to the selected directory
            pathname = dirs[pos];
            filelist->setDirectory(pathname, false);
            pathlink->setPath(filelist->getDirectory());
            pathtext->setText(filelist->getDirectory());
        }
        delete[]dirs;
    }

    return(1);
}


// Update directory forward
long XFileImage::onUpdDirForwardHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* forwardhist;
    FXString    pathname;

    // Get the filelist history
    forwardhist = filelist->forwardhist;

    // Gray out the button if no item in history
    if (forwardhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Back to home directory
long XFileImage::onCmdHome(FXObject*, FXSelector, void*)
{
    filelist->setDirectory(FXSystem::getHomeDirectory());
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());
    filelist->setFocus();
    return(1);
}


// Back to current working directory
long XFileImage::onCmdWork(FXObject*, FXSelector, void*)
{
    filelist->setDirectory(FXSystem::getCurrentDirectory());
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());
    filelist->setFocus();
    return(1);
}


// About box
long XFileImage::onCmdAbout(FXObject*, FXSelector, void*)
{
    FXString msg;

    msg.format(_("X File Image Version %s is a simple image viewer.\n\n"), VERSION);
    msg += COPYRIGHT;
    MessageBox about(this, _("About X File Image"), msg.text(), xfiicon, BOX_OK|DECOR_TITLE|DECOR_BORDER,
                     JUSTIFY_CENTER_X|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    about.execute(PLACEMENT_OWNER);

    filelist->setFocus();

    return(1);
}


// Load file
FXbool XFileImage::loadimage(const FXString& file)
{
    FXString ext = FXPath::extension(file);

    FILE* fp = fopen(file.text(), "r");

    if (!fp)
    {
        MessageBox::error(this, BOX_OK, _("Error Loading File"), _("Unable to open file: %s"), file.text());
        return(false);
    }
    else
    {
        fclose(fp);
    }

    // Free old image if any, before loading a new one
    if (img)
    {
        delete img;
        img = NULL;
    }
    if (tmpimg)
    {
        delete tmpimg;
        tmpimg = NULL;
    }

    if (comparecase(ext, "gif") == 0)
    {
        img = new FXGIFImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXGIFImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "bmp") == 0)
    {
        img = new FXBMPImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXBMPImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "xpm") == 0)
    {
        img = new FXXPMImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXXPMImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "pcx") == 0)
    {
        img = new FXPCXImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXPCXImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if ((comparecase(ext, "ico") == 0) || (comparecase(ext, "cur") == 0))
    {
        img = new FXICOImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXICOImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "tga") == 0)
    {
        img = new FXTGAImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXTGAImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "rgb") == 0)
    {
        img = new FXRGBImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "xbm") == 0)
    {
        img = new FXXBMImage(getApp(), NULL, NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXXBMImage(getApp(), NULL, NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "ppm") == 0)
    {
        img = new FXPPMImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXPPMImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "png") == 0)
    {
        img = new FXPNGImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXPNGImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if ((comparecase(ext, "jpg") == 0) || (comparecase(ext, "jpeg") == 0))
    {
        img = new FXJPGImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXJPGImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if ((comparecase(ext, "tif") == 0) || (comparecase(ext, "tiff") == 0))
    {
        img = new FXTIFImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXTIFImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else
    {
        img = NULL;
        tmpimg = NULL;
    }

    // Perhaps failed
    if (img == NULL)
    {
        MessageBox::error(this, BOX_OK, _("Error Loading Image"), _("Unsupported type: %s"), ext.text());
        return(false);
    }

    if (tmpimg == NULL)
    {
        MessageBox::error(this, BOX_OK, _("Error Loading Image"), _("Unsupported type: %s"), ext.text());
        return(false);
    }

    // Load it
    FXFileStream stream;
    if (stream.open(file, FXStreamLoad))
    {
        getApp()->beginWaitCursor();
        FXbool res = img->loadPixels(stream);

        stream.close();

        // If failed
        if (!res)
        {
            MessageBox::error(this, BOX_OK, _("Error Loading Image"), _("Unable to load image, the file may be corrupted"));
            getApp()->endWaitCursor();
            return(false);
        }

        if (!FXMEMDUP(&tmpdata, img->getData(), FXColor, img->getWidth()*img->getHeight()))
        {
            throw FXMemoryException(_("Unable to load image"));
        }
        tmpimg->setData(tmpdata, IMAGE_OWNED, img->getWidth(), img->getHeight());

        img->create();
        tmpimg->create();

        imageview->setImage(tmpimg);

        // Initial zoom and image format
        indZoom = ZOOM_100;
        zoomval = zoomtab[indZoom];
        getApp()->endWaitCursor();

        // Zoom to fit window if asked
        if (fitwin)
        {
            handle(this, FXSEL(SEL_COMMAND, ID_ZOOM_WIN), NULL);
        }
    }
    filelist->setDirectory(FXPath::directory(file));
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());

    return(true);
}


// Toggle file list before image
long XFileImage::onCmdToggleFileListBefore(FXObject* sender, FXSelector, void*)
{
    filelistbefore = !filelistbefore;

    if (BOX_CLICKED_CANCEL != MessageBox::question(this, BOX_OK_CANCEL, _("Restart"), _("Change will be taken into account after restart.\nRestart X File Image now?")))
    {
        this->handle(this, FXSEL(SEL_COMMAND, XFileImage::ID_RESTART), NULL);
    }

    return(1);
}


// Update file list before image
long XFileImage::onUpdToggleFileListBefore(FXObject* sender, FXSelector, void*)
{
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), NULL);
        if (filelistbefore)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
        }
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), NULL);
    }

    return(1);
}


// Toggle zoom to fit window on startup
long XFileImage::onCmdToggleFitWin(FXObject*, FXSelector, void*)
{
    fitwin = !fitwin;
    filelist->setFocus();
    return(1);
}


// Update toggle wrap mode
long XFileImage::onUpdToggleFitWin(FXObject* sender, FXSelector, void*)
{
    if (fitwin)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


// Toggle filter image files
long XFileImage::onCmdToggleFilterImages(FXObject*, FXSelector, void*)
{
    filterimgs = !filterimgs;
    if (filterimgs)
    {
        filelist->setPattern(imgpatterns);
    }
    else
    {
        filelist->setPattern("*");
    }

    filelist->setFocus();

    return(1);
}


// Update filter image files
long XFileImage::onUpdToggleFilterImages(FXObject* sender, FXSelector, void*)
{
    // Disable menu item if the file list is not shown
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);

        // Update menu item
        if (filterimgs)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
        }
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);

        // Update menu item
        if (filterimgs)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
        }
    }
    return(1);
}


// Open
long XFileImage::onCmdOpen(FXObject*, FXSelector, void*)
{
    FileDialog opendialog(this, _("Open Image"));

    opendialog.setSelectMode(SELECTFILE_EXISTING);
    opendialog.setPatternList(patterns);
    opendialog.setDirectory(filelist->getDirectory());
    if (opendialog.execute())
    {
        filename = opendialog.getFilename();
        filelist->setCurrentFile(filename);
        mrufiles.appendFile(filename);
        loadimage(filename);
    }

    return(1);
}


// Print the text
long XFileImage::onCmdPrint(FXObject*, FXSelector, void*)
{
    // Read the current print command from the registry
    FXString printcommand, command;

    printcommand = getApp()->reg().readStringEntry("OPTIONS", "print_command", "lpr -P printer");

    // Open print dialog filled with the current print command
    int rc = 1;
    if (printdialog == NULL)
    {
        printdialog = new InputDialog(this, printcommand, _("Print command: \n(ex: lpr -P <printer>)"), _("Print"), "", printbigicon);
    }
    printdialog->setText(printcommand);
    printdialog->CursorEnd();
    rc = printdialog->execute(PLACEMENT_CURSOR);
    printcommand = printdialog->getText();

    // If cancel was pressed, exit
    if (!rc)
    {
        return(0);
    }

    // Write the new print command to the registry
    getApp()->reg().writeStringEntry("OPTIONS", "print_command", printcommand.text());

    // Perform the print command
    command = "cat " + filename + " |" + printcommand + " &";
    int ret = system(command.text());
    if (ret < 0)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Can't execute command %s"), command.text());
        return(0);
    }

    return(1);
}


// Handle toggle hidden command
long XFileImage::onCmdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    filelist->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_HIDDEN), ptr);
    filelist->setFocus();

    return(1);
}


// Update toggle hidden command
long XFileImage::onUpdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;

    hiddenfiles = filelist->shownHiddenFiles();

    if (hiddenfiles == true)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);

    // Disable menu item if the file list is not shown
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Handle toggle hidden command
long XFileImage::onCmdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    filelist->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_THUMBNAILS), ptr);
    filelist->setFocus();

    return(1);
}


// Update toggle hidden command
long XFileImage::onUpdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;

    thumbnails = filelist->shownThumbnails();

    if (thumbnails == true)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);

    // Disable menu item if the file list is not shown
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Show mini icons in file list
long XFileImage::onCmdShowMini(FXObject*, FXSelector, void*)
{
    fileview = ID_SHOW_MINI_ICONS;
    filelist->handle(this, FXSEL(SEL_COMMAND, FileList::ID_SHOW_MINI_ICONS), NULL);
    filelist->setFocus();

    return(1);
}


// Show big icons in file list
long XFileImage::onCmdShowBig(FXObject*, FXSelector, void*)
{
    fileview = ID_SHOW_BIG_ICONS;
    filelist->handle(this, FXSEL(SEL_COMMAND, FileList::ID_SHOW_BIG_ICONS), NULL);
    filelist->setFocus();

    return(1);
}


// Show details in file list
long XFileImage::onCmdShowDetails(FXObject*, FXSelector, void*)
{
    fileview = ID_SHOW_DETAILS;
    filelist->handle(this, FXSEL(SEL_COMMAND, FileList::ID_SHOW_DETAILS), NULL);
    filelist->setFocus();

    return(1);
}


// Update filelist
long XFileImage::onUpdFileView(FXObject* sender, FXSelector sel, void* ptr)
{
    // Keep the filebox width / height relative to the window width / height

    // Get the current width and height
    int width = getWidth();
    int height = getHeight();

    // Panel stacked horizontally
    if (vertpanels)
    {
        if (relative_resize && (prev_width != width))
        {
            // File box shown
            if (filebox->shown())
            {
                filebox->setWidth((int)round(filewidth_pct*width));
            }
        }

        // Update the relative width (only if window width is sufficient)
        prev_width = width;
        if (getWidth() > 10)
        {
            filewidth_pct = (double)(filebox->getWidth())/(double)(getWidth());
        }
    }

    // Panel stacked vertically
    else
    {
        if (relative_resize && (prev_height != height))
        {
            // File box shown
            if (filebox->shown())
            {
                filebox->setHeight((int)round(fileheight_pct*height));
            }
        }

        // Update the relative height (only if window height is sufficient)
        prev_height = height;
        if (getHeight() > 10)
        {
            fileheight_pct = (double)(filebox->getHeight())/(double)(getHeight());
        }
    }

    // Update radio buttons
    FXuint msg = FXWindow::ID_UNCHECK;

    switch (FXSELID(sel))
    {
    case ID_SHOW_MINI_ICONS:
        if (fileview == ID_SHOW_MINI_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_BIG_ICONS:
        if (fileview == ID_SHOW_BIG_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_DETAILS:
        if (fileview == ID_SHOW_DETAILS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), NULL);

    // Disable menus items if the file list is not shown
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Harvest the zombies
long XFileImage::onSigHarvest(FXObject*, FXSelector, void*)
{
    while (waitpid(-1, NULL, WNOHANG) > 0)
    {
    }
    return(1);
}


// Quit
long XFileImage::onCmdQuit(FXObject*, FXSelector, void*)
{
    // Save settings
    saveConfig();

    // Quit
    getApp()->exit(EXIT_SUCCESS);
    return(1);
}


// Update title (display image size and actual zoom)
long XFileImage::onUpdTitle(FXObject* sender, FXSelector, void*)
{
    FXString title = "Xfi " + filename;
    FXImage* image = imageview->getImage();

    if (image && (img != NULL))
    {
        title += " (" + FXStringVal(img->getWidth()) + "x" + FXStringVal(img->getHeight()) + " - " + FXStringVal(zoomval*100) + "%" ")";
    }
    sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_SETSTRINGVALUE), (void*)&title);
    return(1);
}


// Open recent file
long XFileImage::onCmdRecentFile(FXObject*, FXSelector, void* ptr)
{
    filename = (char*)ptr;
    filelist->setCurrentFile(filename);
    loadimage(filename);
    return(1);
}


// Double clicked in the file list
long XFileImage::onCmdItemDoubleClicked(FXObject*, FXSelector, void* ptr)
{
    int index = (int)(FXival)ptr;

    if (0 <= index)
    {
        if (filelist->isItemDirectory(index))
        {
            FXString pathname = filelist->getItemPathname(index);

            // Does not have access
            if (!::isReadExecutable(pathname))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _(" Permission to: %s denied."), pathname.text());
                return(0);
            }
            filelist->setDirectory(pathname);
            pathlink->setPath(pathname);
            pathtext->setText(pathname);
        }
        else if (filelist->isItemFile(index))
        {
            filename = filelist->getItemPathname(index);
            mrufiles.appendFile(filename);
            loadimage(filename);
            filelist->setCurrentItem(index);
        }
    }
    return(1);
}


// Single clicked in the file list
long XFileImage::onCmdItemClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    if (single_click != SINGLE_CLICK_NONE)
    {
        // In detailed mode, avoid single click when cursor is not over the first column
        int    x, y;
        FXuint state;
        filelist->getCursorPosition(x, y, state);
        FXbool allow = true;
        if (!(filelist->getListStyle()&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS)) && ((x-filelist->getXPosition()) > filelist->getHeaderSize(0)))
        {
            allow = false;
        }

        int index = (int)(FXival)ptr;
        if (0 <= index)
        {
            if ((single_click != SINGLE_CLICK_NONE) && filelist->isItemDirectory(index) && allow)
            {
                FXString pathname = filelist->getItemPathname(index);

                // Does not have access
                if (!::isReadExecutable(pathname))
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _(" Permission to: %s denied."), pathname.text());
                    return(0);
                }
                filelist->setDirectory(pathname);
                pathlink->setPath(pathname);
                pathtext->setText(pathname);
            }
            else if ((single_click == SINGLE_CLICK_DIR_FILE) && filelist->isItemFile(index) && allow)
            {
                filename = filelist->getItemPathname(index);
                mrufiles.appendFile(filename);
                loadimage(filename);
                filelist->setCurrentItem(index);
            }
        }
    }
    return(1);
}


// Rotate image
long XFileImage::onCmdRotate(FXObject*, FXSelector sel, void*)
{
    getApp()->beginWaitCursor();
    FXImage* image = imageview->getImage();
    switch (FXSELID(sel))
    {
    case ID_ROTATE_90:

        // Rotate the actual image
        image->rotate(90);

        // Need to also rotate the original image only if the actual size is different
        if ((image->getWidth() != img->getWidth()) || (image->getHeight() != img->getHeight()))
        {
            img->rotate(90);
        }
        break;

    case ID_ROTATE_270:

        // Rotate the actual image
        image->rotate(270);

        // Need to also rotate the original image only if the actual size is different
        if ((image->getWidth() != img->getWidth()) || (image->getHeight() != img->getHeight()))
        {
            img->rotate(270);
        }
        break;
    }
    imageview->setImage(image);
    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Update image
long XFileImage::onUpdImage(FXObject* sender, FXSelector, void*)
{
    if (imageview->getImage())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    return(1);
}


// Mirror image
long XFileImage::onCmdMirror(FXObject*, FXSelector sel, void*)
{
    getApp()->beginWaitCursor();
    FXImage* image = imageview->getImage();
    switch (FXSELID(sel))
    {
    case ID_MIRROR_HOR:

        // Mirror the actual image
        image->mirror(true, false);

        // Need to also mirror the original image only if the actual size is different
        if ((image->getWidth() != img->getWidth()) || (image->getHeight() != img->getHeight()))
        {
            img->mirror(true, false);
        }
        break;

    case ID_MIRROR_VER:

        // Mirror the actual image
        image->mirror(false, true);

        // Need to also mirror the original image only if the actual size is different
        if ((image->getWidth() != img->getWidth()) || (image->getHeight() != img->getHeight()))
        {
            img->mirror(false, true);
        }
        break;
    }
    imageview->setImage(image);
    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Zoom in image
long XFileImage::onCmdZoomIn(FXObject*, FXSelector, void*)
{
    getApp()->beginWaitCursor();

    // Copy the original image into the actual one
    if (!FXMEMDUP(&tmpdata, img->getData(), FXColor, img->getWidth()*img->getHeight()))
    {
        throw FXMemoryException(_("Unable to load image"));
    }
    tmpimg->setData(tmpdata, IMAGE_OWNED, img->getWidth(), img->getHeight());

    // Resize the actual image according to the new zoom factor
    indZoom += 1;
    if (indZoom > NB_ZOOM-1)
    {
        indZoom = NB_ZOOM-1;
    }
    int sx = (int)(tmpimg->getWidth()*zoomtab[indZoom]);
    int sy = (int)(tmpimg->getHeight()*zoomtab[indZoom]);

    // Scale only if the actual image size is different
    if (indZoom == ZOOM_100)
    {
        imageview->setImage(img);
    }
    else
    {
        // Maximum zoom allowed
        if ((sx > MAX_IMGSIZE) || (sy > MAX_IMGSIZE))
        {
            indZoom -= 1;
            if (indZoom < 0)
            {
                indZoom = 0;
            }
            sx = (int)(tmpimg->getWidth()*zoomtab[indZoom]);
            sy = (int)(tmpimg->getHeight()*zoomtab[indZoom]);
        }

        // Scale image according to the new zoom factor
        tmpimg->scale(sx, sy, 1);
        imageview->setImage(tmpimg);
    }

    // Set zoom value for window title
    zoomval = zoomtab[indZoom];

    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Zoom out image
long XFileImage::onCmdZoomOut(FXObject*, FXSelector, void*)
{
    getApp()->beginWaitCursor();

    // Copy the original image into the actual one
    if (!FXMEMDUP(&tmpdata, img->getData(), FXColor, img->getWidth()*img->getHeight()))
    {
        throw FXMemoryException(_("Unable to load image"));
    }
    tmpimg->setData(tmpdata, IMAGE_OWNED, img->getWidth(), img->getHeight());

    // Resize the image according to the new zoom factor
    indZoom -= 1;
    if (indZoom < 0)
    {
        indZoom = 0;
    }
    int sx = (int)(tmpimg->getWidth()*zoomtab[indZoom]);
    int sy = (int)(tmpimg->getHeight()*zoomtab[indZoom]);

    // Scale only if the actual image size is different
    if (indZoom == ZOOM_100)
    {
        imageview->setImage(img);
    }
    else
    {
        // Scale image according to the new zoom factor
        tmpimg->scale(sx, sy, 1);
        imageview->setImage(tmpimg);
    }

    // Set zoom value for window title
    zoomval = zoomtab[indZoom];

    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Zoom to 100%
long XFileImage::onCmdZoom100(FXObject*, FXSelector, void*)
{
    getApp()->beginWaitCursor();
    indZoom = ZOOM_100;
    zoomval = zoomtab[indZoom];
    imageview->setImage(img);
    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Zoom to fit window
long XFileImage::onCmdZoomWin(FXObject*, FXSelector, void*)
{
    getApp()->beginWaitCursor();

    // Window and image sizes
    int winw = imageview->getWidth();
    int winh = imageview->getHeight();
    int w = img->getWidth();
    int h = img->getHeight();

    // Compute zoom factor
    double fitwin;
    if (double(w)/double(h) > double(winw)/double(winh))
    {
        fitwin = 0.98*(double)winw/(double)w;
    }
    else
    {
        fitwin = 0.98*(double)winh/(double)h;
    }

    // Find the most approaching predefined zoom
    // This is used in other zoom functions
    for (int k = 0; k < NB_ZOOM; k++)
    {
        if (zoomtab[k] > fitwin)
        {
            indZoom = k-1;
            break;
        }
    }
    if (indZoom < 0)
    {
        indZoom = 0;
    }
    if (indZoom >= NB_ZOOM)
    {
        indZoom = NB_ZOOM-1;
    }

    // Copy the original image into the actual one
    if (!FXMEMDUP(&tmpdata, img->getData(), FXColor, img->getWidth()*img->getHeight()))
    {
        throw FXMemoryException(_("Unable to load image"));
    }
    tmpimg->setData(tmpdata, IMAGE_OWNED, img->getWidth(), img->getHeight());

    // Resize the image according to the new zoom factor
    int sx = (int)(w*fitwin);
    int sy = (int)(h*fitwin);

    // Scale image according to the new zoom factor
    tmpimg->scale(sx, sy, 1);
    imageview->setImage(tmpimg);

    // Set zoom value for window title
    zoomval = fitwin;

    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Restart the application when required
long XFileImage::onCmdRestart(FXObject*, FXSelector, void*)
{
    saveConfig();

    if (fork() == 0) // Child
    {
        execvp("xfi", args);
    }
    else // Parent
    {
        exit(EXIT_SUCCESS);
    }
    return(1);
}


// Start the ball rolling
void XFileImage::start(FXString startimage)
{
    filename = startimage;
    if (filename != "")
    {
        loadimage(filename);
    }
}


// Create and show window
void XFileImage::create()
{
    // Get size and position
    FXuint ww = getApp()->reg().readUnsignedEntry("OPTIONS", "width", DEFAULT_WINDOW_WIDTH);    // Workaround for a possible bug in some WMs
    FXuint hh = getApp()->reg().readUnsignedEntry("OPTIONS", "height", DEFAULT_WINDOW_HEIGHT);  // Workaround for a possible bug in some WMs

    filewidth_pct = getApp()->reg().readRealEntry("OPTIONS", "filewidth_pct", 0.25);
    fileheight_pct = getApp()->reg().readRealEntry("OPTIONS", "fileheight_pct", 0.25);
    FXuint fs = getApp()->reg().readIntEntry("OPTIONS", "filesshown", true);

    filelist->setDirectory(FXSystem::getCurrentDirectory());
    pathlink->setPath(FXSystem::getCurrentDirectory());
    pathtext->setText(FXSystem::getCurrentDirectory());

    // Display or hide path linker and path text
    if (show_pathlink)
    {
        pathtext->hide();
        pathlink->show();
    }
    else
    {
        pathlink->hide();
        pathtext->show();
    }

    // Hide tree if asked for
    if (!fs)
    {
        filebox->hide();
    }

    // Set toolbar status
    if (getApp()->reg().readUnsignedEntry("OPTIONS", "showtoolbar", true) == false)
    {
        toolbar->hide();
    }

    // Set status bar status
    if (getApp()->reg().readUnsignedEntry("OPTIONS", "showstatusbar", true) == false)
    {
        statusbar->hide();
    }

    // Set hidden file status
    hiddenfiles = getApp()->reg().readUnsignedEntry("OPTIONS", "hiddenfiles", 0);
    filelist->showHiddenFiles(hiddenfiles);

    // Set thumbnails status
    thumbnails = getApp()->reg().readUnsignedEntry("OPTIONS", "thumbnails", 0);
    filelist->showThumbnails(thumbnails);

    // Set list style
    liststyle = getApp()->reg().readUnsignedEntry("OPTIONS", "liststyle", _ICONLIST_MINI_ICONS);
    filelist->setListStyle(liststyle|_ICONLIST_BROWSESELECT);

    // Set file view
    fileview = getApp()->reg().readUnsignedEntry("OPTIONS", "fileview", ID_SHOW_MINI_ICONS);
    this->handle(this, FXSEL(SEL_COMMAND, fileview), NULL);

    // Set startup zoom
    fitwin = getApp()->reg().readUnsignedEntry("OPTIONS", "fitwin", 0);

    // Set filter images flag
    filterimgs = getApp()->reg().readUnsignedEntry("OPTIONS", "filterimgs", false);

    // Set position and position window
    if (save_win_pos)
    {
        int xpos = getApp()->reg().readIntEntry("OPTIONS", "xpos", DEFAULT_WINDOW_XPOS);
        int ypos = getApp()->reg().readIntEntry("OPTIONS", "ypos", DEFAULT_WINDOW_YPOS);
        position(xpos, ypos, ww, hh);
    }
    else
    {
        position(getX(), getY(), ww, hh);
    }

    FXMainWindow::create();

    if (filterimgs)
    {
        filelist->setPattern(imgpatterns);
    }

    // Set filebox width or height
    if (vertpanels)
    {
        filebox->setWidth((int)round(filewidth_pct*getWidth()));
    }
    else
    {
        filebox->setHeight((int)round(fileheight_pct*getHeight()));
    }

    // Set focus on file list
    filelist->setFocus();

    show();


#ifdef STARTUP_NOTIFICATION
    startup_completed();
#endif
}


// Switch between vertical and horizontal panels
long XFileImage::onCmdHorzVertPanels(FXObject* sender, FXSelector sel, void* ptr)
{
    switch (FXSELID(sel))
    {
    case ID_VERT_PANELS:
        splitter->setSplitterStyle(splitter->getSplitterStyle()&~SPLITTER_VERTICAL);
        vertpanels = true;
        break;

    case ID_HORZ_PANELS:
        splitter->setSplitterStyle(splitter->getSplitterStyle()|SPLITTER_VERTICAL);
        vertpanels = false;
        break;
    }

    filelist->setFocus();

    return(1);
}


// Update the horizontal / vertical panel radio menus
long XFileImage::onUpdHorzVertPanels(FXObject* sender, FXSelector sel, void* ptr)
{
    sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), ptr);

    if (vertpanels)
    {
        if (FXSELID(sel) == ID_HORZ_PANELS)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_UNCHECK), ptr);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_CHECK), ptr);
        }
    }
    else
    {
        if (FXSELID(sel) == ID_VERT_PANELS)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_UNCHECK), ptr);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_CHECK), ptr);
        }
    }

    return(1);
}


// Save configuration when quitting
void XFileImage::saveConfig()
{
    // Write new window size and position back to registry
    getApp()->reg().writeUnsignedEntry("OPTIONS", "width", (FXuint)getWidth());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "height", (FXuint)getHeight());

    if (save_win_pos)
    {
        // Account for the Window Manager border size
        XWindowAttributes xwattr;
        if (XGetWindowAttributes((Display*)getApp()->getDisplay(), this->id(), &xwattr))
        {
            getApp()->reg().writeIntEntry("OPTIONS", "xpos", getX()-xwattr.x);
            getApp()->reg().writeIntEntry("OPTIONS", "ypos", getY()-xwattr.y);
        }
        else
        {
            getApp()->reg().writeIntEntry("OPTIONS", "xpos", getX());
            getApp()->reg().writeIntEntry("OPTIONS", "ypos", getY());
        }
    }

    // Width and height of filebox
    getApp()->reg().writeRealEntry("OPTIONS", "filewidth_pct", (int)(filewidth_pct*100)/100.0);
    getApp()->reg().writeRealEntry("OPTIONS", "fileheight_pct", (int)(fileheight_pct*100)/100.0);

    // Was filebox shown
    getApp()->reg().writeIntEntry("OPTIONS", "filesshown", filebox->shown());

    // Toolbar status
    if (toolbar->shown())
    {
        getApp()->reg().writeUnsignedEntry("OPTIONS", "showtoolbar", true);
    }
    else
    {
        getApp()->reg().writeUnsignedEntry("OPTIONS", "showtoolbar", false);
    }

    // Hidden files status
    getApp()->reg().writeUnsignedEntry("OPTIONS", "hiddenfiles", hiddenfiles);

    // Thumbnails status
    getApp()->reg().writeUnsignedEntry("OPTIONS", "thumbnails", thumbnails);

    // File view
    getApp()->reg().writeUnsignedEntry("OPTIONS", "fileview", fileview);

    // List style
    getApp()->reg().writeUnsignedEntry("OPTIONS", "liststyle", filelist->getListStyle());

    // Startup zoom
    getApp()->reg().writeUnsignedEntry("OPTIONS", "fitwin", fitwin);

    // Filter images in file list
    getApp()->reg().writeUnsignedEntry("OPTIONS", "filterimgs", filterimgs);

    // Filelist columns sizes
    getApp()->reg().writeUnsignedEntry("OPTIONS", "name_size", filelist->getHeaderSize(0));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "size_size", filelist->getHeaderSize(1));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "type_size", filelist->getHeaderSize(2));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "ext_size", filelist->getHeaderSize(3));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "modd_size", filelist->getHeaderSize(4));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "user_size", filelist->getHeaderSize(5));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "grou_size", filelist->getHeaderSize(6));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "attr_size", filelist->getHeaderSize(7));

    // Panel stacking
    getApp()->reg().writeUnsignedEntry("OPTIONS", "filelist_before", filelistbefore);
    getApp()->reg().writeUnsignedEntry("OPTIONS", "vert_panels", vertpanels);

    // Get and write sort function for search window
    FXString sort_func;
    if (filelist->getSortFunc() == filelist->ascendingCase)
    {
        sort_func = "ascendingCase";
    }
    if (filelist->getSortFunc() == filelist->ascendingCaseMix)
    {
        sort_func = "ascendingCaseMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingCase)
    {
        sort_func = "descendingCase";
    }
    else if (filelist->getSortFunc() == filelist->descendingCaseMix)
    {
        sort_func = "descendingCaseMix";
    }
    else if (filelist->getSortFunc() == filelist->ascending)
    {
        sort_func = "ascending";
    }
    else if (filelist->getSortFunc() == filelist->ascendingMix)
    {
        sort_func = "ascendingMix";
    }
    else if (filelist->getSortFunc() == filelist->descending)
    {
        sort_func = "descending";
    }
    else if (filelist->getSortFunc() == filelist->descendingMix)
    {
        sort_func = "descendingMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingSize)
    {
        sort_func = "ascendingSize";
    }
    else if (filelist->getSortFunc() == filelist->ascendingSizeMix)
    {
        sort_func = "ascendingSizeMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingSize)
    {
        sort_func = "descendingSize";
    }
    else if (filelist->getSortFunc() == filelist->descendingSizeMix)
    {
        sort_func = "descendingSizeMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingType)
    {
        sort_func = "ascendingType";
    }
    else if (filelist->getSortFunc() == filelist->ascendingTypeMix)
    {
        sort_func = "ascendingTypeMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingType)
    {
        sort_func = "descendingType";
    }
    else if (filelist->getSortFunc() == filelist->descendingTypeMix)
    {
        sort_func = "descendingTypeMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingExt)
    {
        sort_func = "ascendingExt";
    }
    else if (filelist->getSortFunc() == filelist->ascendingExtMix)
    {
        sort_func = "ascendingExtMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingExt)
    {
        sort_func = "descendingExt";
    }
    else if (filelist->getSortFunc() == filelist->descendingExtMix)
    {
        sort_func = "descendingExtMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingTime)
    {
        sort_func = "ascendingTime";
    }
    else if (filelist->getSortFunc() == filelist->ascendingTimeMix)
    {
        sort_func = "ascendingTimeMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingTime)
    {
        sort_func = "descendingTime";
    }
    else if (filelist->getSortFunc() == filelist->descendingTimeMix)
    {
        sort_func = "descendingTimeMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingUser)
    {
        sort_func = "ascendingUser";
    }
    else if (filelist->getSortFunc() == filelist->ascendingUserMix)
    {
        sort_func = "ascendingUserMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingUser)
    {
        sort_func = "descendingUser";
    }
    else if (filelist->getSortFunc() == filelist->descendingUserMix)
    {
        sort_func = "descendingUserMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingGroup)
    {
        sort_func = "ascendingGroup";
    }
    else if (filelist->getSortFunc() == filelist->ascendingGroupMix)
    {
        sort_func = "ascendingGroupMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingGroup)
    {
        sort_func = "descendingGroup";
    }
    else if (filelist->getSortFunc() == filelist->descendingGroupMix)
    {
        sort_func = "descendingGroupMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingPerm)
    {
        sort_func = "ascendingPerm";
    }
    else if (filelist->getSortFunc() == filelist->ascendingPermMix)
    {
        sort_func = "ascendingPermMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingPerm)
    {
        sort_func = "descendingPerm";
    }
    else if (filelist->getSortFunc() == filelist->descendingPermMix)
    {
        sort_func = "descendingPermMix";
    }
    else
    {
        sort_func = "ascendingCase";
    }
    getApp()->reg().writeStringEntry("OPTIONS", "sort_func", sort_func.text());

    // Write registry settings
    getApp()->reg().write();
}


// Usage message
#define USAGE_MSG    _("\
\nUsage: xfi [options] [image] \n\
\n\
    [options] can be any of the following:\n\
\n\
        -h, --help         Print (this) help screen and exit.\n\
        -v, --version      Print version information and exit.\n\
\n\
    [image] is the path to the image file you want to open on start up.\n\
\n")



// Start the whole thing
int main(int argc, char* argv[])
{
    int         i;
    FXString    startimage = "";
    const char* appname = "xfi";
    const char* xfename = XFEAPPNAME;
    const char* vdrname = XFEVDRNAME;
    FXbool      loadicons;
    FXString    xmodifiers;

    // Get environment variables $HOME, $XDG_DATA_HOME and $XDG_CONFIG_HOME
    homedir = FXSystem::getHomeDirectory();
    if (homedir == "")
    {
        homedir = ROOTDIR;
    }
    xdgdatahome = getenv("XDG_DATA_HOME");
    if (xdgdatahome == "")
    {
        xdgdatahome = homedir + PATHSEPSTRING DATAPATH;
    }
    xdgconfighome = getenv("XDG_CONFIG_HOME");
    if (xdgconfighome == "")
    {
        xdgconfighome = homedir + PATHSEPSTRING CONFIGPATH;
    }

    // Detect if an X input method is used
    xmodifiers = getenv("XMODIFIERS");
    if ((xmodifiers == "") || (xmodifiers == "@im=none"))
    {
        xim_used = false;
    }
    else
    {
        xim_used = true;
    }

#ifdef HAVE_SETLOCALE
    // Set locale via LC_ALL.
    setlocale(LC_ALL, "");
#endif

#if ENABLE_NLS
    // Set the text message domain.
    bindtextdomain(PACKAGE, LOCALEDIR);
    bind_textdomain_codeset(PACKAGE, "utf-8");
    textdomain(PACKAGE);
#endif

    // Parse basic arguments
    for (i = 1; i < argc; ++i)
    {
        if ((compare(argv[i], "-v") == 0) || (compare(argv[i], "--version") == 0))
        {
            fprintf(stdout, "%s version %s\n", PACKAGE, VERSION);
            exit(EXIT_SUCCESS);
        }
        else if ((compare(argv[i], "-h") == 0) || (compare(argv[i], "--help") == 0))
        {
            fprintf(stdout, USAGE_MSG);
            exit(EXIT_SUCCESS);
        }
        else
        {
            // Start image, if any
            startimage = argv[i];
        }
    }

    args = argv;

    // Make application
    FXApp* application = new FXApp(appname, vdrname);

    // Open display
    application->init(argc, argv);

    // Redefine the default hand cursor
    FXCursor* hand = new FXCursor(application, hand_bits, hand_mask_bits, hand_width, hand_height, hand_x_hot, hand_y_hot);
    application->setDefaultCursor(DEF_HAND_CURSOR, hand);

    // Load all application icons
    loadicons = loadAppIcons(application);

    // Read the Xfe registry
    FXRegistry* reg_xfe = new FXRegistry(xfename, vdrname);
    reg_xfe->read();

    // Set base color (to change the default base color at first run)
    FXColor basecolor = reg_xfe->readColorEntry("SETTINGS", "basecolor", FXRGB(237, 233, 227));
    application->setBaseColor(basecolor);

    // Set Xfi normal font according to the Xfe registry
    FXString fontspec;
    fontspec = reg_xfe->readStringEntry("SETTINGS", "font", DEFAULT_NORMAL_FONT);
    if (!fontspec.empty())
    {
        FXFont* normalFont = new FXFont(application, fontspec);
        normalFont->create();
        application->setNormalFont(normalFont);
    }

    // Set Xfi file list colors according to the Xfe registry
    listbackcolor = reg_xfe->readColorEntry("SETTINGS", "listbackcolor", FXRGB(255, 255, 255));
    listforecolor = reg_xfe->readColorEntry("SETTINGS", "listforecolor", FXRGB(0, 0, 0));
    highlightcolor = reg_xfe->readColorEntry("SETTINGS", "highlightcolor", FXRGB(238, 238, 238));

    // Set single click navigation according to the Xfe registry
    single_click = reg_xfe->readUnsignedEntry("SETTINGS", "single_click", SINGLE_CLICK_NONE);

    // Set smooth scrolling according to the Xfe registry
    FXbool smoothscroll = reg_xfe->readUnsignedEntry("SETTINGS", "smooth_scroll", true);

    // Set file list tooltip flag according to the Xfe registry
    file_tooltips = reg_xfe->readUnsignedEntry("SETTINGS", "file_tooltips", true);

    // Set relative resizing flag according to the Xfe registry
    relative_resize = reg_xfe->readUnsignedEntry("SETTINGS", "relative_resize", true);

    // Set display pathlinker flag according to the Xfe registry
    show_pathlink = reg_xfe->readUnsignedEntry("SETTINGS", "show_pathlinker", true);

    // Get value of the window position flag
    save_win_pos = reg_xfe->readUnsignedEntry("SETTINGS", "save_win_pos", false);

    // Delete the Xfe registry
    delete reg_xfe;

    // Make window
    XFileImage* window = new XFileImage(application, smoothscroll);

    // Catch SIGCHLD to harvest zombie child processes
    application->addSignal(SIGCHLD, window, XFileImage::ID_HARVEST, true);

    // Handle interrupt to save stuff nicely
    application->addSignal(SIGINT, window, XFileImage::ID_QUIT);

    // Create it
    application->create();

    // Smooth scrolling
    window->setSmoothScroll(smoothscroll);

    if (!loadicons)
    {
        MessageBox::error(application, BOX_OK, _("Error loading icons"), _("Unable to load some icons. Please check your icons path!"));
    }

    // Tooltips setup time and duration
    application->setTooltipPause(TOOLTIP_PAUSE);
    application->setTooltipTime(TOOLTIP_TIME);

    // Start
    window->start(startimage);

    // Run
    return(application->run());
}
// This code is adapted from 'imageviewer', a demo image viewer found
// in the FOX library and written by Jeroen van der Zijp.

#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGImage.h>
#include <FXJPGImage.h>
#include <FXTIFImage.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "startupnotification.h"
#include "FileDialog.h"
#include "InputDialog.h"
#include "DirHistBox.h"
#include "MessageBox.h"
#include "FileList.h"
#include "XFileImage.h"

// Add FOX hacks
#include "foxhacks.cpp"
#include "clearlooks.cpp"

// Global variables
char**   args;
FXColor  listbackcolor, listforecolor;
FXColor  highlightcolor;
FXbool   allowPopupScroll = false;
FXuint   single_click;
FXbool   file_tooltips;
FXbool   relative_resize;
FXbool   show_pathlink;
FXbool   save_win_pos;
FXString homedir;
FXString xdgconfighome;
FXString xdgdatahome;
FXbool   xim_used = false;

// Hand cursor replacement
#define hand_width     32
#define hand_height    32
#define hand_x_hot     6
#define hand_y_hot     1
static const FXuchar hand_bits[] =
{
    0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00,
    0x90, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x90, 0x07, 0x00, 0x00,
    0x97, 0x1a, 0x00, 0x00, 0x99, 0x2a, 0x00, 0x00, 0x11, 0x28, 0x00, 0x00,
    0x12, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00,
    0x04, 0x20, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00,
    0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const FXuchar hand_mask_bits[] =
{
    0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
    0xf0, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00,
    0xf7, 0x1f, 0x00, 0x00, 0xff, 0x3f, 0x00, 0x00, 0xff, 0x3f, 0x00, 0x00,
    0xfe, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00,
    0xfc, 0x3f, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00,
    0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// Predefined zoom factors
#define NB_ZOOM    24
double zoomtab[NB_ZOOM] =
{
    0.01, 0.025, 0.05, 0.075, 0.10, 0.15, 0.20, 0.30, 0.50, 0.75, 1, \
    1.5, 2, 3, 4, 5, 7.5, 10, 15, 20, 30, 50, 75, 100
};
#define ZOOM_100       10

// Maximum image size (in pixels) for zooming in
#define MAX_IMGSIZE    5120

// Patterns for supported image formats
const char* patterns[] =
{
    _("All Files"), "*",
    _("GIF Image"), "*.gif",
    _("BMP Image"), "*.bmp",
    _("XPM Image"), "*.xpm",
    _("PCX Image"), "*.pcx",
    _("ICO Image"), "*.ico",
    _("RGB Image"), "*.rgb",
    _("XBM Image"), "*.xbm",
    _("TARGA Image"), "*.tga",
    _("PPM Image"), "*.ppm",
    _("PNG Image"), "*.png",
    _("JPEG Image"), "*.jpg",
    _("JPEG Image"), "*.jpeg",
    _("TIFF Image"), "*.tif",
    _("TIFF Image"), "*.tiff",
    NULL
};


const FXString imgpatterns = "*.gif,*.bmp,*.xpm,*.pcx,*.ico,*.rgb,*.xbm,*.tga,*.ppm,*.png,*.jpg,*.jpeg,*.tif,*.tiff";


// Helper function to draw a toolbar separator
void toolbarSeparator(FXToolBar* tb)
{
#define SEP_SPACE_TB    1
    new FXFrame(tb, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE_TB);
    new FXVerticalSeparator(tb, LAYOUT_SIDE_TOP|LAYOUT_CENTER_Y|SEPARATOR_GROOVE|LAYOUT_FILL_Y);
    new FXFrame(tb, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE_TB);
}


// Helper function to draw a separator in an horizontal frame
void hframeSeparator(FXHorizontalFrame* hframe)
{
#define SEP_SPACE_HF    5
    new FXFrame(hframe, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE_HF);
    new FXVerticalSeparator(hframe, LAYOUT_SIDE_TOP|LAYOUT_CENTER_Y|SEPARATOR_GROOVE|LAYOUT_FILL_Y);
    new FXFrame(hframe, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE_HF);
}


// Map
FXDEFMAP(XFileImage) XFileImageMap[] =
{
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ABOUT, XFileImage::onCmdAbout),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_OPEN, XFileImage::onCmdOpen),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TITLE, XFileImage::onUpdTitle),
    FXMAPFUNC(SEL_SIGNAL, XFileImage::ID_HARVEST, XFileImage::onSigHarvest),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_QUIT, XFileImage::onCmdQuit),
    FXMAPFUNC(SEL_SIGNAL, XFileImage::ID_QUIT, XFileImage::onCmdQuit),
    FXMAPFUNC(SEL_CLOSE, XFileImage::ID_TITLE, XFileImage::onCmdQuit),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_RESTART, XFileImage::onCmdRestart),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_FILELIST_BEFORE, XFileImage::onCmdToggleFileListBefore),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_HORZ_PANELS, XFileImage::onCmdHorzVertPanels),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_VERT_PANELS, XFileImage::onCmdHorzVertPanels),
    FXMAPFUNC(SEL_DOUBLECLICKED, XFileImage::ID_FILELIST, XFileImage::onCmdItemDoubleClicked),
    FXMAPFUNC(SEL_CLICKED, XFileImage::ID_FILELIST, XFileImage::onCmdItemClicked),
    FXMAPFUNC(SEL_KEYPRESS, 0, XFileImage::onKeyPress),
    FXMAPFUNC(SEL_KEYRELEASE, 0, XFileImage::onKeyRelease),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_RECENTFILE, XFileImage::onCmdRecentFile),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_HIDDEN, XFileImage::onCmdToggleHidden),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_THUMBNAILS, XFileImage::onCmdToggleThumbnails),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_SHOW_DETAILS, XFileImage::onCmdShowDetails),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_SHOW_MINI_ICONS, XFileImage::onCmdShowMini),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_SHOW_BIG_ICONS, XFileImage::onCmdShowBig),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ROTATE_90, XFileImage::onCmdRotate),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ROTATE_270, XFileImage::onCmdRotate),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_MIRROR_HOR, XFileImage::onCmdMirror),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_MIRROR_VER, XFileImage::onCmdMirror),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ZOOM_IN, XFileImage::onCmdZoomIn),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ZOOM_OUT, XFileImage::onCmdZoomOut),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ZOOM_100, XFileImage::onCmdZoom100),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ZOOM_WIN, XFileImage::onCmdZoomWin),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_PRINT, XFileImage::onCmdPrint),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_UP, XFileImage::onCmdDirUp),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_UP, XFileImage::onUpdDirUp),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_BACK, XFileImage::onCmdDirBack),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_BACK, XFileImage::onUpdDirBack),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_FORWARD, XFileImage::onCmdDirForward),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_FORWARD, XFileImage::onUpdDirForward),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_BACK_HIST, XFileImage::onCmdDirBackHist),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_BACK_HIST, XFileImage::onUpdDirBackHist),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_FORWARD_HIST, XFileImage::onCmdDirForwardHist),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_FORWARD_HIST, XFileImage::onUpdDirForwardHist),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_GO_HOME, XFileImage::onCmdHome),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_PRINT, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ROTATE_90, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ROTATE_270, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_MIRROR_HOR, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_MIRROR_VER, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ZOOM_IN, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ZOOM_OUT, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ZOOM_100, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ZOOM_WIN, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_SHOW_BIG_ICONS, XFileImage::onUpdFileView),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_SHOW_MINI_ICONS, XFileImage::onUpdFileView),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_SHOW_DETAILS, XFileImage::onUpdFileView),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_HIDDEN, XFileImage::onUpdToggleHidden),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_FILELIST_BEFORE, XFileImage::onUpdToggleFileListBefore),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_THUMBNAILS, XFileImage::onUpdToggleThumbnails),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_FIT_WIN, XFileImage::onCmdToggleFitWin),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_FILTER_IMAGES, XFileImage::onCmdToggleFilterImages),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_FIT_WIN, XFileImage::onUpdToggleFitWin),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_FILTER_IMAGES, XFileImage::onUpdToggleFilterImages),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_HORZ_PANELS, XFileImage::onUpdHorzVertPanels),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_VERT_PANELS, XFileImage::onUpdHorzVertPanels),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_GO_HOME, XFileImage::onCmdHome),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_GO_WORK, XFileImage::onCmdWork),
    FXMAPFUNC(SEL_RIGHTBUTTONRELEASE, XFileImage::ID_FILELIST, XFileImage::onCmdPopupMenu),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_POPUP_MENU, XFileImage::onCmdPopupMenu),
};


// Object implementation
FXIMPLEMENT(XFileImage, FXMainWindow, XFileImageMap, ARRAYNUMBER(XFileImageMap))


// Make some windows
XFileImage::XFileImage(FXApp* a, FXbool smoothscroll) : FXMainWindow(a, "Xfi ", NULL, NULL, DECOR_ALL)
{
    setIcon(xfiicon);

    FXButton* btn = NULL;
    FXHotKey  hotkey;
    FXString  key;

    setTarget(this);
    setSelector(ID_TITLE);

    // Make menu bar
    // menubar = new FXMenuBar(this, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_RAISED);

    // Sites where to dock
    FXDockSite* topdock = new FXDockSite(this, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_SUNKEN);
    new FXDockSite(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X);
    new FXDockSite(this, LAYOUT_SIDE_LEFT|LAYOUT_FILL_Y);
    new FXDockSite(this, LAYOUT_SIDE_RIGHT|LAYOUT_FILL_Y);

    // New menu bar
    FXToolBarShell* dragshell0 = new FXToolBarShell(this, FRAME_RAISED);
    menubar = new FXMenuBar(topdock, dragshell0, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_RAISED);
    new FXToolBarGrip(menubar, menubar, FXToolBar::ID_TOOLBARGRIP, TOOLBARGRIP_SINGLE);

    // Tool bar
    FXToolBarShell* dragshell1 = new FXToolBarShell(this, FRAME_RAISED);
    toolbar = new FXToolBar(topdock, dragshell1, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_RAISED);
    new FXToolBarGrip(toolbar, toolbar, FXToolBar::ID_TOOLBARGRIP, TOOLBARGRIP_SINGLE);

    // File menu
    filemenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&File"), NULL, filemenu);

    // Image Menu
    imagemenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&Image"), NULL, imagemenu);

    // View menu
    viewmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&View"), NULL, viewmenu);

    // Preferences Menu
    prefsmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&Preferences"), NULL, prefsmenu);

    // Help menu
    helpmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&Help"), NULL, helpmenu);

    // Splitter
    FXVerticalFrame* vframe = new FXVerticalFrame(this, LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // Set order of the file list and image widgets
    filelistbefore = getApp()->reg().readUnsignedEntry("OPTIONS", "filelist_before", false);
    if (filelistbefore)
    {
        splitter = new FXSplitter(vframe, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|SPLITTER_TRACKING|SPLITTER_VERTICAL);
        filebox = new FXVerticalFrame(splitter, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        imageview = new FXImageView(splitter, NULL, NULL, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_THICK|FRAME_SUNKEN);
    }
    else
    {
        splitter = new FXSplitter(vframe, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|SPLITTER_TRACKING|SPLITTER_VERTICAL|SPLITTER_REVERSED);
        imageview = new FXImageView(splitter, NULL, NULL, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_THICK|FRAME_SUNKEN);
        filebox = new FXVerticalFrame(splitter, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }

    // Stack panels horizontally or vertically
    vertpanels = getApp()->reg().readUnsignedEntry("OPTIONS", "vert_panels", false);
    if (vertpanels)
    {
        splitter->setSplitterStyle(splitter->getSplitterStyle()&~SPLITTER_VERTICAL);
    }
    else
    {
        splitter->setSplitterStyle(splitter->getSplitterStyle()|SPLITTER_VERTICAL);
    }

    // Container for the action buttons
    FXHorizontalFrame* buttons = new FXHorizontalFrame(filebox, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_RAISED, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0);

    // Container for the path linker
    FXHorizontalFrame* pathframe = new FXHorizontalFrame(filebox, LAYOUT_FILL_X|FRAME_RAISED, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // File list
    FXuint options;
    if (smoothscroll)
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS|_ICONLIST_BROWSESELECT;
    }
    else
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS|_ICONLIST_BROWSESELECT|SCROLLERS_DONT_TRACK;
    }

    thumbnails = getApp()->reg().readUnsignedEntry("OPTIONS", "thumbnails", 0);
    filelist = new FileList(this, filebox, this, ID_FILELIST, thumbnails, options);
    filelist->setTextColor(listforecolor);
    filelist->setBackColor(listbackcolor);
    filelist->setHeaderSize(0, getApp()->reg().readUnsignedEntry("OPTIONS", "name_size", 200));
    filelist->setHeaderSize(1, getApp()->reg().readUnsignedEntry("OPTIONS", "size_size", 60));
    filelist->setHeaderSize(2, getApp()->reg().readUnsignedEntry("OPTIONS", "type_size", 100));
    filelist->setHeaderSize(3, getApp()->reg().readUnsignedEntry("OPTIONS", "ext_size", 100));
    filelist->setHeaderSize(4, getApp()->reg().readUnsignedEntry("OPTIONS", "modd_size", 150));
    filelist->setHeaderSize(5, getApp()->reg().readUnsignedEntry("OPTIONS", "user_size", 50));
    filelist->setHeaderSize(6, getApp()->reg().readUnsignedEntry("OPTIONS", "grou_size", 50));
    filelist->setHeaderSize(7, getApp()->reg().readUnsignedEntry("OPTIONS", "attr_size", 100));

    // Action buttons
    new FXFrame(buttons, LAYOUT_FIX_WIDTH, 0, 0, 4, 1);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_back", "Ctrl-Backspace");
    btn = new FXButton(buttons, TAB+_("Go to previous folder")+PARS(key), dirbackicon, this, ID_DIR_BACK, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);
    btnbackhist = new FXArrowButton(buttons, this, ID_DIR_BACK_HIST, LAYOUT_FILL_Y|FRAME_RAISED|FRAME_THICK|ARROW_DOWN|ARROW_TOOLBAR);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_forward", "Shift-Backspace");
    btn = new FXButton(buttons, TAB+_("Go to next folder")+PARS(key), dirforwardicon, this, ID_DIR_FORWARD, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);
    btnforwardhist = new FXArrowButton(buttons, this, ID_DIR_FORWARD_HIST, LAYOUT_FILL_Y|FRAME_RAISED|FRAME_THICK|ARROW_DOWN|ARROW_TOOLBAR);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_up", "Backspace");
    btn = new FXButton(buttons, TAB+_("Go to parent folder")+PARS(key), dirupicon, this, ID_DIR_UP, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Separator
    hframeSeparator(buttons);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_home", "Ctrl-H");
    new FXButton(buttons, TAB+_("Go to home folder")+PARS(key), homeicon, this, ID_GO_HOME, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_work", "Shift-F2");
    new FXButton(buttons, TAB+_("Go to working folder")+PARS(key), workicon, this, ID_GO_WORK, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Separator
    hframeSeparator(buttons);

    // Switch display modes
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "big_icons", "F10");
    btn = new FXButton(buttons, TAB+_("Big icon list")+PARS(key), bigiconsicon, this, ID_SHOW_BIG_ICONS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "small_icons", "F11");
    btn = new FXButton(buttons, TAB+_("Small icon list")+PARS(key), smalliconsicon, this, ID_SHOW_MINI_ICONS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "detailed_file_list", "F12");
    btn = new FXButton(buttons, TAB+_("Detailed file list")+PARS(key), detailsicon, this, ID_SHOW_DETAILS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Separator
    hframeSeparator(buttons);

    // Vertical panels
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "vert_panels", "Ctrl-Shift-F1");
    btn = new FXButton(buttons, TAB+_("Vertical panels")+PARS(key), vertpanelsicon, this, XFileImage::ID_VERT_PANELS, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Horizontal panels
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "horz_panels", "Ctrl-Shift-F2");
    btn = new FXButton(buttons, TAB+_("Horizontal panels")+PARS(key), horzpanelsicon, this, XFileImage::ID_HORZ_PANELS, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Panel title
    pathtext = new TextLabel(pathframe, 0, this, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    pathtext->setBackColor(getApp()->getBaseColor());

    // Path linker
    pathlink = new PathLinker(pathframe, filelist, NULL, LAYOUT_FILL_X);

    // Status bar
    statusbar = new FXHorizontalFrame(vframe, JUSTIFY_LEFT|LAYOUT_FILL_X, 0, 0, 0, 0, 3, 3, 0, 0);

    // Read and set sort function for file list
    FXString sort_func = getApp()->reg().readStringEntry("OPTIONS", "sort_func", "ascendingCase");
    if (sort_func == "ascendingCase")
    {
        filelist->setSortFunc(filelist->ascendingCase);
    }
    if (sort_func == "ascendingCaseMix")
    {
        filelist->setSortFunc(filelist->ascendingCaseMix);
    }
    else if (sort_func == "descendingCase")
    {
        filelist->setSortFunc(filelist->descendingCase);
    }
    else if (sort_func == "descendingCaseMix")
    {
        filelist->setSortFunc(filelist->descendingCaseMix);
    }
    else if (sort_func == "ascending")
    {
        filelist->setSortFunc(filelist->ascending);
    }
    else if (sort_func == "ascendingMix")
    {
        filelist->setSortFunc(filelist->ascendingMix);
    }
    else if (sort_func == "descending")
    {
        filelist->setSortFunc(filelist->descending);
    }
    else if (sort_func == "descendingMix")
    {
        filelist->setSortFunc(filelist->descendingMix);
    }
    else if (sort_func == "ascendingSize")
    {
        filelist->setSortFunc(filelist->ascendingSize);
    }
    else if (sort_func == "ascendingSizeMix")
    {
        filelist->setSortFunc(filelist->ascendingSizeMix);
    }
    else if (sort_func == "descendingSize")
    {
        filelist->setSortFunc(filelist->descendingSize);
    }
    else if (sort_func == "descendingSizeMix")
    {
        filelist->setSortFunc(filelist->descendingSizeMix);
    }
    else if (sort_func == "ascendingType")
    {
        filelist->setSortFunc(filelist->ascendingType);
    }
    else if (sort_func == "ascendingTypeMix")
    {
        filelist->setSortFunc(filelist->ascendingTypeMix);
    }
    else if (sort_func == "descendingType")
    {
        filelist->setSortFunc(filelist->descendingType);
    }
    else if (sort_func == "descendingTypeMix")
    {
        filelist->setSortFunc(filelist->descendingTypeMix);
    }
    else if (sort_func == "ascendingExt")
    {
        filelist->setSortFunc(filelist->ascendingExt);
    }
    else if (sort_func == "ascendingExtMix")
    {
        filelist->setSortFunc(filelist->ascendingExtMix);
    }
    else if (sort_func == "descendingExt")
    {
        filelist->setSortFunc(filelist->descendingExt);
    }
    else if (sort_func == "descendingExtMix")
    {
        filelist->setSortFunc(filelist->descendingExtMix);
    }
    else if (sort_func == "ascendingTime")
    {
        filelist->setSortFunc(filelist->ascendingTime);
    }
    else if (sort_func == "ascendingTimeMix")
    {
        filelist->setSortFunc(filelist->ascendingTimeMix);
    }
    else if (sort_func == "descendingTime")
    {
        filelist->setSortFunc(filelist->descendingTime);
    }
    else if (sort_func == "descendingTimeMix")
    {
        filelist->setSortFunc(filelist->descendingTimeMix);
    }
    else if (sort_func == "ascendingUser")
    {
        filelist->setSortFunc(filelist->ascendingUser);
    }
    else if (sort_func == "ascendingUserMix")
    {
        filelist->setSortFunc(filelist->ascendingUserMix);
    }
    else if (sort_func == "descendingUser")
    {
        filelist->setSortFunc(filelist->descendingUser);
    }
    else if (sort_func == "descendingUserMix")
    {
        filelist->setSortFunc(filelist->descendingUserMix);
    }
    else if (sort_func == "ascendingGroup")
    {
        filelist->setSortFunc(filelist->ascendingGroup);
    }
    else if (sort_func == "ascendingGroupMix")
    {
        filelist->setSortFunc(filelist->ascendingGroupMix);
    }
    else if (sort_func == "descendingGroup")
    {
        filelist->setSortFunc(filelist->descendingGroup);
    }
    else if (sort_func == "descendingGroupMix")
    {
        filelist->setSortFunc(filelist->descendingGroupMix);
    }
    else if (sort_func == "ascendingPerm")
    {
        filelist->setSortFunc(filelist->ascendingPerm);
    }
    else if (sort_func == "ascendingPermMix")
    {
        filelist->setSortFunc(filelist->ascendingPermMix);
    }
    else if (sort_func == "descendingPerm")
    {
        filelist->setSortFunc(filelist->descendingPerm);
    }
    else if (sort_func == "descendingPermMix")
    {
        filelist->setSortFunc(filelist->descendingPermMix);
    }

    // Single click navigation
    if (single_click == SINGLE_CLICK_DIR_FILE)
    {
        filelist->setDefaultCursor(getApp()->getDefaultCursor(DEF_HAND_CURSOR));
    }

    // Status bar buttons
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");
    // new FXToggleButton(statusbar, TAB+_("Show hidden files")+PARS(key), TAB+_("Hide hidden files")+PARS(key), showhiddenicon, hidehiddenicon, this->filelist,
    //                    FileList::ID_TOGGLE_HIDDEN, BUTTON_TOOLBAR|LAYOUT_LEFT|ICON_BEFORE_TEXT);

    // key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");
    // new FXToggleButton(statusbar, TAB+_("Show thumbnails")+PARS(key), TAB+_("Hide thumbnails")+PARS(key), showthumbicon, hidethumbicon, this->filelist,
    //                    FileList::ID_TOGGLE_THUMBNAILS, BUTTON_TOOLBAR|LAYOUT_LEFT|ICON_BEFORE_TEXT);

    new FXStatusBar(statusbar, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|FRAME_SUNKEN);
    new FXDragCorner(statusbar);

    // Toolbar button: Open file
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "open", "Ctrl-O");
    new FXButton(toolbar, TAB+_("Open")+PARS(key)+TAB+_("Open image file.")+PARS(key), fileopenicon, this, ID_OPEN, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Toolbar button: Print
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "print", "Ctrl-P");
    new FXButton(toolbar, TAB+_("Print")+PARS(key)+TAB+_("Print image file.")+PARS(key), printicon, this, ID_PRINT, BUTTON_TOOLBAR|FRAME_RAISED);

    // Separator
    toolbarSeparator(toolbar);

    // Note : Ctrl+ and Ctrl- cannot be changed from the registry!

    // Toolbar button: Zoom in
    btn = new FXButton(toolbar, TAB+_("Zoom in")+PARS("Ctrl+")+TAB+_("Zoom in image.")+PARS("Ctrl+"), zoominicon, this, ID_ZOOM_IN, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);
    hotkey = (CONTROLMASK<<16) |  KEY_KP_Add;
    btn->addHotKey(hotkey);

    // Toolbar button: Zoom out
    btn = new FXButton(toolbar, TAB+_("Zoom out")+PARS("Ctrl-")+TAB+_("Zoom out image.")+PARS("Ctrl-"), zoomouticon, this, ID_ZOOM_OUT, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);
    hotkey = (CONTROLMASK<<16) | KEY_KP_Subtract;
    btn->addHotKey(hotkey);

    // Toolbar button: Zoom 100%
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_100", "Ctrl-I");
    new FXButton(toolbar, TAB+_("Zoom 100%")+PARS(key)+TAB+_("Zoom image to 100%.")+PARS(key), zoom100icon, this, ID_ZOOM_100, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Toolbar button: Zoom to fit window
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_win", "Ctrl-F");
    new FXButton(toolbar, TAB+_("Zoom to fit")+PARS(key)+TAB+_("Zoom to fit window.")+PARS(key), zoomwinicon, this, ID_ZOOM_WIN, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Separator
    toolbarSeparator(toolbar);

    // Toolbar button: Rotate left
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_left", "Ctrl-L");
    new FXButton(toolbar, TAB+_("Rotate left")+PARS(key)+TAB+_("Rotate left image.")+PARS(key), rotatelefticon, this, ID_ROTATE_90, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Toolbar button: Rotate right
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_right", "Ctrl-R");
    new FXButton(toolbar, TAB+_("Rotate right")+PARS(key)+TAB+_("Rotate right image.")+PARS(key), rotaterighticon, this, ID_ROTATE_270, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Toolbar button: mirror horizontally
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_horizontally", "Ctrl-Shift-H");
    new FXButton(toolbar, TAB+_("Mirror horizontally")+PARS(key)+TAB+_("Mirror image horizontally.")+PARS(key), fliplricon, this, ID_MIRROR_HOR, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // Toolbar button: mirror vertically
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_vertically", "Ctrl-Shift-V");
    new FXButton(toolbar, TAB+_("Mirror vertically")+PARS(key)+TAB+_("Mirror image vertically.")+PARS(key), flipudicon, this, ID_MIRROR_VER, ICON_ABOVE_TEXT|BUTTON_TOOLBAR|FRAME_RAISED);

    // File Menu entries
    FXMenuCommand* mc = NULL;
    FXString       text;

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "open", "Ctrl-O");
    text = _("&Open...")+TABS(key)+_("Open image file.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, fileopenicon, this, ID_OPEN);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "print", "Ctrl-P");
    text = _("&Print...")+TABS(key)+_("Print image file.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, printicon, this, ID_PRINT);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    // Recent file menu; this automatically hides if there are no files
    FXMenuSeparator* sep1 = new FXMenuSeparator(filemenu);
    sep1->setTarget(&mrufiles);
    sep1->setSelector(FXRecentFiles::ID_ANYFILES);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_1);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_2);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_3);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_4);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_5);
    new FXMenuCommand(filemenu, _("&Clear recent files")+TAB2+_("Clear recent file menu."), NULL, &mrufiles, FXRecentFiles::ID_CLEAR);
    FXMenuSeparator* sep2 = new FXMenuSeparator(filemenu);
    sep2->setTarget(&mrufiles);
    sep2->setSelector(FXRecentFiles::ID_ANYFILES);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "quit", "Ctrl-Q");
    text = _("&Quit")+TABS(key)+_("Quit Xfi.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, quiticon, this, ID_QUIT);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));
    getAccelTable()->addAccel(KEY_Escape, this, FXSEL(SEL_COMMAND, ID_QUIT));

    // Image Menu entries
    new FXMenuCommand(imagemenu, _("Zoom &in")+TAB+(FXString)"Ctrl+"+TAB+_("Zoom in image.")+PARS("Ctrl+"), zoominicon, this, ID_ZOOM_IN);
    new FXMenuCommand(imagemenu, _("Zoom &out")+TAB+(FXString)"Ctrl-"+TAB+_("Zoom out image.")+PARS("Ctrl-"), zoomouticon, this, ID_ZOOM_OUT);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_100", "Ctrl-I");
    text = _("Zoo&m 100%")+TABS(key)+_("Zoom image to 100%.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, zoom100icon, this, ID_ZOOM_100);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_win", "Ctrl-F");
    text = _("Zoom to fit &window")+TABS(key)+_("Zoom to fit window.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, zoomwinicon, this, ID_ZOOM_WIN);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_right", "Ctrl-R");
    text = _("Rotate &right")+TABS(key)+_("Rotate right.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, rotaterighticon, this, ID_ROTATE_270);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_left", "Ctrl-L");
    text = _("Rotate &left")+TABS(key)+_("Rotate left.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, rotatelefticon, this, ID_ROTATE_90);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_horizontally", "Ctrl-Shift-H");
    text = _("Mirror &horizontally")+TABS(key)+_("Mirror horizontally.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, fliplricon, this, ID_MIRROR_HOR);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_vertically", "Ctrl-Shift-V");
    text = _("Mirror &vertically")+TABS(key)+_("Mirror vertically.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, flipudicon, this, ID_MIRROR_VER);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    // View Menu entries
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");
    text = _("&Hidden files")+TABS(key)+_("Show hidden files and folders.")+PARS(key);
    mc = new FXMenuCheck(viewmenu, text, this, ID_TOGGLE_HIDDEN);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");
    text = _("&Thumbnails")+TABS(key)+_("Show image thumbnails.")+PARS(key);
    mc = new FXMenuCheck(viewmenu, text, this, ID_TOGGLE_THUMBNAILS);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuSeparator(viewmenu);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "big_icons", "F10");
    text = _("&Big icons")+TABS(key)+_("Display folders with big icons.")+PARS(key);
    mc = new FXMenuRadio(viewmenu, text, this, ID_SHOW_BIG_ICONS);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "small_icons", "F11");
    text = _("&Small icons")+TABS(key)+_("Display folders with small icons.")+PARS(key);
    mc = new FXMenuRadio(viewmenu, text, this, ID_SHOW_MINI_ICONS);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "detailed_file_list", "F12");
    text = _("&Detailed file list")+TABS(key)+_("Display detailed folder listing.")+PARS(key);
    mc = new FXMenuRadio(viewmenu, text, this, ID_SHOW_DETAILS);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuSeparator(viewmenu);

    mc = new FXMenuRadio(viewmenu, _("&Vertical panels"), this, XFileImage::ID_VERT_PANELS);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "vert_panels", "Ctrl-Shift-F1");
    mc->setAccelText(key);

    mc = new FXMenuRadio(viewmenu, _("&Horizontal panels"), this, XFileImage::ID_HORZ_PANELS);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "horz_panels", "Ctrl-Shift-F2");
    mc->setAccelText(key);

    new FXMenuSeparator(viewmenu);
    new FXMenuRadio(viewmenu, _("&Rows")+TAB2+_("View icons row-wise."), filelist, FileList::ID_ARRANGE_BY_ROWS);
    new FXMenuRadio(viewmenu, _("&Columns")+TAB2+_("View icons column-wise."), filelist, FileList::ID_ARRANGE_BY_COLUMNS);
    new FXMenuCheck(viewmenu, _("&Autosize")+TAB2+_("Autosize icon names."), filelist, FileList::ID_AUTOSIZE);

    // Preferences menu
    new FXMenuCheck(prefsmenu, _("&Toolbar")+TAB2+_("Display toolbar."), toolbar, FXWindow::ID_TOGGLESHOWN);
    new FXMenuCheck(prefsmenu, _("&File list")+TAB2+_("Display file list."), filebox, FXWindow::ID_TOGGLESHOWN);
    new FXMenuCheck(prefsmenu, _("File list &before")+TAB2+_("Display file list before image window."), this, ID_TOGGLE_FILELIST_BEFORE);
    new FXMenuCheck(prefsmenu, _("&Filter images")+TAB2+_("List only image files."), this, ID_TOGGLE_FILTER_IMAGES);
    new FXMenuCheck(prefsmenu, _("Fit &window when opening")+TAB2+_("Zoom to fit window when opening an image."), this, ID_TOGGLE_FIT_WIN);


    // Help Menu entries
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "help", "F1");
    text = _("&About X File Image")+TABS(key)+_("About X File Image.")+PARS(key);
    mc = new FXMenuCommand(helpmenu, text, NULL, this, ID_ABOUT, 0);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    // Close accelerator
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "close", "Ctrl-W");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, this, FXSEL(SEL_COMMAND, XFileImage::ID_QUIT));

    // Make a tool tip
    new FXToolTip(getApp(), TOOLTIP_NORMAL);

    // Images
    img = NULL;
    tmpimg = NULL;

    // Dialogs
    printdialog = NULL;

    // Recent files
    mrufiles.setTarget(this);
    mrufiles.setSelector(ID_RECENTFILE);

    // Initialize file name
    filename = "";

    // Initialize some flags
    fileview = ID_SHOW_MINI_ICONS;
    hiddenfiles = false;

    // Initialize zoom to 100%
    indZoom = ZOOM_100;
    zoomval = zoomtab[indZoom];
    fitwin = false;
    filterimgs = false;

    // Initialize previous window width / height
    prev_width = getWidth();
    prev_height = getHeight();
}


// Clean up
XFileImage::~XFileImage()
{
    delete toolbar;
    delete menubar;
    delete statusbar;
    delete filemenu;
    delete imagemenu;
    delete helpmenu;
    delete prefsmenu;
    delete viewmenu;
    delete dragshell1;
    delete pathlink;
    delete pathtext;
    delete filelist;
    delete img;
    delete tmpimg;
    delete printdialog;
    delete btnbackhist;
    delete btnforwardhist;
}


long XFileImage::onCmdPopupMenu(FXObject* o, FXSelector s, void* p)
{
    // Popup menu pane
    FXMenuPane menu(this);
    int        x, y;
    FXuint     state;

    getRoot()->getCursorPosition(x, y, state);

    new FXMenuCommand(&menu, _("Go ho&me"), homeicon, this, ID_GO_HOME);
    new FXMenuCommand(&menu, _("Go &work"), workicon, this, ID_GO_WORK);
    new FXMenuSeparator(&menu);
    new FXMenuCheck(&menu, _("&Hidden files"), this, ID_TOGGLE_HIDDEN);
    new FXMenuCheck(&menu, _("Thum&bnails"), this, ID_TOGGLE_THUMBNAILS);
    new FXMenuSeparator(&menu);
    new FXMenuRadio(&menu, _("B&ig icons"), this, ID_SHOW_BIG_ICONS);
    new FXMenuRadio(&menu, _("&Small icons"), this, ID_SHOW_MINI_ICONS);
    new FXMenuRadio(&menu, _("Fu&ll file list"), this, ID_SHOW_DETAILS);
    new FXMenuSeparator(&menu);
    new FXMenuRadio(&menu, _("&Rows"), filelist, FileList::ID_ARRANGE_BY_ROWS);
    new FXMenuRadio(&menu, _("&Columns"), filelist, FileList::ID_ARRANGE_BY_COLUMNS);
    new FXMenuCheck(&menu, _("Autosize"), filelist, FileList::ID_AUTOSIZE);
    new FXMenuSeparator(&menu);
    new FXMenuRadio(&menu, _("&Name"), filelist, FileList::ID_SORT_BY_NAME);
    new FXMenuRadio(&menu, _("Si&ze"), filelist, FileList::ID_SORT_BY_SIZE);
    new FXMenuRadio(&menu, _("&Type"), filelist, FileList::ID_SORT_BY_TYPE);
    new FXMenuRadio(&menu, _("E&xtension"), filelist, FileList::ID_SORT_BY_EXT);
    new FXMenuRadio(&menu, _("&Date"), filelist, FileList::ID_SORT_BY_TIME);
    new FXMenuRadio(&menu, _("&User"), filelist, FileList::ID_SORT_BY_USER);
    new FXMenuRadio(&menu, _("&Group"), filelist, FileList::ID_SORT_BY_GROUP);
    new FXMenuRadio(&menu, _("&Permissions"), filelist, FileList::ID_SORT_BY_PERM);
    new FXMenuSeparator(&menu);
    new FXMenuCheck(&menu, _("Ignore c&ase"), filelist, FileList::ID_SORT_CASE);
    new FXMenuCheck(&menu, _("Fold&ers first"), filelist, FileList::ID_DIRS_FIRST);
    new FXMenuCheck(&menu, _("Re&verse order"), filelist, FileList::ID_SORT_REVERSE);

    menu.create();
    allowPopupScroll = true;  // Allow keyboard scrolling
    menu.popup(NULL, x, y);
    getApp()->runModalWhileShown(&menu);
    allowPopupScroll = false;
    return(1);
}


// If Shift-F10 or Menu is pressed, opens the popup menu
long XFileImage::onKeyPress(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    // Shift-F10 or Menu was pressed : open popup menu
   	if ((event->state&SHIFTMASK && event->code == KEY_F10) || event->code == KEY_Menu)
    {
        this->handle(sender, FXSEL(SEL_COMMAND, XFileImage::ID_POPUP_MENU), ptr);
        return(1);
    }

    // Any other key was pressed : handle the pressed key in the usual way
    else
    {
        if (FXTopWindow::onKeyPress(sender, sel, ptr))
        {
            return(1);
        }
    }

    return(0);
}


long XFileImage::onKeyRelease(FXObject* sender, FXSelector sel, void* ptr)
{
    if (FXTopWindow::onKeyRelease(sender, sel, ptr))
    {
        return(1);
    }

    return(0);
}


// User clicked up directory button
long XFileImage::onCmdDirUp(FXObject*, FXSelector, void*)
{
    filelist->setDirectory(FXPath::upLevel(filelist->getDirectory()));
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());

    filelist->setFocus();

    return(1);
}


// Can we still go up
long XFileImage::onUpdDirUp(FXObject* sender, FXSelector, void*)
{
    if (FXPath::isTopDirectory(filelist->getDirectory()))
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), NULL);
    }
    return(1);
}


// Directory back
long XFileImage::onCmdDirBack(FXObject*, FXSelector s, void* p)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;
    forwardhist = filelist->forwardhist;

    // Get the previous directory
    item = backhist->getFirst();
    if (item)
    {
        pathname = backhist->getString(item);
    }

    // Update the history
    backhist->removeFirstItem();
    forwardhist->insertFirstItem(filelist->getDirectory());

    // Go to to the previous directory
    filelist->setDirectory(pathname, false);
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());

    filelist->setFocus();

    return(1);
}


// Update directory back
long XFileImage::onUpdDirBack(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;

    // Gray out the button if no item in history
    if (backhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory forward
long XFileImage::onCmdDirForward(FXObject*, FXSelector s, void* p)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;
    forwardhist = filelist->forwardhist;

    // Get the next directory
    item = forwardhist->getFirst();
    if (item)
    {
        pathname = forwardhist->getString(item);
    }

    // Update the history
    forwardhist->removeFirstItem();
    backhist->insertFirstItem(filelist->getDirectory());

    // Go to to the previous directory
    filelist->setDirectory(pathname, false);
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());

    filelist->setFocus();

    return(1);
}


// Update directory forward
long XFileImage::onUpdDirForward(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* forwardhist;
    FXString    pathname;

    // Get the filelist history
    forwardhist = filelist->forwardhist;

    // Gray out the button if no item in history
    if (forwardhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory back history
long XFileImage::onCmdDirBackHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;
    forwardhist = filelist->forwardhist;

    // Get all string items and display them in a list box
    int num = backhist->getNumItems();
    if (num > 0)
    {
        FXString* dirs = new FXString[num];
        FXString  strlist = "";

        // Get string items
        item = backhist->getFirst();
        for (int i = 0; i <= num-1; i++)
        {
            if (item)
            {
                FXString str = backhist->getString(item);
                dirs[i] = str;
                strlist = strlist+str+"\n";
                item = backhist->getNext(item);
            }
        }

        // Display list box
        int pos = DirHistBox::box(btnbackhist, DECOR_NONE, strlist, this->getX()+245, this->getY()+37);

        // If an item was selected
        if (pos != -1)
        {
            // Update back history
            if (pos == num-1)
            {
                backhist->removeAllItems();
            }
            else
            {
                item = backhist->getItemAtPos(pos+1);
                backhist->removeAllItemsBefore(item);
            }

            // Update forward history
            forwardhist->insertFirstItem(filelist->getDirectory());
            if (pos > 0)
            {
                for (int i = 0; i <= pos-1; i++)
                {
                    forwardhist->insertFirstItem(dirs[i]);
                }
            }

            // Go to to the selected directory
            pathname = dirs[pos];
            filelist->setDirectory(pathname, false);
            pathlink->setPath(filelist->getDirectory());
            pathtext->setText(filelist->getDirectory());
        }
        delete[]dirs;
    }

    return(1);
}


// Update directory back
long XFileImage::onUpdDirBackHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;

    // Gray out the button if no item in history
    if (backhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory forward history
long XFileImage::onCmdDirForwardHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;
    forwardhist = filelist->forwardhist;

    // Get all string items and display them in a list box
    int num = forwardhist->getNumItems();
    if (num > 0)
    {
        FXString* dirs = new FXString[num];
        FXString  strlist = "";

        // Get string items
        item = forwardhist->getFirst();
        for (int i = 0; i <= num-1; i++)
        {
            if (item)
            {
                FXString str = forwardhist->getString(item);
                dirs[i] = str;
                strlist = strlist+str+"\n";
                item = forwardhist->getNext(item);
            }
        }

        // Display list box
        int pos = DirHistBox::box(btnforwardhist, DECOR_NONE, strlist, this->getX()+285, this->getY()+37);

        // If an item was selected
        if (pos != -1)
        {
            // Update forward history
            if (pos == num-1)
            {
                forwardhist->removeAllItems();
            }
            else
            {
                item = forwardhist->getItemAtPos(pos+1);
                forwardhist->removeAllItemsBefore(item);
            }

            // Update back history
            backhist->insertFirstItem(filelist->getDirectory());
            if (pos > 0)
            {
                for (int i = 0; i <= pos-1; i++)
                {
                    backhist->insertFirstItem(dirs[i]);
                }
            }

            // Go to to the selected directory
            pathname = dirs[pos];
            filelist->setDirectory(pathname, false);
            pathlink->setPath(filelist->getDirectory());
            pathtext->setText(filelist->getDirectory());
        }
        delete[]dirs;
    }

    return(1);
}


// Update directory forward
long XFileImage::onUpdDirForwardHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* forwardhist;
    FXString    pathname;

    // Get the filelist history
    forwardhist = filelist->forwardhist;

    // Gray out the button if no item in history
    if (forwardhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Back to home directory
long XFileImage::onCmdHome(FXObject*, FXSelector, void*)
{
    filelist->setDirectory(FXSystem::getHomeDirectory());
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());
    filelist->setFocus();
    return(1);
}


// Back to current working directory
long XFileImage::onCmdWork(FXObject*, FXSelector, void*)
{
    filelist->setDirectory(FXSystem::getCurrentDirectory());
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());
    filelist->setFocus();
    return(1);
}


// About box
long XFileImage::onCmdAbout(FXObject*, FXSelector, void*)
{
    FXString msg;

    msg.format(_("X File Image Version %s is a simple image viewer.\n\n"), VERSION);
    msg += COPYRIGHT;
    MessageBox about(this, _("About X File Image"), msg.text(), xfiicon, BOX_OK|DECOR_TITLE|DECOR_BORDER,
                     JUSTIFY_CENTER_X|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    about.execute(PLACEMENT_OWNER);

    filelist->setFocus();

    return(1);
}


// Load file
FXbool XFileImage::loadimage(const FXString& file)
{
    FXString ext = FXPath::extension(file);

    FILE* fp = fopen(file.text(), "r");

    if (!fp)
    {
        MessageBox::error(this, BOX_OK, _("Error Loading File"), _("Unable to open file: %s"), file.text());
        return(false);
    }
    else
    {
        fclose(fp);
    }

    // Free old image if any, before loading a new one
    if (img)
    {
        delete img;
        img = NULL;
    }
    if (tmpimg)
    {
        delete tmpimg;
        tmpimg = NULL;
    }

    if (comparecase(ext, "gif") == 0)
    {
        img = new FXGIFImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXGIFImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "bmp") == 0)
    {
        img = new FXBMPImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXBMPImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "xpm") == 0)
    {
        img = new FXXPMImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXXPMImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "pcx") == 0)
    {
        img = new FXPCXImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXPCXImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if ((comparecase(ext, "ico") == 0) || (comparecase(ext, "cur") == 0))
    {
        img = new FXICOImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXICOImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "tga") == 0)
    {
        img = new FXTGAImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXTGAImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "rgb") == 0)
    {
        img = new FXRGBImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "xbm") == 0)
    {
        img = new FXXBMImage(getApp(), NULL, NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXXBMImage(getApp(), NULL, NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "ppm") == 0)
    {
        img = new FXPPMImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXPPMImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "png") == 0)
    {
        img = new FXPNGImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXPNGImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if ((comparecase(ext, "jpg") == 0) || (comparecase(ext, "jpeg") == 0))
    {
        img = new FXJPGImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXJPGImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if ((comparecase(ext, "tif") == 0) || (comparecase(ext, "tiff") == 0))
    {
        img = new FXTIFImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXTIFImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else
    {
        img = NULL;
        tmpimg = NULL;
    }

    // Perhaps failed
    if (img == NULL)
    {
        MessageBox::error(this, BOX_OK, _("Error Loading Image"), _("Unsupported type: %s"), ext.text());
        return(false);
    }

    if (tmpimg == NULL)
    {
        MessageBox::error(this, BOX_OK, _("Error Loading Image"), _("Unsupported type: %s"), ext.text());
        return(false);
    }

    // Load it
    FXFileStream stream;
    if (stream.open(file, FXStreamLoad))
    {
        getApp()->beginWaitCursor();
        FXbool res = img->loadPixels(stream);

        stream.close();

        // If failed
        if (!res)
        {
            MessageBox::error(this, BOX_OK, _("Error Loading Image"), _("Unable to load image, the file may be corrupted"));
            getApp()->endWaitCursor();
            return(false);
        }

        if (!FXMEMDUP(&tmpdata, img->getData(), FXColor, img->getWidth()*img->getHeight()))
        {
            throw FXMemoryException(_("Unable to load image"));
        }
        tmpimg->setData(tmpdata, IMAGE_OWNED, img->getWidth(), img->getHeight());

        img->create();
        tmpimg->create();

        imageview->setImage(tmpimg);

        // Initial zoom and image format
        indZoom = ZOOM_100;
        zoomval = zoomtab[indZoom];
        getApp()->endWaitCursor();

        // Zoom to fit window if asked
        if (fitwin)
        {
            handle(this, FXSEL(SEL_COMMAND, ID_ZOOM_WIN), NULL);
        }
    }
    filelist->setDirectory(FXPath::directory(file));
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());

    return(true);
}


// Toggle file list before image
long XFileImage::onCmdToggleFileListBefore(FXObject* sender, FXSelector, void*)
{
    filelistbefore = !filelistbefore;

    if (BOX_CLICKED_CANCEL != MessageBox::question(this, BOX_OK_CANCEL, _("Restart"), _("Change will be taken into account after restart.\nRestart X File Image now?")))
    {
        this->handle(this, FXSEL(SEL_COMMAND, XFileImage::ID_RESTART), NULL);
    }

    return(1);
}


// Update file list before image
long XFileImage::onUpdToggleFileListBefore(FXObject* sender, FXSelector, void*)
{
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), NULL);
        if (filelistbefore)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
        }
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), NULL);
    }

    return(1);
}


// Toggle zoom to fit window on startup
long XFileImage::onCmdToggleFitWin(FXObject*, FXSelector, void*)
{
    fitwin = !fitwin;
    filelist->setFocus();
    return(1);
}


// Update toggle wrap mode
long XFileImage::onUpdToggleFitWin(FXObject* sender, FXSelector, void*)
{
    if (fitwin)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


// Toggle filter image files
long XFileImage::onCmdToggleFilterImages(FXObject*, FXSelector, void*)
{
    filterimgs = !filterimgs;
    if (filterimgs)
    {
        filelist->setPattern(imgpatterns);
    }
    else
    {
        filelist->setPattern("*");
    }

    filelist->setFocus();

    return(1);
}


// Update filter image files
long XFileImage::onUpdToggleFilterImages(FXObject* sender, FXSelector, void*)
{
    // Disable menu item if the file list is not shown
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);

        // Update menu item
        if (filterimgs)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
        }
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);

        // Update menu item
        if (filterimgs)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
        }
    }
    return(1);
}


// Open
long XFileImage::onCmdOpen(FXObject*, FXSelector, void*)
{
    FileDialog opendialog(this, _("Open Image"));

    opendialog.setSelectMode(SELECTFILE_EXISTING);
    opendialog.setPatternList(patterns);
    opendialog.setDirectory(filelist->getDirectory());
    if (opendialog.execute())
    {
        filename = opendialog.getFilename();
        filelist->setCurrentFile(filename);
        mrufiles.appendFile(filename);
        loadimage(filename);
    }

    return(1);
}


// Print the text
long XFileImage::onCmdPrint(FXObject*, FXSelector, void*)
{
    // Read the current print command from the registry
    FXString printcommand, command;

    printcommand = getApp()->reg().readStringEntry("OPTIONS", "print_command", "lpr -P printer");

    // Open print dialog filled with the current print command
    int rc = 1;
    if (printdialog == NULL)
    {
        printdialog = new InputDialog(this, printcommand, _("Print command: \n(ex: lpr -P <printer>)"), _("Print"), "", printbigicon);
    }
    printdialog->setText(printcommand);
    printdialog->CursorEnd();
    rc = printdialog->execute(PLACEMENT_CURSOR);
    printcommand = printdialog->getText();

    // If cancel was pressed, exit
    if (!rc)
    {
        return(0);
    }

    // Write the new print command to the registry
    getApp()->reg().writeStringEntry("OPTIONS", "print_command", printcommand.text());

    // Perform the print command
    command = "cat " + filename + " |" + printcommand + " &";
    int ret = system(command.text());
    if (ret < 0)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Can't execute command %s"), command.text());
        return(0);
    }

    return(1);
}


// Handle toggle hidden command
long XFileImage::onCmdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    filelist->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_HIDDEN), ptr);
    filelist->setFocus();

    return(1);
}


// Update toggle hidden command
long XFileImage::onUpdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;

    hiddenfiles = filelist->shownHiddenFiles();

    if (hiddenfiles == true)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);

    // Disable menu item if the file list is not shown
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Handle toggle hidden command
long XFileImage::onCmdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    filelist->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_THUMBNAILS), ptr);
    filelist->setFocus();

    return(1);
}


// Update toggle hidden command
long XFileImage::onUpdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;

    thumbnails = filelist->shownThumbnails();

    if (thumbnails == true)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);

    // Disable menu item if the file list is not shown
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Show mini icons in file list
long XFileImage::onCmdShowMini(FXObject*, FXSelector, void*)
{
    fileview = ID_SHOW_MINI_ICONS;
    filelist->handle(this, FXSEL(SEL_COMMAND, FileList::ID_SHOW_MINI_ICONS), NULL);
    filelist->setFocus();

    return(1);
}


// Show big icons in file list
long XFileImage::onCmdShowBig(FXObject*, FXSelector, void*)
{
    fileview = ID_SHOW_BIG_ICONS;
    filelist->handle(this, FXSEL(SEL_COMMAND, FileList::ID_SHOW_BIG_ICONS), NULL);
    filelist->setFocus();

    return(1);
}


// Show details in file list
long XFileImage::onCmdShowDetails(FXObject*, FXSelector, void*)
{
    fileview = ID_SHOW_DETAILS;
    filelist->handle(this, FXSEL(SEL_COMMAND, FileList::ID_SHOW_DETAILS), NULL);
    filelist->setFocus();

    return(1);
}


// Update filelist
long XFileImage::onUpdFileView(FXObject* sender, FXSelector sel, void* ptr)
{
    // Keep the filebox width / height relative to the window width / height

    // Get the current width and height
    int width = getWidth();
    int height = getHeight();

    // Panel stacked horizontally
    if (vertpanels)
    {
        if (relative_resize && (prev_width != width))
        {
            // File box shown
            if (filebox->shown())
            {
                filebox->setWidth((int)round(filewidth_pct*width));
            }
        }

        // Update the relative width (only if window width is sufficient)
        prev_width = width;
        if (getWidth() > 10)
        {
            filewidth_pct = (double)(filebox->getWidth())/(double)(getWidth());
        }
    }

    // Panel stacked vertically
    else
    {
        if (relative_resize && (prev_height != height))
        {
            // File box shown
            if (filebox->shown())
            {
                filebox->setHeight((int)round(fileheight_pct*height));
            }
        }

        // Update the relative height (only if window height is sufficient)
        prev_height = height;
        if (getHeight() > 10)
        {
            fileheight_pct = (double)(filebox->getHeight())/(double)(getHeight());
        }
    }

    // Update radio buttons
    FXuint msg = FXWindow::ID_UNCHECK;

    switch (FXSELID(sel))
    {
    case ID_SHOW_MINI_ICONS:
        if (fileview == ID_SHOW_MINI_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_BIG_ICONS:
        if (fileview == ID_SHOW_BIG_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_DETAILS:
        if (fileview == ID_SHOW_DETAILS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), NULL);

    // Disable menus items if the file list is not shown
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Harvest the zombies
long XFileImage::onSigHarvest(FXObject*, FXSelector, void*)
{
    while (waitpid(-1, NULL, WNOHANG) > 0)
    {
    }
    return(1);
}


// Quit
long XFileImage::onCmdQuit(FXObject*, FXSelector, void*)
{
    // Save settings
    saveConfig();

    // Quit
    getApp()->exit(EXIT_SUCCESS);
    return(1);
}


// Update title (display image size and actual zoom)
long XFileImage::onUpdTitle(FXObject* sender, FXSelector, void*)
{
    FXString title = "Xfi " + filename;
    FXImage* image = imageview->getImage();

    if (image && (img != NULL))
    {
        title += " (" + FXStringVal(img->getWidth()) + "x" + FXStringVal(img->getHeight()) + " - " + FXStringVal(zoomval*100) + "%" ")";
    }
    sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_SETSTRINGVALUE), (void*)&title);
    return(1);
}


// Open recent file
long XFileImage::onCmdRecentFile(FXObject*, FXSelector, void* ptr)
{
    filename = (char*)ptr;
    filelist->setCurrentFile(filename);
    loadimage(filename);
    return(1);
}


// Double clicked in the file list
long XFileImage::onCmdItemDoubleClicked(FXObject*, FXSelector, void* ptr)
{
    int index = (int)(FXival)ptr;

    if (0 <= index)
    {
        if (filelist->isItemDirectory(index))
        {
            FXString pathname = filelist->getItemPathname(index);

            // Does not have access
            if (!::isReadExecutable(pathname))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _(" Permission to: %s denied."), pathname.text());
                return(0);
            }
            filelist->setDirectory(pathname);
            pathlink->setPath(pathname);
            pathtext->setText(pathname);
        }
        else if (filelist->isItemFile(index))
        {
            filename = filelist->getItemPathname(index);
            mrufiles.appendFile(filename);
            loadimage(filename);
            filelist->setCurrentItem(index);
        }
    }
    return(1);
}


// Single clicked in the file list
long XFileImage::onCmdItemClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    if (single_click != SINGLE_CLICK_NONE)
    {
        // In detailed mode, avoid single click when cursor is not over the first column
        int    x, y;
        FXuint state;
        filelist->getCursorPosition(x, y, state);
        FXbool allow = true;
        if (!(filelist->getListStyle()&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS)) && ((x-filelist->getXPosition()) > filelist->getHeaderSize(0)))
        {
            allow = false;
        }

        int index = (int)(FXival)ptr;
        if (0 <= index)
        {
            if ((single_click != SINGLE_CLICK_NONE) && filelist->isItemDirectory(index) && allow)
            {
                FXString pathname = filelist->getItemPathname(index);

                // Does not have access
                if (!::isReadExecutable(pathname))
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _(" Permission to: %s denied."), pathname.text());
                    return(0);
                }
                filelist->setDirectory(pathname);
                pathlink->setPath(pathname);
                pathtext->setText(pathname);
            }
            else if ((single_click == SINGLE_CLICK_DIR_FILE) && filelist->isItemFile(index) && allow)
            {
                filename = filelist->getItemPathname(index);
                mrufiles.appendFile(filename);
                loadimage(filename);
                filelist->setCurrentItem(index);
            }
        }
    }
    return(1);
}


// Rotate image
long XFileImage::onCmdRotate(FXObject*, FXSelector sel, void*)
{
    getApp()->beginWaitCursor();
    FXImage* image = imageview->getImage();
    switch (FXSELID(sel))
    {
    case ID_ROTATE_90:

        // Rotate the actual image
        image->rotate(90);

        // Need to also rotate the original image only if the actual size is different
        if ((image->getWidth() != img->getWidth()) || (image->getHeight() != img->getHeight()))
        {
            img->rotate(90);
        }
        break;

    case ID_ROTATE_270:

        // Rotate the actual image
        image->rotate(270);

        // Need to also rotate the original image only if the actual size is different
        if ((image->getWidth() != img->getWidth()) || (image->getHeight() != img->getHeight()))
        {
            img->rotate(270);
        }
        break;
    }
    imageview->setImage(image);
    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Update image
long XFileImage::onUpdImage(FXObject* sender, FXSelector, void*)
{
    if (imageview->getImage())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    return(1);
}


// Mirror image
long XFileImage::onCmdMirror(FXObject*, FXSelector sel, void*)
{
    getApp()->beginWaitCursor();
    FXImage* image = imageview->getImage();
    switch (FXSELID(sel))
    {
    case ID_MIRROR_HOR:

        // Mirror the actual image
        image->mirror(true, false);

        // Need to also mirror the original image only if the actual size is different
        if ((image->getWidth() != img->getWidth()) || (image->getHeight() != img->getHeight()))
        {
            img->mirror(true, false);
        }
        break;

    case ID_MIRROR_VER:

        // Mirror the actual image
        image->mirror(false, true);

        // Need to also mirror the original image only if the actual size is different
        if ((image->getWidth() != img->getWidth()) || (image->getHeight() != img->getHeight()))
        {
            img->mirror(false, true);
        }
        break;
    }
    imageview->setImage(image);
    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Zoom in image
long XFileImage::onCmdZoomIn(FXObject*, FXSelector, void*)
{
    getApp()->beginWaitCursor();

    // Copy the original image into the actual one
    if (!FXMEMDUP(&tmpdata, img->getData(), FXColor, img->getWidth()*img->getHeight()))
    {
        throw FXMemoryException(_("Unable to load image"));
    }
    tmpimg->setData(tmpdata, IMAGE_OWNED, img->getWidth(), img->getHeight());

    // Resize the actual image according to the new zoom factor
    indZoom += 1;
    if (indZoom > NB_ZOOM-1)
    {
        indZoom = NB_ZOOM-1;
    }
    int sx = (int)(tmpimg->getWidth()*zoomtab[indZoom]);
    int sy = (int)(tmpimg->getHeight()*zoomtab[indZoom]);

    // Scale only if the actual image size is different
    if (indZoom == ZOOM_100)
    {
        imageview->setImage(img);
    }
    else
    {
        // Maximum zoom allowed
        if ((sx > MAX_IMGSIZE) || (sy > MAX_IMGSIZE))
        {
            indZoom -= 1;
            if (indZoom < 0)
            {
                indZoom = 0;
            }
            sx = (int)(tmpimg->getWidth()*zoomtab[indZoom]);
            sy = (int)(tmpimg->getHeight()*zoomtab[indZoom]);
        }

        // Scale image according to the new zoom factor
        tmpimg->scale(sx, sy, 1);
        imageview->setImage(tmpimg);
    }

    // Set zoom value for window title
    zoomval = zoomtab[indZoom];

    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Zoom out image
long XFileImage::onCmdZoomOut(FXObject*, FXSelector, void*)
{
    getApp()->beginWaitCursor();

    // Copy the original image into the actual one
    if (!FXMEMDUP(&tmpdata, img->getData(), FXColor, img->getWidth()*img->getHeight()))
    {
        throw FXMemoryException(_("Unable to load image"));
    }
    tmpimg->setData(tmpdata, IMAGE_OWNED, img->getWidth(), img->getHeight());

    // Resize the image according to the new zoom factor
    indZoom -= 1;
    if (indZoom < 0)
    {
        indZoom = 0;
    }
    int sx = (int)(tmpimg->getWidth()*zoomtab[indZoom]);
    int sy = (int)(tmpimg->getHeight()*zoomtab[indZoom]);

    // Scale only if the actual image size is different
    if (indZoom == ZOOM_100)
    {
        imageview->setImage(img);
    }
    else
    {
        // Scale image according to the new zoom factor
        tmpimg->scale(sx, sy, 1);
        imageview->setImage(tmpimg);
    }

    // Set zoom value for window title
    zoomval = zoomtab[indZoom];

    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Zoom to 100%
long XFileImage::onCmdZoom100(FXObject*, FXSelector, void*)
{
    getApp()->beginWaitCursor();
    indZoom = ZOOM_100;
    zoomval = zoomtab[indZoom];
    imageview->setImage(img);
    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Zoom to fit window
long XFileImage::onCmdZoomWin(FXObject*, FXSelector, void*)
{
    getApp()->beginWaitCursor();

    // Window and image sizes
    int winw = imageview->getWidth();
    int winh = imageview->getHeight();
    int w = img->getWidth();
    int h = img->getHeight();

    // Compute zoom factor
    double fitwin;
    if (double(w)/double(h) > double(winw)/double(winh))
    {
        fitwin = 0.98*(double)winw/(double)w;
    }
    else
    {
        fitwin = 0.98*(double)winh/(double)h;
    }

    // Find the most approaching predefined zoom
    // This is used in other zoom functions
    for (int k = 0; k < NB_ZOOM; k++)
    {
        if (zoomtab[k] > fitwin)
        {
            indZoom = k-1;
            break;
        }
    }
    if (indZoom < 0)
    {
        indZoom = 0;
    }
    if (indZoom >= NB_ZOOM)
    {
        indZoom = NB_ZOOM-1;
    }

    // Copy the original image into the actual one
    if (!FXMEMDUP(&tmpdata, img->getData(), FXColor, img->getWidth()*img->getHeight()))
    {
        throw FXMemoryException(_("Unable to load image"));
    }
    tmpimg->setData(tmpdata, IMAGE_OWNED, img->getWidth(), img->getHeight());

    // Resize the image according to the new zoom factor
    int sx = (int)(w*fitwin);
    int sy = (int)(h*fitwin);

    // Scale image according to the new zoom factor
    tmpimg->scale(sx, sy, 1);
    imageview->setImage(tmpimg);

    // Set zoom value for window title
    zoomval = fitwin;

    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Restart the application when required
long XFileImage::onCmdRestart(FXObject*, FXSelector, void*)
{
    saveConfig();

    if (fork() == 0) // Child
    {
        execvp("xfi", args);
    }
    else // Parent
    {
        exit(EXIT_SUCCESS);
    }
    return(1);
}


// Start the ball rolling
void XFileImage::start(FXString startimage)
{
    filename = startimage;
    if (filename != "")
    {
        loadimage(filename);
    }
}


// Create and show window
void XFileImage::create()
{
    // Get size and position
    FXuint ww = getApp()->reg().readUnsignedEntry("OPTIONS", "width", DEFAULT_WINDOW_WIDTH);    // Workaround for a possible bug in some WMs
    FXuint hh = getApp()->reg().readUnsignedEntry("OPTIONS", "height", DEFAULT_WINDOW_HEIGHT);  // Workaround for a possible bug in some WMs

    filewidth_pct = getApp()->reg().readRealEntry("OPTIONS", "filewidth_pct", 0.25);
    fileheight_pct = getApp()->reg().readRealEntry("OPTIONS", "fileheight_pct", 0.25);
    FXuint fs = getApp()->reg().readIntEntry("OPTIONS", "filesshown", true);

    filelist->setDirectory(FXSystem::getCurrentDirectory());
    pathlink->setPath(FXSystem::getCurrentDirectory());
    pathtext->setText(FXSystem::getCurrentDirectory());

    // Display or hide path linker and path text
    if (show_pathlink)
    {
        pathtext->hide();
        pathlink->show();
    }
    else
    {
        pathlink->hide();
        pathtext->show();
    }

    // Hide tree if asked for
    if (!fs)
    {
        filebox->hide();
    }

    // Set toolbar status
    if (getApp()->reg().readUnsignedEntry("OPTIONS", "showtoolbar", true) == false)
    {
        toolbar->hide();
    }

    // Set status bar status
    if (getApp()->reg().readUnsignedEntry("OPTIONS", "showstatusbar", true) == false)
    {
        statusbar->hide();
    }

    // Set hidden file status
    hiddenfiles = getApp()->reg().readUnsignedEntry("OPTIONS", "hiddenfiles", 0);
    filelist->showHiddenFiles(hiddenfiles);

    // Set thumbnails status
    thumbnails = getApp()->reg().readUnsignedEntry("OPTIONS", "thumbnails", 0);
    filelist->showThumbnails(thumbnails);

    // Set list style
    liststyle = getApp()->reg().readUnsignedEntry("OPTIONS", "liststyle", _ICONLIST_MINI_ICONS);
    filelist->setListStyle(liststyle|_ICONLIST_BROWSESELECT);

    // Set file view
    fileview = getApp()->reg().readUnsignedEntry("OPTIONS", "fileview", ID_SHOW_MINI_ICONS);
    this->handle(this, FXSEL(SEL_COMMAND, fileview), NULL);

    // Set startup zoom
    fitwin = getApp()->reg().readUnsignedEntry("OPTIONS", "fitwin", 0);

    // Set filter images flag
    filterimgs = getApp()->reg().readUnsignedEntry("OPTIONS", "filterimgs", false);

    // Set position and position window
    if (save_win_pos)
    {
        int xpos = getApp()->reg().readIntEntry("OPTIONS", "xpos", DEFAULT_WINDOW_XPOS);
        int ypos = getApp()->reg().readIntEntry("OPTIONS", "ypos", DEFAULT_WINDOW_YPOS);
        position(xpos, ypos, ww, hh);
    }
    else
    {
        position(getX(), getY(), ww, hh);
    }

    FXMainWindow::create();

    if (filterimgs)
    {
        filelist->setPattern(imgpatterns);
    }

    // Set filebox width or height
    if (vertpanels)
    {
        filebox->setWidth((int)round(filewidth_pct*getWidth()));
    }
    else
    {
        filebox->setHeight((int)round(fileheight_pct*getHeight()));
    }

    // Set focus on file list
    filelist->setFocus();

    show();


#ifdef STARTUP_NOTIFICATION
    startup_completed();
#endif
}


// Switch between vertical and horizontal panels
long XFileImage::onCmdHorzVertPanels(FXObject* sender, FXSelector sel, void* ptr)
{
    switch (FXSELID(sel))
    {
    case ID_VERT_PANELS:
        splitter->setSplitterStyle(splitter->getSplitterStyle()&~SPLITTER_VERTICAL);
        vertpanels = true;
        break;

    case ID_HORZ_PANELS:
        splitter->setSplitterStyle(splitter->getSplitterStyle()|SPLITTER_VERTICAL);
        vertpanels = false;
        break;
    }

    filelist->setFocus();

    return(1);
}


// Update the horizontal / vertical panel radio menus
long XFileImage::onUpdHorzVertPanels(FXObject* sender, FXSelector sel, void* ptr)
{
    sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), ptr);

    if (vertpanels)
    {
        if (FXSELID(sel) == ID_HORZ_PANELS)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_UNCHECK), ptr);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_CHECK), ptr);
        }
    }
    else
    {
        if (FXSELID(sel) == ID_VERT_PANELS)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_UNCHECK), ptr);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_CHECK), ptr);
        }
    }

    return(1);
}


// Save configuration when quitting
void XFileImage::saveConfig()
{
    // Write new window size and position back to registry
    getApp()->reg().writeUnsignedEntry("OPTIONS", "width", (FXuint)getWidth());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "height", (FXuint)getHeight());

    if (save_win_pos)
    {
        // Account for the Window Manager border size
        XWindowAttributes xwattr;
        if (XGetWindowAttributes((Display*)getApp()->getDisplay(), this->id(), &xwattr))
        {
            getApp()->reg().writeIntEntry("OPTIONS", "xpos", getX()-xwattr.x);
            getApp()->reg().writeIntEntry("OPTIONS", "ypos", getY()-xwattr.y);
        }
        else
        {
            getApp()->reg().writeIntEntry("OPTIONS", "xpos", getX());
            getApp()->reg().writeIntEntry("OPTIONS", "ypos", getY());
        }
    }

    // Width and height of filebox
    getApp()->reg().writeRealEntry("OPTIONS", "filewidth_pct", (int)(filewidth_pct*100)/100.0);
    getApp()->reg().writeRealEntry("OPTIONS", "fileheight_pct", (int)(fileheight_pct*100)/100.0);

    // Was filebox shown
    getApp()->reg().writeIntEntry("OPTIONS", "filesshown", filebox->shown());

    // Toolbar status
    if (toolbar->shown())
    {
        getApp()->reg().writeUnsignedEntry("OPTIONS", "showtoolbar", true);
    }
    else
    {
        getApp()->reg().writeUnsignedEntry("OPTIONS", "showtoolbar", false);
    }

    // Hidden files status
    getApp()->reg().writeUnsignedEntry("OPTIONS", "hiddenfiles", hiddenfiles);

    // Thumbnails status
    getApp()->reg().writeUnsignedEntry("OPTIONS", "thumbnails", thumbnails);

    // File view
    getApp()->reg().writeUnsignedEntry("OPTIONS", "fileview", fileview);

    // List style
    getApp()->reg().writeUnsignedEntry("OPTIONS", "liststyle", filelist->getListStyle());

    // Startup zoom
    getApp()->reg().writeUnsignedEntry("OPTIONS", "fitwin", fitwin);

    // Filter images in file list
    getApp()->reg().writeUnsignedEntry("OPTIONS", "filterimgs", filterimgs);

    // Filelist columns sizes
    getApp()->reg().writeUnsignedEntry("OPTIONS", "name_size", filelist->getHeaderSize(0));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "size_size", filelist->getHeaderSize(1));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "type_size", filelist->getHeaderSize(2));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "ext_size", filelist->getHeaderSize(3));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "modd_size", filelist->getHeaderSize(4));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "user_size", filelist->getHeaderSize(5));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "grou_size", filelist->getHeaderSize(6));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "attr_size", filelist->getHeaderSize(7));

    // Panel stacking
    getApp()->reg().writeUnsignedEntry("OPTIONS", "filelist_before", filelistbefore);
    getApp()->reg().writeUnsignedEntry("OPTIONS", "vert_panels", vertpanels);

    // Get and write sort function for search window
    FXString sort_func;
    if (filelist->getSortFunc() == filelist->ascendingCase)
    {
        sort_func = "ascendingCase";
    }
    if (filelist->getSortFunc() == filelist->ascendingCaseMix)
    {
        sort_func = "ascendingCaseMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingCase)
    {
        sort_func = "descendingCase";
    }
    else if (filelist->getSortFunc() == filelist->descendingCaseMix)
    {
        sort_func = "descendingCaseMix";
    }
    else if (filelist->getSortFunc() == filelist->ascending)
    {
        sort_func = "ascending";
    }
    else if (filelist->getSortFunc() == filelist->ascendingMix)
    {
        sort_func = "ascendingMix";
    }
    else if (filelist->getSortFunc() == filelist->descending)
    {
        sort_func = "descending";
    }
    else if (filelist->getSortFunc() == filelist->descendingMix)
    {
        sort_func = "descendingMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingSize)
    {
        sort_func = "ascendingSize";
    }
    else if (filelist->getSortFunc() == filelist->ascendingSizeMix)
    {
        sort_func = "ascendingSizeMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingSize)
    {
        sort_func = "descendingSize";
    }
    else if (filelist->getSortFunc() == filelist->descendingSizeMix)
    {
        sort_func = "descendingSizeMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingType)
    {
        sort_func = "ascendingType";
    }
    else if (filelist->getSortFunc() == filelist->ascendingTypeMix)
    {
        sort_func = "ascendingTypeMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingType)
    {
        sort_func = "descendingType";
    }
    else if (filelist->getSortFunc() == filelist->descendingTypeMix)
    {
        sort_func = "descendingTypeMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingExt)
    {
        sort_func = "ascendingExt";
    }
    else if (filelist->getSortFunc() == filelist->ascendingExtMix)
    {
        sort_func = "ascendingExtMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingExt)
    {
        sort_func = "descendingExt";
    }
    else if (filelist->getSortFunc() == filelist->descendingExtMix)
    {
        sort_func = "descendingExtMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingTime)
    {
        sort_func = "ascendingTime";
    }
    else if (filelist->getSortFunc() == filelist->ascendingTimeMix)
    {
        sort_func = "ascendingTimeMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingTime)
    {
        sort_func = "descendingTime";
    }
    else if (filelist->getSortFunc() == filelist->descendingTimeMix)
    {
        sort_func = "descendingTimeMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingUser)
    {
        sort_func = "ascendingUser";
    }
    else if (filelist->getSortFunc() == filelist->ascendingUserMix)
    {
        sort_func = "ascendingUserMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingUser)
    {
        sort_func = "descendingUser";
    }
    else if (filelist->getSortFunc() == filelist->descendingUserMix)
    {
        sort_func = "descendingUserMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingGroup)
    {
        sort_func = "ascendingGroup";
    }
    else if (filelist->getSortFunc() == filelist->ascendingGroupMix)
    {
        sort_func = "ascendingGroupMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingGroup)
    {
        sort_func = "descendingGroup";
    }
    else if (filelist->getSortFunc() == filelist->descendingGroupMix)
    {
        sort_func = "descendingGroupMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingPerm)
    {
        sort_func = "ascendingPerm";
    }
    else if (filelist->getSortFunc() == filelist->ascendingPermMix)
    {
        sort_func = "ascendingPermMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingPerm)
    {
        sort_func = "descendingPerm";
    }
    else if (filelist->getSortFunc() == filelist->descendingPermMix)
    {
        sort_func = "descendingPermMix";
    }
    else
    {
        sort_func = "ascendingCase";
    }
    getApp()->reg().writeStringEntry("OPTIONS", "sort_func", sort_func.text());

    // Write registry settings
    getApp()->reg().write();
}


// Usage message
#define USAGE_MSG    _("\
\nUsage: xfi [options] [image] \n\
\n\
    [options] can be any of the following:\n\
\n\
        -h, --help         Print (this) help screen and exit.\n\
        -v, --version      Print version information and exit.\n\
\n\
    [image] is the path to the image file you want to open on start up.\n\
\n")



// Start the whole thing
int main(int argc, char* argv[])
{
    int         i;
    FXString    startimage = "";
    const char* appname = "xfi";
    const char* xfename = XFEAPPNAME;
    const char* vdrname = XFEVDRNAME;
    FXbool      loadicons;
    FXString    xmodifiers;

    // Get environment variables $HOME, $XDG_DATA_HOME and $XDG_CONFIG_HOME
    homedir = FXSystem::getHomeDirectory();
    if (homedir == "")
    {
        homedir = ROOTDIR;
    }
    xdgdatahome = getenv("XDG_DATA_HOME");
    if (xdgdatahome == "")
    {
        xdgdatahome = homedir + PATHSEPSTRING DATAPATH;
    }
    xdgconfighome = getenv("XDG_CONFIG_HOME");
    if (xdgconfighome == "")
    {
        xdgconfighome = homedir + PATHSEPSTRING CONFIGPATH;
    }

    // Detect if an X input method is used
    xmodifiers = getenv("XMODIFIERS");
    if ((xmodifiers == "") || (xmodifiers == "@im=none"))
    {
        xim_used = false;
    }
    else
    {
        xim_used = true;
    }

#ifdef HAVE_SETLOCALE
    // Set locale via LC_ALL.
    setlocale(LC_ALL, "");
#endif

#if ENABLE_NLS
    // Set the text message domain.
    bindtextdomain(PACKAGE, LOCALEDIR);
    bind_textdomain_codeset(PACKAGE, "utf-8");
    textdomain(PACKAGE);
#endif

    // Parse basic arguments
    for (i = 1; i < argc; ++i)
    {
        if ((compare(argv[i], "-v") == 0) || (compare(argv[i], "--version") == 0))
        {
            fprintf(stdout, "%s version %s\n", PACKAGE, VERSION);
            exit(EXIT_SUCCESS);
        }
        else if ((compare(argv[i], "-h") == 0) || (compare(argv[i], "--help") == 0))
        {
            fprintf(stdout, USAGE_MSG);
            exit(EXIT_SUCCESS);
        }
        else
        {
            // Start image, if any
            startimage = argv[i];
        }
    }

    args = argv;

    // Make application
    FXApp* application = new FXApp(appname, vdrname);

    // Open display
    application->init(argc, argv);

    // Redefine the default hand cursor
    FXCursor* hand = new FXCursor(application, hand_bits, hand_mask_bits, hand_width, hand_height, hand_x_hot, hand_y_hot);
    application->setDefaultCursor(DEF_HAND_CURSOR, hand);

    // Load all application icons
    loadicons = loadAppIcons(application);

    // Read the Xfe registry
    FXRegistry* reg_xfe = new FXRegistry(xfename, vdrname);
    reg_xfe->read();

    // Set base color (to change the default base color at first run)
    FXColor basecolor = reg_xfe->readColorEntry("SETTINGS", "basecolor", FXRGB(237, 233, 227));
    application->setBaseColor(basecolor);

    // Set Xfi normal font according to the Xfe registry
    FXString fontspec;
    fontspec = reg_xfe->readStringEntry("SETTINGS", "font", DEFAULT_NORMAL_FONT);
    if (!fontspec.empty())
    {
        FXFont* normalFont = new FXFont(application, fontspec);
        normalFont->create();
        application->setNormalFont(normalFont);
    }

    // Set Xfi file list colors according to the Xfe registry
    listbackcolor = reg_xfe->readColorEntry("SETTINGS", "listbackcolor", FXRGB(255, 255, 255));
    listforecolor = reg_xfe->readColorEntry("SETTINGS", "listforecolor", FXRGB(0, 0, 0));
    highlightcolor = reg_xfe->readColorEntry("SETTINGS", "highlightcolor", FXRGB(238, 238, 238));

    // Set single click navigation according to the Xfe registry
    single_click = reg_xfe->readUnsignedEntry("SETTINGS", "single_click", SINGLE_CLICK_NONE);

    // Set smooth scrolling according to the Xfe registry
    FXbool smoothscroll = reg_xfe->readUnsignedEntry("SETTINGS", "smooth_scroll", true);

    // Set file list tooltip flag according to the Xfe registry
    file_tooltips = reg_xfe->readUnsignedEntry("SETTINGS", "file_tooltips", true);

    // Set relative resizing flag according to the Xfe registry
    relative_resize = reg_xfe->readUnsignedEntry("SETTINGS", "relative_resize", true);

    // Set display pathlinker flag according to the Xfe registry
    show_pathlink = reg_xfe->readUnsignedEntry("SETTINGS", "show_pathlinker", true);

    // Get value of the window position flag
    save_win_pos = reg_xfe->readUnsignedEntry("SETTINGS", "save_win_pos", false);

    // Delete the Xfe registry
    delete reg_xfe;

    // Make window
    XFileImage* window = new XFileImage(application, smoothscroll);

    // Catch SIGCHLD to harvest zombie child processes
    application->addSignal(SIGCHLD, window, XFileImage::ID_HARVEST, true);

    // Handle interrupt to save stuff nicely
    application->addSignal(SIGINT, window, XFileImage::ID_QUIT);

    // Create it
    application->create();

    // Smooth scrolling
    window->setSmoothScroll(smoothscroll);

    if (!loadicons)
    {
        MessageBox::error(application, BOX_OK, _("Error loading icons"), _("Unable to load some icons. Please check your icons path!"));
    }

    // Tooltips setup time and duration
    application->setTooltipPause(TOOLTIP_PAUSE);
    application->setTooltipTime(TOOLTIP_TIME);

    // Start
    window->start(startimage);

    // Run
    return(application->run());
}
// This code is adapted from 'imageviewer', a demo image viewer found
// in the FOX library and written by Jeroen van der Zijp.

#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGImage.h>
#include <FXJPGImage.h>
#include <FXTIFImage.h>
#include <FXPNGIcon.h>

#include <X11/Xlib.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "startupnotification.h"
#include "FileDialog.h"
#include "InputDialog.h"
#include "DirHistBox.h"
#include "MessageBox.h"
#include "FileList.h"
#include "XFileImage.h"

// Add FOX hacks
#include "foxhacks.cpp"
#include "clearlooks.cpp"

// Global variables
char**   args;
FXColor  listbackcolor, listforecolor;
FXColor  highlightcolor;
FXbool   allowPopupScroll = false;
FXuint   single_click;
FXbool   file_tooltips;
FXbool   relative_resize;
FXbool   show_pathlink;
FXbool   save_win_pos;
FXString homedir;
FXString xdgconfighome;
FXString xdgdatahome;
FXbool   xim_used = false;

// Hand cursor replacement
#define hand_width     32
#define hand_height    32
#define hand_x_hot     6
#define hand_y_hot     1
static const FXuchar hand_bits[] =
{
    0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00,
    0x90, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x90, 0x07, 0x00, 0x00,
    0x97, 0x1a, 0x00, 0x00, 0x99, 0x2a, 0x00, 0x00, 0x11, 0x28, 0x00, 0x00,
    0x12, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00,
    0x04, 0x20, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00,
    0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const FXuchar hand_mask_bits[] =
{
    0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
    0xf0, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00,
    0xf7, 0x1f, 0x00, 0x00, 0xff, 0x3f, 0x00, 0x00, 0xff, 0x3f, 0x00, 0x00,
    0xfe, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00,
    0xfc, 0x3f, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00,
    0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// Predefined zoom factors
#define NB_ZOOM    24
double zoomtab[NB_ZOOM] =
{
    0.01, 0.025, 0.05, 0.075, 0.10, 0.15, 0.20, 0.30, 0.50, 0.75, 1, \
    1.5, 2, 3, 4, 5, 7.5, 10, 15, 20, 30, 50, 75, 100
};
#define ZOOM_100       10

// Maximum image size (in pixels) for zooming in
#define MAX_IMGSIZE    5120

// Patterns for supported image formats
const char* patterns[] =
{
    _("All Files"), "*",
    _("GIF Image"), "*.gif",
    _("BMP Image"), "*.bmp",
    _("XPM Image"), "*.xpm",
    _("PCX Image"), "*.pcx",
    _("ICO Image"), "*.ico",
    _("RGB Image"), "*.rgb",
    _("XBM Image"), "*.xbm",
    _("TARGA Image"), "*.tga",
    _("PPM Image"), "*.ppm",
    _("PNG Image"), "*.png",
    _("JPEG Image"), "*.jpg",
    _("JPEG Image"), "*.jpeg",
    _("TIFF Image"), "*.tif",
    _("TIFF Image"), "*.tiff",
    NULL
};


const FXString imgpatterns = "*.gif,*.bmp,*.xpm,*.pcx,*.ico,*.rgb,*.xbm,*.tga,*.ppm,*.png,*.jpg,*.jpeg,*.tif,*.tiff";

int zoomwin = 0;

// Helper function to draw a toolbar separator
void toolbarSeparator(FXToolBar* tb)
{
#define SEP_SPACE_TB    8
    new FXFrame(tb, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE_TB);
//    new FXVerticalSeparator(tb, LAYOUT_SIDE_TOP|LAYOUT_CENTER_Y|SEPARATOR_GROOVE|LAYOUT_FILL_Y);
//    new FXFrame(tb, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE_TB);
}


// Helper function to draw a separator in an horizontal frame
void hframeSeparator(FXHorizontalFrame* hframe)
{
#define SEP_SPACE_HF    5
    new FXFrame(hframe, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE_HF);
    new FXVerticalSeparator(hframe, LAYOUT_SIDE_TOP|LAYOUT_CENTER_Y|SEPARATOR_GROOVE|LAYOUT_FILL_Y);
    new FXFrame(hframe, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT, 0, 0, SEP_SPACE_HF);
}

#define TBBUTTONSTYLE ICON_ABOVE_TEXT|FRAME_RAISED|FRAME_THICK
#define TBBUTTONPAD 0,0,0,0,1,2,1,1

// Map
FXDEFMAP(XFileImage) XFileImageMap[] =
{
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ABOUT, XFileImage::onCmdAbout),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_OPEN, XFileImage::onCmdOpen),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TITLE, XFileImage::onUpdTitle),
    FXMAPFUNC(SEL_SIGNAL, XFileImage::ID_HARVEST, XFileImage::onSigHarvest),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_QUIT, XFileImage::onCmdQuit),
    FXMAPFUNC(SEL_SIGNAL, XFileImage::ID_QUIT, XFileImage::onCmdQuit),
    FXMAPFUNC(SEL_CLOSE, XFileImage::ID_TITLE, XFileImage::onCmdQuit),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_RESTART, XFileImage::onCmdRestart),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_FILELIST_BEFORE, XFileImage::onCmdToggleFileListBefore),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_HORZ_PANELS, XFileImage::onCmdHorzVertPanels),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_VERT_PANELS, XFileImage::onCmdHorzVertPanels),
    FXMAPFUNC(SEL_DOUBLECLICKED, XFileImage::ID_FILELIST, XFileImage::onCmdItemDoubleClicked),
    FXMAPFUNC(SEL_CLICKED, XFileImage::ID_FILELIST, XFileImage::onCmdItemClicked),
    FXMAPFUNC(SEL_KEYPRESS, 0, XFileImage::onKeyPress),
    FXMAPFUNC(SEL_KEYRELEASE, 0, XFileImage::onKeyRelease),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_RECENTFILE, XFileImage::onCmdRecentFile),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_HIDDEN, XFileImage::onCmdToggleHidden),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_THUMBNAILS, XFileImage::onCmdToggleThumbnails),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_SHOW_DETAILS, XFileImage::onCmdShowDetails),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_SHOW_MINI_ICONS, XFileImage::onCmdShowMini),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_SHOW_BIG_ICONS, XFileImage::onCmdShowBig),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ROTATE_90, XFileImage::onCmdRotate),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ROTATE_270, XFileImage::onCmdRotate),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_MIRROR_HOR, XFileImage::onCmdMirror),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_MIRROR_VER, XFileImage::onCmdMirror),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ZOOM_IN, XFileImage::onCmdZoomIn),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ZOOM_OUT, XFileImage::onCmdZoomOut),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ZOOM_100, XFileImage::onCmdZoom100),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_ZOOM_WIN, XFileImage::onCmdZoomWin),
    FXMAPFUNC(SEL_TIMEOUT, XFileImage::ID_ZOOM_WIN, XFileImage::onCmdZoomWin),
    // FXMAPFUNC(SEL_CONFIGURE, XFileImage::ID_ZOOM_WIN, XFileImage::onConfigureZoomWin),
    FXMAPFUNC(SEL_CONFIGURE, 0, XFileImage::onConfigureZoomWin),
    // FXMAPFUNC(SEL_SIGNAL, 0, XFileImage::onLower),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_PRINT, XFileImage::onCmdPrint),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_UP, XFileImage::onCmdDirUp),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_UP, XFileImage::onUpdDirUp),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_BACK, XFileImage::onCmdDirBack),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_BACK, XFileImage::onUpdDirBack),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_FORWARD, XFileImage::onCmdDirForward),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_FORWARD, XFileImage::onUpdDirForward),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_BACK_HIST, XFileImage::onCmdDirBackHist),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_BACK_HIST, XFileImage::onUpdDirBackHist),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_DIR_FORWARD_HIST, XFileImage::onCmdDirForwardHist),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_DIR_FORWARD_HIST, XFileImage::onUpdDirForwardHist),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_GO_HOME, XFileImage::onCmdHome),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_PRINT, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ROTATE_90, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ROTATE_270, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_MIRROR_HOR, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_MIRROR_VER, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ZOOM_IN, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ZOOM_OUT, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ZOOM_100, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_ZOOM_WIN, XFileImage::onUpdImage),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_SHOW_BIG_ICONS, XFileImage::onUpdFileView),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_SHOW_MINI_ICONS, XFileImage::onUpdFileView),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_SHOW_DETAILS, XFileImage::onUpdFileView),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_HIDDEN, XFileImage::onUpdToggleHidden),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_FILELIST_BEFORE, XFileImage::onUpdToggleFileListBefore),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_THUMBNAILS, XFileImage::onUpdToggleThumbnails),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_FIT_WIN, XFileImage::onCmdToggleFitWin),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_TOGGLE_FILTER_IMAGES, XFileImage::onCmdToggleFilterImages),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_FIT_WIN, XFileImage::onUpdToggleFitWin),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_TOGGLE_FILTER_IMAGES, XFileImage::onUpdToggleFilterImages),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_HORZ_PANELS, XFileImage::onUpdHorzVertPanels),
    FXMAPFUNC(SEL_UPDATE, XFileImage::ID_VERT_PANELS, XFileImage::onUpdHorzVertPanels),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_GO_HOME, XFileImage::onCmdHome),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_GO_WORK, XFileImage::onCmdWork),
    FXMAPFUNC(SEL_RIGHTBUTTONRELEASE, XFileImage::ID_FILELIST, XFileImage::onCmdPopupMenu),
    FXMAPFUNC(SEL_COMMAND, XFileImage::ID_POPUP_MENU, XFileImage::onCmdPopupMenu),

    //FXMAPFUNC(SEL_UPDATE, 0, XFileImage::onUpdStatus),
};


// Object implementation
FXIMPLEMENT(XFileImage, FXMainWindow, XFileImageMap, ARRAYNUMBER(XFileImageMap))

// zoomwin = 0;

// Helper function to draw a horizontal separator
// im a dumbass and didnt realize fxhorizontalseparator is a thing

/* static void horSeparator(FXToolBar* tb)
{
#define SEP_SPACE    1
    FXHorizontalFrame* sepcont = new FXHorizontalFrame(filebox, LAYOUT_FILL_X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    new FXFrame(tb, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X, 0, 0, 0,0,0,0,0,0);
    new FXVerticalSeparator(tb, LAYOUT_SIDE_TOP|LAYOUT_CENTER_Y|SEPARATOR_GROOVE|LAYOUT_FILL_Y, 0, 0, 0, 0, 1, 2, 2, 2);
    new FXFrame(tb, LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FIX_WIDTH, 0, 0, SEP_SPACE,0,0,0,0,0);
}*/


/* int onTop(int argc, char* argv[]) {
    Display *display;
    // Window window_id;

    // Connect to the X server
    display = XOpenDisplay(NULL);
    if (display == NULL) {
        fprintf(stderr, "Cannot open display\n");
        return 1;
    }

    // Window ID to be raised (replace with your target window ID)
    window_id = 0x01234567;  // Example window ID

    // Raise the window to the top
    XRaiseWindow(display, window_id);

    // Flush the request to the X server
    XFlush(display);

    // Close the display connection
    XCloseDisplay(display);

    return 0;
} */


// Make some windows
XFileImage::XFileImage(FXApp* a, FXbool smoothscroll) : FXMainWindow(a, "Xfi ", NULL, NULL, DECOR_ALL)
{
    setIcon(xfiicon);

    FXButton* btn = NULL;
    FXHotKey  hotkey;
    FXString  key;

    setTarget(this);
    setSelector(ID_TITLE);

    // Make menu bar
    menubar = new FXMenuBar(this, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X,0,0,0,0,0,0,0,0,0,0);

    //new FXFrame(this, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FIX_HEIGHT, 0, 0, 0, 1, 0, 0, 0, 0);
    //new FXHorizontalSeparator(this, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|SEPARATOR_GROOVE|LAYOUT_FILL_X|LAYOUT_FIX_HEIGHT, 0, 0, 0, 2, 0, 0, 0, 0);
    new FXFrame(this, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FIX_HEIGHT, 0, 0, 0, 1, 0, 0, 0, 0);


    // Sites where to dock
    //FXDockSite* topdock = new FXDockSite(this, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_SUNKEN);
    FXDockSite* topdock = new FXDockSite(this, LAYOUT_SIDE_TOP|LAYOUT_FILL_X);
    new FXDockSite(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X);
    new FXDockSite(this, LAYOUT_SIDE_LEFT|LAYOUT_FILL_Y);
    new FXDockSite(this, LAYOUT_SIDE_RIGHT|LAYOUT_FILL_Y);

    // New menu bar
    // FXToolBarShell* dragshell0 = new FXToolBarShell(this, FRAME_RAISED);
    // menubar = new FXMenuBar(topdock, dragshell0, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_RAISED);
    // new FXToolBarGrip(menubar, menubar, FXToolBar::ID_TOOLBARGRIP, TOOLBARGRIP_SINGLE);

    // Tool bar
    FXToolBarShell* dragshell1 = new FXToolBarShell(this, FRAME_RAISED);
    //toolbar = new FXToolBar(topdock, dragshell1, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_RAISED);
    toolbarcont = new FXVerticalFrame(this, LAYOUT_FILL_X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    new FXHorizontalSeparator(toolbarcont, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_TOP|SEPARATOR_GROOVE|LAYOUT_FILL_X|LAYOUT_FIX_HEIGHT, 0, 0, 0, 2, 0, 0, 0, 0);
    toolbar = new FXToolBar(toolbarcont, dragshell1, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y,0,0,0,0,0,0,2,3,0,0);
    // new FXToolBarGrip(toolbar, toolbar, FXToolBar::ID_TOOLBARGRIP, TOOLBARGRIP_SINGLE);

    // File menu
    filemenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&File"), NULL, filemenu);

    // View menu
    viewmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&View"), NULL, viewmenu);

    // Image Menu
    imagemenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&Image"), NULL, imagemenu);

    // Options Menu
    prefsmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&Options"), NULL, prefsmenu);

    // Help menu
    helpmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&Help"), NULL, helpmenu);

    // Splitter
    FXVerticalFrame* vframe = new FXVerticalFrame(this, LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // Set order of the file list and image widgets
    filelistbefore = getApp()->reg().readUnsignedEntry("OPTIONS", "filelist_before", false);
    if (filelistbefore)
    {
        splitter = new FXSplitter(vframe, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|SPLITTER_TRACKING|SPLITTER_VERTICAL);
        filebox = new FXVerticalFrame(splitter, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	//FXPacker* imageviewcont2 = new FXPacker(splitter, LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0);
	FXPacker* imageviewcont2 = new FXPacker(splitter, LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	imageviewcontainer = new FXVerticalFrame(imageviewcont2, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_THICK|FRAME_SUNKEN, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        imageview = new FXImageView(imageviewcontainer, NULL, NULL, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    }
    else
    {
        splitter = new FXSplitter(vframe, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|SPLITTER_TRACKING|SPLITTER_VERTICAL|SPLITTER_REVERSED);
	// FXPacker* imageviewcont2 = new FXPacker(splitter, LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0);
	FXPacker* imageviewcont2 = new FXPacker(splitter, LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	imageviewcontainer = new FXVerticalFrame(imageviewcont2, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_THICK|FRAME_SUNKEN, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        imageview = new FXImageView(imageviewcontainer, NULL, NULL, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y);
        filebox = new FXVerticalFrame(splitter, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }

    // Stack panels horizontally or vertically
    vertpanels = getApp()->reg().readUnsignedEntry("OPTIONS", "vert_panels", false);
    if (vertpanels)
    {
        splitter->setSplitterStyle(splitter->getSplitterStyle()&~SPLITTER_VERTICAL);
    }
    else
    {
        splitter->setSplitterStyle(splitter->getSplitterStyle()|SPLITTER_VERTICAL);
    }

    // Container for the action buttons
    FXHorizontalFrame* buttons = new FXHorizontalFrame(filebox, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_RAISED, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0);

    // Container for the path linker
    FXHorizontalFrame* pathframe = new FXHorizontalFrame(filebox, LAYOUT_FILL_X|FRAME_RAISED, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // File list
    FXuint options;
    if (smoothscroll)
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS|_ICONLIST_BROWSESELECT;
    }
    else
    {
        options = LAYOUT_FILL_X|LAYOUT_FILL_Y|_ICONLIST_MINI_ICONS|_ICONLIST_BROWSESELECT|SCROLLERS_DONT_TRACK;
    }

    thumbnails = getApp()->reg().readUnsignedEntry("OPTIONS", "thumbnails", 0);
    filelist = new FileList(this, filebox, this, ID_FILELIST, thumbnails, options);
    filelist->setTextColor(listforecolor);
    filelist->setBackColor(listbackcolor);
    filelist->setHeaderSize(0, getApp()->reg().readUnsignedEntry("OPTIONS", "name_size", 200));
    filelist->setHeaderSize(1, getApp()->reg().readUnsignedEntry("OPTIONS", "size_size", 60));
    filelist->setHeaderSize(2, getApp()->reg().readUnsignedEntry("OPTIONS", "type_size", 100));
    filelist->setHeaderSize(3, getApp()->reg().readUnsignedEntry("OPTIONS", "ext_size", 100));
    filelist->setHeaderSize(4, getApp()->reg().readUnsignedEntry("OPTIONS", "modd_size", 150));
    filelist->setHeaderSize(5, getApp()->reg().readUnsignedEntry("OPTIONS", "user_size", 50));
    filelist->setHeaderSize(6, getApp()->reg().readUnsignedEntry("OPTIONS", "grou_size", 50));
    filelist->setHeaderSize(7, getApp()->reg().readUnsignedEntry("OPTIONS", "attr_size", 100));

    // Action buttons
    new FXFrame(buttons, LAYOUT_FIX_WIDTH, 0, 0, 4, 1);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_back", "Ctrl-Backspace");
    btn = new FXButton(buttons, TAB+_("Go to previous folder")+PARS(key), dirbackicon, this, ID_DIR_BACK, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);
    btnbackhist = new FXArrowButton(buttons, this, ID_DIR_BACK_HIST, LAYOUT_FILL_Y|FRAME_RAISED|FRAME_THICK|ARROW_DOWN|ARROW_TOOLBAR);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_forward", "Shift-Backspace");
    btn = new FXButton(buttons, TAB+_("Go to next folder")+PARS(key), dirforwardicon, this, ID_DIR_FORWARD, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);
    btnforwardhist = new FXArrowButton(buttons, this, ID_DIR_FORWARD_HIST, LAYOUT_FILL_Y|FRAME_RAISED|FRAME_THICK|ARROW_DOWN|ARROW_TOOLBAR);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_up", "Backspace");
    btn = new FXButton(buttons, TAB+_("Go to parent folder")+PARS(key), dirupicon, this, ID_DIR_UP, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Separator
    hframeSeparator(buttons);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_home", "Ctrl-H");
    new FXButton(buttons, TAB+_("Go to home folder")+PARS(key), homeicon, this, ID_GO_HOME, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "go_work", "Shift-F2");
    new FXButton(buttons, TAB+_("Go to working folder")+PARS(key), workicon, this, ID_GO_WORK, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Separator
    hframeSeparator(buttons);

    // Switch display modes
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "big_icons", "F10");
    btn = new FXButton(buttons, TAB+_("Big icon list")+PARS(key), bigiconsicon, this, ID_SHOW_BIG_ICONS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "small_icons", "F11");
    btn = new FXButton(buttons, TAB+_("Small icon list")+PARS(key), smalliconsicon, this, ID_SHOW_MINI_ICONS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "detailed_file_list", "F12");
    btn = new FXButton(buttons, TAB+_("Detailed file list")+PARS(key), detailsicon, this, ID_SHOW_DETAILS, BUTTON_TOOLBAR|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT|FRAME_RAISED);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Separator
    hframeSeparator(buttons);

    // Vertical panels
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "vert_panels", "Ctrl-Shift-F1");
    btn = new FXButton(buttons, TAB+_("Vertical panels")+PARS(key), vertpanelsicon, this, XFileImage::ID_VERT_PANELS, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Horizontal panels
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "horz_panels", "Ctrl-Shift-F2");
    btn = new FXButton(buttons, TAB+_("Horizontal panels")+PARS(key), horzpanelsicon, this, XFileImage::ID_HORZ_PANELS, BUTTON_TOOLBAR|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT|ICON_BEFORE_TEXT);
    hotkey = _parseAccel(key);
    btn->addHotKey(hotkey);

    // Panel title
    pathtext = new TextLabel(pathframe, 0, this, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y);
    pathtext->setBackColor(getApp()->getBaseColor());

    // Path linker
    pathlink = new PathLinker(pathframe, filelist, NULL, LAYOUT_FILL_X);

    // Status bar
    //statusbar = new FXHorizontalFrame(vframe, JUSTIFY_LEFT|LAYOUT_FILL_X, 0, 0, 0, 0, 3, 3, 0, 0);
    FXPacker* statusbarcont = new FXPacker(vframe, LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|LAYOUT_BOTTOM, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0);
    // statusbar = new FXHorizontalFrame(statusbarcont, JUSTIFY_LEFT|LAYOUT_FILL_X, 0, 0, 0, 0, 0, 0, 0, 0);
    statusbar = new FXHorizontalFrame(statusbarcont, FRAME_SUNKEN|LAYOUT_LEFT|JUSTIFY_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_X|LAYOUT_SIDE_LEFT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

    // Read and set sort function for file list
    FXString sort_func = getApp()->reg().readStringEntry("OPTIONS", "sort_func", "ascendingCase");
    if (sort_func == "ascendingCase")
    {
        filelist->setSortFunc(filelist->ascendingCase);
    }
    if (sort_func == "ascendingCaseMix")
    {
        filelist->setSortFunc(filelist->ascendingCaseMix);
    }
    else if (sort_func == "descendingCase")
    {
        filelist->setSortFunc(filelist->descendingCase);
    }
    else if (sort_func == "descendingCaseMix")
    {
        filelist->setSortFunc(filelist->descendingCaseMix);
    }
    else if (sort_func == "ascending")
    {
        filelist->setSortFunc(filelist->ascending);
    }
    else if (sort_func == "ascendingMix")
    {
        filelist->setSortFunc(filelist->ascendingMix);
    }
    else if (sort_func == "descending")
    {
        filelist->setSortFunc(filelist->descending);
    }
    else if (sort_func == "descendingMix")
    {
        filelist->setSortFunc(filelist->descendingMix);
    }
    else if (sort_func == "ascendingSize")
    {
        filelist->setSortFunc(filelist->ascendingSize);
    }
    else if (sort_func == "ascendingSizeMix")
    {
        filelist->setSortFunc(filelist->ascendingSizeMix);
    }
    else if (sort_func == "descendingSize")
    {
        filelist->setSortFunc(filelist->descendingSize);
    }
    else if (sort_func == "descendingSizeMix")
    {
        filelist->setSortFunc(filelist->descendingSizeMix);
    }
    else if (sort_func == "ascendingType")
    {
        filelist->setSortFunc(filelist->ascendingType);
    }
    else if (sort_func == "ascendingTypeMix")
    {
        filelist->setSortFunc(filelist->ascendingTypeMix);
    }
    else if (sort_func == "descendingType")
    {
        filelist->setSortFunc(filelist->descendingType);
    }
    else if (sort_func == "descendingTypeMix")
    {
        filelist->setSortFunc(filelist->descendingTypeMix);
    }
    else if (sort_func == "ascendingExt")
    {
        filelist->setSortFunc(filelist->ascendingExt);
    }
    else if (sort_func == "ascendingExtMix")
    {
        filelist->setSortFunc(filelist->ascendingExtMix);
    }
    else if (sort_func == "descendingExt")
    {
        filelist->setSortFunc(filelist->descendingExt);
    }
    else if (sort_func == "descendingExtMix")
    {
        filelist->setSortFunc(filelist->descendingExtMix);
    }
    else if (sort_func == "ascendingTime")
    {
        filelist->setSortFunc(filelist->ascendingTime);
    }
    else if (sort_func == "ascendingTimeMix")
    {
        filelist->setSortFunc(filelist->ascendingTimeMix);
    }
    else if (sort_func == "descendingTime")
    {
        filelist->setSortFunc(filelist->descendingTime);
    }
    else if (sort_func == "descendingTimeMix")
    {
        filelist->setSortFunc(filelist->descendingTimeMix);
    }
    else if (sort_func == "ascendingUser")
    {
        filelist->setSortFunc(filelist->ascendingUser);
    }
    else if (sort_func == "ascendingUserMix")
    {
        filelist->setSortFunc(filelist->ascendingUserMix);
    }
    else if (sort_func == "descendingUser")
    {
        filelist->setSortFunc(filelist->descendingUser);
    }
    else if (sort_func == "descendingUserMix")
    {
        filelist->setSortFunc(filelist->descendingUserMix);
    }
    else if (sort_func == "ascendingGroup")
    {
        filelist->setSortFunc(filelist->ascendingGroup);
    }
    else if (sort_func == "ascendingGroupMix")
    {
        filelist->setSortFunc(filelist->ascendingGroupMix);
    }
    else if (sort_func == "descendingGroup")
    {
        filelist->setSortFunc(filelist->descendingGroup);
    }
    else if (sort_func == "descendingGroupMix")
    {
        filelist->setSortFunc(filelist->descendingGroupMix);
    }
    else if (sort_func == "ascendingPerm")
    {
        filelist->setSortFunc(filelist->ascendingPerm);
    }
    else if (sort_func == "ascendingPermMix")
    {
        filelist->setSortFunc(filelist->ascendingPermMix);
    }
    else if (sort_func == "descendingPerm")
    {
        filelist->setSortFunc(filelist->descendingPerm);
    }
    else if (sort_func == "descendingPermMix")
    {
        filelist->setSortFunc(filelist->descendingPermMix);
    }

    // Single click navigation
    if (single_click == SINGLE_CLICK_DIR_FILE)
    {
        filelist->setDefaultCursor(getApp()->getDefaultCursor(DEF_HAND_CURSOR));
    }

    // Status bar buttons
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");
    // new FXToggleButton(statusbar, TAB+_("Show hidden files")+PARS(key), TAB+_("Hide hidden files")+PARS(key), showhiddenicon, hidehiddenicon, this->filelist,
    //                    FileList::ID_TOGGLE_HIDDEN, BUTTON_TOOLBAR|LAYOUT_LEFT|ICON_BEFORE_TEXT);

    // key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");
    // new FXToggleButton(statusbar, TAB+_("Show thumbnails")+PARS(key), TAB+_("Hide thumbnails")+PARS(key), showthumbicon, hidethumbicon, this->filelist,
    //                    FileList::ID_TOGGLE_THUMBNAILS, BUTTON_TOOLBAR|LAYOUT_LEFT|ICON_BEFORE_TEXT);

    //new FXStatusBar(statusbar, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|FRAME_SUNKEN);
    //FXLabel* realstatusbar = new FXLabel(statusbar, _("Status"), NULL, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|FRAME_SUNKEN,0,0,0,0,0,0,0,0);
    //FXLabel* realstatusbar = new FXLabel(statusbar, "a", NULL, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|FRAME_SUNKEN,0,0,0,0,0,0,0,0);
    new FXStatusLine(statusbar);
    //ealstatusbar->setTarget(this);
    //realstatusbar->setSelector(FXSEL(SEL_UPDATE, FXWindow::ID_SETHELPSTRING));
//FXSEL(SEL_COMMAND, FXWindow::ID_SETSTRINGVALUE)

    //new FXLabel(statusbar, _("Status"), NULL, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_FILL_X|FRAME_SUNKEN, 0, 0, 0, 0, 1, 0, 0, 0);
    corner = new FXPacker(statusbarcont, JUSTIFY_LEFT|LAYOUT_LEFT|LAYOUT_RIGHT|LAYOUT_FIX_WIDTH|LAYOUT_FIX_HEIGHT|LAYOUT_SIDE_RIGHT|LAYOUT_BOTTOM, 0, 0, 13, 13, 0, 0, 0, 0, 0, 0);
    realcorner = new FXDragCorner(corner);

    toolbarSeparator(toolbar);

    // Toolbar button: Open file
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "open", "Ctrl-O");
    new FXButton(toolbar, TAB+_("Open")+PARS(key)+TAB+_("Open image file.")+PARS(key), fileopenicon, this, ID_OPEN, TBBUTTONSTYLE,TBBUTTONPAD);

    // Toolbar button: Print
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "print", "Ctrl-P");
    new FXButton(toolbar, TAB+_("Print")+PARS(key)+TAB+_("Print image file.")+PARS(key), printicon, this, ID_PRINT, TBBUTTONSTYLE,TBBUTTONPAD);

    // Separator
    toolbarSeparator(toolbar);

    // Note : Ctrl+ and Ctrl- cannot be changed from the registry!

    // Toolbar button: Zoom in
    btn = new FXButton(toolbar, TAB+_("Zoom in")+PARS("Ctrl+")+TAB+_("Zoom in image.")+PARS("Ctrl+"), zoominicon, this, ID_ZOOM_IN, TBBUTTONSTYLE,TBBUTTONPAD);
    hotkey = (CONTROLMASK<<16) |  KEY_KP_Add;
    btn->addHotKey(hotkey);

    // Toolbar button: Zoom out
    btn = new FXButton(toolbar, TAB+_("Zoom out")+PARS("Ctrl-")+TAB+_("Zoom out image.")+PARS("Ctrl-"), zoomouticon, this, ID_ZOOM_OUT, TBBUTTONSTYLE,TBBUTTONPAD);
    hotkey = (CONTROLMASK<<16) | KEY_KP_Subtract;
    btn->addHotKey(hotkey);

    // Toolbar button: Zoom 100%
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_100", "Ctrl-I");
    new FXButton(toolbar, TAB+_("Zoom 100%")+PARS(key)+TAB+_("Zoom image to 100%.")+PARS(key), zoom100icon, this, ID_ZOOM_100, TBBUTTONSTYLE,TBBUTTONPAD);

    // Toolbar button: Zoom to fit window
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_win", "Ctrl-F");
    new FXButton(toolbar, TAB+_("Zoom to fit")+PARS(key)+TAB+_("Zoom to fit window.")+PARS(key), zoomwinicon, this, ID_ZOOM_WIN, TBBUTTONSTYLE,TBBUTTONPAD);

    // Separator
    toolbarSeparator(toolbar);

    // Toolbar button: Rotate left
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_left", "Ctrl-L");
    new FXButton(toolbar, TAB+_("Rotate left")+PARS(key)+TAB+_("Rotate left image.")+PARS(key), rotatelefticon, this, ID_ROTATE_90, TBBUTTONSTYLE,TBBUTTONPAD);

    // Toolbar button: Rotate right
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_right", "Ctrl-R");
    new FXButton(toolbar, TAB+_("Rotate right")+PARS(key)+TAB+_("Rotate right image.")+PARS(key), rotaterighticon, this, ID_ROTATE_270, TBBUTTONSTYLE,TBBUTTONPAD);

    toolbarSeparator(toolbar);

    // Toolbar button: mirror horizontally
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_horizontally", "Ctrl-Shift-H");
    new FXButton(toolbar, TAB+_("Mirror horizontally")+PARS(key)+TAB+_("Mirror image horizontally.")+PARS(key), fliplricon, this, ID_MIRROR_HOR, TBBUTTONSTYLE,TBBUTTONPAD);

    // Toolbar button: mirror vertically
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_vertically", "Ctrl-Shift-V");
    new FXButton(toolbar, TAB+_("Mirror vertically")+PARS(key)+TAB+_("Mirror image vertically.")+PARS(key), flipudicon, this, ID_MIRROR_VER, TBBUTTONSTYLE,TBBUTTONPAD);

    // File Menu entries
    FXMenuCommand* mc = NULL;
    FXString       text;

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "open", "Ctrl-O");
    text = _("&Open...")+TABS(key)+_("Open image file.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, fileopenicon, this, ID_OPEN);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "print", "Ctrl-P");
    text = _("&Print...")+TABS(key)+_("Print image file.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, printicon, this, ID_PRINT);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    // Recent file menu; this automatically hides if there are no files
    FXMenuSeparator* sep1 = new FXMenuSeparator(filemenu);
    sep1->setTarget(&mrufiles);
    sep1->setSelector(FXRecentFiles::ID_ANYFILES);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_1);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_2);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_3);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_4);
    new FXMenuCommand(filemenu, FXString::null, NULL, &mrufiles, FXRecentFiles::ID_FILE_5);
    new FXMenuCommand(filemenu, _("&Clear recent files")+TAB2+_("Clear recent file menu."), NULL, &mrufiles, FXRecentFiles::ID_CLEAR);
    FXMenuSeparator* sep2 = new FXMenuSeparator(filemenu);
    sep2->setTarget(&mrufiles);
    sep2->setSelector(FXRecentFiles::ID_ANYFILES);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "quit", "Ctrl-Q");
    text = _("&Quit")+TABS(key)+_("Quit Xfi.")+PARS(key);
    mc = new FXMenuCommand(filemenu, text, quiticon, this, ID_QUIT);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));
    getAccelTable()->addAccel(KEY_Escape, this, FXSEL(SEL_COMMAND, ID_QUIT));

    // Image Menu entries
    new FXMenuCommand(imagemenu, _("Zoom &in")+TAB+(FXString)"Ctrl+"+TAB+_("Zoom in image.")+PARS("Ctrl+"), zoominicon, this, ID_ZOOM_IN);
    new FXMenuCommand(imagemenu, _("Zoom &out")+TAB+(FXString)"Ctrl-"+TAB+_("Zoom out image.")+PARS("Ctrl-"), zoomouticon, this, ID_ZOOM_OUT);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_100", "Ctrl-I");
    text = _("Zoo&m 100%")+TABS(key)+_("Zoom image to 100%.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, zoom100icon, this, ID_ZOOM_100);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "zoom_win", "Ctrl-F");
    text = _("Zoom to fit &window")+TABS(key)+_("Zoom to fit window.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, zoomwinicon, this, ID_ZOOM_WIN);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_right", "Ctrl-R");
    text = _("Rotate &right")+TABS(key)+_("Rotate right.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, rotaterighticon, this, ID_ROTATE_270);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "rotate_left", "Ctrl-L");
    text = _("Rotate &left")+TABS(key)+_("Rotate left.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, rotatelefticon, this, ID_ROTATE_90);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_horizontally", "Ctrl-Shift-H");
    text = _("Mirror &horizontally")+TABS(key)+_("Mirror horizontally.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, fliplricon, this, ID_MIRROR_HOR);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "mirror_vertically", "Ctrl-Shift-V");
    text = _("Mirror &vertically")+TABS(key)+_("Mirror vertically.")+PARS(key);
    mc = new FXMenuCommand(imagemenu, text, flipudicon, this, ID_MIRROR_VER);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    // View Menu entries
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "hidden_files", "Ctrl-F6");
    text = _("&Hidden files")+TABS(key)+_("Show hidden files and folders.")+PARS(key);
    mc = new FXMenuCheck(viewmenu, text, this, ID_TOGGLE_HIDDEN);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "thumbnails", "Ctrl-F7");
    text = _("&Thumbnails")+TABS(key)+_("Show image thumbnails.")+PARS(key);
    mc = new FXMenuCheck(viewmenu, text, this, ID_TOGGLE_THUMBNAILS);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuSeparator(viewmenu);

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "big_icons", "F10");
    text = _("&Big icons")+TABS(key)+_("Display folders with big icons.")+PARS(key);
    mc = new FXMenuRadio(viewmenu, text, this, ID_SHOW_BIG_ICONS);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "small_icons", "F11");
    text = _("&Small icons")+TABS(key)+_("Display folders with small icons.")+PARS(key);
    mc = new FXMenuRadio(viewmenu, text, this, ID_SHOW_MINI_ICONS);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    key = getApp()->reg().readStringEntry("KEYBINDINGS", "detailed_file_list", "F12");
    text = _("&Detailed file list")+TABS(key)+_("Display detailed folder listing.")+PARS(key);
    mc = new FXMenuRadio(viewmenu, text, this, ID_SHOW_DETAILS);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    new FXMenuSeparator(viewmenu);

    mc = new FXMenuRadio(viewmenu, _("&Vertical panels"), this, XFileImage::ID_VERT_PANELS);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "vert_panels", "Ctrl-Shift-F1");
    mc->setAccelText(key);

    mc = new FXMenuRadio(viewmenu, _("&Horizontal panels"), this, XFileImage::ID_HORZ_PANELS);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "horz_panels", "Ctrl-Shift-F2");
    mc->setAccelText(key);

    new FXMenuSeparator(viewmenu);
    new FXMenuRadio(viewmenu, _("&Rows")+TAB2+_("View icons row-wise."), filelist, FileList::ID_ARRANGE_BY_ROWS);
    new FXMenuRadio(viewmenu, _("&Columns")+TAB2+_("View icons column-wise."), filelist, FileList::ID_ARRANGE_BY_COLUMNS);
    new FXMenuCheck(viewmenu, _("&Autosize")+TAB2+_("Autosize icon names."), filelist, FileList::ID_AUTOSIZE);

    // Preferences menu
    new FXMenuCheck(prefsmenu, _("&Toolbar")+TAB2+_("Display toolbar."), toolbarcont, FXWindow::ID_TOGGLESHOWN);
    new FXMenuCheck(prefsmenu, _("&File list")+TAB2+_("Display file list."), filebox, FXWindow::ID_TOGGLESHOWN);
    new FXMenuCheck(prefsmenu, _("File list &before")+TAB2+_("Display file list before image window."), this, ID_TOGGLE_FILELIST_BEFORE);
    new FXMenuCheck(prefsmenu, _("&Filter images")+TAB2+_("List only image files."), this, ID_TOGGLE_FILTER_IMAGES);
    new FXMenuCheck(prefsmenu, _("Fit &window when opening")+TAB2+_("Zoom to fit window when opening an image."), this, ID_TOGGLE_FIT_WIN);


    // Help Menu entries
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "help", "F1");
    text = _("&About X File Image")+TABS(key)+_("About X File Image.")+PARS(key);
    mc = new FXMenuCommand(helpmenu, text, NULL, this, ID_ABOUT, 0);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    // Close accelerator
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "close", "Ctrl-W");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, this, FXSEL(SEL_COMMAND, XFileImage::ID_QUIT));

    // Make a tool tip
    new FXToolTip(getApp(), TOOLTIP_NORMAL);

    // Images
    img = NULL;
    tmpimg = NULL;

    // Dialogs
    printdialog = NULL;

    // Recent files
    mrufiles.setTarget(this);
    mrufiles.setSelector(ID_RECENTFILE);

    // Initialize file name
    filename = "";

    // Initialize some flags
    fileview = ID_SHOW_MINI_ICONS;
    hiddenfiles = false;

    // Initialize zoom to 100%
    indZoom = ZOOM_100;
    zoomval = zoomtab[indZoom];
    fitwin = false;
    filterimgs = false;

    // Initialize previous window width / height
    prev_width = getWidth();
    prev_height = getHeight();
}


// Clean up
XFileImage::~XFileImage()
{
    delete toolbar;
    delete menubar;
    delete statusbar;
    delete filemenu;
    delete imagemenu;
    delete helpmenu;
    delete prefsmenu;
    delete viewmenu;
    delete dragshell1;
    delete pathlink;
    delete pathtext;
    delete filelist;
    delete img;
    delete tmpimg;
    delete printdialog;
    delete btnbackhist;
    delete btnforwardhist;
}


long XFileImage::onCmdPopupMenu(FXObject* o, FXSelector s, void* p)
{
    // Popup menu pane
    FXMenuPane menu(this);
    int        x, y;
    FXuint     state;

    getRoot()->getCursorPosition(x, y, state);

    new FXMenuCommand(&menu, _("Go ho&me"), homeicon, this, ID_GO_HOME);
    new FXMenuCommand(&menu, _("Go &work"), workicon, this, ID_GO_WORK);
    new FXMenuSeparator(&menu);
    new FXMenuCheck(&menu, _("&Hidden files"), this, ID_TOGGLE_HIDDEN);
    new FXMenuCheck(&menu, _("Thum&bnails"), this, ID_TOGGLE_THUMBNAILS);
    new FXMenuSeparator(&menu);
    new FXMenuRadio(&menu, _("B&ig icons"), this, ID_SHOW_BIG_ICONS);
    new FXMenuRadio(&menu, _("&Small icons"), this, ID_SHOW_MINI_ICONS);
    new FXMenuRadio(&menu, _("Fu&ll file list"), this, ID_SHOW_DETAILS);
    new FXMenuSeparator(&menu);
    new FXMenuRadio(&menu, _("&Rows"), filelist, FileList::ID_ARRANGE_BY_ROWS);
    new FXMenuRadio(&menu, _("&Columns"), filelist, FileList::ID_ARRANGE_BY_COLUMNS);
    new FXMenuCheck(&menu, _("Autosize"), filelist, FileList::ID_AUTOSIZE);
    new FXMenuSeparator(&menu);
    new FXMenuRadio(&menu, _("&Name"), filelist, FileList::ID_SORT_BY_NAME);
    new FXMenuRadio(&menu, _("Si&ze"), filelist, FileList::ID_SORT_BY_SIZE);
    new FXMenuRadio(&menu, _("&Type"), filelist, FileList::ID_SORT_BY_TYPE);
    new FXMenuRadio(&menu, _("E&xtension"), filelist, FileList::ID_SORT_BY_EXT);
    new FXMenuRadio(&menu, _("&Date"), filelist, FileList::ID_SORT_BY_TIME);
    new FXMenuRadio(&menu, _("&User"), filelist, FileList::ID_SORT_BY_USER);
    new FXMenuRadio(&menu, _("&Group"), filelist, FileList::ID_SORT_BY_GROUP);
    new FXMenuRadio(&menu, _("&Permissions"), filelist, FileList::ID_SORT_BY_PERM);
    new FXMenuSeparator(&menu);
    new FXMenuCheck(&menu, _("Ignore c&ase"), filelist, FileList::ID_SORT_CASE);
    new FXMenuCheck(&menu, _("Fold&ers first"), filelist, FileList::ID_DIRS_FIRST);
    new FXMenuCheck(&menu, _("Re&verse order"), filelist, FileList::ID_SORT_REVERSE);

    menu.create();
    allowPopupScroll = true;  // Allow keyboard scrolling
    menu.popup(NULL, x, y);
    getApp()->runModalWhileShown(&menu);
    allowPopupScroll = false;
    return(1);
}


// If Shift-F10 or Menu is pressed, opens the popup menu
long XFileImage::onKeyPress(FXObject* sender, FXSelector sel, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    // Shift-F10 or Menu was pressed : open popup menu
   	if ((event->state&SHIFTMASK && event->code == KEY_F10) || event->code == KEY_Menu)
    {
        this->handle(sender, FXSEL(SEL_COMMAND, XFileImage::ID_POPUP_MENU), ptr);
        return(1);
    }

    // Any other key was pressed : handle the pressed key in the usual way
    else
    {
        if (FXTopWindow::onKeyPress(sender, sel, ptr))
        {
            return(1);
        }
    }

    return(0);
}


long XFileImage::onKeyRelease(FXObject* sender, FXSelector sel, void* ptr)
{
    if (FXTopWindow::onKeyRelease(sender, sel, ptr))
    {
        return(1);
    }

    return(0);
}


// User clicked up directory button
long XFileImage::onCmdDirUp(FXObject*, FXSelector, void*)
{
    filelist->setDirectory(FXPath::upLevel(filelist->getDirectory()));
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());

    filelist->setFocus();

    return(1);
}

// If the cursor is inside a widget, flash its help text;
// Otherwise, unflash back to the regular status message.
/* long XFileImage::onUpdStatus(FXObject* sender,FXSelector sel,void* ptr){
  FXWindow *helpsource=getApp()->getCursorWindow();

  // Regular GUI update
  FXFrame::onUpdate(sender,sel,ptr);

  // Ask the help source for a new status text first, but only if the
  // statusline's shell is a direct or indirect owner of the help source
  if(helpsource && getShell()->isOwnerOf(helpsource) && helpsource->handle(this,FXSEL(SEL_QUERY_HELP,0),NULL)){
    return 1;
    }

  // Otherwise, supply normal message
  setText(normal);
  return 1;
} */


// Can we still go up
long XFileImage::onUpdDirUp(FXObject* sender, FXSelector, void*)
{
    if (FXPath::isTopDirectory(filelist->getDirectory()))
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), NULL);
    }
    return(1);
}


// Directory back
long XFileImage::onCmdDirBack(FXObject*, FXSelector s, void* p)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;
    forwardhist = filelist->forwardhist;

    // Get the previous directory
    item = backhist->getFirst();
    if (item)
    {
        pathname = backhist->getString(item);
    }

    // Update the history
    backhist->removeFirstItem();
    forwardhist->insertFirstItem(filelist->getDirectory());

    // Go to to the previous directory
    filelist->setDirectory(pathname, false);
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());

    filelist->setFocus();

    return(1);
}


// Update directory back
long XFileImage::onUpdDirBack(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;

    // Gray out the button if no item in history
    if (backhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory forward
long XFileImage::onCmdDirForward(FXObject*, FXSelector s, void* p)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;
    forwardhist = filelist->forwardhist;

    // Get the next directory
    item = forwardhist->getFirst();
    if (item)
    {
        pathname = forwardhist->getString(item);
    }

    // Update the history
    forwardhist->removeFirstItem();
    backhist->insertFirstItem(filelist->getDirectory());

    // Go to to the previous directory
    filelist->setDirectory(pathname, false);
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());

    filelist->setFocus();

    return(1);
}


// Update directory forward
long XFileImage::onUpdDirForward(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* forwardhist;
    FXString    pathname;

    // Get the filelist history
    forwardhist = filelist->forwardhist;

    // Gray out the button if no item in history
    if (forwardhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory back history
long XFileImage::onCmdDirBackHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;
    forwardhist = filelist->forwardhist;

    // Get all string items and display them in a list box
    int num = backhist->getNumItems();
    if (num > 0)
    {
        FXString* dirs = new FXString[num];
        FXString  strlist = "";

        // Get string items
        item = backhist->getFirst();
        for (int i = 0; i <= num-1; i++)
        {
            if (item)
            {
                FXString str = backhist->getString(item);
                dirs[i] = str;
                strlist = strlist+str+"\n";
                item = backhist->getNext(item);
            }
        }

        // Display list box
        int pos = DirHistBox::box(btnbackhist, DECOR_NONE, strlist, this->getX()+245, this->getY()+37);

        // If an item was selected
        if (pos != -1)
        {
            // Update back history
            if (pos == num-1)
            {
                backhist->removeAllItems();
            }
            else
            {
                item = backhist->getItemAtPos(pos+1);
                backhist->removeAllItemsBefore(item);
            }

            // Update forward history
            forwardhist->insertFirstItem(filelist->getDirectory());
            if (pos > 0)
            {
                for (int i = 0; i <= pos-1; i++)
                {
                    forwardhist->insertFirstItem(dirs[i]);
                }
            }

            // Go to to the selected directory
            pathname = dirs[pos];
            filelist->setDirectory(pathname, false);
            pathlink->setPath(filelist->getDirectory());
            pathtext->setText(filelist->getDirectory());
        }
        delete[]dirs;
    }

    return(1);
}


// Update directory back
long XFileImage::onUpdDirBackHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;

    // Gray out the button if no item in history
    if (backhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Directory forward history
long XFileImage::onCmdDirForwardHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* backhist, *forwardhist;
    StringItem* item;
    FXString    pathname;

    // Get the filelist history
    backhist = filelist->backhist;
    forwardhist = filelist->forwardhist;

    // Get all string items and display them in a list box
    int num = forwardhist->getNumItems();
    if (num > 0)
    {
        FXString* dirs = new FXString[num];
        FXString  strlist = "";

        // Get string items
        item = forwardhist->getFirst();
        for (int i = 0; i <= num-1; i++)
        {
            if (item)
            {
                FXString str = forwardhist->getString(item);
                dirs[i] = str;
                strlist = strlist+str+"\n";
                item = forwardhist->getNext(item);
            }
        }

        // Display list box
        int pos = DirHistBox::box(btnforwardhist, DECOR_NONE, strlist, this->getX()+285, this->getY()+37);

        // If an item was selected
        if (pos != -1)
        {
            // Update forward history
            if (pos == num-1)
            {
                forwardhist->removeAllItems();
            }
            else
            {
                item = forwardhist->getItemAtPos(pos+1);
                forwardhist->removeAllItemsBefore(item);
            }

            // Update back history
            backhist->insertFirstItem(filelist->getDirectory());
            if (pos > 0)
            {
                for (int i = 0; i <= pos-1; i++)
                {
                    backhist->insertFirstItem(dirs[i]);
                }
            }

            // Go to to the selected directory
            pathname = dirs[pos];
            filelist->setDirectory(pathname, false);
            pathlink->setPath(filelist->getDirectory());
            pathtext->setText(filelist->getDirectory());
        }
        delete[]dirs;
    }

    return(1);
}


// Update directory forward
long XFileImage::onUpdDirForwardHist(FXObject* sender, FXSelector sel, void* ptr)
{
    StringList* forwardhist;
    FXString    pathname;

    // Get the filelist history
    forwardhist = filelist->forwardhist;

    // Gray out the button if no item in history
    if (forwardhist->getNumItems() == 0)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), ptr);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), ptr);
    }

    return(1);
}


// Back to home directory
long XFileImage::onCmdHome(FXObject*, FXSelector, void*)
{
    filelist->setDirectory(FXSystem::getHomeDirectory());
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());
    filelist->setFocus();
    return(1);
}


// Back to current working directory
long XFileImage::onCmdWork(FXObject*, FXSelector, void*)
{
    filelist->setDirectory(FXSystem::getCurrentDirectory());
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());
    filelist->setFocus();
    return(1);
}


// About box
long XFileImage::onCmdAbout(FXObject*, FXSelector, void*)
{
    FXString msg;

    msg.format(_("X File Image Version %s is a simple image viewer.\n\n"), VERSION);
    msg += COPYRIGHT;
    MessageBox about(this, _("About X File Image"), msg.text(), xfiicon, BOX_OK|DECOR_TITLE|DECOR_BORDER,
                     JUSTIFY_CENTER_X|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    about.execute(PLACEMENT_OWNER);

    filelist->setFocus();

    return(1);
}


// Load file
FXbool XFileImage::loadimage(const FXString& file)
{
    FXString ext = FXPath::extension(file);

    FILE* fp = fopen(file.text(), "r");

    if (!fp)
    {
        MessageBox::error(this, BOX_OK, _("Error Loading File"), _("Unable to open file: %s"), file.text());
        return(false);
    }
    else
    {
        fclose(fp);
    }

    // Free old image if any, before loading a new one
    if (img)
    {
        delete img;
        img = NULL;
    }
    if (tmpimg)
    {
        delete tmpimg;
        tmpimg = NULL;
    }

    if (comparecase(ext, "gif") == 0)
    {
        img = new FXGIFImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXGIFImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "bmp") == 0)
    {
        img = new FXBMPImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXBMPImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "xpm") == 0)
    {
        img = new FXXPMImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXXPMImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "pcx") == 0)
    {
        img = new FXPCXImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXPCXImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if ((comparecase(ext, "ico") == 0) || (comparecase(ext, "cur") == 0))
    {
        img = new FXICOImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXICOImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "tga") == 0)
    {
        img = new FXTGAImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXTGAImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "rgb") == 0)
    {
        img = new FXRGBImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "xbm") == 0)
    {
        img = new FXXBMImage(getApp(), NULL, NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXXBMImage(getApp(), NULL, NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "ppm") == 0)
    {
        img = new FXPPMImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXPPMImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if (comparecase(ext, "png") == 0)
    {
        img = new FXPNGImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXPNGImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if ((comparecase(ext, "jpg") == 0) || (comparecase(ext, "jpeg") == 0))
    {
        img = new FXJPGImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXJPGImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else if ((comparecase(ext, "tif") == 0) || (comparecase(ext, "tiff") == 0))
    {
        img = new FXTIFImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
        tmpimg = new FXTIFImage(getApp(), NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP);
    }
    else
    {
        img = NULL;
        tmpimg = NULL;
    }

    // Perhaps failed
    if (img == NULL)
    {
        MessageBox::error(this, BOX_OK, _("Error Loading Image"), _("Unsupported type: %s"), ext.text());
        return(false);
    }

    if (tmpimg == NULL)
    {
        MessageBox::error(this, BOX_OK, _("Error Loading Image"), _("Unsupported type: %s"), ext.text());
        return(false);
    }

    // Load it
    FXFileStream stream;
    if (stream.open(file, FXStreamLoad))
    {
        getApp()->beginWaitCursor();
        FXbool res = img->loadPixels(stream);

        stream.close();

        // If failed
        if (!res)
        {
            MessageBox::error(this, BOX_OK, _("Error Loading Image"), _("Unable to load image, the file may be corrupted"));
            getApp()->endWaitCursor();
            return(false);
        }

        if (!FXMEMDUP(&tmpdata, img->getData(), FXColor, img->getWidth()*img->getHeight()))
        {
            throw FXMemoryException(_("Unable to load image"));
        }
        tmpimg->setData(tmpdata, IMAGE_OWNED, img->getWidth(), img->getHeight());

        img->blend(getApp()->getBackColor());
        tmpimg->blend(getApp()->getBackColor());

        img->create();
        tmpimg->create();

        imageview->setImage(tmpimg);

        // Initial zoom and image format
        indZoom = ZOOM_100;
        zoomval = zoomtab[indZoom];
        getApp()->endWaitCursor();

        // Zoom to fit window if asked
        if (fitwin)
        {
            handle(this, FXSEL(SEL_COMMAND, ID_ZOOM_WIN), NULL);
        }
    }
    filelist->setDirectory(FXPath::directory(file));
    pathlink->setPath(filelist->getDirectory());
    pathtext->setText(filelist->getDirectory());

    return(true);
}


// Toggle file list before image
long XFileImage::onCmdToggleFileListBefore(FXObject* sender, FXSelector, void*)
{
    filelistbefore = !filelistbefore;

    if (BOX_CLICKED_CANCEL != MessageBox::question(this, BOX_OK_CANCEL, _("Restart"), _("Change will be taken into account after restart.\nRestart X File Image now?")))
    {
        this->handle(this, FXSEL(SEL_COMMAND, XFileImage::ID_RESTART), NULL);
    }

    return(1);
}


// Update file list before image
long XFileImage::onUpdToggleFileListBefore(FXObject* sender, FXSelector, void*)
{
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_ENABLE), NULL);
        if (filelistbefore)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
        }
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_DISABLE), NULL);
    }

    return(1);
}


// Toggle zoom to fit window on startup
long XFileImage::onCmdToggleFitWin(FXObject*, FXSelector, void*)
{
    fitwin = !fitwin;
    filelist->setFocus();
    return(1);
}


// Update toggle wrap mode
long XFileImage::onUpdToggleFitWin(FXObject* sender, FXSelector, void*)
{
    if (fitwin)
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
    }
    return(1);
}


// Toggle filter image files
long XFileImage::onCmdToggleFilterImages(FXObject*, FXSelector, void*)
{
    filterimgs = !filterimgs;
    if (filterimgs)
    {
        filelist->setPattern(imgpatterns);
    }
    else
    {
        filelist->setPattern("*");
    }

    filelist->setFocus();

    return(1);
}


// Update filter image files
long XFileImage::onUpdToggleFilterImages(FXObject* sender, FXSelector, void*)
{
    // Disable menu item if the file list is not shown
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);

        // Update menu item
        if (filterimgs)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
        }
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);

        // Update menu item
        if (filterimgs)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_CHECK), NULL);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, ID_UNCHECK), NULL);
        }
    }
    return(1);
}


// Open
long XFileImage::onCmdOpen(FXObject*, FXSelector, void*)
{
    FileDialog opendialog(this, _("Open Image"));

    opendialog.setSelectMode(SELECTFILE_EXISTING);
    opendialog.setPatternList(patterns);
    opendialog.setDirectory(filelist->getDirectory());
    if (opendialog.execute())
    {
        filename = opendialog.getFilename();
        filelist->setCurrentFile(filename);
        mrufiles.appendFile(filename);
        loadimage(filename);
    }

    return(1);
}


// Print the text
long XFileImage::onCmdPrint(FXObject*, FXSelector, void*)
{
    // Read the current print command from the registry
    FXString printcommand, command;

    printcommand = getApp()->reg().readStringEntry("OPTIONS", "print_command", "lpr -P printer");

    // Open print dialog filled with the current print command
    int rc = 1;
    if (printdialog == NULL)
    {
        printdialog = new InputDialog(this, printcommand, _("Print command: \n(ex: lpr -P <printer>)"), _("Print"), "", printbigicon);
    }
    printdialog->setText(printcommand);
    printdialog->CursorEnd();
    rc = printdialog->execute(PLACEMENT_CURSOR);
    printcommand = printdialog->getText();

    // If cancel was pressed, exit
    if (!rc)
    {
        return(0);
    }

    // Write the new print command to the registry
    getApp()->reg().writeStringEntry("OPTIONS", "print_command", printcommand.text());

    // Perform the print command
    command = "cat " + filename + " |" + printcommand + " &";
    int ret = system(command.text());
    if (ret < 0)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Can't execute command %s"), command.text());
        return(0);
    }

    return(1);
}


// Handle toggle hidden command
long XFileImage::onCmdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    filelist->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_HIDDEN), ptr);
    filelist->setFocus();

    return(1);
}


// Update toggle hidden command
long XFileImage::onUpdToggleHidden(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;

    hiddenfiles = filelist->shownHiddenFiles();

    if (hiddenfiles == true)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);

    // Disable menu item if the file list is not shown
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Handle toggle hidden command
long XFileImage::onCmdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    filelist->handle(sender, FXSEL(SEL_COMMAND, FileList::ID_TOGGLE_THUMBNAILS), ptr);
    filelist->setFocus();

    return(1);
}


// Update toggle hidden command
long XFileImage::onUpdToggleThumbnails(FXObject* sender, FXSelector sel, void* ptr)
{
    FXuint msg = FXWindow::ID_UNCHECK;

    thumbnails = filelist->shownThumbnails();

    if (thumbnails == true)
    {
        msg = FXWindow::ID_CHECK;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), ptr);

    // Disable menu item if the file list is not shown
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Show mini icons in file list
long XFileImage::onCmdShowMini(FXObject*, FXSelector, void*)
{
    fileview = ID_SHOW_MINI_ICONS;
    filelist->handle(this, FXSEL(SEL_COMMAND, FileList::ID_SHOW_MINI_ICONS), NULL);
    filelist->setFocus();

    return(1);
}


// Show big icons in file list
long XFileImage::onCmdShowBig(FXObject*, FXSelector, void*)
{
    fileview = ID_SHOW_BIG_ICONS;
    filelist->handle(this, FXSEL(SEL_COMMAND, FileList::ID_SHOW_BIG_ICONS), NULL);
    filelist->setFocus();

    return(1);
}


// Show details in file list
long XFileImage::onCmdShowDetails(FXObject*, FXSelector, void*)
{
    fileview = ID_SHOW_DETAILS;
    filelist->handle(this, FXSEL(SEL_COMMAND, FileList::ID_SHOW_DETAILS), NULL);
    filelist->setFocus();

    return(1);
}


// Update filelist
long XFileImage::onUpdFileView(FXObject* sender, FXSelector sel, void* ptr)
{
    // Keep the filebox width / height relative to the window width / height

    // Get the current width and height
    int width = getWidth();
    int height = getHeight();

    // Panel stacked horizontally
    if (vertpanels)
    {
        if (relative_resize && (prev_width != width))
        {
            // File box shown
            if (filebox->shown())
            {
                filebox->setWidth((int)round(filewidth_pct*width));
            }
        }

        // Update the relative width (only if window width is sufficient)
        prev_width = width;
        if (getWidth() > 10)
        {
            filewidth_pct = (double)(filebox->getWidth())/(double)(getWidth());
        }
    }

    // Panel stacked vertically
    else
    {
        if (relative_resize && (prev_height != height))
        {
            // File box shown
            if (filebox->shown())
            {
                filebox->setHeight((int)round(fileheight_pct*height));
            }
        }

        // Update the relative height (only if window height is sufficient)
        prev_height = height;
        if (getHeight() > 10)
        {
            fileheight_pct = (double)(filebox->getHeight())/(double)(getHeight());
        }
    }

    // Update radio buttons
    FXuint msg = FXWindow::ID_UNCHECK;

    switch (FXSELID(sel))
    {
    case ID_SHOW_MINI_ICONS:
        if (fileview == ID_SHOW_MINI_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_BIG_ICONS:
        if (fileview == ID_SHOW_BIG_ICONS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;

    case ID_SHOW_DETAILS:
        if (fileview == ID_SHOW_DETAILS)
        {
            msg = FXWindow::ID_CHECK;
        }
        break;
    }
    sender->handle(this, FXSEL(SEL_COMMAND, msg), NULL);

    // Disable menus items if the file list is not shown
    if (filebox->shown())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }

    return(1);
}


// Harvest the zombies
long XFileImage::onSigHarvest(FXObject*, FXSelector, void*)
{
    while (waitpid(-1, NULL, WNOHANG) > 0)
    {
    }
    return(1);
}


// Quit
long XFileImage::onCmdQuit(FXObject*, FXSelector, void*)
{
    // Save settings
    saveConfig();

    // Quit
    getApp()->exit(EXIT_SUCCESS);
    return(1);
}


// Update title (display image size and actual zoom)
long XFileImage::onUpdTitle(FXObject* sender, FXSelector, void*)
{
    FXString title = "Xfi " + filename;
    FXImage* image = imageview->getImage();

    if (image && (img != NULL))
    {
        title += " (" + FXStringVal(img->getWidth()) + "x" + FXStringVal(img->getHeight()) + " - " + FXStringVal(zoomval*100) + "%" ")";
    }
    sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_SETSTRINGVALUE), (void*)&title);
    return(1);
}


// Open recent file
long XFileImage::onCmdRecentFile(FXObject*, FXSelector, void* ptr)
{
    filename = (char*)ptr;
    filelist->setCurrentFile(filename);
    loadimage(filename);
    return(1);
}


// Double clicked in the file list
long XFileImage::onCmdItemDoubleClicked(FXObject*, FXSelector, void* ptr)
{
    int index = (int)(FXival)ptr;

    if (0 <= index)
    {
        if (filelist->isItemDirectory(index))
        {
            FXString pathname = filelist->getItemPathname(index);

            // Does not have access
            if (!::isReadExecutable(pathname))
            {
                MessageBox::error(this, BOX_OK, _("Error"), _(" Permission to: %s denied."), pathname.text());
                return(0);
            }
            filelist->setDirectory(pathname);
            pathlink->setPath(pathname);
            pathtext->setText(pathname);
        }
        else if (filelist->isItemFile(index))
        {
            filename = filelist->getItemPathname(index);
            mrufiles.appendFile(filename);
            loadimage(filename);
            filelist->setCurrentItem(index);
        }
    }
    return(1);
}


// Single clicked in the file list
long XFileImage::onCmdItemClicked(FXObject* sender, FXSelector sel, void* ptr)
{
    if (single_click != SINGLE_CLICK_NONE)
    {
        // In detailed mode, avoid single click when cursor is not over the first column
        int    x, y;
        FXuint state;
        filelist->getCursorPosition(x, y, state);
        FXbool allow = true;
        if (!(filelist->getListStyle()&(_ICONLIST_BIG_ICONS|_ICONLIST_MINI_ICONS)) && ((x-filelist->getXPosition()) > filelist->getHeaderSize(0)))
        {
            allow = false;
        }

        int index = (int)(FXival)ptr;
        if (0 <= index)
        {
            if ((single_click != SINGLE_CLICK_NONE) && filelist->isItemDirectory(index) && allow)
            {
                FXString pathname = filelist->getItemPathname(index);

                // Does not have access
                if (!::isReadExecutable(pathname))
                {
                    MessageBox::error(this, BOX_OK, _("Error"), _(" Permission to: %s denied."), pathname.text());
                    return(0);
                }
                filelist->setDirectory(pathname);
                pathlink->setPath(pathname);
                pathtext->setText(pathname);
            }
            else if ((single_click == SINGLE_CLICK_DIR_FILE) && filelist->isItemFile(index) && allow)
            {
                filename = filelist->getItemPathname(index);
                mrufiles.appendFile(filename);
                loadimage(filename);
                filelist->setCurrentItem(index);
            }
        }
    }
    return(1);
}


// Rotate image
long XFileImage::onCmdRotate(FXObject* sender, FXSelector sel, void* ptr)
{
    getApp()->beginWaitCursor();
    FXImage* image = imageview->getImage();
    switch (FXSELID(sel))
    {
    case ID_ROTATE_90:

        // Rotate the actual image
        image->rotate(90);

        // Need to also rotate the original image only if the actual size is different
        if ((image->getWidth() != img->getWidth()) || (image->getHeight() != img->getHeight()))
        {
            img->rotate(90);
        }

        break;

    case ID_ROTATE_270:

        // Rotate the actual image
        image->rotate(270);

        // Need to also rotate the original image only if the actual size is different
        if ((image->getWidth() != img->getWidth()) || (image->getHeight() != img->getHeight()))
        {
            img->rotate(270);
        }
        break;
    }
    imageview->setImage(image);
    if ( zoomwin == 1 ) {
        //this->handle(sender, FXSEL(SEL_COMMAND, XFileImage::ID_ZOOM_WIN), ptr);
        handle(this, FXSEL(SEL_COMMAND, ID_ZOOM_WIN), NULL);
        //getApp()->removeTimeout(this,ID_ZOOM_WIN);
        //getApp()->addTimeout(this,ID_ZOOM_WIN,75);
        //XFileImage::onCmdZoomWin(sender, sel, ptr);
        //printf("lol\n");
    }
    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Update image
long XFileImage::onUpdImage(FXObject* sender, FXSelector, void*)
{
    if (imageview->getImage())
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), NULL);
    }
    else
    {
        sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_DISABLE), NULL);
    }
    return(1);
}


// Mirror image
long XFileImage::onCmdMirror(FXObject*, FXSelector sel, void*)
{
    getApp()->beginWaitCursor();
    FXImage* image = imageview->getImage();
    switch (FXSELID(sel))
    {
    case ID_MIRROR_HOR:

        // Mirror the actual image
        image->mirror(true, false);

        // Need to also mirror the original image only if the actual size is different
        if ((image->getWidth() != img->getWidth()) || (image->getHeight() != img->getHeight()))
        {
            img->mirror(true, false);
        }
        break;

    case ID_MIRROR_VER:

        // Mirror the actual image
        image->mirror(false, true);

        // Need to also mirror the original image only if the actual size is different
        if ((image->getWidth() != img->getWidth()) || (image->getHeight() != img->getHeight()))
        {
            img->mirror(false, true);
        }
        break;
    }
    imageview->setImage(image);
    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Zoom in image
long XFileImage::onCmdZoomIn(FXObject*, FXSelector, void*)
{
    zoomwin = 0;

    imgvwidth = NULL;
    imgvheight = NULL;
    //getApp()->removeTimeout(this,ID_ZOOM_WIN);

    // getApp()->removeTimeout(this,ID_ZOOM_WIN);
    getApp()->beginWaitCursor();

    // Copy the original image into the actual one
    if (!FXMEMDUP(&tmpdata, img->getData(), FXColor, img->getWidth()*img->getHeight()))
    {
        throw FXMemoryException(_("Unable to load image"));
    }
    tmpimg->setData(tmpdata, IMAGE_OWNED, img->getWidth(), img->getHeight());

    // Resize the actual image according to the new zoom factor
    indZoom += 1;
    if (indZoom > NB_ZOOM-1)
    {
        indZoom = NB_ZOOM-1;
    }
    int sx = (int)(tmpimg->getWidth()*zoomtab[indZoom]);
    int sy = (int)(tmpimg->getHeight()*zoomtab[indZoom]);

    // Scale only if the actual image size is different
    if (indZoom == ZOOM_100)
    {
        imageview->setImage(img);
    }
    else
    {
        // Maximum zoom allowed
        if ((sx > MAX_IMGSIZE) || (sy > MAX_IMGSIZE))
        {
            indZoom -= 1;
            if (indZoom < 0)
            {
                indZoom = 0;
            }
            sx = (int)(tmpimg->getWidth()*zoomtab[indZoom]);
            sy = (int)(tmpimg->getHeight()*zoomtab[indZoom]);
        }

        // Scale image according to the new zoom factor
        tmpimg->scale(sx, sy, 1);
        imageview->setImage(tmpimg);
    }

    // Set zoom value for window title
    zoomval = zoomtab[indZoom];

    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Zoom out image
long XFileImage::onCmdZoomOut(FXObject*, FXSelector, void*)
{
    zoomwin = 0;

    imgvwidth = NULL;
    imgvheight = NULL;
    //getApp()->removeTimeout(this,ID_ZOOM_WIN);

    //getApp()->removeTimeout(this,ID_ZOOM_WIN);
    getApp()->beginWaitCursor();

    // Copy the original image into the actual one
    if (!FXMEMDUP(&tmpdata, img->getData(), FXColor, img->getWidth()*img->getHeight()))
    {
        throw FXMemoryException(_("Unable to load image"));
    }
    tmpimg->setData(tmpdata, IMAGE_OWNED, img->getWidth(), img->getHeight());

    // Resize the image according to the new zoom factor
    indZoom -= 1;
    if (indZoom < 0)
    {
        indZoom = 0;
    }
    int sx = (int)(tmpimg->getWidth()*zoomtab[indZoom]);
    int sy = (int)(tmpimg->getHeight()*zoomtab[indZoom]);

    // Scale only if the actual image size is different
    if (indZoom == ZOOM_100)
    {
        imageview->setImage(img);
    }
    else
    {
        // Scale image according to the new zoom factor
        tmpimg->scale(sx, sy, 1);
        imageview->setImage(tmpimg);
    }

    // Set zoom value for window title
    zoomval = zoomtab[indZoom];

    filelist->setFocus();
    getApp()->endWaitCursor();
    return(1);
}


// Zoom to 100%
long XFileImage::onCmdZoom100(FXObject*, FXSelector, void*)
{
    zoomwin = 0;

    imgvwidth = NULL;
    imgvheight = NULL;
    //getApp()->removeTimeout(this,ID_ZOOM_WIN);

    getApp()->beginWaitCursor();
    indZoom = ZOOM_100;
    zoomval = zoomtab[indZoom];
    imageview->setImage(img);
    filelist->setFocus();
    getApp()->endWaitCursor();
    //getApp()->removeTimeout(this,ID_ZOOM_WIN);
    return(1);
}


// Zoom to fit window
long XFileImage::onCmdZoomWin(FXObject*, FXSelector, void*)
{
    //getApp()->addTimeout(this,ID_ZOOM_WIN,200);

    // set zoomwin as used
    zoomwin = 1;

    //printf("lol2\n");

    // Window and image sizes
    //int winw = (this->getShell())->getWidth();
    //int winh = (this->getShell())->getHeight();
    int winw = imageview->getWidth();
    int winh = imageview->getHeight();
    //if (winw != imgvwidth || winh != imgvheight) {
    //printf("hi\n");
    getApp()->beginWaitCursor();
    // imgvwidth = (this->getShell())->getWidth();
    // imgvheight = (this->getShell())->getHeight();

    imgvwidth = imageview->getWidth();
    imgvheight = imageview->getHeight();

    int w = img->getWidth();
    int h = img->getHeight();

    // Compute zoom factor
    double fitwin;
    if (double(w)/double(h) > double(winw)/double(winh))
    {
        fitwin = 0.98*(double)winw/(double)w;
    }
    else
    {
        fitwin = 0.98*(double)winh/(double)h;
    }

    // Find the most approaching predefined zoom
    // This is used in other zoom functions
    for (int k = 0; k < NB_ZOOM; k++)
    {
        if (zoomtab[k] > fitwin)
        {
            indZoom = k-1;
            break;
        }
    }
    if (indZoom < 0)
    {
        indZoom = 0;
    }
    if (indZoom >= NB_ZOOM)
    {
        indZoom = NB_ZOOM-1;
    }

    // Copy the original image into the actual one
    if (!FXMEMDUP(&tmpdata, img->getData(), FXColor, img->getWidth()*img->getHeight()))
    {
        throw FXMemoryException(_("Unable to load image"));
    }
    tmpimg->setData(tmpdata, IMAGE_OWNED, img->getWidth(), img->getHeight());

    // Resize the image according to the new zoom factor
    int sx = (int)(w*fitwin);
    int sy = (int)(h*fitwin);

    // Scale image according to the new zoom factor
    tmpimg->scale(sx, sy, 1);
    imageview->setImage(tmpimg);

    // Set zoom value for window title
    zoomval = fitwin;

    filelist->setFocus();
    getApp()->endWaitCursor();
    //}
    zoomwin = 1;
    return(1);
}


// Zoom to fit window
long XFileImage::onConfigureZoomWin(FXObject* sender, FXSelector sel, void* ptr)
{
    //printf("hi\n");

    // this is skidded from fox toolkit src
    FXEvent *ev = (FXEvent*)ptr;
    FXComposite::onConfigure(sender, sel, ptr);
    xpos=ev->rect.x;
    ypos=ev->rect.y;
    if ( ( ev->rect.w != width ) || ( ev->rect.h != height ) ) {
        width = ev->rect.w;               // Record new size
        height = ev->rect.h;

        recalc();
    }


    //printf("test\n");
    //int winw = imageview->getWidth();
    //int winh = imageview->getHeight();

    int winw = imageview->getWidth();
    int winh = imageview->getHeight();

    //printf("test2\n");

    if ( zoomwin == 1 ) {
    	//printf("test3\n");
    	if (winw != imgvwidth || winh != imgvheight) {
   		if (imgvwidth != 0 || imgvheight != 0 || imgvwidth != NULL || imgvheight != NULL) {
    		    //printf("test\n");
		    getApp()->removeTimeout(this,ID_ZOOM_WIN);
		    getApp()->addTimeout(this,ID_ZOOM_WIN,75);
    		    //handle(this, FXSEL(SEL_COMMAND, ID_ZOOM_WIN), NULL);
 	   	}
	}
    }




    return(1);
}


// hack to always be on top
long XFileImage::onLower(FXObject* sender, FXSelector sel, void* ptr)
{
    printf("test\n");
    this->raise();
    return(1);
}


// Restart the application when required
long XFileImage::onCmdRestart(FXObject*, FXSelector, void*)
{
    saveConfig();

    if (fork() == 0) // Child
    {
        execvp("xfi", args);
    }
    else // Parent
    {
        exit(EXIT_SUCCESS);
    }
    return(1);
}


// Start the ball rolling
void XFileImage::start(FXString startimage)
{
    filename = startimage;
    if (filename != "")
    {
        loadimage(filename);
    }
}


// Create and show window
void XFileImage::create()
{
    // Get size and position
    FXuint ww = getApp()->reg().readUnsignedEntry("OPTIONS", "width", DEFAULT_WINDOW_WIDTH);    // Workaround for a possible bug in some WMs
    FXuint hh = getApp()->reg().readUnsignedEntry("OPTIONS", "height", DEFAULT_WINDOW_HEIGHT);  // Workaround for a possible bug in some WMs

    filewidth_pct = getApp()->reg().readRealEntry("OPTIONS", "filewidth_pct", 0.25);
    fileheight_pct = getApp()->reg().readRealEntry("OPTIONS", "fileheight_pct", 0.25);
    FXuint fs = getApp()->reg().readIntEntry("OPTIONS", "filesshown", true);

    filelist->setDirectory(FXSystem::getCurrentDirectory());
    pathlink->setPath(FXSystem::getCurrentDirectory());
    pathtext->setText(FXSystem::getCurrentDirectory());

    // Display or hide path linker and path text
    if (show_pathlink)
    {
        pathtext->hide();
        pathlink->show();
    }
    else
    {
        pathlink->hide();
        pathtext->show();
    }

    // Hide tree if asked for
    if (!fs)
    {
        filebox->hide();
    }

    // Set toolbar status
    if (getApp()->reg().readUnsignedEntry("OPTIONS", "showtoolbar", true) == false)
    {
        toolbarcont->hide();
    }

    // Set status bar status
    if (getApp()->reg().readUnsignedEntry("OPTIONS", "showstatusbar", true) == false)
    {
        statusbar->hide();
    }

    // Set hidden file status
    hiddenfiles = getApp()->reg().readUnsignedEntry("OPTIONS", "hiddenfiles", 0);
    filelist->showHiddenFiles(hiddenfiles);

    // Set thumbnails status
    thumbnails = getApp()->reg().readUnsignedEntry("OPTIONS", "thumbnails", 0);
    filelist->showThumbnails(thumbnails);

    // Set list style
    liststyle = getApp()->reg().readUnsignedEntry("OPTIONS", "liststyle", _ICONLIST_MINI_ICONS);
    filelist->setListStyle(liststyle|_ICONLIST_BROWSESELECT);

    // Set file view
    fileview = getApp()->reg().readUnsignedEntry("OPTIONS", "fileview", ID_SHOW_MINI_ICONS);
    this->handle(this, FXSEL(SEL_COMMAND, fileview), NULL);

    // Set startup zoom
    fitwin = getApp()->reg().readUnsignedEntry("OPTIONS", "fitwin", 0);

    // Set filter images flag
    filterimgs = getApp()->reg().readUnsignedEntry("OPTIONS", "filterimgs", false);

    // Set position and position window
    if (save_win_pos)
    {
        int xpos = getApp()->reg().readIntEntry("OPTIONS", "xpos", DEFAULT_WINDOW_XPOS);
        int ypos = getApp()->reg().readIntEntry("OPTIONS", "ypos", DEFAULT_WINDOW_YPOS);
        position(xpos, ypos, ww, hh);
    }
    else
    {
        position(getX(), getY(), ww, hh);
    }

    FXMainWindow::create();

    if (filterimgs)
    {
        filelist->setPattern(imgpatterns);
    }

    // Set filebox width or height
    if (vertpanels)
    {
        filebox->setWidth((int)round(filewidth_pct*getWidth()));
    }
    else
    {
        filebox->setHeight((int)round(fileheight_pct*getHeight()));
    }

    // Set focus on file list
    filelist->setFocus();

    show();


#ifdef STARTUP_NOTIFICATION
    startup_completed();
#endif
}


// Switch between vertical and horizontal panels
long XFileImage::onCmdHorzVertPanels(FXObject* sender, FXSelector sel, void* ptr)
{
    switch (FXSELID(sel))
    {
    case ID_VERT_PANELS:
        splitter->setSplitterStyle(splitter->getSplitterStyle()&~SPLITTER_VERTICAL);
        vertpanels = true;
        break;

    case ID_HORZ_PANELS:
        splitter->setSplitterStyle(splitter->getSplitterStyle()|SPLITTER_VERTICAL);
        vertpanels = false;
        break;
    }

    filelist->setFocus();

    return(1);
}


// Update the horizontal / vertical panel radio menus
long XFileImage::onUpdHorzVertPanels(FXObject* sender, FXSelector sel, void* ptr)
{
    sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_ENABLE), ptr);

    if (vertpanels)
    {
        if (FXSELID(sel) == ID_HORZ_PANELS)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_UNCHECK), ptr);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_CHECK), ptr);
        }
    }
    else
    {
        if (FXSELID(sel) == ID_VERT_PANELS)
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_UNCHECK), ptr);
        }
        else
        {
            sender->handle(this, FXSEL(SEL_COMMAND, FXWindow::ID_CHECK), ptr);
        }
    }

    return(1);
}


// Save configuration when quitting
void XFileImage::saveConfig()
{
    // Write new window size and position back to registry
    getApp()->reg().writeUnsignedEntry("OPTIONS", "width", (FXuint)getWidth());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "height", (FXuint)getHeight());

    if (save_win_pos)
    {
        // Account for the Window Manager border size
        XWindowAttributes xwattr;
        if (XGetWindowAttributes((Display*)getApp()->getDisplay(), this->id(), &xwattr))
        {
            getApp()->reg().writeIntEntry("OPTIONS", "xpos", getX()-xwattr.x);
            getApp()->reg().writeIntEntry("OPTIONS", "ypos", getY()-xwattr.y);
        }
        else
        {
            getApp()->reg().writeIntEntry("OPTIONS", "xpos", getX());
            getApp()->reg().writeIntEntry("OPTIONS", "ypos", getY());
        }
    }

    // Width and height of filebox
    getApp()->reg().writeRealEntry("OPTIONS", "filewidth_pct", (int)(filewidth_pct*100)/100.0);
    getApp()->reg().writeRealEntry("OPTIONS", "fileheight_pct", (int)(fileheight_pct*100)/100.0);

    // Was filebox shown
    getApp()->reg().writeIntEntry("OPTIONS", "filesshown", filebox->shown());

    // Toolbar status
    if (toolbarcont->shown())
    {
        getApp()->reg().writeUnsignedEntry("OPTIONS", "showtoolbar", true);
    }
    else
    {
        getApp()->reg().writeUnsignedEntry("OPTIONS", "showtoolbar", false);
    }

    // Hidden files status
    getApp()->reg().writeUnsignedEntry("OPTIONS", "hiddenfiles", hiddenfiles);

    // Thumbnails status
    getApp()->reg().writeUnsignedEntry("OPTIONS", "thumbnails", thumbnails);

    // File view
    getApp()->reg().writeUnsignedEntry("OPTIONS", "fileview", fileview);

    // List style
    getApp()->reg().writeUnsignedEntry("OPTIONS", "liststyle", filelist->getListStyle());

    // Startup zoom
    getApp()->reg().writeUnsignedEntry("OPTIONS", "fitwin", fitwin);

    // Filter images in file list
    getApp()->reg().writeUnsignedEntry("OPTIONS", "filterimgs", filterimgs);

    // Filelist columns sizes
    getApp()->reg().writeUnsignedEntry("OPTIONS", "name_size", filelist->getHeaderSize(0));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "size_size", filelist->getHeaderSize(1));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "type_size", filelist->getHeaderSize(2));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "ext_size", filelist->getHeaderSize(3));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "modd_size", filelist->getHeaderSize(4));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "user_size", filelist->getHeaderSize(5));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "grou_size", filelist->getHeaderSize(6));
    getApp()->reg().writeUnsignedEntry("OPTIONS", "attr_size", filelist->getHeaderSize(7));

    // Panel stacking
    getApp()->reg().writeUnsignedEntry("OPTIONS", "filelist_before", filelistbefore);
    getApp()->reg().writeUnsignedEntry("OPTIONS", "vert_panels", vertpanels);

    // Get and write sort function for search window
    FXString sort_func;
    if (filelist->getSortFunc() == filelist->ascendingCase)
    {
        sort_func = "ascendingCase";
    }
    if (filelist->getSortFunc() == filelist->ascendingCaseMix)
    {
        sort_func = "ascendingCaseMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingCase)
    {
        sort_func = "descendingCase";
    }
    else if (filelist->getSortFunc() == filelist->descendingCaseMix)
    {
        sort_func = "descendingCaseMix";
    }
    else if (filelist->getSortFunc() == filelist->ascending)
    {
        sort_func = "ascending";
    }
    else if (filelist->getSortFunc() == filelist->ascendingMix)
    {
        sort_func = "ascendingMix";
    }
    else if (filelist->getSortFunc() == filelist->descending)
    {
        sort_func = "descending";
    }
    else if (filelist->getSortFunc() == filelist->descendingMix)
    {
        sort_func = "descendingMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingSize)
    {
        sort_func = "ascendingSize";
    }
    else if (filelist->getSortFunc() == filelist->ascendingSizeMix)
    {
        sort_func = "ascendingSizeMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingSize)
    {
        sort_func = "descendingSize";
    }
    else if (filelist->getSortFunc() == filelist->descendingSizeMix)
    {
        sort_func = "descendingSizeMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingType)
    {
        sort_func = "ascendingType";
    }
    else if (filelist->getSortFunc() == filelist->ascendingTypeMix)
    {
        sort_func = "ascendingTypeMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingType)
    {
        sort_func = "descendingType";
    }
    else if (filelist->getSortFunc() == filelist->descendingTypeMix)
    {
        sort_func = "descendingTypeMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingExt)
    {
        sort_func = "ascendingExt";
    }
    else if (filelist->getSortFunc() == filelist->ascendingExtMix)
    {
        sort_func = "ascendingExtMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingExt)
    {
        sort_func = "descendingExt";
    }
    else if (filelist->getSortFunc() == filelist->descendingExtMix)
    {
        sort_func = "descendingExtMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingTime)
    {
        sort_func = "ascendingTime";
    }
    else if (filelist->getSortFunc() == filelist->ascendingTimeMix)
    {
        sort_func = "ascendingTimeMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingTime)
    {
        sort_func = "descendingTime";
    }
    else if (filelist->getSortFunc() == filelist->descendingTimeMix)
    {
        sort_func = "descendingTimeMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingUser)
    {
        sort_func = "ascendingUser";
    }
    else if (filelist->getSortFunc() == filelist->ascendingUserMix)
    {
        sort_func = "ascendingUserMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingUser)
    {
        sort_func = "descendingUser";
    }
    else if (filelist->getSortFunc() == filelist->descendingUserMix)
    {
        sort_func = "descendingUserMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingGroup)
    {
        sort_func = "ascendingGroup";
    }
    else if (filelist->getSortFunc() == filelist->ascendingGroupMix)
    {
        sort_func = "ascendingGroupMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingGroup)
    {
        sort_func = "descendingGroup";
    }
    else if (filelist->getSortFunc() == filelist->descendingGroupMix)
    {
        sort_func = "descendingGroupMix";
    }
    else if (filelist->getSortFunc() == filelist->ascendingPerm)
    {
        sort_func = "ascendingPerm";
    }
    else if (filelist->getSortFunc() == filelist->ascendingPermMix)
    {
        sort_func = "ascendingPermMix";
    }
    else if (filelist->getSortFunc() == filelist->descendingPerm)
    {
        sort_func = "descendingPerm";
    }
    else if (filelist->getSortFunc() == filelist->descendingPermMix)
    {
        sort_func = "descendingPermMix";
    }
    else
    {
        sort_func = "ascendingCase";
    }
    getApp()->reg().writeStringEntry("OPTIONS", "sort_func", sort_func.text());

    // Write registry settings
    getApp()->reg().write();
}


// Usage message
#define USAGE_MSG    _("\
\nUsage: xfi [options] [image] \n\
\n\
    [options] can be any of the following:\n\
\n\
        -h, --help         Print (this) help screen and exit.\n\
        -v, --version      Print version information and exit.\n\
\n\
    [image] is the path to the image file you want to open on start up.\n\
\n")



// Start the whole thing
int main(int argc, char* argv[])
{
    int         i;
    FXString    startimage = "";
    const char* appname = "xfi";
    const char* xfename = XFEAPPNAME;
    const char* vdrname = XFEVDRNAME;
    FXbool      loadicons;
    FXString    xmodifiers;

    // Get environment variables $HOME, $XDG_DATA_HOME and $XDG_CONFIG_HOME
    homedir = FXSystem::getHomeDirectory();
    if (homedir == "")
    {
        homedir = ROOTDIR;
    }
    xdgdatahome = getenv("XDG_DATA_HOME");
    if (xdgdatahome == "")
    {
        xdgdatahome = homedir + PATHSEPSTRING DATAPATH;
    }
    xdgconfighome = getenv("XDG_CONFIG_HOME");
    if (xdgconfighome == "")
    {
        xdgconfighome = homedir + PATHSEPSTRING CONFIGPATH;
    }

    // Detect if an X input method is used
    xmodifiers = getenv("XMODIFIERS");
    if ((xmodifiers == "") || (xmodifiers == "@im=none"))
    {
        xim_used = false;
    }
    else
    {
        xim_used = true;
    }

#ifdef HAVE_SETLOCALE
    // Set locale via LC_ALL.
    setlocale(LC_ALL, "");
#endif

#if ENABLE_NLS
    // Set the text message domain.
    bindtextdomain(PACKAGE, LOCALEDIR);
    bind_textdomain_codeset(PACKAGE, "utf-8");
    textdomain(PACKAGE);
#endif

    // Parse basic arguments
    for (i = 1; i < argc; ++i)
    {
        if ((compare(argv[i], "-v") == 0) || (compare(argv[i], "--version") == 0))
        {
            fprintf(stdout, "%s version %s\n", PACKAGE, VERSION);
            exit(EXIT_SUCCESS);
        }
        else if ((compare(argv[i], "-h") == 0) || (compare(argv[i], "--help") == 0))
        {
            fprintf(stdout, USAGE_MSG);
            exit(EXIT_SUCCESS);
        }
        else
        {
            // Start image, if any
            startimage = argv[i];
        }
    }

    args = argv;

    // Make application
    FXApp* application = new FXApp(appname, vdrname);

    // Open display
    application->init(argc, argv);

    // Redefine the default hand cursor
    FXCursor* hand = new FXCursor(application, hand_bits, hand_mask_bits, hand_width, hand_height, hand_x_hot, hand_y_hot);
    application->setDefaultCursor(DEF_HAND_CURSOR, hand);

    // Load all application icons
    loadicons = loadAppIcons(application);

    // Read the Xfe registry
    FXRegistry* reg_xfe = new FXRegistry(xfename, vdrname);
    reg_xfe->read();

    // Set base color (to change the default base color at first run)
    FXColor basecolor = reg_xfe->readColorEntry("SETTINGS", "basecolor", FXRGB(237, 233, 227));
    application->setBaseColor(basecolor);

    // Set Xfi normal font according to the Xfe registry
    FXString fontspec;
    fontspec = reg_xfe->readStringEntry("SETTINGS", "font", DEFAULT_NORMAL_FONT);
    if (!fontspec.empty())
    {
        FXFont* normalFont = new FXFont(application, fontspec);
        normalFont->create();
        application->setNormalFont(normalFont);
    }

    // Set Xfi file list colors according to the Xfe registry
    listbackcolor = reg_xfe->readColorEntry("SETTINGS", "listbackcolor", FXRGB(255, 255, 255));
    listforecolor = reg_xfe->readColorEntry("SETTINGS", "listforecolor", FXRGB(0, 0, 0));
    highlightcolor = reg_xfe->readColorEntry("SETTINGS", "highlightcolor", FXRGB(238, 238, 238));

    // Set single click navigation according to the Xfe registry
    single_click = reg_xfe->readUnsignedEntry("SETTINGS", "single_click", SINGLE_CLICK_NONE);

    // Set smooth scrolling according to the Xfe registry
    FXbool smoothscroll = reg_xfe->readUnsignedEntry("SETTINGS", "smooth_scroll", true);

    // Set file list tooltip flag according to the Xfe registry
    file_tooltips = reg_xfe->readUnsignedEntry("SETTINGS", "file_tooltips", true);

    // Set relative resizing flag according to the Xfe registry
    relative_resize = reg_xfe->readUnsignedEntry("SETTINGS", "relative_resize", true);

    // Set display pathlinker flag according to the Xfe registry
    show_pathlink = reg_xfe->readUnsignedEntry("SETTINGS", "show_pathlinker", true);

    // Get value of the window position flag
    save_win_pos = reg_xfe->readUnsignedEntry("SETTINGS", "save_win_pos", false);

    // Delete the Xfe registry
    delete reg_xfe;

    // Make window
    XFileImage* window = new XFileImage(application, smoothscroll);

    // Catch SIGCHLD to harvest zombie child processes
    application->addSignal(SIGCHLD, window, XFileImage::ID_HARVEST, true);

    // Handle interrupt to save stuff nicely
    application->addSignal(SIGINT, window, XFileImage::ID_QUIT);

    // Create it
    application->create();

    // Smooth scrolling
    window->setSmoothScroll(smoothscroll);

    if (!loadicons)
    {
        MessageBox::error(application, BOX_OK, _("Error loading icons"), _("Unable to load some icons. Please check your icons path!"));
    }

    // Tooltips setup time and duration
    application->setTooltipPause(TOOLTIP_PAUSE);
    application->setTooltipTime(TOOLTIP_TIME);

    // Start
    window->start(startimage);

    // Run
    return(application->run());
}
#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/signal.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "startupnotification.h"
#include "FileDialog.h"
#include "MessageBox.h"
#include "CommandWindow.h"
#include "XFilePackage.h"


// Add FOX hacks
#include "foxhacks.cpp"
#include "clearlooks.cpp"


// Global variables
char**   args;
FXbool   dpkg = false;
FXbool   rpm = false;
FXColor  highlightcolor;
FXbool   allowPopupScroll = false;
FXuint   single_click;
FXbool   file_tooltips;
FXbool   relative_resize;
FXbool   save_win_pos;
FXString homedir;
FXString xdgconfighome;
FXString xdgdatahome;
FXbool   xim_used = false;

// Hand cursor replacement
#define hand_width     32
#define hand_height    32
#define hand_x_hot     6
#define hand_y_hot     1
static const FXuchar hand_bits[] =
{
    0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00,
    0x90, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x90, 0x07, 0x00, 0x00,
    0x97, 0x1a, 0x00, 0x00, 0x99, 0x2a, 0x00, 0x00, 0x11, 0x28, 0x00, 0x00,
    0x12, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00,
    0x04, 0x20, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00,
    0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const FXuchar hand_mask_bits[] =
{
    0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
    0xf0, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00,
    0xf7, 0x1f, 0x00, 0x00, 0xff, 0x3f, 0x00, 0x00, 0xff, 0x3f, 0x00, 0x00,
    0xfe, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00,
    0xfc, 0x3f, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00,
    0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// Map
FXDEFMAP(XFilePackage) XFilePackageMap[] =
{
    FXMAPFUNC(SEL_SIGNAL, XFilePackage::ID_HARVEST, XFilePackage::onSigHarvest),
    FXMAPFUNC(SEL_CLOSE, 0, XFilePackage::onCmdQuit),
    FXMAPFUNC(SEL_COMMAND, XFilePackage::ID_QUIT, XFilePackage::onCmdQuit),
    FXMAPFUNC(SEL_COMMAND, XFilePackage::ID_UNINSTALL, XFilePackage::onCmdUninstall),
    FXMAPFUNC(SEL_COMMAND, XFilePackage::ID_ABOUT, XFilePackage::onCmdAbout),
    FXMAPFUNC(SEL_COMMAND, XFilePackage::ID_OPEN, XFilePackage::onCmdOpen),
    FXMAPFUNC(SEL_COMMAND, XFilePackage::ID_INSTALL, XFilePackage::onCmdInstall),
};


// Object implementation
FXIMPLEMENT(XFilePackage, FXMainWindow, XFilePackageMap, ARRAYNUMBER(XFilePackageMap))

// Constructor
XFilePackage::XFilePackage(FXApp* a) : FXMainWindow(a, "Xfp", NULL, NULL, DECOR_ALL)
{
    FXString key;
    FXHotKey hotkey;

    setIcon(xfpicon);

    // Make menu bar
    // menubar = new FXMenuBar(this, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_RAISED);

    // Sites where to dock
    FXDockSite* topdock = new FXDockSite(this, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_SUNKEN);
    new FXDockSite(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X);
    new FXDockSite(this, LAYOUT_SIDE_LEFT|LAYOUT_FILL_Y);
    new FXDockSite(this, LAYOUT_SIDE_RIGHT|LAYOUT_FILL_Y);

    // New menu bar
    FXToolBarShell* dragshell0 = new FXToolBarShell(this, FRAME_RAISED);
    menubar = new FXMenuBar(topdock, dragshell0, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|FRAME_RAISED);
    new FXToolBarGrip(menubar, menubar, FXToolBar::ID_TOOLBARGRIP, TOOLBARGRIP_SINGLE);

    // Tool bar
    FXToolBarShell* dragshell1 = new FXToolBarShell(this, FRAME_RAISED);
    toolbar = new FXToolBar(topdock, dragshell1, LAYOUT_DOCK_NEXT|LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_RAISED);
    new FXToolBarGrip(toolbar, toolbar, FXToolBar::ID_TOOLBARGRIP, TOOLBARGRIP_SINGLE);
    int style = BUTTON_TOOLBAR;

    // File menu
    filemenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&File"), NULL, filemenu);

    // Preferences Menu
    prefsmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&Preferences"), NULL, prefsmenu);

    // Help menu
    helpmenu = new FXMenuPane(this);
    new FXMenuTitle(menubar, _("&Help"), NULL, helpmenu);

    // Toolbar button: File open
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "open", "Ctrl-O");
    new FXButton(toolbar, TAB+_("Open package file")+PARS(key), fileopenicon, this, ID_OPEN, style|FRAME_RAISED|LAYOUT_TOP|LAYOUT_LEFT);

    // File Menu entries
    FXMenuCommand* mc = NULL;

    mc = new FXMenuCommand(filemenu, _("&Open..."), fileopenicon, this, ID_OPEN);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "open", "Ctrl-O");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    mc = new FXMenuCommand(filemenu, _("&Quit"), quiticon, this, ID_QUIT);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "quit", "Ctrl-Q");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));
    getAccelTable()->addAccel(KEY_Escape, this, FXSEL(SEL_COMMAND, ID_QUIT));

    // Preferences menu
    new FXMenuCheck(prefsmenu, _("&Toolbar"), toolbar, FXWindow::ID_TOGGLESHOWN);

    // Help Menu entries
    mc = new FXMenuCommand(helpmenu, _("&About X File Package"), NULL, this, ID_ABOUT, 0);
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "help", "F1");
    mc->setAccelText(key);
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, mc, FXSEL(SEL_COMMAND, FXMenuCommand::ID_ACCEL));

    // Close accelerator
    key = getApp()->reg().readStringEntry("KEYBINDINGS", "close", "Ctrl-W");
    hotkey = _parseAccel(key);
    getAccelTable()->addAccel(hotkey, this, FXSEL(SEL_COMMAND, XFilePackage::ID_QUIT));

    // Make a tool tip
    new FXToolTip(getApp(), 0);

    // Buttons
    FXHorizontalFrame* buttons = new FXHorizontalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X);
    new FXDragCorner(buttons);

    // Close
    new FXButton(buttons, _("&Close"), NULL, this, XFilePackage::ID_QUIT, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);

    // Uninstall
    new FXButton(buttons, _("&Uninstall"), NULL, this, XFilePackage::ID_UNINSTALL, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);

    // Install/Upgrade
    new FXButton(buttons, _("&Install/Upgrade"), NULL, this, XFilePackage::ID_INSTALL, FRAME_RAISED|FRAME_THICK|LAYOUT_RIGHT|LAYOUT_CENTER_Y, 0, 0, 0, 0, 20, 20);

    // Switcher
    FXTabBook* tabbook = new FXTabBook(this, NULL, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y|LAYOUT_RIGHT|FRAME_NONE, 0, 0, 0, 0, 0, 0, 0, 0);

    // First item is Description
    new FXTabItem(tabbook, _("&Description"), NULL);
    FXVerticalFrame* descr = new FXVerticalFrame(tabbook);
    FXPacker*        p = new FXPacker(descr, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_SUNKEN|FRAME_THICK, 0, 0, 0, 0, 0, 0, 0, 0);
    description = new FXText(p, this, XFilePackage::ID_DESCRIPTION, LAYOUT_FILL_X|LAYOUT_FILL_Y);

    // Second item is File List
    new FXTabItem(tabbook, _("File &List"), NULL);
    FXVerticalFrame* flistfr = new FXVerticalFrame(tabbook);
    p = new FXPacker(flistfr, LAYOUT_FILL_X|LAYOUT_FILL_Y|FRAME_SUNKEN|FRAME_THICK, 0, 0, 0, 0, 0, 0, 0, 0);
    list = new FXTreeList(p, this, XFilePackage::ID_FILELIST, LAYOUT_FILL_X|LAYOUT_FILL_Y|TREELIST_SHOWS_LINES);

    // Initialize file name
    filename = "";

    // Other initializations
    smoothscroll = true;
    errorflag = false;
}


// Destructor
XFilePackage::~XFilePackage()
{
    delete menubar;
    delete toolbar;
    delete filemenu;
    delete prefsmenu;
    delete helpmenu;
    delete list;
    delete description;
}


// About box
long XFilePackage::onCmdAbout(FXObject*, FXSelector, void*)
{
    FXString msg;

    msg.format(_("X File Package Version %s is a simple rpm or deb package manager.\n\n"), VERSION);
    msg += COPYRIGHT;
    MessageBox about(this, _("About X File Package"), msg.text(), xfpicon, BOX_OK|DECOR_TITLE|DECOR_BORDER,
                     JUSTIFY_CENTER_X|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X|LAYOUT_FILL_Y);
    about.execute(PLACEMENT_OWNER);
    return(1);
}


// Open package
long XFilePackage::onCmdOpen(FXObject*, FXSelector, void*)
{
    const char* patterns[] =
    {
        _("All Files"), "*",
        _("RPM source packages"), "*.src.rpm",
        _("RPM packages"), "*.rpm",
        _("DEB packages"), "*.deb",
        NULL
    };

    FileDialog opendialog(this, _("Open Document"));

    opendialog.setSelectMode(SELECTFILE_EXISTING);
    opendialog.setPatternList(patterns);
    opendialog.setDirectory(FXPath::directory(filename));
    if (opendialog.execute())
    {
        filename = opendialog.getFilename();
        readDescription();
        readFileList();
    }

    return(1);
}


// Install/upgrade package
long XFilePackage::onCmdInstall(FXObject*, FXSelector, void*)
{
    FXString cmd;

    getApp()->flush();

    if (strlen(filename.text()) == 0)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("No package loaded"));
        return(0);
    }

    // Package name
    FXString package = FXPath::name(filename);

    // Command to perform
    FXString ext = FXPath::extension(filename);
    if (comparecase(ext, "rpm") == 0)
    {
        cmd = "rpm -Uvh "+filename;
    }
    else if (comparecase(ext, "deb") == 0)
    {
        cmd = "dpkg -i "+filename;
    }
    else
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Unknown package format"));
        return(0);
    }

    // Make and show command window
    CommandWindow* cmdwin = new CommandWindow(this, _("Install/Upgrade Package"), cmd, 10, 80);
    cmdwin->create();

    FXString msg;
    msg.format(_("Installing package: %s \n"), package.text());
    cmdwin->appendText(msg.text());

    // The CommandWindow object will delete itself when closed!

    return(1);
}


// Uninstall package based on the package name (version is ignored)
long XFilePackage::onCmdUninstall(FXObject*, FXSelector, void*)
{
    FXString cmd;

    getApp()->flush();

    if (strlen(filename.text()) == 0)
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("No package loaded"));
        return(0);
    }

    // Command to perform
    FXString package;
    FXString ext = FXPath::extension(filename);
    if (comparecase(ext, "rpm") == 0)
    {
        // Get package name
        package = FXPath::name(filename);
        package = package.section('-', 0);
        cmd = "rpm -e "+ package;
    }
    else if (comparecase(ext, "deb") == 0)
    {
        // Get package name
        package = FXPath::name(filename);
        package = package.section('_', 0);
        cmd = "dpkg -r "+ package;
    }
    else
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Unknown package format"));
        return(0);
    }

    // Make and show command window
    CommandWindow* cmdwin = new CommandWindow(this, _("Uninstall Package"), cmd, 10, 80);
    cmdwin->create();

    FXString msg;
    msg.format(_("Uninstalling package: %s \n"), package.text());
    cmdwin->appendText(msg.text());

    // The CommandWindow object will delete itself when closed!

    return(1);
}


// Save configuration when quitting
void XFilePackage::saveConfig()
{
    // Write new window size and position back to registry
    getApp()->reg().writeUnsignedEntry("OPTIONS", "width", (FXuint)getWidth());
    getApp()->reg().writeUnsignedEntry("OPTIONS", "height", (FXuint)getHeight());

    if (save_win_pos)
    {
        // Account for the Window Manager border size
        XWindowAttributes xwattr;
        if (XGetWindowAttributes((Display*)getApp()->getDisplay(), this->id(), &xwattr))
        {
            getApp()->reg().writeIntEntry("OPTIONS", "xpos", getX()-xwattr.x);
            getApp()->reg().writeIntEntry("OPTIONS", "ypos", getY()-xwattr.y);
        }
        else
        {
            getApp()->reg().writeIntEntry("OPTIONS", "xpos", getX());
            getApp()->reg().writeIntEntry("OPTIONS", "ypos", getY());
        }
    }

    // Last opened filename
    getApp()->reg().writeStringEntry("OPTIONS", "filename", filename.text());

    // Toolbar status
    if (toolbar->shown())
    {
        getApp()->reg().writeUnsignedEntry("OPTIONS", "showtoolbar", true);
    }
    else
    {
        getApp()->reg().writeUnsignedEntry("OPTIONS", "showtoolbar", false);
    }

    // Write registry options
    getApp()->reg().write();
}


// Harvest the zombies
long XFilePackage::onSigHarvest(FXObject*, FXSelector, void*)
{
    while (waitpid(-1, NULL, WNOHANG) > 0)
    {
    }
    return(1);
}


// Quit application
long XFilePackage::onCmdQuit(FXObject*, FXSelector, void*)
{
    // Save options
    saveConfig();

    // Exit
    getApp()->exit(EXIT_SUCCESS);
    return(1);
}


// Update file list
int XFilePackage::readFileList(void)
{
    FXString cmd;

    FXString ext = FXPath::extension(filename);

    if (comparecase(ext, "rpm") == 0)
    {
        errorflag = false;
        cmd = "rpm -qlp "+::quote(filename);
    }
    else if (comparecase(ext, "deb") == 0)
    {
        errorflag = false;
        cmd = "dpkg -c "+::quote(filename);
    }
    else if (errorflag == false)
    {
        errorflag = true;
        list->clearItems();
        MessageBox::error(this, BOX_OK, _("Error"), _("Unknown package format"));
        return(0);
    }

    FILE* pcmd = popen(cmd.text(), "r");
    if (!pcmd)
    {
        perror("popen");
        exit(EXIT_FAILURE);
    }
    char     text[10000] = { 0 };
    FXString str;
    str = FXPath::name(filename);
    strlcpy(text, str.text(), str.length()+1);

    // Clear list
    list->clearItems();

    // First item
    getApp()->beginWaitCursor();
    FXTreeItem* topmost;
    topmost = list->prependItem(NULL, text, minifoldericon, minifolderopenicon);

    // Next items
    while (fgets(text, sizeof(text), pcmd))
    {
        text[strlen(text)-1] = '\0'; // kill trailing lf
        list->appendItem(topmost, text, minidocicon, minidocicon);

        // Force refresh
        getApp()->forceRefresh();
        getApp()->repaint();
    }
    list->expandTree(topmost);
    getApp()->endWaitCursor();

    pclose(pcmd);
    return(1);
}


int XFilePackage::readDescription(void)
{
    FXString cmd;
    FXString buf;

    FXString ext = FXPath::extension(filename);

    if (comparecase(ext, "rpm") == 0)
    {
        errorflag = false;
        cmd = "rpm -qip "+::quote(filename);
        buf += _("[RPM package]\n");
    }
    else if (comparecase(ext, "deb") == 0)
    {
        errorflag = false;
        buf += _("[DEB package]\n");
        cmd = "dpkg -I "+::quote(filename);
    }
    else if (errorflag == false)
    {
        errorflag = true;
        list->clearItems();
        MessageBox::error(this, BOX_OK, _("Error"), _("Unknown package format"));
        return(0);
    }

    FILE* pcmd = popen(cmd.text(), "r");
    if (!pcmd)
    {
        perror("popen");
        exit(EXIT_FAILURE);
    }

    // Don't display the header for Debian packages
    int suppress_header = 0;
    if (comparecase(ext, "deb") == 0)
    {
        suppress_header = 1;
    }

    char text[10000] = { 0 };
    while (fgets(text, sizeof(text), pcmd))
    {
        if (suppress_header)
        {
            suppress_header = (strstr(text, "Package:") == NULL);
        }
        if (!suppress_header)
        {
            buf += text;
        }
    }
    if ((pclose(pcmd) == -1) && (errno != ECHILD))  // ECHILD can be set if the child was caught by sigHarvest
    {
        MessageBox::error(this, BOX_OK, _("Error"), _("Query of %s failed!"), filename.text());
        list->clearItems();
        description->setText("");
        filename = "";
    }
    else
    {
        description->setText(buf.text());
    }

    return(1);
}


// Start the ball rolling
void XFilePackage::start(FXString startpkg)
{
    filename = startpkg;

    if (filename != "")
    {
        FILE* fp = fopen(filename.text(), "r");
        if (!fp)
        {
            MessageBox::error(this, BOX_OK, _("Error Loading File"), _("Unable to open file: %s"), filename.text());
            filename = "";
        }
        else
        {
            fclose(fp);
            readDescription();
            readFileList();
        }
    }
    else
    {
        filename = "";
    }
}


void XFilePackage::create()
{
    // Read the Xfe registry
    FXRegistry* reg_xfe = new FXRegistry(XFEAPPNAME, "");

    reg_xfe->read();

    // Set Xfp text font according to the Xfe registry
    FXString fontspec;
    fontspec = reg_xfe->readStringEntry("SETTINGS", "textfont", DEFAULT_TEXT_FONT);
    if (!fontspec.empty())
    {
        FXFont* font = new FXFont(getApp(), fontspec);
        font->create();
        description->setFont(font);
        list->setFont(font);
    }
    delete reg_xfe;

    // Get toolbar status
    if (getApp()->reg().readUnsignedEntry("OPTIONS", "showtoolbar", true) == false)
    {
        toolbar->hide();
    }

    // Get size
    FXuint width = getApp()->reg().readUnsignedEntry("OPTIONS", "width", DEFAULT_WINDOW_WIDTH);
    FXuint height = getApp()->reg().readUnsignedEntry("OPTIONS", "height", DEFAULT_WINDOW_HEIGHT);

    // Get position and position window
    if (save_win_pos)
    {
        int xpos = getApp()->reg().readIntEntry("OPTIONS", "xpos", DEFAULT_WINDOW_XPOS);
        int ypos = getApp()->reg().readIntEntry("OPTIONS", "ypos", DEFAULT_WINDOW_YPOS);
        position(xpos, ypos, width, height);
    }
    else
    {
        position(getX(), getY(), width, height);
    }

    FXMainWindow::create();

    // This is necessary otherwise Xfp crashes when opening a package, but why?
    minifoldericon->create();
    minifolderopenicon->create();
    minidocicon->create();

    // Description is not editable
    description->handle(this, FXSEL(SEL_COMMAND, FXText::ID_TOGGLE_EDITABLE), NULL);

    // Show window
    show();

#ifdef STARTUP_NOTIFICATION
    startup_completed();
#endif
}


// Usage message
#define USAGE_MSG    _("\
\nUsage: xfp [options] [package] \n\
\n\
    [options] can be any of the following:\n\
\n\
        -h, --help         Print (this) help screen and exit.\n\
        -v, --version      Print version information and exit.\n\
\n\
    [package] is the path to the rpm or deb package you want to open on start up.\n\
\n")



// Main function to start the program
int main(int argc, char* argv[])
{
    int         i;
    FXString    startpkg = "";
    const char* appname = "xfp";
    const char* xfename = XFEAPPNAME;
    const char* vdrname = XFEVDRNAME;
    FXbool      loadicons;
    FXString    xmodifiers;

    // Get environment variables $HOME, $XDG_DATA_HOME and $XDG_CONFIG_HOME
    homedir = FXSystem::getHomeDirectory();
    if (homedir == "")
    {
        homedir = ROOTDIR;
    }
    xdgdatahome = getenv("XDG_DATA_HOME");
    if (xdgdatahome == "")
    {
        xdgdatahome = homedir + PATHSEPSTRING DATAPATH;
    }
    xdgconfighome = getenv("XDG_CONFIG_HOME");
    if (xdgconfighome == "")
    {
        xdgconfighome = homedir + PATHSEPSTRING CONFIGPATH;
    }

    // Detect if an X input method is used
    xmodifiers = getenv("XMODIFIERS");
    if ((xmodifiers == "") || (xmodifiers == "@im=none"))
    {
        xim_used = false;
    }
    else
    {
        xim_used = true;
    }

#ifdef HAVE_SETLOCALE
    // Set locale via LC_ALL.
    setlocale(LC_ALL, "");
#endif

#if ENABLE_NLS
    // Set the text message domain.
    bindtextdomain(PACKAGE, LOCALEDIR);
    bind_textdomain_codeset(PACKAGE, "utf-8");
    textdomain(PACKAGE);
#endif

    // Parse basic arguments
    for (i = 1; i < argc; ++i)
    {
        if ((compare(argv[i], "-v") == 0) || (compare(argv[i], "--version") == 0))
        {
            fprintf(stdout, "%s version %s\n", PACKAGE, VERSION);
            exit(EXIT_SUCCESS);
        }
        else if ((compare(argv[i], "-h") == 0) || (compare(argv[i], "--help") == 0))
        {
            fprintf(stdout, USAGE_MSG);
            exit(EXIT_SUCCESS);
        }
        else
        {
            // Start file, if any
            startpkg = argv[i];
        }
    }

    // Global variable
    args = argv;

    // Make application
    FXApp* application = new FXApp(appname, vdrname);

    // Open display
    application->init(argc, argv);

    // Redefine the default hand cursor
    FXCursor* hand = new FXCursor(application, hand_bits, hand_mask_bits, hand_width, hand_height, hand_x_hot, hand_y_hot);
    application->setDefaultCursor(DEF_HAND_CURSOR, hand);

    // Load all application icons
    loadicons = loadAppIcons(application);

    // Read the Xfe registry
    FXRegistry* reg_xfe;
    reg_xfe = new FXRegistry(xfename, vdrname);
    reg_xfe->read();

    // Set base color (to change the default base color at first run)
    FXColor basecolor = reg_xfe->readColorEntry("SETTINGS", "basecolor", FXRGB(237, 233, 227));
    application->setBaseColor(basecolor);

    // Set Xfp normal font according to the Xfe registry
    FXString fontspec;
    fontspec = reg_xfe->readStringEntry("SETTINGS", "font", DEFAULT_NORMAL_FONT);
    if (!fontspec.empty())
    {
        FXFont* normalFont = new FXFont(application, fontspec);
        normalFont->create();
        application->setNormalFont(normalFont);
    }

    // Set single click navigation according to the Xfe registry
    single_click = reg_xfe->readUnsignedEntry("SETTINGS", "single_click", SINGLE_CLICK_NONE);

    // Set smooth scrolling according to the Xfe registry
    FXbool smoothscroll = reg_xfe->readUnsignedEntry("SETTINGS", "smooth_scroll", true);

    // Set file list tooltip flag according to the Xfe registry
    file_tooltips = reg_xfe->readUnsignedEntry("SETTINGS", "file_tooltips", true);

    // Set relative resizing flag according to the Xfe registry
    relative_resize = reg_xfe->readUnsignedEntry("SETTINGS", "relative_resize", true);

    // Get value of the window position flag
    save_win_pos = reg_xfe->readUnsignedEntry("SETTINGS", "save_win_pos", false);

    // Delete the Xfe registry
    delete reg_xfe;

    // Make window
    XFilePackage* window = new XFilePackage(application);

    // Catch SIGCHLD to harvest zombie child processes
    application->addSignal(SIGCHLD, window, XFilePackage::ID_HARVEST, true);

    // Smooth scrolling
    window->setSmoothScroll(smoothscroll);

    // Create it
    application->create();
    if (!loadicons)
    {
        MessageBox::error(application, BOX_OK, _("Error loading icons"), _("Unable to load some icons. Please check your icons path!"));
    }

    // Tooltips setup time and duration
    application->setTooltipPause(TOOLTIP_PAUSE);
    application->setTooltipTime(TOOLTIP_TIME);

    // Test the existence of the Debian package manager (dpkg)
    // and the RedHat package manager (rpm)
    FXString cmd = "dpkg --version";
    FXString str = getCommandOutput(cmd);

    if (str.find("Debian") != -1)
    {
        dpkg = true;
    }

    cmd = "rpm --version";
    str = getCommandOutput(cmd);

    if (str.find("RPM") != -1)
    {
        rpm = true;
    }

    // No package manager was found
    if ((dpkg == false) && (rpm == false))
    {
        MessageBox::error(window, BOX_OK, _("Error"), _("No compatible package manager (rpm or dpkg) found!"));
        exit(EXIT_FAILURE);
    }

    // Start
    window->start(startpkg);

    // Run the application
    return(application->run());
}
// This is adapted from 'adie', a demo text editor found
// in the FOX library and written by Jeroen van der Zijp.

#include "config.h"
#include "i18n.h"


#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "startupnotification.h"
#include "MessageBox.h"
#include "DirList.h"
#include "WriteWindow.h"
#include "XFileWrite.h"

// Add FOX hacks
#include "foxhacks.cpp"
#include "clearlooks.cpp"

// Global variables
FXColor  highlightcolor;
FXbool   allowPopupScroll = false;
FXuint   single_click;
FXbool   file_tooltips;
FXbool   relative_resize;
FXString homedir;
FXString xdgconfighome;
FXString xdgdatahome;
FXbool   xim_used = false;


// Hand cursor replacement
#define hand_width     32
#define hand_height    32
#define hand_x_hot     6
#define hand_y_hot     1
static const FXuchar hand_bits[] =
{
    0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00,
    0x90, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x90, 0x07, 0x00, 0x00,
    0x97, 0x1a, 0x00, 0x00, 0x99, 0x2a, 0x00, 0x00, 0x11, 0x28, 0x00, 0x00,
    0x12, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00,
    0x04, 0x20, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00,
    0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const FXuchar hand_mask_bits[] =
{
    0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
    0xf0, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00,
    0xf7, 0x1f, 0x00, 0x00, 0xff, 0x3f, 0x00, 0x00, 0xff, 0x3f, 0x00, 0x00,
    0xfe, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00,
    0xfc, 0x3f, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00,
    0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// Map
FXDEFMAP(XFileWrite) XFileWriteMap[] =
{
    FXMAPFUNC(SEL_SIGNAL, XFileWrite::ID_CLOSEALL, XFileWrite::onCmdCloseAll),
    FXMAPFUNC(SEL_COMMAND, XFileWrite::ID_CLOSEALL, XFileWrite::onCmdCloseAll),
};


// Object implementation
FXIMPLEMENT(XFileWrite, FXApp, XFileWriteMap, ARRAYNUMBER(XFileWriteMap))


// Make some windows
XFileWrite::XFileWrite(const FXString& appname, const FXString& vdrname) : FXApp(appname, vdrname)
{
    // If interrupt happens, quit gracefully; we may want to
    // save edit buffer contents w/o asking if display gets
    // disconnected or if hangup signal is received.
    addSignal(SIGINT, this, ID_CLOSEALL);
    addSignal(SIGQUIT, this, ID_CLOSEALL);
    addSignal(SIGHUP, this, ID_CLOSEALL);
    addSignal(SIGPIPE, this, ID_CLOSEALL);
}


// Initialize application
void XFileWrite::init(int& argc, char** argv, bool connect)
{
    // After init, the registry has been loaded
    FXApp::init(argc, argv, connect);
}


// Exit application
void XFileWrite::exit(int code)
{
    // Write registry, and quit
    FXApp::exit(code);
}


// Close all windows
long XFileWrite::onCmdCloseAll(FXObject*, FXSelector, void*)
{
    while (0 < windowlist.no() && windowlist[0]->close(true))
    {
    }
    return(1);
}


// Clean up
XFileWrite::~XFileWrite()
{
    FXASSERT(windowlist.no() == 0);
}


// Usage message
#define USAGE_MSG    _("\
\nUsage: xfw [options] [file1] [file2] [file3]...\n\
\n\
    [options] can be any of the following:\n\
\n\
        -r, --read-only    Open files in read-only mode.\n\
        -h, --help         Print (this) help screen and exit.\n\
        -v, --version      Print version information and exit.\n\
\n\
    [file1] [file2] [file3]... are the path(s) to the file(s) you want to open on start up.\n\
\n")


// Start the whole thing
int main(int argc, char* argv[])
{
    WriteWindow* window = NULL;
    FXString     file;
    int          i;
    const char*  appname = "xfw";
    const char*  xfename = XFEAPPNAME;
    const char*  vdrname = XFEVDRNAME;
    FXbool       loadicons;
    FXbool       readonly = false;
    FXString     xmodifiers;

    // Get environment variables $HOME, $XDG_DATA_HOME and $XDG_CONFIG_HOME
    homedir = FXSystem::getHomeDirectory();
    if (homedir == "")
    {
        homedir = ROOTDIR;
    }
    xdgdatahome = getenv("XDG_DATA_HOME");
    if (xdgdatahome == "")
    {
        xdgdatahome = homedir + PATHSEPSTRING DATAPATH;
    }
    xdgconfighome = getenv("XDG_CONFIG_HOME");
    if (xdgconfighome == "")
    {
        xdgconfighome = homedir + PATHSEPSTRING CONFIGPATH;
    }

    // Detect if an X input method is used
    xmodifiers = getenv("XMODIFIERS");
    if ((xmodifiers == "") || (xmodifiers == "@im=none"))
    {
        xim_used = false;
    }
    else
    {
        xim_used = true;
    }

#ifdef HAVE_SETLOCALE
    // Set locale via LC_ALL.
    setlocale(LC_ALL, "");
#endif

#if ENABLE_NLS
    // Set the text message domain.
    bindtextdomain(PACKAGE, LOCALEDIR);
    bind_textdomain_codeset(PACKAGE, "utf-8");
    textdomain(PACKAGE);
#endif

    // Make application
    XFileWrite* application = new XFileWrite(appname, vdrname);

    // Open display
    application->init(argc, argv);

    // Redefine the default hand cursor
    FXCursor* hand = new FXCursor(application, hand_bits, hand_mask_bits, hand_width, hand_height, hand_x_hot, hand_y_hot);
    application->setDefaultCursor(DEF_HAND_CURSOR, hand);

    // Load all application icons
    loadicons = loadAppIcons(application);

    // Read the Xfe registry
    FXRegistry* reg_xfe = new FXRegistry(xfename, vdrname);
    reg_xfe->read();

    // Set base color (to change the default base color at first run)
    FXColor basecolor = reg_xfe->readColorEntry("SETTINGS", "basecolor", FXRGB(237, 233, 227));
    application->setBaseColor(basecolor);

    // Set Xfw normal font according to the Xfe registry
    FXString fontspec;
    fontspec = reg_xfe->readStringEntry("SETTINGS", "font", DEFAULT_NORMAL_FONT);
    if (!fontspec.empty())
    {
        FXFont* normalFont = new FXFont(application, fontspec);
        application->setNormalFont(normalFont);
    }

    // Set single click navigation according to the Xfe registry
    single_click = reg_xfe->readUnsignedEntry("SETTINGS", "single_click", SINGLE_CLICK_NONE);

    // Set smooth scrolling according to the Xfe registry
    FXbool smoothscroll = reg_xfe->readUnsignedEntry("SETTINGS", "smooth_scroll", true);

    // Set file list tooltip flag according to the Xfe registry
    file_tooltips = reg_xfe->readUnsignedEntry("SETTINGS", "file_tooltips", true);

    // Set relative resizing flag according to the Xfe registry
    relative_resize = reg_xfe->readUnsignedEntry("SETTINGS", "relative_resize", true);

    // Delete the Xfe registry
    delete reg_xfe;

    // Make a tool tip
    new FXToolTip(application, 0);

    // Create application
    application->create();
    if (!loadicons)
    {
        MessageBox::error(application, BOX_OK, _("Error loading icons"), _("Unable to load some icons. Please check your icons path!"));
    }

    // Tooltips setup time and duration
    application->setTooltipPause(TOOLTIP_PAUSE);
    application->setTooltipTime(TOOLTIP_TIME);

    // Parse basic arguments
    for (i = 1; i < argc; ++i)
    {
        // Parse a few options
        if ((compare(argv[i], "-v") == 0) || (compare(argv[i], "--version") == 0))
        {
            fprintf(stdout, "%s version %s\n", PACKAGE, VERSION);
            exit(EXIT_SUCCESS);
        }
        if ((compare(argv[i], "-h") == 0) || (compare(argv[i], "--help") == 0))
        {
            fprintf(stdout, USAGE_MSG);
            exit(EXIT_SUCCESS);
        }

        if ((compare(argv[i], "-r") == 0) || (compare(argv[i], "--read-only") == 0))
        {
            readonly = true;
        }

        // Load the file
        else
        {
            file = FXPath::absolute(argv[i]);
            window = new WriteWindow(application, _("Untitled"), readonly);

            // Catch SIGCHLD to harvest zombie child processes
            application->addSignal(SIGCHLD, window, WriteWindow::ID_HARVEST, true);

            window->setSmoothScroll(smoothscroll);
            window->create();
            window->loadFile(file);
        }
    }

    // Make window, if none opened yet
    if (!window)
    {
        window = new WriteWindow(application, _("Untitled"), readonly);

        // Catch SIGCHLD to harvest zombie child processes
        application->addSignal(SIGCHLD, window, WriteWindow::ID_HARVEST, true);

        window->setSmoothScroll(smoothscroll);
        window->create();
    }

    // Run
    return(application->run());
}
#include "comboarrow.xbm"
#include "icons.h"
// This file contains some FOX functions redefinitions (FOX hacks for the Clearlooks controls)
// The Clearlooks controls try to mimic the GTK Clearlooks theme
// They are optional and can be set within the Preferences dialog
// The hack is done mainly by redefining the onPaint() functions of the various widgets



//
// Some useful functions and macros
//


// Draw rectangle with gradient effect
// Default is vertical gradient
static void drawGradientRectangle(FXDC& dc, FXColor upper, FXColor lower, int x, int y, int w, int h, FXbool vert = true)
{
    register int rr, gg, bb, dr, dg, db, r1, g1, b1, r2, g2, b2, yl, yh, yy, dy, n, t, ww;
    const int    MAXSTEPS = 128;

    if ((0 < w) && (0 < h))
    {
        // Horizontal gradient : exchange w and h
        if (!vert)
        {
            ww = w;
            w = h;
            h = ww;
        }

        dc.setStipple(STIPPLE_NONE);
        dc.setFillStyle(FILL_SOLID);

        r1 = FXREDVAL(upper);
        r2 = FXREDVAL(lower);
        dr = r2-r1;
        g1 = FXGREENVAL(upper);
        g2 = FXGREENVAL(lower);
        dg = g2-g1;
        b1 = FXBLUEVAL(upper);
        b2 = FXBLUEVAL(lower);
        db = b2-b1;

        n = FXABS(dr);
        if ((t = FXABS(dg)) > n)
        {
            n = t;
        }
        if ((t = FXABS(db)) > n)
        {
            n = t;
        }
        n++;
        if (n > h)
        {
            n = h;
        }
        if (n > MAXSTEPS)
        {
            n = MAXSTEPS;
        }
        rr = (r1<<16)+32767;
        gg = (g1<<16)+32767;
        bb = (b1<<16)+32767;
        yy = 32767;

        dr = (dr<<16)/n;
        dg = (dg<<16)/n;
        db = (db<<16)/n;
        dy = (h<<16)/n;

        do
        {
            yl = yy>>16;
            yy += dy;
            yh = yy>>16;
            dc.setForeground(FXRGB(rr>>16, gg>>16, bb>>16));

            // Vertical gradient
            if (vert)
            {
                dc.fillRectangle(x, y+yl, w, yh-yl);
            }

            // Horizontal gradient
            else
            {
                dc.fillRectangle(x+yl, y, yh-yl, w);
            }

            rr += dr;
            gg += dg;
            bb += db;
        } while (yh < h);
    }
}


// These macros are used to simplify the code
// They draw a button in Standard or Clearlooks mode, in up or down state

#define DRAW_CLEARLOOKS_BUTTON_UP                                              \
    dc.setForeground(backColor);                                               \
    dc.drawPoints(basebackground, 4);                                          \
                                                                               \
    dc.setForeground(bordercolor);                                             \
    dc.drawRectangle(2, 0, width-5, 0);                                        \
    dc.drawRectangle(2, height-1, width-5, height-1);                          \
    dc.drawRectangle(0, 2, 0, height-5);                                       \
    dc.drawRectangle(width-1, 2, 0, height-5);                                 \
    dc.drawPoints(bordercorners, 4);                                           \
    dc.setForeground(shadecolor);                                              \
    dc.drawPoints(bordershade, 16);                                            \
                                                                               \
    drawGradientRectangle(dc, topcolor, bottomcolor, 2, 1, width-4, height-2); \
    dc.setForeground(topcolor);                                                \
    dc.drawRectangle(1, 3, 0, height-7);                                       \
    dc.setForeground(bottomcolor);                                             \
    dc.drawRectangle(width-2, 3, 0, height-7);


#define DRAW_CLEARLOOKS_BUTTON_DOWN                   \
    dc.setForeground(shadecolor);                     \
    dc.fillRectangle(0, 0, width, height);            \
                                                      \
    dc.setForeground(backColor);                      \
    dc.drawPoints(basebackground, 4);                 \
                                                      \
    dc.setForeground(bordercolor);                    \
    dc.drawRectangle(2, 0, width-5, 0);               \
    dc.drawRectangle(2, height-1, width-5, height-1); \
    dc.drawRectangle(0, 2, 0, height-5);              \
    dc.drawRectangle(width-1, 2, 0, height-5);        \
    dc.drawPoints(bordercorners, 4);                  \
    dc.setForeground(shadecolor);                     \
    dc.drawPoints(bordershade, 16);


#define DRAW_STANDARD_BUTTON_UP                                        \
    dc.setForeground(backColor);                                       \
    dc.fillRectangle(border, border, width-border*2, height-border*2); \
    if (options&FRAME_THICK) {                                         \
        drawDoubleRaisedRectangle(dc, 0, 0, width, height); }          \
    else{                                                              \
        drawRaisedRectangle(dc, 0, 0, width, height); }


#define DRAW_STANDARD_BUTTON_DOWN                                      \
    dc.setForeground(hiliteColor);                                     \
    dc.fillRectangle(border, border, width-border*2, height-border*2); \
    if (options&FRAME_THICK) {                                         \
        drawDoubleSunkenRectangle(dc, 0, 0, width, height); }          \
    else{                                                              \
        drawSunkenRectangle(dc, 0, 0, width, height); }


#define INIT_CLEARLOOKS                                                                          \
    static FXbool init = true;                                                                   \
    static FXbool  use_clearlooks = true;                                                        \
    static FXColor topcolor, bottomcolor, shadecolor, bordercolor;                               \
                                                                                                 \
    FXPoint basebackground[4] = { FXPoint(0, 0), FXPoint(width-1, 0), FXPoint(0, height-1),      \
                                  FXPoint(width-1, height-1) };                                  \
    FXPoint bordershade[16] = { FXPoint(0, 1), FXPoint(1, 0), FXPoint(1, 2), FXPoint(2, 1),      \
                                FXPoint(width-2, 0), FXPoint(width-1, 1), FXPoint(width-3, 1),   \
                                FXPoint(width-2, 2), FXPoint(0, height-2), FXPoint(1, height-1), \
                                FXPoint(1, height-3), FXPoint(2, height-2),                      \
                                FXPoint(width-1, height-2), FXPoint(width-2, height-1),          \
                                FXPoint(width-2, height-3), FXPoint(width-3, height-2)           \
    };                                                                                           \
    FXPoint bordercorners[4] = { FXPoint(1, 1), FXPoint(1, height-2), FXPoint(width-2, 1),       \
                                 FXPoint(width-2, height-2) };                                   \
                                                                                                 \
    if (init)                                                                                    \
    {                                                                                            \
        use_clearlooks = getApp()->reg().readUnsignedEntry("SETTINGS", "use_clearlooks", true);  \
                                                                                                 \
        if (use_clearlooks)                                                                      \
        {                                                                                        \
            FXuint r = FXREDVAL(baseColor);                                                      \
            FXuint g = FXGREENVAL(baseColor);                                                    \
            FXuint b = FXBLUEVAL(baseColor);                                                     \
                                                                                                 \
            topcolor = FXRGB(FXMIN(1.1*r, 255), FXMIN(1.1*g, 255), FXMIN(1.1*b, 255));           \
            (void)topcolor;      /* Hack to avoid unused variable compiler warning */            \
            bottomcolor = FXRGB(0.9*r, 0.9*g, 0.9*b);                                            \
            (void)bottomcolor;   /* Hack to avoid unused variable compiler warning */            \
            shadecolor = FXRGB(0.9*r, 0.9*g, 0.9*b);                                             \
            bordercolor = FXRGB(0.5*r, 0.5*g, 0.5*b);                                            \
        }                                                                                        \
        init = false;                                                                            \
    }



//
// Hack of FXButton (button with gradient effect and rounded corners)
// Original author : Sander Jansen <sander@knology.net>
//


// Handle repaint
long FXButton::onPaint(FXObject*, FXSelector, void* ptr)
{
    // Initialize Clearlooks
    INIT_CLEARLOOKS

    FXEvent*   ev = (FXEvent*)ptr;
    FXDCWindow dc(this, ev);
    int        tw = 0, th = 0, iw = 0, ih = 0, tx, ty, ix, iy;

    // Button with nice gradient effect and rounded corners (Clearlooks)
    if (use_clearlooks)
    {
        // Toolbar style
        if (options&BUTTON_TOOLBAR)
        {
            // Enabled and cursor inside, and up
            if (isEnabled() && underCursor() && (state == STATE_UP))
            {
                DRAW_CLEARLOOKS_BUTTON_UP
            }

            // Enabled and cursor inside and down
            else if (isEnabled() && underCursor() && (state == STATE_DOWN))
            {
                DRAW_CLEARLOOKS_BUTTON_DOWN
            }

            // Enabled and checked
            else if (isEnabled() && (state == STATE_ENGAGED))
            {
                DRAW_CLEARLOOKS_BUTTON_UP
            }

            // Disabled or unchecked or not under cursor
            else
            {
                dc.setForeground(backColor);
                dc.fillRectangle(0, 0, width, height);
            }
        }

        // Normal style
        else
        {
            // Draw in up state if disabled or up
            if (!isEnabled() || (state == STATE_UP))
            {
                DRAW_CLEARLOOKS_BUTTON_UP
            }

            // Draw in down state if enabled and either checked or pressed
            else
            {
                DRAW_CLEARLOOKS_BUTTON_DOWN
            }
        }
    }   // End of gradient painting

    // Normal flat rectangular button
    else
    {
        // Got a border at all?
        if (options&(FRAME_RAISED|FRAME_SUNKEN))
        {
            // Toolbar style
            if (options&BUTTON_TOOLBAR)
            {
                // Enabled and cursor inside, and up
                if (isEnabled() && underCursor() && (state == STATE_UP))
                {
                    DRAW_STANDARD_BUTTON_UP
                }

                // Enabled and cursor inside and down
                else if (isEnabled() && underCursor() && (state == STATE_DOWN))
                {
                    DRAW_STANDARD_BUTTON_DOWN
                }

                // Enabled and checked
                else if (isEnabled() && (state == STATE_ENGAGED))
                {
                    DRAW_STANDARD_BUTTON_DOWN
                }

                // Disabled or unchecked or not under cursor
                else
                {
                    dc.setForeground(backColor);
                    dc.fillRectangle(0, 0, width, height);
                }
            }

            // Normal style
            else
            {
                // Draw in up state if disabled or up
                if (!isEnabled() || (state == STATE_UP))
                {
                    DRAW_STANDARD_BUTTON_UP
                }

                // Draw sunken if enabled and either checked or pressed
                // Caution! This one is different!
                else
                {
                    if (state == STATE_ENGAGED)
                    {
                        dc.setForeground(hiliteColor);
                    }
                    else
                    {
                        dc.setForeground(backColor);
                    }
                    dc.fillRectangle(border, border, width-border*2, height-border*2);
                    if (options&FRAME_THICK)
                    {
                        drawDoubleSunkenRectangle(dc, 0, 0, width, height);
                    }
                    else
                    {
                        drawSunkenRectangle(dc, 0, 0, width, height);
                    }
                }
            }
        }

        // No borders
        else
        {
            if (isEnabled() && (state == STATE_ENGAGED))
            {
                dc.setForeground(hiliteColor);
                dc.fillRectangle(0, 0, width, height);
            }
            else
            {
                dc.setForeground(backColor);
                dc.fillRectangle(0, 0, width, height);
            }
        }
    }   // End of normal painting

    // Place text & icon
    if (!label.empty())
    {
        tw = labelWidth(label);
        th = labelHeight(label);
    }
    if (icon)
    {
        iw = icon->getWidth();
        ih = icon->getHeight();
    }

    just_x(tx, ix, tw, iw);
    just_y(ty, iy, th, ih);

    // Shift a bit when pressed
    if (state && (options&(FRAME_RAISED|FRAME_SUNKEN)))
    {
        ++tx;
        ++ty;
        ++ix;
        ++iy;
    }

    // Draw enabled state
    if (isEnabled())
    {
        if (icon)
        {
            dc.drawIcon(icon, ix, iy);
        }
        if (!label.empty())
        {
            dc.setFont(font);
            dc.setForeground(textColor);
            drawLabel(dc, label, hotoff, tx, ty, tw, th);
        }
        if (hasFocus())
        {
            dc.drawFocusRectangle(border+1, border+1, width-2*border-2, height-2*border-2);
        }
    }

    // Draw grayed-out state
    else
    {
        if (icon)
        {
            dc.drawIconSunken(icon, ix, iy);
        }
        if (!label.empty())
        {
            dc.setFont(font);
            dc.setForeground(hiliteColor);
            drawLabel(dc, label, hotoff, tx+1, ty+1, tw, th);
            dc.setForeground(shadowColor);
            drawLabel(dc, label, hotoff, tx, ty, tw, th);
        }
    }

    return(1);
}


//
// Hack of FXCheckButton
//

// Handle repaint
long FXCheckButton::onPaint(FXObject*, FXSelector, void* ptr)
{
    // Initialize Clearlooks (don't use the macro because here it's different)
    static FXbool  init = true;
    static FXbool  use_clearlooks = true;
    static FXColor shadecolor, bordercolor;

    if (init)
    {
        use_clearlooks = getApp()->reg().readUnsignedEntry("SETTINGS", "use_clearlooks", true);

        if (use_clearlooks)
        {
            FXuint r = FXREDVAL(baseColor);
            FXuint g = FXGREENVAL(baseColor);
            FXuint b = FXBLUEVAL(baseColor);

            shadecolor = FXRGB(0.9*r, 0.9*g, 0.9*b);
            bordercolor = FXRGB(0.5*r, 0.5*g, 0.5*b);
        }
        init = false;
    }

    FXEvent* ev = (FXEvent*)ptr;
    FXint    tw = 0, th = 0, tx, ty, ix, iy;

    FXDCWindow dc(this, ev);

    // Figure text size
    if (!label.empty())
    {
        tw = labelWidth(label);
        th = labelHeight(label);
    }

    // Placement
    just_x(tx, ix, tw, 13);
    just_y(ty, iy, th, 13);

    // Button with nice gradient effect and rounded corners (Clearlooks)
    if (use_clearlooks)
    {
        // Widget background
        dc.setForeground(backColor);
        dc.fillRectangle(ev->rect.x, ev->rect.y, ev->rect.w, ev->rect.h);

        // Check background
        if ((check == MAYBE) || !isEnabled())
        {
            dc.setForeground(baseColor);
        }
        else
        {
            dc.setForeground(boxColor);
        }

        // Check border for +
        if (options&CHECKBUTTON_PLUS)
        {
            dc.fillRectangle(ix+2, iy+2, 9, 9);
            dc.setForeground(bordercolor);
            dc.drawRectangle(ix+2, iy+2, 8, 8);
        }

        // Check border for v
        else
        {
            // Check background
            dc.fillRectangle(ix+2, iy+2, 9, 9);

            // Border
            dc.setForeground(bordercolor);
            dc.drawRectangle(ix+2, iy+1, 8, 0);
            dc.drawRectangle(ix+2, iy+11, 8, 0);
            dc.drawRectangle(ix+1, iy+2, 0, 8);
            dc.drawRectangle(ix+11, iy+2, 0, 8);

            // Border corners
            FXPoint checkcorners[4] =
            {
                FXPoint(ix+1, iy+1), FXPoint(ix+1, iy+11), \
                FXPoint(ix+11, iy+1), FXPoint(ix+11, iy+11)
            };
            dc.setForeground(shadecolor);
            dc.drawPoints(checkcorners, 4);
        }

        // Check color
        if ((check == MAYBE) || !isEnabled())
        {
            dc.setForeground(shadowColor);
        }
        else
        {
            dc.setForeground(checkColor);
        }
    }

    // Normal flat rectangular button
    else
    {
        // Widget background
        dc.setForeground(backColor);
        dc.fillRectangle(ev->rect.x, ev->rect.y, ev->rect.w, ev->rect.h);

        // Check background
        if ((check == MAYBE) || !isEnabled())
        {
            dc.setForeground(baseColor);
        }
        else
        {
            dc.setForeground(boxColor);
        }
        dc.fillRectangle(ix+2, iy+2, 9, 9);

        // Check border for +
        if (options&CHECKBUTTON_PLUS)
        {
            dc.setForeground(textColor);
            dc.drawRectangle(ix+2, iy+2, 8, 8);
        }

        // Check border for v
        else
        {
            dc.setForeground(shadowColor);
            dc.fillRectangle(ix, iy, 12, 1);
            dc.fillRectangle(ix, iy, 1, 12);
            dc.setForeground(borderColor);
            dc.fillRectangle(ix+1, iy+1, 10, 1);
            dc.fillRectangle(ix+1, iy+1, 1, 10);
            dc.setForeground(hiliteColor);
            dc.fillRectangle(ix, iy+12, 13, 1);
            dc.fillRectangle(ix+12, iy, 1, 13);
            dc.setForeground(baseColor);
            dc.fillRectangle(ix+1, iy+11, 11, 1);
            dc.fillRectangle(ix+11, iy+1, 1, 11);
        }

        // Check color
        if ((check == MAYBE) || !isEnabled())
        {
            dc.setForeground(shadowColor);
        }
        else
        {
            dc.setForeground(checkColor);
        }
    }

    // Show as +
    if (options&CHECKBUTTON_PLUS)
    {
        if (check != true)
        {
            dc.fillRectangle(ix+6, iy+4, 1, 5);
        }
        dc.fillRectangle(ix+4, iy+6, 5, 1);
    }

    // Show as v
    else
    {
        if (check != false)
        {
            FXSegment seg[6];
            seg[0].x1 = 3+ix;
            seg[0].y1 = 5+iy;
            seg[0].x2 = 5+ix;
            seg[0].y2 = 7+iy;
            seg[1].x1 = 3+ix;
            seg[1].y1 = 6+iy;
            seg[1].x2 = 5+ix;
            seg[1].y2 = 8+iy;
            seg[2].x1 = 3+ix;
            seg[2].y1 = 7+iy;
            seg[2].x2 = 5+ix;
            seg[2].y2 = 9+iy;
            seg[3].x1 = 5+ix;
            seg[3].y1 = 7+iy;
            seg[3].x2 = 9+ix;
            seg[3].y2 = 3+iy;
            seg[4].x1 = 5+ix;
            seg[4].y1 = 8+iy;
            seg[4].x2 = 9+ix;
            seg[4].y2 = 4+iy;
            seg[5].x1 = 5+ix;
            seg[5].y1 = 9+iy;
            seg[5].x2 = 9+ix;
            seg[5].y2 = 5+iy;
            dc.drawLineSegments(seg, 6);
        }
    }

    // Text
    if (!label.empty())
    {
        dc.setFont(font);
        if (isEnabled())
        {
            dc.setForeground(textColor);
            drawLabel(dc, label, hotoff, tx, ty, tw, th);
            if (hasFocus())
            {
                dc.drawFocusRectangle(tx-1, ty-1, tw+2, th+2);
            }
        }
        else
        {
            dc.setForeground(hiliteColor);
            drawLabel(dc, label, hotoff, tx+1, ty+1, tw, th);
            dc.setForeground(shadowColor);
            drawLabel(dc, label, hotoff, tx, ty, tw, th);
        }
    }

    // Frame
    drawFrame(dc, 0, 0, width, height);

    return(1);
}


//
// Hack of FXTextField
//

// Handle repaint
long FXTextField::onPaint(FXObject*, FXSelector, void* ptr)
{
    // Initialize Clearlooks
    INIT_CLEARLOOKS

    FXEvent*   ev = (FXEvent*)ptr;
    FXDCWindow dc(this, ev);

    // Draw frame
    drawFrame(dc, 0, 0, width, height);

    // Draw background
    dc.setForeground(backColor);
    dc.fillRectangle(border, border, width-(border<<1), height-(border<<1));

    // !!! Hack to get an optional rounded rectangle shape
    // only if _TEXTFIELD_NOFRAME is not specified !!!
    if ( (!(options&_TEXTFIELD_NOFRAME))  & use_clearlooks )
    {
        // Outside Background
        dc.setForeground(baseColor);
        dc.fillRectangle(0, 0, width, height);
        dc.drawPoints(basebackground, 4);

        // Border
        dc.setForeground(bordercolor);
        dc.drawRectangle(2, 0, width-5, 0);
        dc.drawRectangle(2, height-1, width-5, height-1);
        dc.drawRectangle(0, 2, 0, height-5);
        dc.drawRectangle(width-1, 2, 0, height-5);
        dc.drawPoints(bordercorners, 4);
        dc.setForeground(shadecolor);
        dc.drawPoints(bordershade, 16);
        dc.setForeground(backColor);
        dc.fillRectangle(2, 1, width-4, height-2);
    }
    // !!! End of hack

    // Draw text, clipped against frame interior
    dc.setClipRectangle(border, border, width-(border<<1), height-(border<<1));
    drawTextRange(dc, 0, contents.length());

    // Draw caret
    if (flags&FLAG_CARET)
    {
        int xx = coord(cursor)-1;
        dc.setForeground(cursorColor);
        dc.fillRectangle(xx+1, padtop+border, 1, height-padbottom-padtop-(border<<1));
        //dc.fillRectangle(xx-2, padtop+border, 5, 1);
        //dc.fillRectangle(xx-2, height-border-padbottom-1, 5, 1);
    }

    return(1);
}


void FXTextField::drawTextFragment(FXDCWindow& dc,FXint x,FXint y,FXint fm,FXint to){
  x+=font->getTextWidth(contents.text(),fm);
  y+=font->getFontAscent();
  dc.drawText(x,y+1,&contents[fm],to-fm);
}


//
// Hack of FXToggleButton
//

// Handle repaint
long FXToggleButton::onPaint(FXObject*, FXSelector, void* ptr)
{
    // Initialize Clearlooks
    INIT_CLEARLOOKS

    int        tw = 0, th = 0, iw = 0, ih = 0, tx, ty, ix, iy;
    FXEvent*   ev = (FXEvent*)ptr;
    FXDCWindow dc(this, ev);

    // Button with nice gradient effect and rounded corners (Clearlooks)
    if (use_clearlooks)
    {
        // Button style is toolbar
        if (options&TOGGLEBUTTON_TOOLBAR)
        {
            // Enabled and cursor inside and button down
            if (down || ((options&TOGGLEBUTTON_KEEPSTATE) && state))
            {
                DRAW_CLEARLOOKS_BUTTON_DOWN
            }
            // Enabled and cursor inside but button not down
            else if (isEnabled() && underCursor())
            {
                DRAW_CLEARLOOKS_BUTTON_UP
            }

            // Disabled or unchecked or not under cursor
            else
            {
                dc.setForeground(backColor);
                dc.fillRectangle(0, 0, width, height);
            }
        }

        // Button style is normal
        else
        {
            // Button down
            if (down || ((options&TOGGLEBUTTON_KEEPSTATE) && state))
            {
                DRAW_CLEARLOOKS_BUTTON_DOWN
            }

            // Button up
            else
            {
                DRAW_CLEARLOOKS_BUTTON_UP
            }
        }
    }   // End of gradient painting

    // Normal flat rectangular button
    else
    {
        // Got a border at all?
        if (options&(FRAME_RAISED|FRAME_SUNKEN))
        {
            // Button style is normal
            if (options&TOGGLEBUTTON_TOOLBAR)
            {
                // Enabled and cursor inside and down
                if (down || ((options&TOGGLEBUTTON_KEEPSTATE) && state))
                {
                    DRAW_STANDARD_BUTTON_DOWN
                }

                // Enabled and cursor inside, and up
                else if (isEnabled() && underCursor())
                {
                    DRAW_STANDARD_BUTTON_UP
                }

                // Disabled or unchecked or not under cursor
                else
                {
                    dc.setForeground(backColor);
                    dc.fillRectangle(0, 0, width, height);
                }
            }

            // Button style is normal
            else
            {
                // Draw sunken if pressed
                if (down || ((options&TOGGLEBUTTON_KEEPSTATE) && state))
                {
                    DRAW_STANDARD_BUTTON_DOWN
                }

                // Draw raised if not currently pressed down
                else
                {
                    DRAW_STANDARD_BUTTON_UP
                }
            }
        }

        // No borders
        else
        {
            dc.setForeground(backColor);
            dc.fillRectangle(0, 0, width, height);
        }
    }   // End of normal painting

    // Place text & icon
    if (state && !altlabel.empty())
    {
        tw = labelWidth(altlabel);
        th = labelHeight(altlabel);
    }
    else if (!label.empty())
    {
        tw = labelWidth(label);
        th = labelHeight(label);
    }
    if (state && alticon)
    {
        iw = alticon->getWidth();
        ih = alticon->getHeight();
    }
    else if (icon)
    {
        iw = icon->getWidth();
        ih = icon->getHeight();
    }

    just_x(tx, ix, tw, iw);
    just_y(ty, iy, th, ih);

    // Shift a bit when pressed
    if ((down || ((options&TOGGLEBUTTON_KEEPSTATE) && state)) && (options&(FRAME_RAISED|FRAME_SUNKEN)))
    {
        ++tx;
        ++ty;
        ++ix;
        ++iy;
    }

    // Draw enabled state
    if (isEnabled())
    {
        if (state && alticon)
        {
            dc.drawIcon(alticon, ix, iy);
        }
        else if (icon)
        {
            dc.drawIcon(icon, ix, iy);
        }
        if (state && !altlabel.empty())
        {
            dc.setFont(font);
            dc.setForeground(textColor);
            drawLabel(dc, altlabel, althotoff, tx, ty, tw, th);
        }
        else if (!label.empty())
        {
            dc.setFont(font);
            dc.setForeground(textColor);
            drawLabel(dc, label, hotoff, tx, ty, tw, th);
        }
        if (hasFocus())
        {
            dc.drawFocusRectangle(border+1, border+1, width-2*border-2, height-2*border-2);
        }
    }

    // Draw grayed-out state
    else
    {
        if (state && alticon)
        {
            dc.drawIconSunken(alticon, ix, iy);
        }
        else if (icon)
        {
            dc.drawIconSunken(icon, ix, iy);
        }
        if (state && !altlabel.empty())
        {
            dc.setFont(font);
            dc.setForeground(hiliteColor);
            drawLabel(dc, altlabel, althotoff, tx+1, ty+1, tw, th);
            dc.setForeground(shadowColor);
            drawLabel(dc, altlabel, althotoff, tx, ty, tw, th);
        }
        else if (!label.empty())
        {
            dc.setFont(font);
            dc.setForeground(hiliteColor);
            drawLabel(dc, label, hotoff, tx+1, ty+1, tw, th);
            dc.setForeground(shadowColor);
            drawLabel(dc, label, hotoff, tx, ty, tw, th);
        }
    }

    return(1);
}


//
// Hack of FXScrollBar
//


// Draw scrollbar button with gradient effect and nice grip
static void drawGradientScrollButton(FXDCWindow& dc, FXColor topcolor, FXColor bottomcolor, FXColor shadecolor, FXColor lightcolor,
                                     FXuint options, int x, int y, int w, int h)
{
    // Fill rectangle with gradient in the right direction (vertical or horizontal)
    FXbool vertical = ((options&SCROLLBAR_HORIZONTAL) ? true : false);

    drawGradientRectangle(dc, topcolor, bottomcolor, x, y, w, h, vertical);

    // Draw button borders
    dc.setForeground(lightcolor);
    dc.fillRectangle(x+1, y+1, w-1, 1);
    dc.fillRectangle(x+1, y+1, 1, h-2);
    dc.setForeground(shadecolor);
    dc.fillRectangle(x, y, w, 1);
    dc.fillRectangle(x, y, 1, h-1);
    dc.fillRectangle(x, y+h-1, w, 1);
    dc.fillRectangle(x+w-1, y, 1, h);

    // Draw grip lines for horizontal scrollbar
    if ((options&SCROLLBAR_HORIZONTAL))
    {
        dc.setForeground(shadecolor);
        dc.fillRectangle(x+w/2-3, y+4, 1, h-7);
        dc.fillRectangle(x+w/2, y+4, 1, h-7);
        dc.fillRectangle(x+w/2+3, y+4, 1, h-7);
        dc.setForeground(lightcolor);
        dc.fillRectangle(x+w/2-2, y+4, 1, h-7);
        dc.fillRectangle(x+w/2+1, y+4, 1, h-7);
        dc.fillRectangle(x+w/2+4, y+4, 1, h-7);
    }

    // Draw grip lines for vertical scrollbar
    else
    {
        dc.setForeground(shadecolor);
        dc.fillRectangle(x+4, y+h/2-3, w-7, 1);
        dc.fillRectangle(x+4, y+h/2, w-7, 1);
        dc.fillRectangle(x+4, y+h/2+3, w-7, 1);
        dc.setForeground(lightcolor);
        dc.fillRectangle(x+4, y+h/2-2, w-7, 1);
        dc.fillRectangle(x+4, y+h/2+1, w-7, 1);
        dc.fillRectangle(x+4, y+h/2+4, w-7, 1);
    }
}


// Small hack to set the minimum length of the scrollbar button to barsize*2 instead of barsize/2
void FXScrollBar::setPosition(int p)
{
    int total, travel, lo, hi, l, h;

    pos = p;
    if (pos < 0)
    {
        pos = 0;
    }
    if (pos > (range-page))
    {
        pos = range-page;
    }
    lo = thumbpos;
    hi = thumbpos+thumbsize;
    if (options&SCROLLBAR_HORIZONTAL)
    {
        total = width-height-height;
        thumbsize = (total*page)/range;
        // !!! Hack to change the minimum button size !!!
        if (thumbsize < (barsize<<1))
        {
            thumbsize = (barsize<<1);
        }
        // !!! End of hack !!!
        travel = total-thumbsize;
        if (range > page)
        {
            thumbpos = height+(int)((((double)pos)*travel)/(range-page));
        }
        else
        {
            thumbpos = height;
        }
        l = thumbpos;
        h = thumbpos+thumbsize;
        if ((l != lo) || (h != hi))
        {
            update(FXMIN(l, lo), 0, FXMAX(h, hi)-FXMIN(l, lo), height);
        }
    }
    else
    {
        total = height-width-width;
        thumbsize = (total*page)/range;
        // !!! Hack to change the minimum button size !!!
        if (thumbsize < (barsize<<1))
        {
            thumbsize = (barsize<<1);
        }
        // !!! End of hack !!!
        travel = total-thumbsize;
        if (range > page)
        {
            thumbpos = width+(int)((((double)pos)*travel)/(range-page));
        }
        else
        {
            thumbpos = width;
        }
        l = thumbpos;
        h = thumbpos+thumbsize;
        if ((l != lo) || (h != hi))
        {
            update(0, FXMIN(l, lo), width, FXMAX(h, hi)-FXMIN(l, lo));
        }
    }
}


// Arrow directions
enum
{
    _ARROW_LEFT,
    _ARROW_RIGHT,
    _ARROW_UP,
    _ARROW_DOWN
};


// Draw arrow button in scrollbar with gradient effect and rounded corners (Clearlooks)
static void drawGradientArrowButton(FXDCWindow& dc, FXColor backcolor, FXColor topcolor, FXColor bottomcolor, FXColor shadecolor,
                                    FXColor lightcolor, FXColor bordercolor, FXColor arrowcolor,
                                    FXuint options, int x, int y, int w, int h, FXbool down, FXuint direction)
{
    FXPoint arrowpoints[3];
    int     xx, yy, ah, ab;

    FXPoint basebackground[2];
    FXPoint bordershade[8];
    FXPoint bordercorners[2];

    // Rounded corner and arrow point coordinates depend on the button direction
    if (direction == _ARROW_UP)
    {
        // Rounded corners
        basebackground[0] = FXPoint(0, 0);
        basebackground[1] = FXPoint(w-1, 0);
        bordercorners[0] = FXPoint(1, 1);
        bordercorners[1] = FXPoint(w-2, 1);
        bordershade[0] = FXPoint(0, 1);
        bordershade[1] = FXPoint(1, 0);
        bordershade[2] = FXPoint(1, 2);
        bordershade[3] = FXPoint(2, 1);
        bordershade[4] = FXPoint(w-2, 0);
        bordershade[5] = FXPoint(w-1, 1);
        bordershade[6] = FXPoint(w-3, 1);
        bordershade[7] = FXPoint(w-2, 2);

        // Arrow points
        ab = (w-7)|1;
        ah = ab>>1;
        xx = x+((w-ab)>>1);
        yy = y+((h-ah)>>1);
        if (down)
        {
            ++xx;
            ++yy;
        }
        arrowpoints[0] = FXPoint(xx+(ab>>1), yy-1);
        arrowpoints[1] = FXPoint(xx, yy+ah);
        arrowpoints[2] = FXPoint(xx+ab, yy+ah);
    }
    else if (direction == _ARROW_DOWN)
    {
        // Rounded corners
        basebackground[0] = FXPoint(x, y+h-1);
        basebackground[1] = FXPoint(x+w-1, y+h-1);
        bordercorners[0] = FXPoint(x+1, y+h-2);
        bordercorners[1] = FXPoint(x+w-2, y+h-2);
        bordershade[0] = FXPoint(x, y+h-2);
        bordershade[1] = FXPoint(x+1, y+h-1);
        bordershade[2] = FXPoint(x+1, y+h-3);
        bordershade[3] = FXPoint(x+2, y+h-2);
        bordershade[4] = FXPoint(x+w-1, y+h-2);
        bordershade[5] = FXPoint(x+w-2, y+h-1);
        bordershade[6] = FXPoint(x+w-2, y+h-3);
        bordershade[7] = FXPoint(x+w-3, y+h-2);

        // Arrow points
        ab = (w-7)|1;
        ah = ab>>1;
        xx = x+((w-ab)>>1);
        yy = y+((h-ah)>>1);
        if (down)
        {
            ++xx;
            ++yy;
        }
        arrowpoints[0] = FXPoint(xx+1, yy);
        arrowpoints[1] = FXPoint(xx+ab-1, yy);
        arrowpoints[2] = FXPoint(xx+(ab>>1), yy+ah);
    }
    else if (direction == _ARROW_LEFT)
    {
        // Rounded corners
        basebackground[0] = FXPoint(0, 0);
        basebackground[1] = FXPoint(0, h-1);
        bordercorners[0] = FXPoint(1, 1);
        bordercorners[1] = FXPoint(1, h-2);
        bordershade[0] = FXPoint(0, 1);
        bordershade[1] = FXPoint(1, 0);
        bordershade[2] = FXPoint(1, 2);
        bordershade[3] = FXPoint(2, 1);
        bordershade[4] = FXPoint(0, h-2);
        bordershade[5] = FXPoint(1, h-1);
        bordershade[6] = FXPoint(1, h-3);
        bordershade[7] = FXPoint(2, h-2);

        // Arrow points
        ab = (h-7)|1;
        ah = ab>>1;
        xx = x+((w-ah)>>1);
        yy = y+((h-ab)>>1);
        if (down)
        {
            ++xx;
            ++yy;
        }
        arrowpoints[0] = FXPoint(xx+ah, yy);
        arrowpoints[1] = FXPoint(xx+ah, yy+ab-1);
        arrowpoints[2] = FXPoint(xx, yy+(ab>>1));
    }
    else // _ARROW_RIGHT
    {
        // Rounded corners
        basebackground[0] = FXPoint(x+w-1, y);
        basebackground[1] = FXPoint(x+w-1, y+h-1);
        bordercorners[0] = FXPoint(x+w-2, y+1);
        bordercorners[1] = FXPoint(x+w-2, y+h-2);
        bordershade[0] = FXPoint(x+w-2, y);
        bordershade[1] = FXPoint(x+w-1, y+1);
        bordershade[2] = FXPoint(x+w-3, y+1);
        bordershade[3] = FXPoint(x+w-2, y+2);
        bordershade[4] = FXPoint(x+w-1, y+h-2);
        bordershade[5] = FXPoint(x+w-2, y+h-1);
        bordershade[6] = FXPoint(x+w-2, y+h-3);
        bordershade[7] = FXPoint(x+w-3, y+h-2);

        // Arrow points
        ab = (h-7)|1;
        ah = ab>>1;
        xx = x+((w-ah)>>1);
        yy = y+((h-ab)>>1);
        if (down)
        {
            ++xx;
            ++yy;
        }
        arrowpoints[0] = FXPoint(xx, yy);
        arrowpoints[1] = FXPoint(xx, yy+ab-1);
        arrowpoints[2] = FXPoint(xx+ah, yy+(ab>>1));
    }

    // Draw button when up
    if (!down)
    {
        // Fill rectangle with gradient in the right direction (vertical or horizontal)
        FXbool vertical = ((options&SCROLLBAR_HORIZONTAL) ? true : false);
        drawGradientRectangle(dc, topcolor, bottomcolor, x, y, w, h, vertical);

        // Button borders
        dc.setForeground(lightcolor);
        dc.fillRectangle(x+1, y+1, w-1, 1);
        dc.fillRectangle(x+1, y+1, 1, h-2);
        dc.setForeground(shadecolor);
        dc.fillRectangle(x, y, w, 1);
        dc.fillRectangle(x, y, 1, h-1);
        dc.fillRectangle(x, y+h-1, w, 1);
        dc.fillRectangle(x+w-1, y, 1, h);

        // Rounded corners
        dc.setForeground(backcolor);
        dc.drawPoints(basebackground, 2);
        dc.setForeground(shadecolor);
        dc.drawPoints(bordercorners, 2);
        dc.setForeground(bordercolor);
        dc.drawPoints(bordershade, 8);

        // Arrow
        dc.setForeground(arrowcolor);
        dc.fillPolygon(arrowpoints, 3);
    }

    // Draw button when down (pressed)
    else
    {
        // Dark background
        dc.setForeground(bordercolor);
        dc.fillRectangle(x, y, w, h);

        // Button borders
        dc.setForeground(lightcolor);
        dc.fillRectangle(x+1, y+1, w-1, 1);
        dc.fillRectangle(x+1, y+1, 1, h-2);
        dc.setForeground(shadecolor);
        dc.fillRectangle(x, y, w, 1);
        dc.fillRectangle(x, y, 1, h-1);
        dc.fillRectangle(x, y+h-1, w, 1);
        dc.fillRectangle(x+w-1, y, 1, h);

        // Rounded corners
        dc.setForeground(backcolor);
        dc.drawPoints(basebackground, 2);
        dc.setForeground(shadecolor);
        dc.drawPoints(bordercorners, 2);
        dc.setForeground(bordercolor);
        dc.drawPoints(bordershade, 8);

        // Arrow
        dc.setForeground(arrowcolor);
        dc.fillPolygon(arrowpoints, 3);
    }
}


// Draw flat scrollbar button with selected colors
static void drawFlatScrollButton(FXDCWindow& dc, FXint x, FXint y, FXint w, FXint h, FXbool down, FXColor hilitecolor, FXColor shadowcolor, FXColor bordercolor, FXColor scrollbarcolor)
{
    dc.setForeground(scrollbarcolor);
    dc.fillRectangle(x+2, y+2, w-4, h-4);
    if (!down)
    {
        dc.setForeground(scrollbarcolor);
        dc.fillRectangle(x, y, w-1, 1);
        dc.fillRectangle(x, y, 1, h-1);
        dc.setForeground(hilitecolor);
        dc.fillRectangle(x+1, y+1, w-2, 1);
        dc.fillRectangle(x+1, y+1, 1, h-2);
        dc.setForeground(shadowcolor);
        dc.fillRectangle(x+1, y+h-2, w-2, 1);
        dc.fillRectangle(x+w-2, y+1, 1, h-2);
        dc.setForeground(bordercolor);
        dc.fillRectangle(x, y+h-1, w, 1);
        dc.fillRectangle(x+w-1, y, 1, h);
    }
    else
    {
        dc.setForeground(bordercolor);
        dc.fillRectangle(x, y, w-2, 1);
        dc.fillRectangle(x, y, 1, h-2);
        dc.setForeground(shadowcolor);
        dc.fillRectangle(x+1, y+1, w-3, 1);
        dc.fillRectangle(x+1, y+1, 1, h-3);
        dc.setForeground(hilitecolor);
        dc.fillRectangle(x, y+h-1, w-1, 1);
        dc.fillRectangle(x+w-1, y+1, 1, h-1);
        dc.setForeground(scrollbarcolor);
        dc.fillRectangle(x+1, y+h-2, w-1, 1);
        dc.fillRectangle(x+w-2, y+2, 1, h-2);
    }
}


// Handle repaint
long FXScrollBar::onPaint(FXObject*, FXSelector, void* ptr)
{
    // Caution! Don't use the macro here because it's slightly different

    static FXbool  init = true;
    static FXbool  use_clearlooks = true;
    static FXColor bg_topcolor, bg_bottomcolor, bg_shadecolor, bg_bordercolor, bg_lightcolor;
    static FXColor sb_topcolor, sb_bottomcolor, sb_shadecolor, sb_bordercolor, sb_lightcolor, scrollbarcolor;

    register FXEvent* ev = (FXEvent*)ptr;
    register int      total;
    FXDCWindow        dc(this, ev);

    // At first run, select the scrollbar style and color
    if (init)
    {
        use_clearlooks = getApp()->reg().readUnsignedEntry("SETTINGS", "use_clearlooks", true);
        scrollbarcolor = getApp()->reg().readColorEntry("SETTINGS", "scrollbarcolor", FXRGB(237, 233, 227));

        // Compute gradient colors from the base color
        if (use_clearlooks)
        {
            // Decompose the base color
            FXuint r = FXREDVAL(backColor);
            FXuint g = FXGREENVAL(backColor);
            FXuint b = FXBLUEVAL(backColor);

            // Compute the gradient colors from the base color (background)
            bg_topcolor = FXRGB(FXMIN(1.1*r, 255), FXMIN(1.1*g, 255), FXMIN(1.1*b, 255));
            bg_bottomcolor = FXRGB(0.9*r, 0.9*g, 0.9*b);
            bg_shadecolor = FXRGB(0.8*r, 0.8*g, 0.8*b);
            bg_bordercolor = FXRGB(0.9*r, 0.9*g, 0.9*b);
            bg_lightcolor = FXRGB(FXMIN(1.3*r, 255), FXMIN(1.3*g, 255), FXMIN(1.3*b, 255));

            // Compute the gradient colors from the base color (scrollbar)
            r = FXREDVAL(scrollbarcolor);
            g = FXGREENVAL(scrollbarcolor);
            b = FXBLUEVAL(scrollbarcolor);
            sb_topcolor = FXRGB(FXMIN(1.1*r, 255), FXMIN(1.1*g, 255), FXMIN(1.1*b, 255));
            sb_bottomcolor = FXRGB(0.9*r, 0.9*g, 0.9*b);
            sb_shadecolor = FXRGB(0.8*r, 0.8*g, 0.8*b);
            sb_bordercolor = FXRGB(0.9*r, 0.9*g, 0.9*b);
            (void)sb_bordercolor; // Hack to avoid unused variable compiler warning
            sb_lightcolor = FXRGB(FXMIN(1.3*r, 255), FXMIN(1.3*g, 255), FXMIN(1.3*b, 255));
        }
        init = false;
    }

    // Nice scrollbar with gradient and rounded corners
    if (use_clearlooks)
    {
        if (options&SCROLLBAR_HORIZONTAL)
        {
            total = width-height-height;
            if (thumbsize < total)                                    // Scrollable
            {
                drawGradientScrollButton(dc, sb_topcolor, sb_bottomcolor, sb_shadecolor, sb_lightcolor, options, thumbpos, 0, thumbsize, height);
                dc.setForeground(bg_bordercolor);
                dc.setBackground(backColor);
                dc.fillRectangle(height, 0, thumbpos-height, height);
                dc.fillRectangle(thumbpos+thumbsize, 0, width-height-thumbpos-thumbsize, height);
            }
            else                                                    // Non-scrollable
            {
                dc.setForeground(bg_bordercolor);
                dc.setBackground(backColor);
                dc.fillRectangle(height, 0, total, height);
            }
            drawGradientArrowButton(dc, backColor, bg_topcolor, bg_bottomcolor, bg_shadecolor, bg_lightcolor, bg_bordercolor, arrowColor, options, width-height, 0, height, height, (mode == MODE_INC), _ARROW_RIGHT);
            drawGradientArrowButton(dc, backColor, bg_topcolor, bg_bottomcolor, bg_shadecolor, bg_lightcolor, bg_bordercolor, arrowColor, options, 0, 0, height, height, (mode == MODE_DEC), _ARROW_LEFT);
        }

        // Vertical
        else
        {
            total = height-width-width;
            if (thumbsize < total)                                    // Scrollable
            {
                drawGradientScrollButton(dc, sb_topcolor, sb_bottomcolor, sb_shadecolor, sb_lightcolor, options, 0, thumbpos, width, thumbsize);
                dc.setForeground(bg_bordercolor);
                dc.setBackground(backColor);
                dc.fillRectangle(0, width, width, thumbpos-width);
                dc.fillRectangle(0, thumbpos+thumbsize, width, height-width-thumbpos-thumbsize);
            }
            else                                                    // Non-scrollable
            {
                dc.setForeground(bg_bordercolor);
                dc.setBackground(backColor);
                dc.fillRectangle(0, width, width, total);
            }
            drawGradientArrowButton(dc, backColor, bg_topcolor, bg_bottomcolor, bg_shadecolor, bg_lightcolor, bg_bordercolor, arrowColor, options, 0, height-width, width, width, (mode == MODE_INC), _ARROW_DOWN);
            drawGradientArrowButton(dc, backColor, bg_topcolor, bg_bottomcolor, bg_shadecolor, bg_lightcolor, bg_bordercolor, arrowColor, options, 0, 0, width, width, (mode == MODE_DEC), _ARROW_UP);
        }
    }

    // Standard (flat) scrollbar with selected color
    else
    {
        if (options&SCROLLBAR_HORIZONTAL)
        {
            total = width-height-height;
            if (thumbsize < total)                                    // Scrollable
            {
                drawFlatScrollButton(dc, thumbpos, 0, thumbsize, height, 0, hiliteColor, shadowColor, borderColor, scrollbarcolor);
                dc.setStipple(STIPPLE_GRAY);
                dc.setFillStyle(FILL_OPAQUESTIPPLED);
                if (mode == MODE_PAGE_DEC)
                {
                    dc.setForeground(backColor);
                    dc.setBackground(shadowColor);
                }
                else
                {
                    dc.setForeground(hiliteColor);
                    dc.setBackground(backColor);
                }
                dc.fillRectangle(height, 0, thumbpos-height, height);
                if (mode == MODE_PAGE_INC)
                {
                    dc.setForeground(backColor);
                    dc.setBackground(shadowColor);
                }
                else
                {
                    dc.setForeground(hiliteColor);
                    dc.setBackground(backColor);
                }
                dc.fillRectangle(thumbpos+thumbsize, 0, width-height-thumbpos-thumbsize, height);
            }
            else                                                    // Non-scrollable
            {
                dc.setStipple(STIPPLE_GRAY);
                dc.setFillStyle(FILL_OPAQUESTIPPLED);
                dc.setForeground(hiliteColor);
                dc.setBackground(backColor);
                dc.fillRectangle(height, 0, total, height);
            }
            dc.setFillStyle(FILL_SOLID);
            drawButton(dc, width-height, 0, height, height, (mode == MODE_INC));
            drawRightArrow(dc, width-height, 0, height, height, (mode == MODE_INC));
            drawButton(dc, 0, 0, height, height, (mode == MODE_DEC));
            drawLeftArrow(dc, 0, 0, height, height, (mode == MODE_DEC));
        }
        else
        {
            total = height-width-width;
            if (thumbsize < total)                                    // Scrollable
            {
                drawFlatScrollButton(dc, 0, thumbpos, width, thumbsize, 0, hiliteColor, shadowColor, borderColor, scrollbarcolor);
                dc.setStipple(STIPPLE_GRAY);
                dc.setFillStyle(FILL_OPAQUESTIPPLED);
                if (mode == MODE_PAGE_DEC)
                {
                    dc.setForeground(backColor);
                    dc.setBackground(shadowColor);
                }
                else
                {
                    dc.setForeground(hiliteColor);
                    dc.setBackground(backColor);
                }
                dc.fillRectangle(0, width, width, thumbpos-width);
                if (mode == MODE_PAGE_INC)
                {
                    dc.setForeground(backColor);
                    dc.setBackground(shadowColor);
                }
                else
                {
                    dc.setForeground(hiliteColor);
                    dc.setBackground(backColor);
                }
                dc.fillRectangle(0, thumbpos+thumbsize, width, height-width-thumbpos-thumbsize);
            }
            else                                                    // Non-scrollable
            {
                dc.setStipple(STIPPLE_GRAY);
                dc.setFillStyle(FILL_OPAQUESTIPPLED);
                dc.setForeground(hiliteColor);
                dc.setBackground(backColor);
                dc.fillRectangle(0, width, width, total);
            }
            dc.setFillStyle(FILL_SOLID);
            drawButton(dc, 0, height-width, width, width, (mode == MODE_INC));
            drawDownArrow(dc, 0, height-width, width, width, (mode == MODE_INC));
            drawButton(dc, 0, 0, width, width, (mode == MODE_DEC));
            drawUpArrow(dc, 0, 0, width, width, (mode == MODE_DEC));
        }
    }
    return(1);
}


//
// Hack of FXComboBox
//


#define MENUBUTTONARROW_WIDTH     11
#define MENUBUTTONARROW_HEIGHT    5

// Small hack related to the Clearlooks theme
FXComboBox::FXComboBox(FXComposite* p, int cols, FXObject* tgt, FXSelector sel, FXuint opts, int x, int y, int w, int h, int pl, int pr, int pt, int pb) :
    FXPacker(p, FRAME_SUNKEN|FRAME_THICK|opts, x, y, w, h, 0, 0, 0, 0, 0, 0)
{
    flags |= FLAG_ENABLED;
    target = tgt;
    message = sel;

    // !!! Hack to set options to TEXTFIELD_NORMAL instead of 0 (used by the Clearlooks theme)
    //new FXButton(this, "a", bigfoldericon, this, FXApp::ID_QUIT, LAYOUT_RIGHT);
    if (options&0x01000000)
    {
        field = new FXTextField(this, cols, this, FXComboBox::ID_TEXT, FRAME_NONE, 0, 0, 0, 0, 21, pr, pt, pb);
    } else {
        field = new FXTextField(this, cols, this, FXComboBox::ID_TEXT, FRAME_NONE, 0, 0, 0, 0, pl, pr, pt, pb);
    }
    // !!! End of hack

    if (options&COMBOBOX_STATIC)
    {
        field->setEditable(false);
    }

    pane = new FXPopup(this, FRAME_LINE);
    list = new FXList(pane, this, FXComboBox::ID_LIST, LIST_BROWSESELECT|LIST_AUTOSELECT|LAYOUT_FILL_X|LAYOUT_FILL_Y|SCROLLERS_TRACK|HSCROLLER_NEVER);
    if (options&COMBOBOX_STATIC)
    {
        list->setScrollStyle(SCROLLERS_TRACK|HSCROLLING_OFF);
    }

    // Load the XBM icon
    //FXBitmap* comboarrowbmp = NULL;
    //comboarrowbmp = new FXXBMIcon(getApp(), comboarrow_bits, comboarrow_bits, FXRGB(255,255,255), NULL, comboarrow_width, comboarrow_height);
    //convertBlackPixelsToColor(comboarrow, FXRGB(255, 0, 0));

    // Modify the icon color (for example, change all black pixels to red)
    //for(int y = 0; y < comboarrow_height; ++y) {
    //    for(int x = 0; x < comboarrow_width; ++x) {
    //        if(comboarrow_bits[y * (comboarrow_width / 8) + (x / 8)] & (0x80 >> (x % 8))) {
    //            // This pixel is set, change its color
    //            comboarrow->setPixel(x, y, FXRGB(255, 0, 0)); // Set it to red
    //        }
    //    }
    //}

    button = new FXMenuButton(this, FXString::null, comboarrowicon, pane, FRAME_RAISED|FRAME_THICK|MENUBUTTON_DOWN|MENUBUTTON_ATTACH_RIGHT|LAYOUT_FIX_WIDTH, 0, 0, 1, 0, 0, 0, 0, 0);
    button->setXOffset(border);
    button->setYOffset(border);
    button->setBaseColor(getApp()->getHiliteColor());
    button->setHiliteColor(getApp()->getBaseColor());

    flags &= ~FLAG_UPDATE;  // Never GUI update
}

//
// Hack of FXMenuTitle
//

// This hack adds an optional gradient with rounded corner theme to the menu title (Clearlooks)

// Handle repaint
long FXMenuTitle::onPaint(FXObject*, FXSelector, void* ptr)
{
    // Initialize Clearlooks
    FXColor baseColor = backColor;
    INIT_CLEARLOOKS

    FXEvent*   ev = (FXEvent*)ptr;
    FXDCWindow dc(this, ev);
    FXint      xx, yy;

    dc.setFont(font);
    xx = 6;
    yy = 0;

    if (isEnabled())
    {
        if (isActive())
        {
            // Button with nice gradient effect and rounded corners (Clearlooks)
            if (use_clearlooks)
            {
                dc.setForeground(selbackColor);
                dc.fillRectangle(0, 0, width, height);
                dc.setForeground(backColor);
                dc.drawPoints(basebackground, 4);
                dc.setForeground(bordercolor);
                dc.drawRectangle(2, 0, width-5, 0);
                dc.drawRectangle(2, height-1, width-5, height-1);
                dc.drawRectangle(0, 2, 0, height-5);
                dc.drawRectangle(width-1, 2, 0, height-5);
                dc.drawPoints(bordercorners, 4);
                dc.setForeground(selbackColor);
                dc.drawPoints(bordershade, 16);
            }

            // Normal flat rectangular button
            else
            {
                dc.setForeground(selbackColor);
                dc.fillRectangle(1, 1, width-2, height-2);
                dc.setForeground(shadowColor);
                dc.fillRectangle(0, 0, width, 1);
                dc.fillRectangle(0, 0, 1, height);
                dc.setForeground(hiliteColor);
                dc.fillRectangle(0, height-1, width, 1);
                dc.fillRectangle(width-1, 0, 1, height);
            }
            xx++;
            yy++;
        }
        else if (underCursor())
        {
            // Button with nice gradient effect and rounded corners (Clearlooks)
            if (use_clearlooks)
            {
                DRAW_CLEARLOOKS_BUTTON_UP
            }

            // Normal flat rectangular button
            else
            {
                dc.setForeground(backColor);
                dc.fillRectangle(1, 1, width-2, height-2);
                dc.setForeground(shadowColor);
                dc.fillRectangle(0, height-1, width, 1);
                dc.fillRectangle(width-1, 0, 1, height);
                dc.setForeground(hiliteColor);
                dc.fillRectangle(0, 0, width, 1);
                dc.fillRectangle(0, 0, 1, height);
            }
        }

        else
        {
            dc.setForeground(backColor);
            dc.fillRectangle(0, 0, width, height);
        }

        if (icon)
        {
            dc.drawIcon(icon, xx, yy+(height-icon->getHeight())/2);
            xx += 5+icon->getWidth();
        }

        if (!label.empty())
        {
            yy += font->getFontAscent()+(height-font->getFontHeight())/2;
            dc.setForeground(isActive() ? seltextColor : textColor);
            dc.drawText(xx, yy, label);
            if (0 <= hotoff)
            {
                dc.fillRectangle(xx+font->getTextWidth(&label[0], hotoff), yy+1, font->getTextWidth(&label[hotoff], wclen(&label[hotoff])), 1);
            }
        }
    }

    else
    {
        dc.setForeground(backColor);
        dc.fillRectangle(0, 0, width, height);
        if (icon)
        {
            dc.drawIconSunken(icon, xx, yy+(height-icon->getHeight())/2);
            xx += 5+icon->getWidth();
        }
        if (!label.empty())
        {
            yy += font->getFontAscent()+(height-font->getFontHeight())/2;
            dc.setForeground(hiliteColor);
            dc.drawText(xx+1, yy+1, label);
            if (0 <= hotoff)
            {
                dc.fillRectangle(xx+font->getTextWidth(&label[0], hotoff), yy+1, font->getTextWidth(&label[hotoff], wclen(&label[hotoff])), 1);
            }
            dc.setForeground(shadowColor);
            dc.drawText(xx, yy, label);
            if (0 <= hotoff)
            {
                dc.fillRectangle(xx+font->getTextWidth(&label[0], hotoff), yy+1, font->getTextWidth(&label[hotoff], wclen(&label[hotoff])), 1);
            }
        }
    }

    return(1);
}


//
// Hack of FXRadioButton
//


// Handle repaint
long FXRadioButton::onPaint(FXObject*, FXSelector, void* ptr)
{
    // Initialize Clearlooks (don't use the macro because here it's different)
    static FXbool  init = true;
    static FXbool  use_clearlooks = true;
    static FXColor bordercolor;

    if (init)
    {
        use_clearlooks = getApp()->reg().readUnsignedEntry("SETTINGS", "use_clearlooks", true);

        if (use_clearlooks)
        {
            FXuint r = FXREDVAL(baseColor);
            FXuint g = FXGREENVAL(baseColor);
            FXuint b = FXBLUEVAL(baseColor);

            bordercolor = FXRGB(0.5*r, 0.5*g, 0.5*b);
        }
        init = false;
    }

    FXEvent*    ev = (FXEvent*)ptr;
    FXint       tw = 0, th = 0, tx, ty, ix, iy;
    FXRectangle recs[6];
    FXDCWindow  dc(this, ev);

    dc.setForeground(backColor);
    dc.fillRectangle(ev->rect.x, ev->rect.y, ev->rect.w, ev->rect.h);

    if (!label.empty())
    {
        tw = labelWidth(label);
        th = labelHeight(label);
    }

    just_x(tx, ix, tw, 13);
    just_y(ty, iy, th, 13);

    // Inside
    recs[0].x = ix+4;
    recs[0].y = iy+2;
    recs[0].w = 4;
    recs[0].h = 1;
    recs[1].x = ix+3;
    recs[1].y = iy+3;
    recs[1].w = 6;
    recs[1].h = 1;
    recs[2].x = ix+2;
    recs[2].y = iy+4;
    recs[2].w = 8;
    recs[2].h = 4;
    recs[3].x = ix+3;
    recs[3].y = iy+8;
    recs[3].w = 6;
    recs[3].h = 1;
    recs[4].x = ix+4;
    recs[4].y = iy+9;
    recs[4].w = 4;
    recs[4].h = 1;
    if (!isEnabled())                   // fix by Daniel Gehriger (gehriger@linkcad.com)
    {
        dc.setForeground(baseColor);
    }
    else
    {
        dc.setForeground(diskColor);
    }
    dc.fillRectangles(recs, 5);

    // Radio button with Clearlooks appearance
    if (use_clearlooks)
    {
        // Top left inside
        recs[0].x = ix+4;
        recs[0].y = iy+1;
        recs[0].w = 4;
        recs[0].h = 1;
        recs[1].x = ix+2;
        recs[1].y = iy+2;
        recs[1].w = 2;
        recs[1].h = 1;
        recs[2].x = ix+8;
        recs[2].y = iy+2;
        recs[2].w = 2;
        recs[2].h = 1;
        recs[3].x = ix+2;
        recs[3].y = iy+3;
        recs[3].w = 1;
        recs[3].h = 1;
        recs[4].x = ix+1;
        recs[4].y = iy+4;
        recs[4].w = 1;
        recs[4].h = 4;
        recs[5].x = ix+2;
        recs[5].y = iy+8;
        recs[5].w = 1;
        recs[5].h = 2;
        dc.setForeground(bordercolor);
        dc.fillRectangles(recs, 6);

        // Bottom right inside
        recs[0].x = ix+9;
        recs[0].y = iy+3;
        recs[0].w = 1;
        recs[0].h = 1;
        recs[1].x = ix+10;
        recs[1].y = iy+4;
        recs[1].w = 1;
        recs[1].h = 4;
        recs[2].x = ix+9;
        recs[2].y = iy+8;
        recs[2].w = 1;
        recs[2].h = 1;
        recs[3].x = ix+8;
        recs[3].y = iy+9;
        recs[3].w = 2;
        recs[3].h = 1;
        recs[4].x = ix+3;
        recs[4].y = iy+9;
        recs[4].w = 1;
        recs[4].h = 1;
        recs[5].x = ix+4;
        recs[5].y = iy+10;
        recs[5].w = 4;
        recs[5].h = 1;
        dc.setForeground(bordercolor);
        dc.fillRectangles(recs, 6);
    }

    // Standard radio button
    else
    {
        // Top left outside
        recs[0].x = ix+4;
        recs[0].y = iy+0;
        recs[0].w = 4;
        recs[0].h = 1;
        recs[1].x = ix+2;
        recs[1].y = iy+1;
        recs[1].w = 2;
        recs[1].h = 1;
        recs[2].x = ix+8;
        recs[2].y = iy+1;
        recs[2].w = 2;
        recs[2].h = 1;
        recs[3].x = ix+1;
        recs[3].y = iy+2;
        recs[3].w = 1;
        recs[3].h = 2;
        recs[4].x = ix+0;
        recs[4].y = iy+4;
        recs[4].w = 1;
        recs[4].h = 4;
        recs[5].x = ix+1;
        recs[5].y = iy+8;
        recs[5].w = 1;
        recs[5].h = 2;
        dc.setForeground(shadowColor);
        dc.fillRectangles(recs, 6);

        // Top left inside
        recs[0].x = ix+4;
        recs[0].y = iy+1;
        recs[0].w = 4;
        recs[0].h = 1;
        recs[1].x = ix+2;
        recs[1].y = iy+2;
        recs[1].w = 2;
        recs[1].h = 1;
        recs[2].x = ix+8;
        recs[2].y = iy+2;
        recs[2].w = 2;
        recs[2].h = 1;
        recs[3].x = ix+2;
        recs[3].y = iy+3;
        recs[3].w = 1;
        recs[3].h = 1;
        recs[4].x = ix+1;
        recs[4].y = iy+4;
        recs[4].w = 1;
        recs[4].h = 4;
        recs[5].x = ix+2;
        recs[5].y = iy+8;
        recs[5].w = 1;
        recs[5].h = 2;
        dc.setForeground(borderColor);
        dc.fillRectangles(recs, 6);

        // Bottom right outside
        recs[0].x = ix+10;
        recs[0].y = iy+2;
        recs[0].w = 1;
        recs[0].h = 2;
        recs[1].x = ix+11;
        recs[1].y = iy+4;
        recs[1].w = 1;
        recs[1].h = 4;
        recs[2].x = ix+10;
        recs[2].y = iy+8;
        recs[2].w = 1;
        recs[2].h = 2;
        recs[3].x = ix+8;
        recs[3].y = iy+10;
        recs[3].w = 2;
        recs[3].h = 1;
        recs[4].x = ix+2;
        recs[4].y = iy+10;
        recs[4].w = 2;
        recs[4].h = 1;
        recs[5].x = ix+4;
        recs[5].y = iy+11;
        recs[5].w = 4;
        recs[5].h = 1;
        dc.setForeground(hiliteColor);
        dc.fillRectangles(recs, 6);

        // Bottom right inside
        recs[0].x = ix+9;
        recs[0].y = iy+3;
        recs[0].w = 1;
        recs[0].h = 1;
        recs[1].x = ix+10;
        recs[1].y = iy+4;
        recs[1].w = 1;
        recs[1].h = 4;
        recs[2].x = ix+9;
        recs[2].y = iy+8;
        recs[2].w = 1;
        recs[2].h = 1;
        recs[3].x = ix+8;
        recs[3].y = iy+9;
        recs[3].w = 2;
        recs[3].h = 1;
        recs[4].x = ix+3;
        recs[4].y = iy+9;
        recs[4].w = 1;
        recs[4].h = 1;
        recs[5].x = ix+4;
        recs[5].y = iy+10;
        recs[5].w = 4;
        recs[5].h = 1;
        dc.setForeground(baseColor);
        dc.fillRectangles(recs, 6);
    }

    // Ball inside
    if (check != false)
    {
        recs[0].x = ix+5;
        recs[0].y = iy+4;
        recs[0].w = 2;
        recs[0].h = 1;
        recs[1].x = ix+4;
        recs[1].y = iy+5;
        recs[1].w = 4;
        recs[1].h = 2;
        recs[2].x = ix+5;
        recs[2].y = iy+7;
        recs[2].w = 2;
        recs[2].h = 1;
        if (isEnabled())
        {
            dc.setForeground(radioColor);
        }
        else
        {
            dc.setForeground(shadowColor);
        }
        dc.fillRectangles(recs, 3);
    }

    // Label
    if (!label.empty())
    {
        dc.setFont(font);
        if (isEnabled())
        {
            dc.setForeground(textColor);
            drawLabel(dc, label, hotoff, tx, ty, tw, th);
            if (hasFocus())
            {
                dc.drawFocusRectangle(tx-1, ty-1, tw+2, th+2);
            }
        }
        else
        {
            dc.setForeground(hiliteColor);
            drawLabel(dc, label, hotoff, tx+1, ty+1, tw, th);
            dc.setForeground(shadowColor);
            drawLabel(dc, label, hotoff, tx, ty, tw, th);
        }
    }
    drawFrame(dc, 0, 0, width, height);
    return(1);
}


//
// Hack of FXMenuButton
//



// Handle repaint
long FXMenuButton::onPaint(FXObject*, FXSelector, void* ptr)
{
    // Initialize Clearlooks
    INIT_CLEARLOOKS

    int        tw = 0, th = 0, iw = 0, ih = 0, tx, ty, ix, iy;
    FXEvent*   ev = (FXEvent*)ptr;
    FXPoint    points[3];
    FXDCWindow dc(this, ev);

    // Button with nice gradient effect and rounded corners (Clearlooks)
    if (use_clearlooks)
    {
        // Toolbar style
        if (options&MENUBUTTON_TOOLBAR)
        {
            // Enabled and cursor inside, and not popped up
            if (isEnabled() && underCursor() && !state)
            {
                DRAW_CLEARLOOKS_BUTTON_DOWN
            }

            // Enabled and popped up
            else if (isEnabled() && state)
            {
                DRAW_CLEARLOOKS_BUTTON_UP
            }

            // Disabled or unchecked or not under cursor
            else
            {
                dc.setForeground(backColor);
                dc.fillRectangle(0, 0, width, height);
            }
        }

        // Normal style
        else
        {
            // Draw in up state if disabled or up
            if (!isEnabled() || !state)
            {
                DRAW_CLEARLOOKS_BUTTON_UP
            }

            // If enabled and either checked or pressed
            else
            {
                DRAW_CLEARLOOKS_BUTTON_DOWN
            }
        }
    }   // End of gradient painting


    // Normal flat rectangular button
    else
    {
        // Got a border at all?
        if (options&(FRAME_RAISED|FRAME_SUNKEN))
        {
            // Toolbar style
            if (options&MENUBUTTON_TOOLBAR)
            {
                // Enabled and cursor inside, and not popped up
                if (isEnabled() && underCursor() && !state)
                {
                    DRAW_STANDARD_BUTTON_DOWN
                }

                // Enabled and popped up
                else if (isEnabled() && state)
                {
                    DRAW_STANDARD_BUTTON_UP
                }

                // Disabled or unchecked or not under cursor
                else
                {
                    dc.setForeground(backColor);
                    dc.fillRectangle(0, 0, width, height);
                }
            }

            // Normal style
            else
            {
                // Draw in up state if disabled or up
                if (!isEnabled() || !state)
                {
                    DRAW_STANDARD_BUTTON_UP
                }

                // Draw sunken if enabled and either checked or pressed
                else
                {
                    DRAW_STANDARD_BUTTON_DOWN
                }
            }
        }

        // No borders
        else
        {
            if (isEnabled() && state)
            {
                dc.setForeground(hiliteColor);
                dc.fillRectangle(0, 0, width, height);
            }
            else
            {
                dc.setForeground(backColor);
                dc.fillRectangle(0, 0, width, height);
            }
        }
    }   // End of normal painting

    // Position text & icon
    if (!label.empty())
    {
        tw = labelWidth(label);
        th = labelHeight(label);
    }

    // Icon?
    if (icon)
    {
        iw = icon->getWidth();
        ih = icon->getHeight();
    }

    // Arrows?
    else if (!(options&MENUBUTTON_NOARROWS))
    {
        if (options&MENUBUTTON_LEFT)
        {
            ih = MENUBUTTONARROW_WIDTH;
            iw = MENUBUTTONARROW_HEIGHT;
        }
        else
        {
            iw = MENUBUTTONARROW_WIDTH;
            ih = MENUBUTTONARROW_HEIGHT;
        }
    }

    // Keep some room for the arrow!
    just_x(tx, ix, tw, iw);
    just_y(ty, iy, th, ih);

    // Move a bit when pressed
    if (state)
    {
        ++tx;
        ++ty;
        ++ix;
        ++iy;
    }

    // Draw icon
    if (icon)
    {
        if (isEnabled())
        {
            dc.drawIcon(icon, ix, iy);
        }
        else
        {
            dc.drawIconSunken(icon, ix, iy);
        }
    }

    // Draw arrows
    else if (!(options&MENUBUTTON_NOARROWS))
    {
        // Right arrow
        if ((options&MENUBUTTON_RIGHT) == MENUBUTTON_RIGHT)
        {
            if (isEnabled())
            {
                dc.setForeground(textColor);
            }
            else
            {
                dc.setForeground(shadowColor);
            }
            points[0].x = ix;
            points[0].y = iy;
            points[1].x = ix;
            points[1].y = iy+MENUBUTTONARROW_WIDTH-1;
            points[2].x = ix+MENUBUTTONARROW_HEIGHT;
            points[2].y = (short)(iy+(MENUBUTTONARROW_WIDTH>>1));
            dc.fillPolygon(points, 3);
        }

        // Left arrow
        else if (options&MENUBUTTON_LEFT)
        {
            if (isEnabled())
            {
                dc.setForeground(textColor);
            }
            else
            {
                dc.setForeground(shadowColor);
            }
            points[0].x = ix+MENUBUTTONARROW_HEIGHT;
            points[0].y = iy;
            points[1].x = ix+MENUBUTTONARROW_HEIGHT;
            points[1].y = iy+MENUBUTTONARROW_WIDTH-1;
            points[2].x = ix;
            points[2].y = (short)(iy+(MENUBUTTONARROW_WIDTH>>1));
            dc.fillPolygon(points, 3);
        }

        // Up arrow
        else if (options&MENUBUTTON_UP)
        {
            if (isEnabled())
            {
                dc.setForeground(textColor);
            }
            else
            {
                dc.setForeground(shadowColor);
            }
            points[0].x = (short)(ix+(MENUBUTTONARROW_WIDTH>>1));
            points[0].y = iy-1;
            points[1].x = ix;
            points[1].y = iy+MENUBUTTONARROW_HEIGHT;
            points[2].x = ix+MENUBUTTONARROW_WIDTH;
            points[2].y = iy+MENUBUTTONARROW_HEIGHT;
            dc.fillPolygon(points, 3);
        }

        // Down arrow
        else
        {
            if (isEnabled())
            {
                dc.setForeground(textColor);
            }
            else
            {
                dc.setForeground(shadowColor);
            }
            points[0].x = ix+1;
            points[0].y = iy;
            points[2].x = ix+MENUBUTTONARROW_WIDTH-1;
            points[2].y = iy;
            points[1].x = (short)(ix+(MENUBUTTONARROW_WIDTH>>1));
            points[1].y = iy+MENUBUTTONARROW_HEIGHT;
            dc.fillPolygon(points, 3);
        }
    }

    // Draw text
    if (!label.empty())
    {
        dc.setFont(font);
        if (isEnabled())
        {
            dc.setForeground(textColor);
            drawLabel(dc, label, hotoff, tx, ty, tw, th);
        }
        else
        {
            dc.setForeground(hiliteColor);
            drawLabel(dc, label, hotoff, tx+1, ty+1, tw, th);
            dc.setForeground(shadowColor);
            drawLabel(dc, label, hotoff, tx, ty, tw, th);
        }
    }

    // Draw focus
    if (hasFocus())
    {
        if (isEnabled())
        {
            dc.drawFocusRectangle(border+1, border+1, width-2*border-2, height-2*border-2);
        }
    }
    return(1);
}


//
// Hack of FXArrowButton
//


// Handle repaint
long FXArrowButton::onPaint(FXObject*, FXSelector, void* ptr)
{
    // Initialize Clearlooks
    INIT_CLEARLOOKS

    FXEvent*   ev = (FXEvent*)ptr;
    FXDCWindow dc(this, ev);
    FXPoint    points[3];
    int        xx, yy, ww, hh, q;

    // Button with nice gradient effect and rounded corners (Clearlooks)
    if (use_clearlooks)
    {
        // Toolbar style
        if (options&ARROW_TOOLBAR)
        {
            // Enabled and cursor inside, and up
            if (isEnabled() && underCursor() && !state)
            {
                DRAW_CLEARLOOKS_BUTTON_UP
            }

            // Enabled and cursor inside and down
            else if (isEnabled() && state)
            {
                DRAW_CLEARLOOKS_BUTTON_DOWN
            }

            // Disabled or unchecked or not under cursor
            else
            {
                dc.setForeground(backColor);
                dc.fillRectangle(0, 0, width, height);
            }
        }

        // Normal style
        else
        {
            // Draw sunken if enabled and pressed
            if (isEnabled() && state)
            {
                DRAW_CLEARLOOKS_BUTTON_DOWN
            }

            // Draw in up state if disabled or up
            else
            {
                DRAW_CLEARLOOKS_BUTTON_UP
            }
        }
    }   // End of gradient painting

    // Normal flat rectangular button
    else
    {
        // With borders
        if (options&(FRAME_RAISED|FRAME_SUNKEN))
        {
            // Toolbar style
            if (options&ARROW_TOOLBAR)
            {
                // Enabled and cursor inside, and up
                if (isEnabled() && underCursor() && !state)
                {
                    DRAW_STANDARD_BUTTON_UP
                }

                // Enabled and cursor inside and down
                else if (isEnabled() && state)
                {
                    DRAW_STANDARD_BUTTON_DOWN
                }

                // Disabled or unchecked or not under cursor
                else
                {
                    dc.setForeground(backColor);
                    dc.fillRectangle(0, 0, width, height);
                }
            }

            // Normal style
            else
            {
                // Draw sunken if enabled and pressed
                if (isEnabled() && state)
                {
                    DRAW_STANDARD_BUTTON_DOWN
                }

                // Draw in up state if disabled or up
                else
                {
                    DRAW_STANDARD_BUTTON_UP
                }
            }
        }

        // No borders
        else
        {
            if (isEnabled() && state)
            {
                dc.setForeground(hiliteColor);
                dc.fillRectangle(0, 0, width, height);
            }
            else
            {
                dc.setForeground(backColor);
                dc.fillRectangle(0, 0, width, height);
            }
        }
    }   // End of normal painting

    // Compute size of the arrows....
    ww = width-padleft-padright-(border<<1);
    hh = height-padtop-padbottom-(border<<1);
    if (options&(ARROW_UP|ARROW_DOWN))
    {
        q = ww|1;
        if (q > (hh<<1))
        {
            q = (hh<<1)-1;
        }
        ww = q;
        hh = q>>1;
    }
    else
    {
        q = hh|1;
        if (q > (ww<<1))
        {
            q = (ww<<1)-1;
        }
        ww = q>>1;
        hh = q;
    }

    if (options&JUSTIFY_LEFT)
    {
        xx = padleft+border;
    }
    else if (options&JUSTIFY_RIGHT)
    {
        xx = width-ww-padright-border;
    }
    else
    {
        xx = (width-ww)/2;
    }

    if (options&JUSTIFY_TOP)
    {
        yy = padtop+border;
    }
    else if (options&JUSTIFY_BOTTOM)
    {
        yy = height-hh-padbottom-border;
    }
    else
    {
        yy = (height-hh)/2;
    }

    if (state)
    {
        ++xx;
        ++yy;
    }

    if (isEnabled())
    {
        dc.setForeground(arrowColor);
    }
    else
    {
        dc.setForeground(shadowColor);
    }

    // NB Size of arrow should stretch
    if (options&ARROW_UP)
    {
        points[0].x = xx+(ww>>1);
        points[0].y = yy-1;
        points[1].x = xx;
        points[1].y = yy+hh;
        points[2].x = xx+ww;
        points[2].y = yy+hh;
        dc.fillPolygon(points, 3);
    }
    else if (options&ARROW_DOWN)
    {
        points[0].x = xx+1;
        points[0].y = yy;
        points[1].x = xx+ww-1;
        points[1].y = yy;
        points[2].x = xx+(ww>>1);
        points[2].y = yy+hh;
        dc.fillPolygon(points, 3);
    }
    else if (options&ARROW_LEFT)
    {
        points[0].x = xx+ww;
        points[0].y = yy;
        points[1].x = xx+ww;
        points[1].y = yy+hh-1;
        points[2].x = xx;
        points[2].y = yy+(hh>>1);
        dc.fillPolygon(points, 3);
    }
    else if (options&ARROW_RIGHT)
    {
        points[0].x = xx;
        points[0].y = yy;
        points[1].x = xx;
        points[1].y = yy+hh-1;
        points[2].x = xx+ww;
        points[2].y = yy+(hh>>1);
        dc.fillPolygon(points, 3);
    }
    return(1);
}


//
// Hack of FXProgressBar
//

// Note : Not implemented for the dial and vertical progress bar!
//        This hacks assumes that border = 2


// Draw only the interior, i.e. the part that changes
void FXProgressBar::drawInterior(FXDCWindow& dc)
{
    static FXbool  init = true;
    static FXbool  use_clearlooks = true;
    static FXColor topcolor, bottomcolor, bordercolor;

    FXPoint bordercorners[4] = { FXPoint(1, 1), FXPoint(1, height-2), FXPoint(width-2, 1),      
                                 FXPoint(width-2, height-2) };                                  

    // Init Clearlooks (don't use the macro because here it's different)
    if (init)
    {
        use_clearlooks = getApp()->reg().readUnsignedEntry("SETTINGS", "use_clearlooks", true);

        if (use_clearlooks)
        {
            FXuint r = FXREDVAL(barColor);
            FXuint g = FXGREENVAL(barColor);
            FXuint b = FXBLUEVAL(barColor);

            topcolor = FXRGB(FXMIN(1.2*r, 255), FXMIN(1.2*g, 255), FXMIN(1.2*b, 255));
            bottomcolor = FXRGB(0.9*r, 0.9*g, 0.9*b);

            r = FXREDVAL(baseColor);
            g = FXGREENVAL(baseColor);
            b = FXBLUEVAL(baseColor);

            bordercolor = FXRGB(0.5*r, 0.5*g, 0.5*b);
        }
        init = false;
    }

    int  percent, barlength, barfilled, tx, ty, tw, th, n, d;
    char numtext[6];

    if (options&PROGRESSBAR_DIAL)
    {
        // If total is 0, it's 100%
        barfilled = 23040;
        percent = 100;
        if (total != 0)
        {
            barfilled = (FXuint)(((double)progress * (double)23040) / (double)total);
            percent = (FXuint)(((double)progress * 100.0) / (double)total);
        }

        tw = width-(border<<1)-padleft-padright;
        th = height-(border<<1)-padtop-padbottom;
        d = FXMIN(tw, th)-1;

        tx = border+padleft+((tw-d)/2);
        ty = border+padtop+((th-d)/2);

        if (barfilled != 23040)
        {
            dc.setForeground(barBGColor);
            dc.fillArc(tx, ty, d, d, 5760, 23040-barfilled);
        }
        if (barfilled != 0)
        {
            dc.setForeground(barColor);
            dc.fillArc(tx, ty, d, d, 5760, -barfilled);
        }

        // Draw outside circle
        dc.setForeground(borderColor);
        dc.drawArc(tx+1, ty, d, d, 90*64, 45*64);
        dc.drawArc(tx, ty+1, d, d, 135*64, 45*64);
        dc.setForeground(baseColor);
        dc.drawArc(tx-1, ty, d, d, 270*64, 45*64);
        dc.drawArc(tx, ty-1, d, d, 315*64, 45*64);

        dc.setForeground(shadowColor);
        dc.drawArc(tx, ty, d, d, 45*64, 180*64);
        dc.setForeground(hiliteColor);
        dc.drawArc(tx, ty, d, d, 225*64, 180*64);

        // Draw text
        if (options&PROGRESSBAR_PERCENTAGE)
        {
            dc.setFont(font);
            tw = font->getTextWidth("100%", 4);
            if (tw > (10*d)/16)
            {
                return;
            }
            th = font->getFontHeight();
            if (th > d/2)
            {
                return;
            }
            snprintf(numtext, sizeof(numtext)-1, "%d%%", percent);
            n = strlen(numtext);
            tw = font->getTextWidth(numtext, n);
            th = font->getFontHeight();
            tx = tx+d/2-tw/2;
            ty = ty+d/2+font->getFontAscent()+5;
            //dc.setForeground(textNumColor);
#ifdef HAVE_XFT_H
            dc.setForeground(barBGColor);             // Code for XFT until XFT can use BLT_SRC_XOR_DST
            dc.drawText(tx-1, ty, numtext, n);
            dc.drawText(tx+1, ty, numtext, n);
            dc.drawText(tx, ty-1, numtext, n);
            dc.drawText(tx, ty+1, numtext, n);
            dc.setForeground(textNumColor);
            dc.drawText(tx, ty, numtext, n);
#else
            dc.setForeground(FXRGB(255, 255, 255));     // Original code
            dc.setFunction(BLT_SRC_XOR_DST);
            dc.drawText(tx, ty, numtext, n);
#endif
        }
    }

    // Vertical bar
    else if (options&PROGRESSBAR_VERTICAL)
    {
        // If total is 0, it's 100%
        barlength = height-border-border;
        barfilled = barlength;
        percent = 100;
      
        if (total != 0)
        {
            barfilled = (FXuint)(((double)progress * (double)barlength) / (double)total);
            percent = (FXuint)(((double)progress * 100.0) / (double)total);
        }

        // Draw completed bar
        if (0 < barfilled)
        {
			dc.setForeground(barColor);
			dc.fillRectangle(border, height-border-barfilled, width-(border<<1), barfilled);
        }

        // Draw uncompleted bar
        if (barfilled < barlength)
        {
			dc.setForeground(barBGColor);
			dc.fillRectangle(border, border, width-(border<<1), barlength-barfilled);
        }

        // Draw text
        if (options&PROGRESSBAR_PERCENTAGE)
        {
            dc.setFont(font);
            snprintf(numtext, sizeof(numtext)-1, "%d%%", percent);
            n = strlen(numtext);
            tw = font->getTextWidth(numtext, n);
            th = font->getFontHeight();
            ty = (height-th)/2+font->getFontAscent();
            tx = (width-tw)/2;
            if (height-border-barfilled > ty)           // In upper side
            {
                dc.setForeground(textNumColor);
                dc.setClipRectangle(border, border, width-(border<<1), height-(border<<1));
                dc.drawText(tx, ty, numtext, n);
            }
            else if (ty-th > height-border-barfilled)   // In lower side
            {
                dc.setForeground(textAltColor);
                dc.setClipRectangle(border, border, width-(border<<1), height-(border<<1));
                dc.drawText(tx, ty, numtext, n);
            }
            else                                      // In between!
            {
                dc.setForeground(textAltColor);
                dc.setClipRectangle(border, height-border-barfilled, width-(border<<1), barfilled);
                dc.drawText(tx, ty, numtext, n);
                dc.setForeground(textNumColor);
                dc.setClipRectangle(border, border, width-(border<<1), barlength-barfilled);
                dc.drawText(tx, ty, numtext, n);
                dc.clearClipRectangle();
            }
        }
    }

    // Horizontal bar
    else
    {
        // If total is 0, it's 100%
        barlength = width-border-border;
        barfilled = barlength;
        percent = 100;
        if (total != 0)
        {
            barfilled = (FXuint)(((double)progress * (double)barlength) / (double)total);
            percent = (FXuint)(((double)progress * 100.0) / (double)total);
        }

        // Draw uncompleted bar
        if (barfilled < barlength)
        {
            // Clearlooks (gradient with rounded corners)
            if (use_clearlooks)
            {
	            dc.setForeground(barBGColor);
	            dc.fillRectangle(border+barfilled+(border>>1), border>>1, barlength-barfilled, height-border);
            }
            // Standard (flat)
            else
            {
	            dc.setForeground(barBGColor);
	            dc.fillRectangle(border+barfilled, border, barlength-barfilled, height-(border<<1));
            }
        }

        // Draw completed bar
        if (0 < barfilled)
        {
            // Clearlooks (gradient with rounded corners)
            if (use_clearlooks)
            {
                drawGradientRectangle(dc, topcolor, bottomcolor, border-1, border-1, barfilled+2, height-border, true);
				
				dc.setForeground(bordercolor);                                               
				dc.fillRectangle(barfilled+3, 2, 1, height-(border<<1));
				dc.drawPoints(bordercorners, 4);

    			FXPoint barcorners[2] = { FXPoint(barfilled+2, 1), FXPoint(barfilled+2, height-border) };                                  
				dc.drawPoints(barcorners, 2);
			}
            // Standard (flat)
            else
            {
                dc.setForeground(barColor);
                dc.fillRectangle(border, border, barfilled, height-(border<<1));
            }
        }
        // Draw text
        if (options&PROGRESSBAR_PERCENTAGE)
        {
            dc.setFont(font);
            snprintf(numtext, sizeof(numtext)-1, "%d%%", percent);
            n = strlen(numtext);
            tw = font->getTextWidth(numtext, n);
            th = font->getFontHeight();
            ty = (height-th)/2+font->getFontAscent();
            tx = (width-tw)/2;
            if (border+barfilled <= tx)           // In right side
            {
                dc.setForeground(textNumColor);
                dc.setClipRectangle(border, border, width-(border<<1), height-(border<<1));
                dc.drawText(tx, ty, numtext, n);
            }
            else if (tx+tw <= border+barfilled)   // In left side
            {
                dc.setForeground(textAltColor);
                dc.setClipRectangle(border, border, width-(border<<1), height-(border<<1));
                dc.drawText(tx, ty, numtext, n);
            }
            else                                // In between!
            {
                dc.setForeground(textAltColor);
                dc.setClipRectangle(border, border, barfilled, height);
                dc.drawText(tx, ty, numtext, n);
                dc.setForeground(textNumColor);
                dc.setClipRectangle(border+barfilled, border, barlength-barfilled, height);
                dc.drawText(tx, ty, numtext, n);
                dc.clearClipRectangle();
            }
        }
    }
}


// Draw the progress bar
long FXProgressBar::onPaint(FXObject*,FXSelector,void *ptr)
{
    // Initialize Clearlooks
    INIT_CLEARLOOKS

	FXEvent *event=(FXEvent*)ptr;
	FXDCWindow dc(this,event);

	// Draw borders if any
	drawFrame(dc,0,0,width,height);

	// Background
	dc.setForeground(getBaseColor());
	dc.fillRectangle(border,border,width-(border<<1),height-(border<<1));

    // !!! Hack to get an optional rounded rectangle shape
    // only if _TEXTFIELD_NOFRAME is not specified !!!
    if ( (!(options&_TEXTFIELD_NOFRAME))  & use_clearlooks )
    {
        // Outside Background
        dc.setForeground(baseColor);
        dc.fillRectangle(0, 0, width, height);
        dc.drawPoints(basebackground, 4);

        // Border
        dc.setForeground(bordercolor);
        dc.drawRectangle(2, 0, width-5, 0);
        dc.drawRectangle(2, height-1, width-5, height-1);
        dc.drawRectangle(0, 2, 0, height-5);
        dc.drawRectangle(width-1, 2, 0, height-5);
        dc.drawPoints(bordercorners, 4);
        dc.setForeground(shadecolor);
        dc.drawPoints(bordershade, 16);
        dc.setForeground(backColor);
        dc.fillRectangle(2, 1, width-4, height-2);
    }
    // !!! End of hack

	// Interior
	drawInterior(dc);
	return 1;
}


//
// Hack of FXPacker
//

// This hack optionally draws a rectangle with rounded corners (Clearlooks)
void FXPacker::drawGrooveRectangle(FXDCWindow& dc, FXint x, FXint y, FXint w, FXint h)
{
    static FXbool  init = true;
    static FXbool  use_clearlooks = true;
    static FXColor shadecolor, bordercolor;

    FXPoint bordershade[16] =
    {
        FXPoint(x, y+1), FXPoint(x+1, y), FXPoint(x+1, y+2), FXPoint(x+2, y+1),
        FXPoint(x+w-2, y), FXPoint(x+w-1, y+1), FXPoint(x+w-3, y+1),
        FXPoint(x+w-2, y+2), FXPoint(x, y+h-2), FXPoint(x+1, y+h-1),
        FXPoint(x+1, y+h-3), FXPoint(x+2, y+h-2),
        FXPoint(x+w-1, y+h-2), FXPoint(x+w-2, y+h-1),
        FXPoint(x+w-2, y+h-3), FXPoint(x+w-3, y+h-2)
    };
    FXPoint bordercorners[4] =
    {
        FXPoint(x+1, y+1), FXPoint(x+1, y+h-2), FXPoint(x+w-2, y+1),
        FXPoint(x+w-2, y+h-2)
    };

    if (init)
    {
        use_clearlooks = getApp()->reg().readUnsignedEntry("SETTINGS", "use_clearlooks", true);

        if (use_clearlooks)
        {
            FXuint r = FXREDVAL(backColor);
            FXuint g = FXGREENVAL(backColor);
            FXuint b = FXBLUEVAL(backColor);

            shadecolor = FXRGB(0.9*r, 0.9*g, 0.9*b);
            bordercolor = FXRGB(0.5*r, 0.5*g, 0.5*b);
            (void)bordercolor; // Hack to avoid unused variable compiler warning
        }
        init = false;
    }

    if ((0 < w) && (0 < h))
    {
        // Rectangle with rounded corners (Clearlooks)
        if (use_clearlooks)
        {
            // Draw the 4 edges
            dc.setForeground(shadowColor);
            dc.drawRectangle(x+w-1, y+2, 0, h-5); // right
            dc.drawRectangle(x, y+2, 0, h-5);     // left
            dc.drawRectangle(x+2, y, w-5, 0);     // up
            dc.drawRectangle(x+2, y+h-1, w-5, 0); // down

            // Draw the 4 rounded corners (with shade)
            dc.setForeground(shadowColor);
            dc.drawPoints(bordercorners, 4);
            dc.setForeground(shadecolor);
            dc.drawPoints(bordershade, 16);
        }

        // Standard rectangle
        else
        {
            dc.setForeground(shadowColor);
            dc.fillRectangle(x, y, w, 1);
            dc.fillRectangle(x, y, 1, h);
            dc.setForeground(hiliteColor);
            dc.fillRectangle(x, y+h-1, w, 1);
            dc.fillRectangle(x+w-1, y, 1, h);
            if ((1 < w) && (1 < h))
            {
                dc.setForeground(shadowColor);
                dc.fillRectangle(x+1, y+h-2, w-2, 1);
                dc.fillRectangle(x+w-2, y+1, 1, h-2);
                dc.setForeground(hiliteColor);
                dc.fillRectangle(x+1, y+1, w-3, 1);
                dc.fillRectangle(x+1, y+1, 1, h-3);
            }
        }
    }
}

//
// Hack of FXDragCorner
//

#define CORNERSIZE    13


long FXDragCorner::onPaint(FXObject*,FXSelector,void* ptr){
    FXEvent*   ev = (FXEvent*)ptr;
    FXDCWindow dc(this, ev);
/*  dc.setForeground(backColor);
  dc.fillRectangle(ev->rect.x,ev->rect.y,ev->rect.w,ev->rect.h);
  dc.setForeground(shadowColor);
  dc.drawLine(width-2,height-1,width,height-3);
  dc.drawLine(width-8,height-1,width,height-9);
  dc.drawLine(width-14,height-1,width,height-15);
  dc.setForeground(hiliteColor);
  dc.drawLine(width-5,height-1,width,height-6);
  dc.drawLine(width-11,height-1,width,height-12);
  dc.drawLine(width-17,height-1,width,height-18);*/
     dc.setForeground(backColor);
     dc.fillRectangle(ev->rect.x,ev->rect.y,ev->rect.w,ev->rect.h);
     dc.drawIcon(resizecorner, height-13, width-13);
  return 1;
}

//long FXDragCorner::onMap(FXObject*,FXSelector,void* ptr){


// Get default width
FXint FXDragCorner::getDefaultWidth(){
  return CORNERSIZE;
}


// Get default height
FXint FXDragCorner::getDefaultHeight(){
  return CORNERSIZE;
}


// Everything below including FXText and FXTextField is modified from FOX
// Draw the cursor
void FXText::drawCursor(FXuint state){
  register FXint xx,yt,yb,xlo,xhi,fh;
  if((state^flags)&FLAG_CARET){
    if(xid){
      FXASSERT(0<=cursorpos && cursorpos<=length);
      FXASSERT(0<=cursorrow && cursorrow<=nrows);
      if(toprow<=cursorrow && cursorrow<toprow+nvisrows){
        xx=pos_x+marginleft+barwidth+lineWidth(cursorstart,cursorpos-cursorstart)-1;
        if(barwidth<=xx+3 && xx-2<viewport_w){
          FXDCWindow dc(this);
          fh=font->getFontHeight();
          yt=pos_y+margintop+cursorrow*fh;
          yb=yt+fh-1;

          // Cursor can overhang margins but not line number bar
          dc.setClipRectangle(barwidth,0,viewport_w-barwidth,viewport_h);

          // Draw I beam
          if(state&FLAG_CARET){

            // Draw I-beam
            dc.setForeground(cursorColor);
            dc.fillRectangle(xx+2,yt+1,1,yb-yt-1);
            // dc.fillRectangle(xx-2,yt,6,1);
            // dc.fillRectangle(xx-2,yb,6,1);
            }

          // Erase I-beam
          else{

            // Erase I-beam, plus the text immediately surrounding it
            dc.setForeground(backColor);
            dc.fillRectangle(xx-2,yt,6,yb-yt+1);

            // Clip the text to the margins AND the rectangle that was
            // just erased.  We don't want to overdraw any existing
            // characters, because of ClearType.
            xlo=FXMAX(xx-2,marginleft+barwidth);
            xhi=FXMIN(xx+4,viewport_w-marginright);
            dc.setClipRectangle(xlo,margintop,xhi-xlo,viewport_h-margintop-marginbottom);

            // Restore text
            dc.setFont(font);
            drawTextRow(dc,cursorrow-toprow,xx-3,xx+4);
            }
          }
        }
      }
    flags^=FLAG_CARET;
    }
  }


void FXTextField::drawCursor(FXuint state){
  FXint cl,ch,xx,xlo,xhi;
  if((state^flags)&FLAG_CARET){
    if(xid){
      FXDCWindow dc(this);
      FXASSERT(0<=cursor && cursor<=contents.length());
      FXASSERT(0<=anchor && anchor<=contents.length());
      xx=coord(cursor)-1;

      // Clip rectangle around cursor
      xlo=FXMAX(xx-2,border);
      xhi=FXMIN(xx+3,width-border);

      // Cursor can overhang padding but not borders
      dc.setClipRectangle(xlo,border,xhi-xlo,height-(border<<1));

      // Draw I beam
      if(state&FLAG_CARET){

        // Draw I-beam
        dc.setForeground(cursorColor);
        dc.fillRectangle(xx+1,padtop+border+1,1,height-1-padbottom-padtop-(border<<1));
        //dc.fillRectangle(xx-2,padtop+border,5,1);
        //dc.fillRectangle(xx-2,height-border-padbottom-1,5,1);
        }

      // Erase I-beam
      else{

        // Erase I-beam, plus the text immediately surrounding it
        dc.setForeground(backColor);
        dc.fillRectangle(xx-2,border+1,5,height-1-(border<<1));

        // Draw two characters before and after cursor
        cl=ch=cursor;
        if(0<cl){
          cl=contents.dec(cl);
          if(0<cl){
            cl=contents.dec(cl);
            }
          }
        if(ch<contents.length()){
          ch=contents.inc(ch);
          if(ch<contents.length()){
            ch=contents.inc(ch);
            }
          }
        drawTextRange(dc,cl,ch);
        }
      }
    flags^=FLAG_CARET;
    }
  }

// Handle repaint
/* long FXTextField::onPaint(FXObject*,FXSelector,void* ptr){
  FXEvent *ev=(FXEvent*)ptr;
  FXDCWindow dc(this,ev);

  // Draw frame
  drawFrame(dc,0,0,width,height);

  // Gray background if disabled
  if(isEnabled())
    dc.setForeground(backColor);
  else
    dc.setForeground(baseColor);

  // Draw background
  dc.fillRectangle(border,border,width-(border<<1),height-(border<<1));

  // Draw text, clipped against frame interior
  dc.setClipRectangle(border,border,width-(border<<1),height-(border<<1));
  drawTextRange(dc,0,contents.length());

  // Draw caret
  if(flags&FLAG_CARET){
    int xx=coord(cursor)-1;
    dc.setForeground(cursorColor);
    dc.fillRectangle(xx+1,padtop+border,1,height-padbottom-padtop-(border<<1));
    //dc.fillRectangle(xx-2,padtop+border,5,1);
    //dc.fillRectangle(xx-2,height-border-padbottom-1,5,1);
    }
  return 1;
  } */
// This file contains some FOX functions redefinitions (FOX hacks for various purposes, except for Clearlooks controls)

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>

#ifdef HAVE_XFT_H
#include <X11/Xft/Xft.h>
#endif

#ifdef HAVE_XRANDR_H
#include <X11/extensions/Xrandr.h>
#endif

extern FXbool   file_tooltips;
extern FXString xdgconfighome;
extern FXbool   xim_used;


// Hack to fix issues with drag and drop within, from and to the dirList
#define SELECT_MASK    (TREELIST_SINGLESELECT|TREELIST_BROWSESELECT)

// Remove all siblings from [fm,to]
void FXTreeList::removeItems(FXTreeItem* fm, FXTreeItem* to, FXbool notify)
{
    register FXTreeItem* olditem = currentitem;
    register FXTreeItem* prv;
    register FXTreeItem* nxt;
    register FXTreeItem* par;

    if (fm && to)
    {
        if (fm->parent != to->parent)
        {
            fxerror("%s::removeItems: arguments have different parent.\n", getClassName());
        }

        // Delete items
        while (1)
        {
            // Scan till end
            while (to->last)
            {
                to = to->last;
            }
            do
            {
                // Notify item will be deleted
                if (notify && target)
                {
                    target->tryHandle(this, FXSEL(SEL_DELETED, message), (void*)to);
                }

                // Remember hookups
                nxt = to->next;
                prv = to->prev;
                par = to->parent;

                // !!! Hack to go back to the parent when an item disappeared

                // Adjust pointers; suggested by Alan Ott <ott@acusoft.com>
                anchoritem = par;
                currentitem = par;
                extentitem = par;
                viewableitem = par;

                // !!! End of hack

                // Remove item from list
                if (prv)
                {
                    prv->next = nxt;
                }
                else if (par)
                {
                    par->first = nxt;
                }
                else
                {
                    firstitem = nxt;
                }
                if (nxt)
                {
                    nxt->prev = prv;
                }
                else if (par)
                {
                    par->last = prv;
                }
                else
                {
                    lastitem = prv;
                }

                // Delete it
                delete to;

                // Was last one?
                if (to == fm)
                {
                    goto x;
                }
                to = par;
            } while (!prv);
            to = prv;
        }

        // Current item has changed
x:
        if (olditem != currentitem)
        {
            if (notify && target)
            {
                target->tryHandle(this, FXSEL(SEL_CHANGED, message), (void*)currentitem);
            }
        }

        // Deleted current item
        if (currentitem && (currentitem != olditem))
        {
            if (hasFocus())
            {
                currentitem->setFocus(true);
            }
            if (((options&SELECT_MASK) == TREELIST_BROWSESELECT) && currentitem->isEnabled())
            {
                selectItem(currentitem, notify);
            }
        }

        // Redo layout
        recalc();
    }
}


// Hack to display a tooltip with name, size, date, etc.
// We were asked about tip text
long FXTreeList::onQueryTip(FXObject* sender, FXSelector sel, void* ptr)
{
    if (FXWindow::onQueryTip(sender, sel, ptr))
    {
        return(1);
    }

    // File tooltips are optional
    if (file_tooltips)
    {
        if ((flags&FLAG_TIP) && !(options&TREELIST_AUTOSELECT)) // No tip when autoselect!
        {
            int    x, y;
            FXuint buttons;

            getCursorPosition(x, y, buttons);
            DirItem* item = (DirItem*)getItemAt(x, y);
            if (item)
            {
                // !!! Hack to display a tooltip with name, size, date, etc.
                FXString string;

                // Root folder
                if (item->getText() == ROOTDIR)
                {
                    string = _("Root folder");
                }

                // Other folders
                else
                {
                    // Get tooltip data
                    FXString str = item->getTooltipData();
                    if (str == "")
                    {
                        return(0);
                    }

                    // Add name, type, permissions, etc. to the tool tip
                    FXString name = str.section('\t', 0);
                    FXString type = str.section('\t', 1);
                    FXString date = str.section('\t', 2);
                    FXString user = str.section('\t', 3);
                    FXString group = str.section('\t', 4);
                    FXString perms = str.section('\t', 5);
                    FXString deldate = str.section('\t', 6);
                    FXString pathname = str.section('\t', 7);

                    // Compute root file size
                    FXulong dnsize;
                    char    dsize[64];
                    dnsize = ::dirsize(pathname.text());
#if __WORDSIZE == 64
                    snprintf(dsize, sizeof(dsize)-1, "%lu", dnsize);
#else
                    snprintf(dsize, sizeof(dsize)-1, "%llu", dnsize);
#endif
                    FXString size = ::hSize(dsize);
                    if (deldate.empty())
                    {
                        string = _("Name: ")+name+"\n"+_("Size in root: ")+size+"\n"+_("Type: ")+type
                                 +"\n"+_("Modified date: ")+date+"\n"+_("User: ")+user+" - "+_("Group: ")+group
                                 +"\n"+_("Permissions: ")+perms;
                    }
                    else
                    {
                        string = _("Name: ")+name+"\n"+_("Size in root: ")+size+"\n"+_("Type: ")+type
                                 +"\n"+_("Modified date: ")+date+"\n"+_("Deletion date: ")+deldate+"\n"+_("User: ")+user+" - "+_("Group: ")+group
                                 +"\n"+_("Permissions: ")+perms;
                    }
                }
                // !!! End of hack !!!

                sender->handle(this, FXSEL(SEL_COMMAND, ID_SETSTRINGVALUE), (void*)&string);
                return(1);
            }
        }
    }
    return(0);
}


//
// Hack of FXDCWindow
//

#define DISPLAY(app)    ((Display*)((app)->display))
#define FS    ((XFontStruct*)(font->font))

#ifndef HAVE_XFT_H
static int utf2db(XChar2b* dst, const char* src, int n)
{
    register int     len, p;
    register FXwchar w;

    for (p = len = 0; p < n; p += wclen(src+p), len++)
    {
        w = wc(src+p);
        dst[len].byte1 = (w>>8);
        dst[len].byte2 = (w&255);
    }
    return(len);
}


#endif


// Hack to take into account non UTF-8 strings
void FXDCWindow::drawText(int x, int y, const char* string, FXuint length)
{
    if (!surface)
    {
        fprintf(stderr, "FXDCWindow::drawText: DC not connected to drawable.\n");
        exit(EXIT_FAILURE);
    }
    if (!font)
    {
        fprintf(stderr, "FXDCWindow::drawText: no font selected.\n");
        exit(EXIT_FAILURE);
    }
    if (!string)
    {
        fprintf(stderr, "FXDCWindow::drawText: NULL string argument.\n");
        exit(EXIT_FAILURE);
    }

#ifdef HAVE_XFT_H
    XftColor color;
    color.pixel = devfg;
    color.color.red = FXREDVAL(fg)*257;
    color.color.green = FXGREENVAL(fg)*257;
    color.color.blue = FXBLUEVAL(fg)*257;
    color.color.alpha = FXALPHAVAL(fg)*257;

    // !!! Hack to draw string depending on its encoding !!!
    if (isUtf8(string, length))
    {
        XftDrawStringUtf8((XftDraw*)xftDraw, &color, (XftFont*)font->font, x, y, (const FcChar8*)string, length);
    }
    else
    {
        XftDrawString8((XftDraw*)xftDraw, &color, (XftFont*)font->font, x, y, (const FcChar8*)string, length);
    }
    // !!! End of hack !!!
#else
    register int     count, escapement, defwidth, ww, size, i;
    register double  ang, ux, uy;
    register FXuchar r, c;
    XChar2b          sbuffer[4096];
    count = utf2db(sbuffer, string, FXMIN(length, 4096));
    if (font->getAngle())
    {
        ang = font->getAngle()*0.00027270769562411399179;
        defwidth = FS->min_bounds.width;
        ux = cos(ang);
        uy = sin(ang);
        if (FS->per_char)
        {
            r = FS->default_char>>8;
            c = FS->default_char&255;
            size = (FS->max_char_or_byte2-FS->min_char_or_byte2+1);
            if ((FS->min_char_or_byte2 <= c) && (c <= FS->max_char_or_byte2) && (FS->min_byte1 <= r) && (r <= FS->max_byte1))
            {
                defwidth = FS->per_char[(r-FS->min_byte1)*size+(c-FS->min_char_or_byte2)].width;
            }
            for (i = escapement = 0; i < count; i++)
            {
                XDrawString16(DISPLAY(getApp()), surface->id(), (GC)ctx, (int)(x+escapement*ux), (int)(y-escapement*uy), &sbuffer[i], 1);
                r = sbuffer[i].byte1;
                c = sbuffer[i].byte2;
                escapement += defwidth;
                if ((FS->min_char_or_byte2 <= c) && (c <= FS->max_char_or_byte2) && (FS->min_byte1 <= r) && (r <= FS->max_byte1))
                {
                    if ((ww = FS->per_char[(r-FS->min_byte1)*size+(c-FS->min_char_or_byte2)].width) != 0)
                    {
                        escapement += ww-defwidth;
                    }
                }
            }
        }
        else
        {
            for (i = escapement = 0; i < count; i++)
            {
                XDrawString16(DISPLAY(getApp()), surface->id(), (GC)ctx, (int)(x+escapement*ux), (int)(y-escapement*uy), &sbuffer[i], 1);
                escapement += defwidth;
            }
        }
    }
    else
    {
        XDrawString16(DISPLAY(getApp()), surface->id(), (GC)ctx, x, y, sbuffer, count);
    }
#endif
}


//
// Hack of FXFont
//

// Hack to take into account non UTF-8 strings
int FXFont::getTextWidth(const char* string, FXuint length) const
{
    if (!string)
    {
        fprintf(stderr, "FXDCWindow::drawText: NULL string argument.\n");
        exit(EXIT_FAILURE);
    }

    if (font)
    {
#ifdef HAVE_XFT_H
        XGlyphInfo extents;
        // This returns rotated metrics; FOX likes to work with unrotated metrics, so if angle
        // is not 0, we calculate the unrotated baseline; note however that the calculation is
        // not 100% pixel exact when the angle is not a multiple of 90 degrees.

        // !!! Hack to evaluate string extent depending on its encoding !!!
        if (isUtf8(string, length))
        {
            XftTextExtentsUtf8(DISPLAY(getApp()), (XftFont*)font, (const FcChar8*)string, length, &extents);
        }
        else
        {
            XftTextExtents8(DISPLAY(getApp()), (XftFont*)font, (const FcChar8*)string, length, &extents);
        }
        // !!! End of hack !!!

        if (angle)
        {
            return((int)(0.5+sqrt(extents.xOff*extents.xOff+extents.yOff*extents.yOff)));
        }

        return(extents.xOff);

#else
        register const XFontStruct* fs = (XFontStruct*)font;
        register int                defwidth = fs->min_bounds.width;
        register int                width = 0, ww;
        register FXuint             p = 0;
        register FXuint             s;
        register FXuchar            r;
        register FXuchar            c;
        register FXwchar            w;
        if (fs->per_char)
        {
            r = fs->default_char>>8;
            c = fs->default_char&255;
            s = (fs->max_char_or_byte2-fs->min_char_or_byte2+1);
            if ((fs->min_char_or_byte2 <= c) && (c <= fs->max_char_or_byte2) && (fs->min_byte1 <= r) && (r <= fs->max_byte1))
            {
                defwidth = fs->per_char[(r-fs->min_byte1)*s+(c-fs->min_char_or_byte2)].width;
            }
            while (p < length)
            {
                w = wc(string+p);
                p += wclen(string+p);
                r = w>>8;
                c = w&255;
                if ((fs->min_char_or_byte2 <= c) && (c <= fs->max_char_or_byte2) && (fs->min_byte1 <= r) && (r <= fs->max_byte1))
                {
                    if ((ww = fs->per_char[(r-fs->min_byte1)*s+(c-fs->min_char_or_byte2)].width) != 0)
                    {
                        width += ww;
                        continue;
                    }
                }
                width += defwidth;
            }
        }
        else
        {
            while (p < length)
            {
                p += wclen(string+p);
                width += defwidth;
            }
        }
        return(width);
#endif
    }
    return(length);
}


//
// Hack of FXSplitter
//
// NB : - MIN_PANEL_WIDTH is defined in xfedefs.h
//      - Don't use LAYOUT_FIX_WIDTH with this hack because it won't work!
// This function is taken from the FXSplitter class
// and hacked to set a minimum splitter width when moving splitter to right
// It replaces the normal function...
void FXSplitter::moveHSplit(int pos)
{
    register int smin, smax;

    //register FXuint hints;
    FXASSERT(window);
    //hints=window->getLayoutHints();
    // !!! Hack to limit the width to a minimum value !!!
    if (options&SPLITTER_REVERSED)
    {
        smin = barsize;
        smax = window->getX()+window->getWidth();
    }
    else
    {
        smin = window->getX();
        smax = width-barsize;
    }
    smax = smax-MIN_PANEL_WIDTH;
    smin = smin+MIN_PANEL_WIDTH;
    split = pos;
    if (split < smin)
    {
        split = smin;
    }
    if (split > smax)
    {
        split = smax;
    }
    // !!! End of hack
}


void FXSplitter::moveVSplit(int pos)
{
    register int smin, smax;

    //register FXuint hints;
    FXASSERT(window);
    //hints=window->getLayoutHints();
    if (options&SPLITTER_REVERSED)
    {
        smin = barsize;
        smax = window->getY()+window->getHeight();
    }
    else
    {
        smin = window->getY();
        smax = height-barsize;
    }
    smax = smax-MIN_PANEL_WIDTH;
    smin = smin+MIN_PANEL_WIDTH;
    split = pos;
    if (split < smin)
    {
        split = smin;
    }
    if (split > smax)
    {
        split = smax;
    }
}


//
// Hack of FXRegistry
//

// Hack to change the defaults directories for config files and icons
// The vendor key is not used anymore

#define DESKTOP         "xferc"
#define REGISTRYPATH    "/etc:/usr/share:/usr/local/share"

// Read registry
bool FXRegistry::read()
{
    FXString      dirname;
    register bool ok = false;

    dirname = FXPath::search(REGISTRYPATH, "xfe");
    if (!dirname.empty())
    {
        ok = readFromDir(dirname, false);
    }

    // Try search along PATH if still not found
    if (!ok)
    {
        dirname = FXPath::search(FXSystem::getExecPath(), "xfe");
        if (!dirname.empty())
        {
            ok = readFromDir(dirname, false);
        }
    }

    // Get path to per-user settings directory
    dirname = xdgconfighome + PATHSEPSTRING XFECONFIGPATH;

    // Then read per-user settings; overriding system-wide ones
    if (readFromDir(dirname, true))
    {
        ok = true;
    }

    return(ok);
}


// Try read registry from directory
bool FXRegistry::readFromDir(const FXString& dirname, bool mark)
{
    bool ok = false;

    // Directory is empty?
    if (!dirname.empty())
    {
        // First try to load desktop registry
        if (parseFile(dirname+PATHSEPSTRING DESKTOP, false))
        {
            FXString nn = dirname+PATHSEPSTRING DESKTOP;
            ok = true;
        }

        // Have application key
        if (!applicationkey.empty())
        {
            if (parseFile(dirname+PATHSEPSTRING+applicationkey + "rc", mark))
            {
                ok = true;
            }
        }
    }
    return(ok);
}


// Write registry
bool FXRegistry::write()
{
    FXString pathname, tempname;

    // Settings have not changed
    if (!isModified())
    {
        return(true);
    }

    // We can not save if no application key given
    if (!applicationkey.empty())
    {
        // Changes written only in the per-user registry
        pathname = xdgconfighome + PATHSEPSTRING XFECONFIGPATH;

        // If this directory does not exist, make it
        if (!FXStat::exists(pathname))
        {
            if (!FXDir::create(pathname))
            {
                return(false);
            }
        }
        else
        {
            if (!FXStat::isDirectory(pathname))
            {
                return(false);
            }
        }

        // Add application key
        pathname.append(PATHSEPSTRING+applicationkey+"rc");

        // Construct temp name
        tempname.format("%s_%d", pathname.text(), fxgetpid());

        // Unparse settings into temp file first
        if (unparseFile(tempname))
        {
            // Rename ATOMICALLY to proper name
            if (!FXFile::rename(tempname, pathname))
            {
                return(false);
            }

            setModified(false);
            return(true);
        }
    }
    return(false);
}


//
// Hack of FXSettings
//

// Hack to allow writing any registry global registry key to user settings
// for the xfe application only


#define MAXVALUE    2000


// Write string
static bool writeString(FXFile& file, const FXchar* string)
{
    register FXint len = strlen(string);

    return(file.writeBlock(string, len) == len);
}


// Unparse registry file
bool FXSettings::unparseFile(const FXString& filename)
{
    // !!! Hack here !!!
    // Distinguish between xfe and other applications
    FXbool xfe = (filename.contains(DESKTOP) ? true : false);

    FXFile file(filename, FXIO::Writing);
    FXchar line[MAXVALUE];

    if (file.isOpen())
    {
        // Loop over all sections
        for (FXint s = first(); s < size(); s = next(s))
        {
            // Get group
            FXStringDict* group = data(s);
            bool          sec = false;

            // Loop over all entries
            for (FXint e = group->first(); e < group->size(); e = group->next(e))
            {
                // !!! Hack here !!!
                // Do this always for the xfe application
                // Is key-value pair marked?
                if (xfe | group->mark(e))
                {
                    // Write section name if not written yet
                    if (!sec)
                    {
                        if (!writeString(file, "["))
                        {
                            goto x;
                        }
                        if (!writeString(file, key(s)))
                        {
                            goto x;
                        }
                        if (!writeString(file, "]" ENDLINE))
                        {
                            goto x;
                        }
                        sec = true;
                    }

                    // Write marked key-value pairs only
                    if (!writeString(file, group->key(e)))
                    {
                        goto x;
                    }
                    if (!writeString(file, "="))
                    {
                        goto x;
                    }
                    if (!writeString(file, enquote(line, group->data(e))))
                    {
                        goto x;
                    }
                    if (!writeString(file, ENDLINE))
                    {
                        goto x;
                    }
                }
            }

            // Blank line after end
            if (sec)
            {
                if (!writeString(file, ENDLINE))
                {
                    goto x;
                }
            }
        }
        return(true);
    }
x:
    return(false);
}


//
// Hack of FXPopup
//

// The two functions below are taken from the FXPopup class
// and hacked to allow navigating using the keyboard on popup menus
// They replace the normal functions...

// !!! Global variable control keyboard scrolling on right click popup menus !!!
extern FXbool allowPopupScroll;

void FXPopup::setFocus()
{
    FXShell::setFocus();

    // !!! Hack to allow keyboard scroll on popup dialogs !!!
    if (allowPopupScroll)
    {
        grabKeyboard();
    }
}


void FXPopup::killFocus()
{
    FXShell::killFocus();

    // !!! Hack to allow keyboard scroll on popup dialogs !!!
    if (allowPopupScroll)
    {
        if (prevActive)
        {
            prevActive->setFocus();
        }
        else
        {
            ungrabKeyboard();
        }
    }
}


//
// Hack of FXStatusLine(translation hack)
//

// Status line construct and init
FXStatusLine::FXStatusLine(FXComposite* p, FXObject* tgt, FXSelector sel) :
    FXFrame(p, LAYOUT_LEFT|LAYOUT_FILL_Y|LAYOUT_FILL_X, 0, 0, 0, 0, 1, 1, 1, 1)
{
    flags |= FLAG_SHOWN;
    status = normal = _(" ");
    font = getApp()->getNormalFont();
    textColor = getApp()->getForeColor();
    textHighlightColor = getApp()->getForeColor();
    target = tgt;
    message = sel;
}


//
// Hack of FXReplaceDialog
//

// Taken from the FXReplaceDialog class
// - translation hack
// - small hack for the Clearlooks theme

// Padding for buttons
#define HORZ_PAD       12
#define VERT_PAD       2
#define SEARCH_MASK    (SEARCH_EXACT|SEARCH_IGNORECASE|SEARCH_REGEX)

// File Open Dialog
FXReplaceDialog::FXReplaceDialog(FXWindow* owner, const FXString& caption, FXIcon* ic, FXuint opts, int x, int y, int w, int h) :
    FXDialogBox(owner, caption, opts|DECOR_TITLE|DECOR_BORDER|DECOR_RESIZE, x, y, w, h, 10, 10, 10, 10, 10, 10)
{
    FXHorizontalFrame* buttons = new FXHorizontalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|PACK_UNIFORM_WIDTH|PACK_UNIFORM_HEIGHT, 0, 0, 0, 0, 0, 0, 0, 0);

    accept = new FXButton(buttons, _("&Replace"), NULL, this, ID_ACCEPT, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_FILL_Y|LAYOUT_RIGHT, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
    every = new FXButton(buttons, _("Re&place All"), NULL, this, ID_ALL, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_CENTER_Y|LAYOUT_RIGHT, 0, 0, 0, 0, 6, 6, VERT_PAD, VERT_PAD);
    cancel = new FXButton(buttons, _("&Cancel"), NULL, this, ID_CANCEL, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_FILL_Y|LAYOUT_RIGHT, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
    FXHorizontalFrame* pair = new FXHorizontalFrame(buttons, LAYOUT_FILL_Y|LAYOUT_RIGHT, 0, 0, 0, 0, 0, 0, 0, 0);
    FXArrowButton*     searchlast = new FXArrowButton(pair, this, ID_PREV, ARROW_LEFT|FRAME_RAISED|FRAME_THICK|LAYOUT_FILL_Y, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
    FXArrowButton*     searchnext = new FXArrowButton(pair, this, ID_NEXT, ARROW_RIGHT|FRAME_RAISED|FRAME_THICK|LAYOUT_FILL_Y, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
    FXHorizontalFrame* toppart = new FXHorizontalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|LAYOUT_CENTER_Y, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10);
    new FXLabel(toppart, FXString::null, ic, ICON_BEFORE_TEXT|JUSTIFY_CENTER_X|JUSTIFY_CENTER_Y|LAYOUT_FILL_Y|LAYOUT_FILL_X);
    FXVerticalFrame* entry = new FXVerticalFrame(toppart, LAYOUT_FILL_X|LAYOUT_CENTER_Y, 0, 0, 0, 0, 0, 0, 0, 0);
    searchlabel = new FXLabel(entry, _("Search for:"), NULL, JUSTIFY_LEFT|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X);

    // !!! Hack to remove the FRAME_THICK and FRAME_SUNKEN options (required for the Clearlooks theme)
    searchbox = new FXHorizontalFrame(entry, LAYOUT_FILL_X|LAYOUT_CENTER_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    searchtext = new FXTextField(searchbox, 26, this, ID_SEARCH_TEXT, FRAME_SUNKEN|TEXTFIELD_ENTER_ONLY|LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 4, 4, 4, 4);
    // !!! End of hack

    FXVerticalFrame* searcharrows = new FXVerticalFrame(searchbox, LAYOUT_RIGHT|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    FXArrowButton*   ar1 = new FXArrowButton(searcharrows, this, ID_SEARCH_UP, FRAME_RAISED|FRAME_THICK|ARROW_UP|ARROW_REPEAT|LAYOUT_FILL_Y|LAYOUT_FIX_WIDTH, 0, 0, 16, 0, 1, 1, 1, 1);
    FXArrowButton*   ar2 = new FXArrowButton(searcharrows, this, ID_SEARCH_DN, FRAME_RAISED|FRAME_THICK|ARROW_DOWN|ARROW_REPEAT|LAYOUT_FILL_Y|LAYOUT_FIX_WIDTH, 0, 0, 16, 0, 1, 1, 1, 1);
    ar1->setArrowSize(3);
    ar2->setArrowSize(3);
    replacelabel = new FXLabel(entry, _("Replace with:"), NULL, LAYOUT_LEFT);

    // !!! Hack to remove the FRAME_THICK and FRAME_SUNKEN options (required for the Clearlooks theme)
    replacebox = new FXHorizontalFrame(entry, LAYOUT_FILL_X|LAYOUT_CENTER_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    replacetext = new FXTextField(replacebox, 26, this, ID_REPLACE_TEXT, FRAME_SUNKEN|TEXTFIELD_ENTER_ONLY|LAYOUT_FILL_X|LAYOUT_FILL_Y, 0, 0, 0, 0, 4, 4, 4, 4);
    // !!! End of hack

    FXVerticalFrame* replacearrows = new FXVerticalFrame(replacebox, LAYOUT_RIGHT|LAYOUT_FILL_Y, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    FXArrowButton*   ar3 = new FXArrowButton(replacearrows, this, ID_REPLACE_UP, FRAME_RAISED|FRAME_THICK|ARROW_UP|ARROW_REPEAT|LAYOUT_FILL_Y|LAYOUT_FIX_WIDTH, 0, 0, 16, 0, 1, 1, 1, 1);
    FXArrowButton*   ar4 = new FXArrowButton(replacearrows, this, ID_REPLACE_DN, FRAME_RAISED|FRAME_THICK|ARROW_DOWN|ARROW_REPEAT|LAYOUT_FILL_Y|LAYOUT_FIX_WIDTH, 0, 0, 16, 0, 1, 1, 1, 1);
    ar3->setArrowSize(3);
    ar4->setArrowSize(3);
    FXHorizontalFrame* options1 = new FXHorizontalFrame(entry, LAYOUT_FILL_X, 0, 0, 0, 0, 0, 0, 0, 0);
    new FXRadioButton(options1, _("Ex&act"), this, ID_MODE+SEARCH_EXACT, ICON_BEFORE_TEXT|LAYOUT_CENTER_X);
    new FXRadioButton(options1, _("&Ignore Case"), this, ID_MODE+SEARCH_IGNORECASE, ICON_BEFORE_TEXT|LAYOUT_CENTER_X);
    new FXRadioButton(options1, _("E&xpression"), this, ID_MODE+SEARCH_REGEX, ICON_BEFORE_TEXT|LAYOUT_CENTER_X);
    new FXCheckButton(options1, _("&Backward"), this, ID_DIR, ICON_BEFORE_TEXT|LAYOUT_CENTER_X);
    searchlast->setTipText("Ctrl-B");
    searchnext->setTipText("Ctrl-F");
    searchlast->addHotKey(MKUINT(KEY_b, CONTROLMASK));
    searchnext->addHotKey(MKUINT(KEY_f, CONTROLMASK));
    searchmode = SEARCH_EXACT|SEARCH_FORWARD;
    current = 0;
}


//
// Hack of FXSearchDialog (translation hack)
//

// Taken from the FXSearchDialog class
FXSearchDialog::FXSearchDialog(FXWindow* owner, const FXString& caption, FXIcon* ic, FXuint opts, int x, int y, int w, int h) :
    FXReplaceDialog(owner, caption, ic, opts, x, y, w, h)
{
    accept->setText(_("&Search"));
    every->hide();
    replacelabel->hide();
    replacebox->hide();
}


//
// Hack of FXInputDialog (translation hack)
//

// Taken from the FXInputDialog class
void FXInputDialog::initialize(const FXString& label, FXIcon* icon)
{
    FXuint             textopts = TEXTFIELD_ENTER_ONLY|FRAME_SUNKEN|FRAME_THICK|LAYOUT_FILL_X;
    FXHorizontalFrame* buttons = new FXHorizontalFrame(this, LAYOUT_SIDE_BOTTOM|LAYOUT_FILL_X|PACK_UNIFORM_WIDTH, 0, 0, 0, 0, 0, 0, 0, 0);

    new FXButton(buttons, _("&OK"), NULL, this, ID_ACCEPT, BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_CENTER_Y|LAYOUT_RIGHT, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
    new FXButton(buttons, _("&Cancel"), NULL, this, ID_CANCEL, BUTTON_INITIAL|BUTTON_DEFAULT|FRAME_RAISED|FRAME_THICK|LAYOUT_CENTER_Y|LAYOUT_RIGHT, 0, 0, 0, 0, HORZ_PAD, HORZ_PAD, VERT_PAD, VERT_PAD);
    FXHorizontalFrame* toppart = new FXHorizontalFrame(this, LAYOUT_SIDE_TOP|LAYOUT_FILL_X|LAYOUT_CENTER_Y, 0, 0, 0, 0, 0, 0, 0, 0, 10, 10);
    new FXLabel(toppart, FXString::null, icon, ICON_BEFORE_TEXT|JUSTIFY_CENTER_X|JUSTIFY_CENTER_Y|LAYOUT_FILL_Y|LAYOUT_FILL_X);
    FXVerticalFrame* entry = new FXVerticalFrame(toppart, LAYOUT_FILL_X|LAYOUT_CENTER_Y, 0, 0, 0, 0, 0, 0, 0, 0);
    new FXLabel(entry, label, NULL, JUSTIFY_LEFT|ICON_BEFORE_TEXT|LAYOUT_TOP|LAYOUT_LEFT|LAYOUT_FILL_X);
    if (options&INPUTDIALOG_PASSWORD)
    {
        textopts |= TEXTFIELD_PASSWD;
    }
    if (options&INPUTDIALOG_INTEGER)
    {
        textopts |= TEXTFIELD_INTEGER|JUSTIFY_RIGHT;
    }
    if (options&INPUTDIALOG_REAL)
    {
        textopts |= TEXTFIELD_REAL|JUSTIFY_RIGHT;
    }
    input = new FXTextField(entry, 20, this, ID_ACCEPT, textopts, 0, 0, 0, 0, 8, 8, 4, 4);
    limlo = 1.0;
    limhi = 0.0;
}


//
// Hack of fxpriv (clipboard management)
//


// These two functions are hacked to reduce the timeout when the owner app of the clipboard has been closed

// Send request for selection info
Atom fxsendrequest(Display* display, Window window, Atom selection, Atom prop, Atom type, FXuint time)
{
    // !!! Hack here to reduce timeout !!!
    FXuint loops = 10;
    XEvent ev;

    XConvertSelection(display, selection, type, prop, window, time);
    while (!XCheckTypedWindowEvent(display, window, SelectionNotify, &ev))
    {
        if (loops == 0)
        {
            //fxwarning("fxsendrequest:timed out!\n");
            return(None);
        }
        FXThread::sleep(10000000);  // Don't burn too much CPU here:- the other guy needs it more....
        loops--;
    }
    return(ev.xselection.property);
}


// Wait for event of certain type
static FXbool fxwaitforevent(Display* display, Window window, int type, XEvent& event)
{
    // !!! Hack here to reduce timeout !!!
    FXuint loops = 10;

    while (!XCheckTypedWindowEvent(display, window, type, &event))
    {
        if (loops == 0)
        {
            //fxwarning("fxwaitforevent:timed out!\n");
            return(false);
        }
        FXThread::sleep(10000000);  // Don't burn too much CPU here:- the other guy needs it more....
        loops--;
    }
    return(true);
}


// The four following functions are not modified but are necessary here because the previous ones are not called directly

// Read property in chunks smaller than maximum transfer length,
// appending to data array; returns amount read from the property.
static FXuint fxrecvprop(Display* display, Window window, Atom prop, Atom& type, FXuchar*& data, FXuint& size)
{
    unsigned long maxtfrsize = XMaxRequestSize(display)*4;
    unsigned long tfroffset, tfrsize, tfrleft;
    FXuchar*      ptr;
    int           format;

    tfroffset = 0;

    // Read next chunk of data from property
    while (XGetWindowProperty(display, window, prop, tfroffset>>2, maxtfrsize>>2, False, AnyPropertyType, &type, &format, &tfrsize, &tfrleft, &ptr) == Success && type != None)
    {
        tfrsize *= (format>>3);

        // Grow the array to accomodate new data
        if (!FXRESIZE(&data, FXuchar, size+tfrsize+1))
        {
            XFree(ptr);
            break;
        }

        // Append new data at the end, plus the extra 0.
        memcpy(&data[size], ptr, tfrsize+1);
        size += tfrsize;
        tfroffset += tfrsize;
        XFree(ptr);
        if (tfrleft == 0)
        {
            break;
        }
    }

    // Delete property after we're done
    XDeleteProperty(display, window, prop);
    XFlush(display);
    return(tfroffset);
}


// Receive data via property
Atom fxrecvdata(Display* display, Window window, Atom prop, Atom incr, Atom& type, FXuchar*& data, FXuint& size)
{
    unsigned long tfrsize, tfrleft;
    FXuchar*      ptr;
    XEvent        ev;
    int           format;

    data = NULL;
    size = 0;
    if (prop)
    {
        // First, see what we've got
        if ((XGetWindowProperty(display, window, prop, 0, 0, False, AnyPropertyType, &type, &format, &tfrsize, &tfrleft, &ptr) == Success) && (type != None))
        {
            XFree(ptr);

            // Incremental transfer
            if (type == incr)
            {
                // Delete the INCR property
                XDeleteProperty(display, window, prop);
                XFlush(display);

                // Wait for the next batch of data
                while (fxwaitforevent(display, window, PropertyNotify, ev))
                {
                    // Wrong type of notify event; perhaps stale event
                    if ((ev.xproperty.atom != prop) || (ev.xproperty.state != PropertyNewValue))
                    {
                        continue;
                    }

                    // See what we've got
                    if ((XGetWindowProperty(display, window, prop, 0, 0, False, AnyPropertyType, &type, &format, &tfrsize, &tfrleft, &ptr) == Success) && (type != None))
                    {
                        XFree(ptr);

                        // if empty property, its the last one
                        if (tfrleft == 0)
                        {
                            // Delete property so the other side knows we've got the data
                            XDeleteProperty(display, window, prop);
                            XFlush(display);
                            break;
                        }

                        // Read and delete the property
                        fxrecvprop(display, window, prop, type, data, size);
                    }
                }
            }

            // All data in one shot
            else
            {
                // Read and delete the property
                fxrecvprop(display, window, prop, type, data, size);
            }
        }
        return(prop);
    }
    return(None);
}


// Retrieve CLIPBOARD selection data
void FXApp::clipboardGetData(const FXWindow* window, FXDragType type, FXuchar*& data, FXuint& size)
{
    FXID answer;

    data = NULL;
    size = 0;
    if (clipboardWindow)
    {
        event.type = SEL_CLIPBOARD_REQUEST;
        event.target = type;
        ddeData = NULL;
        ddeSize = 0;
        clipboardWindow->handle(this, FXSEL(SEL_CLIPBOARD_REQUEST, 0), &event);
        data = ddeData;
        size = ddeSize;
        ddeData = NULL;
        ddeSize = 0;
    }
    else
    {
        answer = fxsendrequest((Display*)display, window->id(), xcbSelection, ddeAtom, type, event.time);
        fxrecvdata((Display*)display, window->id(), answer, ddeIncr, type, data, size);
    }
}


// Get dropped data; called in response to DND enter or DND drop
bool FXWindow::getDNDData(FXDNDOrigin origin, FXDragType targettype, FXuchar*& data, FXuint& size) const
{
    if (xid == 0)
    {
        fxerror("%s::getDNDData: window has not yet been created.\n", getClassName());
    }

    switch (origin)
    {
    case FROM_DRAGNDROP:
        getApp()->dragdropGetData(this, targettype, data, size);
        break;

    case FROM_CLIPBOARD:
        getApp()->clipboardGetData(this, targettype, data, size);
        break;

    case FROM_SELECTION:
        getApp()->selectionGetData(this, targettype, data, size);
        break;
    }
    return(data != NULL);
}


//
// Hack of FXWindow
//

// This hack fixes a bug in FOX that prevent any character to be entered
// when FOX is compiled with the --with-xim option
// The bug is fixed in FOX 1.6.35 and above
// However, the hack is still here because the latest FOX is not necessarily present
// on the user's Linux distribution

#include "FXComposeContext.h"

// Create compose context
void FXWindow::createComposeContext()
{
    if (!composeContext)
    {
        composeContext = new FXComposeContext(getApp(), this, 0);

        // !!! This line was missing !!!
        composeContext->create();
    }
}


//
// Hack of FXTextField
//

// This hack fixes a bug in FOX that make some input fields crash the application
// when FOX was compiled with the --with-xim option
// The bug is not fixed yet in FOX 1.6.36

// Into focus chain
void FXTextField::setFocus()
{
    FXFrame::setFocus();
    setDefault(true);
    flags &= ~FLAG_UPDATE;
    if (getApp()->hasInputMethod() && this->id())
    {
        createComposeContext();
    }
}


// This hack allows to ignore caps lock when using Ctrl-A, Ctrl-C, Ctrl-V and Ctrl-X shortcuts

// Pressed a key
long FXTextField::onKeyPress(FXObject*, FXSelector, void* ptr)
{
    FXEvent* event = (FXEvent*)ptr;

    flags &= ~FLAG_TIP;
    if (isEnabled())
    {
        if (target && target->tryHandle(this, FXSEL(SEL_KEYPRESS, message), ptr))
        {
            return(1);
        }
        flags &= ~FLAG_UPDATE;
        switch (event->code)
        {
        case KEY_Right:
        case KEY_KP_Right:
            if (!(event->state&SHIFTMASK))
            {
                handle(this, FXSEL(SEL_COMMAND, ID_DESELECT_ALL), NULL);
            }
            if (event->state&CONTROLMASK)
            {
                handle(this, FXSEL(SEL_COMMAND, ID_CURSOR_WORD_RIGHT), NULL);
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, ID_CURSOR_RIGHT), NULL);
            }
            if (event->state&SHIFTMASK)
            {
                handle(this, FXSEL(SEL_COMMAND, ID_EXTEND), NULL);
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, ID_MARK), NULL);
            }
            return(1);

        case KEY_Left:
        case KEY_KP_Left:
            if (!(event->state&SHIFTMASK))
            {
                handle(this, FXSEL(SEL_COMMAND, ID_DESELECT_ALL), NULL);
            }
            if (event->state&CONTROLMASK)
            {
                handle(this, FXSEL(SEL_COMMAND, ID_CURSOR_WORD_LEFT), NULL);
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, ID_CURSOR_LEFT), NULL);
            }
            if (event->state&SHIFTMASK)
            {
                handle(this, FXSEL(SEL_COMMAND, ID_EXTEND), NULL);
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, ID_MARK), NULL);
            }
            return(1);

        case KEY_Home:
        case KEY_KP_Home:
            if (!(event->state&SHIFTMASK))
            {
                handle(this, FXSEL(SEL_COMMAND, ID_DESELECT_ALL), NULL);
            }
            handle(this, FXSEL(SEL_COMMAND, ID_CURSOR_HOME), NULL);
            if (event->state&SHIFTMASK)
            {
                handle(this, FXSEL(SEL_COMMAND, ID_EXTEND), NULL);
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, ID_MARK), NULL);
            }
            return(1);

        case KEY_End:
        case KEY_KP_End:
            if (!(event->state&SHIFTMASK))
            {
                handle(this, FXSEL(SEL_COMMAND, ID_DESELECT_ALL), NULL);
            }
            handle(this, FXSEL(SEL_COMMAND, ID_CURSOR_END), NULL);
            if (event->state&SHIFTMASK)
            {
                handle(this, FXSEL(SEL_COMMAND, ID_EXTEND), NULL);
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, ID_MARK), NULL);
            }
            return(1);

        case KEY_Insert:
        case KEY_KP_Insert:
            if (event->state&CONTROLMASK)
            {
                handle(this, FXSEL(SEL_COMMAND, ID_COPY_SEL), NULL);
                return(1);
            }
            else if (event->state&SHIFTMASK)
            {
                handle(this, FXSEL(SEL_COMMAND, ID_PASTE_SEL), NULL);
                return(1);
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, ID_TOGGLE_OVERSTRIKE), NULL);
            }
            return(1);

        case KEY_Delete:
        case KEY_KP_Delete:
            if (hasSelection())
            {
                if (event->state&SHIFTMASK)
                {
                    handle(this, FXSEL(SEL_COMMAND, ID_CUT_SEL), NULL);
                }
                else
                {
                    handle(this, FXSEL(SEL_COMMAND, ID_DELETE_SEL), NULL);
                }
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, ID_DELETE), NULL);
            }
            return(1);

        case KEY_BackSpace:
            if (hasSelection())
            {
                handle(this, FXSEL(SEL_COMMAND, ID_DELETE_SEL), NULL);
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, ID_BACKSPACE), NULL);
            }
            return(1);

        case KEY_Return:
        case KEY_KP_Enter:
            if (isEditable())
            {
                flags |= FLAG_UPDATE;
                flags &= ~FLAG_CHANGED;
                if (target)
                {
                    target->tryHandle(this, FXSEL(SEL_COMMAND, message), (void*)contents.text());
                }
            }
            else
            {
                getApp()->beep();
            }
            return(1);

        case KEY_a:
        case KEY_A: // Hack
            if (!(event->state&CONTROLMASK))
            {
                goto ins;
            }
            handle(this, FXSEL(SEL_COMMAND, ID_SELECT_ALL), NULL);
            return(1);

        case KEY_x:
        case KEY_X: // Hack
            if (!(event->state&CONTROLMASK))
            {
                goto ins;
            }

        case KEY_F20:                             // Sun Cut key
            handle(this, FXSEL(SEL_COMMAND, ID_CUT_SEL), NULL);
            return(1);

        case KEY_c:
        case KEY_C: // Hack
            if (!(event->state&CONTROLMASK))
            {
                goto ins;
            }

        case KEY_F16:                             // Sun Copy key
            handle(this, FXSEL(SEL_COMMAND, ID_COPY_SEL), NULL);
            return(1);

        case KEY_v:
        case KEY_V: // Hack
            if (!(event->state&CONTROLMASK))
            {
                goto ins;
            }

        case KEY_F18:                             // Sun Paste key
            handle(this, FXSEL(SEL_COMMAND, ID_PASTE_SEL), NULL);
            return(1);

        default:
ins:
            if ((event->state&(CONTROLMASK|ALTMASK)) || ((FXuchar)event->text[0] < 32))
            {
                return(0);
            }
            if (isOverstrike())
            {
                handle(this, FXSEL(SEL_COMMAND, ID_OVERST_STRING), (void*)event->text.text());
            }
            else
            {
                handle(this, FXSEL(SEL_COMMAND, ID_INSERT_STRING), (void*)event->text.text());
            }
            return(1);
        }
    }
    return(0);
}


//
// Hack of FXApp
//
// This hack fixes a bug in FOX that prevent to enter composed characters when the mouse pointer
// lies outside the text field. The implementation differs if iBus is running or not
// The bug is not fixed yet in FOX 1.6.50


namespace FX
{
// Callback Record
struct FXCBSpec
{
    FXObject*  target;                // Receiver object
    FXSelector message;               // Message sent to receiver
};


// Timer record
struct FXTimer
{
    FXTimer*   next;                  // Next timeout in list
    FXObject*  target;                // Receiver object
    void*      data;                  // User data
    FXSelector message;               // Message sent to receiver
    FXlong     due;                   // When timer is due (ns)
};


// Signal record
struct FXSignal
{
    FXObject*  target;                // Receiver object
    FXSelector message;               // Message sent to receiver
    FXbool     handlerset;            // Handler was already set
    FXbool     notified;              // Signal has fired
};


// Idle record
struct FXChore
{
    FXChore*   next;                  // Next chore in list
    FXObject*  target;                // Receiver object
    void*      data;                  // User data
    FXSelector message;               // Message sent to receiver
};


// Input record
struct FXInput
{
    FXCBSpec read;                    // Callback spec for read
    FXCBSpec write;                   // Callback spec for write
    FXCBSpec excpt;                   // Callback spec for except
};


// A repaint event record
struct FXRepaint
{
    FXRepaint*  next;               // Next repaint in list
    FXID        window;             // Window ID of the dirty window
    FXRectangle rect;               // Dirty rectangle
    int         hint;               // Hint for compositing
    FXbool      synth;              // Synthetic expose event or real one?
};


// Recursive Event Loop Invocation
struct FXInvocation
{
    FXInvocation** invocation; // Pointer to variable holding pointer to current invocation
    FXInvocation*  upper;      // Invocation above this one
    FXWindow*      window;     // Modal window (if any)
    FXModality     modality;   // Modality mode
    int            code;       // Return code
    FXbool         done;       // True if breaking out

    // Enter modal loop
    FXInvocation(FXInvocation** inv, FXModality mode, FXWindow* win) : invocation(inv), upper(*inv), window(win), modality(mode), code(0), done(false)
    {
        *invocation = this;
    }

    // Exit modal loop
    ~FXInvocation()
    {
        *invocation = upper;
    }
};
} // namespace FX


// Largest number of signals on this system
#define MAXSIGNALS    64

// Regular define
#define SELECT(n, r, w, e, t)    select(n, r, w, e, t)

// DND protocol version
#define XDND_PROTOCOL_VERSION    5


// Send types via property
Atom fxsendtypes(Display* display, Window window, Atom prop, FXDragType* types, FXuint numtypes)
{
    if (types && numtypes)
    {
        XChangeProperty(display, window, prop, XA_ATOM, 32, PropModeReplace, (unsigned char*)types, numtypes);
        return(prop);
    }
    return(None);
}


// Send data via property
Atom fxsenddata(Display* display, Window window, Atom prop, Atom type, FXuchar* data, FXuint size)
{
    unsigned long maxtfrsize, tfrsize, tfroffset;
    int           mode;

    if (data && size)
    {
        maxtfrsize = 4*XMaxRequestSize(display);
        mode = PropModeReplace;
        tfroffset = 0;
        while (size)
        {
            tfrsize = size;
            if (tfrsize > maxtfrsize)
            {
                tfrsize = maxtfrsize;
            }
            XChangeProperty(display, window, prop, type, 8, mode, &data[tfroffset], tfrsize);
            mode = PropModeAppend;
            tfroffset += tfrsize;
            size -= tfrsize;
        }
        return(prop);
    }
    return(None);
}


// Reply to request for selection info
Atom fxsendreply(Display* display, Window window, Atom selection, Atom prop, Atom target, FXuint time)
{
    XEvent se;

    se.xselection.type = SelectionNotify;
    se.xselection.send_event = TRUE;
    se.xselection.display = display;
    se.xselection.requestor = window;
    se.xselection.selection = selection;
    se.xselection.target = target;
    se.xselection.property = prop;
    se.xselection.time = time;
    XSendEvent(display, window, True, NoEventMask, &se);
    XFlush(display);
    return(prop);
}


// Read type list from property
Atom fxrecvtypes(Display* display, Window window, Atom prop, FXDragType*& types, FXuint& numtypes, FXbool del)
{
    unsigned long  numitems, bytesleft;
    unsigned char* ptr;
    int            actualformat;
    Atom           actualtype;

    types = NULL;
    numtypes = 0;
    if (prop)
    {
        if (XGetWindowProperty(display, window, prop, 0, 1024, del, XA_ATOM, &actualtype, &actualformat, &numitems, &bytesleft, &ptr) == Success)
        {
            if ((actualtype == XA_ATOM) && (actualformat == 32) && (numitems > 0))
            {
                if (FXMALLOC(&types, Atom, numitems))
                {
                    memcpy(types, ptr, sizeof(Atom)*numitems);
                    numtypes = numitems;
                }
            }
            XFree(ptr);
        }
        return(prop);
    }
    return(None);
}


// Get an event
bool FXApp::getNextEvent(FXRawEvent& ev, bool blocking)
{
    XEvent e;

    // Set to no-op just in case
    ev.xany.type = 0;

    // Handle all past due timers
    if (timers)
    {
        handleTimeouts();
    }

    // Check non-immediate signals that may have fired
    if (nsignals)
    {
        for (int sig = 0; sig < MAXSIGNALS; sig++)
        {
            if (signals[sig].notified)
            {
                signals[sig].notified = false;
                if (signals[sig].target && signals[sig].target->tryHandle(this, FXSEL(SEL_SIGNAL, signals[sig].message), (void*)(FXival)sig))
                {
                    refresh();
                    return(false);
                }
            }
        }
    }

    // Are there no events already queued up?
    if (!initialized || !XEventsQueued((Display*)display, QueuedAfterFlush))
    {
        struct timeval delta;
        fd_set         readfds;
        fd_set         writefds;
        fd_set         exceptfds;
        int            maxfds;
        int            nfds;

        // Prepare fd's to check
        maxfds = maxinput;
        readfds = *((fd_set*)r_fds);
        writefds = *((fd_set*)w_fds);
        exceptfds = *((fd_set*)e_fds);

        // Add connection to display if its open
        if (initialized)
        {
            FD_SET(ConnectionNumber((Display*)display), &readfds);
            if (ConnectionNumber((Display*)display) > maxfds)
            {
                maxfds = ConnectionNumber((Display*)display);
            }
        }

        delta.tv_usec = 0;
        delta.tv_sec = 0;

        // Do a quick poll for any ready events or inputs
        nfds = SELECT(maxfds+1, &readfds, &writefds, &exceptfds, &delta);

        // Nothing to do, so perform idle processing
        if (nfds == 0)
        {
            // Release the expose events
            if (repaints)
            {
                register FXRepaint* r = repaints;
                ev.xany.type = Expose;
                ev.xexpose.window = r->window;
                ev.xexpose.send_event = r->synth;
                ev.xexpose.x = r->rect.x;
                ev.xexpose.y = r->rect.y;
                ev.xexpose.width = r->rect.w-r->rect.x;
                ev.xexpose.height = r->rect.h-r->rect.y;
                repaints = r->next;
                r->next = repaintrecs;
                repaintrecs = r;
                return(true);
            }

            // Do our chores :-)
            if (chores)
            {
                register FXChore* c = chores;
                chores = c->next;
                if (c->target && c->target->tryHandle(this, FXSEL(SEL_CHORE, c->message), c->data))
                {
                    refresh();
                }
                c->next = chorerecs;
                chorerecs = c;
            }

            // GUI updating:- walk the whole widget tree.
            if (refresher)
            {
                refresher->handle(this, FXSEL(SEL_UPDATE, 0), NULL);
                if (refresher->getFirst())
                {
                    refresher = refresher->getFirst();
                }
                else
                {
                    while (refresher->getParent())
                    {
                        if (refresher->getNext())
                        {
                            refresher = refresher->getNext();
                            break;
                        }
                        refresher = refresher->getParent();
                    }
                }
                FXASSERT(refresher);
                if (refresher != refresherstop)
                {
                    return(false);
                }
                refresher = refresherstop = NULL;
            }

            // There are more chores to do
            if (chores)
            {
                return(false);
            }

            // We're not blocking
            if (!blocking)
            {
                return(false);
            }

            // Now, block till timeout, i/o, or event
            maxfds = maxinput;
            readfds = *((fd_set*)r_fds);
            writefds = *((fd_set*)w_fds);
            exceptfds = *((fd_set*)e_fds);

            // Add connection to display if its open
            if (initialized)
            {
                FD_SET(ConnectionNumber((Display*)display), &readfds);
                if (ConnectionNumber((Display*)display) > maxfds)
                {
                    maxfds = ConnectionNumber((Display*)display);
                }
            }

            // If there are timers, we block only for a little while.
            if (timers)
            {
                // All that testing above may have taken some time...
                FXlong interval = timers->due-FXThread::time();

                // Some timers are already due; do them right away!
                if (interval <= 0)
                {
                    return(false);
                }

                // Compute how long to wait
                delta.tv_usec = (interval/1000)%1000000;
                delta.tv_sec = interval/1000000000;

                // Exit critical section
                appMutex.unlock();

                // Block till timer or event or interrupt
                nfds = SELECT(maxfds+1, &readfds, &writefds, &exceptfds, &delta);

                // Enter critical section
                appMutex.lock();
            }

            // If no timers, we block till event or interrupt
            else
            {
                // Exit critical section
                appMutex.unlock();

                // Block until something happens
                nfds = SELECT(maxfds+1, &readfds, &writefds, &exceptfds, NULL);

                // Enter critical section
                appMutex.lock();
            }
        }

        // Timed out or interrupted
        if (nfds <= 0)
        {
            if ((nfds < 0) && (errno != EAGAIN) && (errno != EINTR))
            {
                fxerror("Application terminated: interrupt or lost connection errno=%d\n", errno);
            }
            return(false);
        }

        // Any other file descriptors set?
        if (0 <= maxinput)
        {
            // Examine I/O file descriptors
            for (FXInputHandle fff = 0; fff <= maxinput; fff++)
            {
                // Copy the record as the callbacks may try to change things
                FXInput in = inputs[fff];

                // Skip the display connection, which is treated differently
                if (initialized && (fff == ConnectionNumber((Display*)display)))
                {
                    continue;
                }

                // Check file descriptors
                if (FD_ISSET(fff, &readfds))
                {
                    if (in.read.target && in.read.target->tryHandle(this, FXSEL(SEL_IO_READ, in.read.message), (void*)(FXival)fff))
                    {
                        refresh();
                    }
                }
                if (FD_ISSET(fff, &writefds))
                {
                    if (in.write.target && in.write.target->tryHandle(this, FXSEL(SEL_IO_WRITE, in.write.message), (void*)(FXival)fff))
                    {
                        refresh();
                    }
                }
                if (FD_ISSET(fff, &exceptfds))
                {
                    if (in.excpt.target && in.excpt.target->tryHandle(this, FXSEL(SEL_IO_EXCEPT, in.excpt.message), (void*)(FXival)fff))
                    {
                        refresh();
                    }
                }
            }
        }

        // If there is no event, we're done
        if (!initialized || !FD_ISSET(ConnectionNumber((Display*)display), &readfds) || !XEventsQueued((Display*)display, QueuedAfterReading))
        {
            return(false);
        }
    }

    // Get an event
    XNextEvent((Display*)display, &ev);

    // !!! Hack to fix the bug with composed characters !!!
    if (xim_used)
    {
        // Filter event through input method context, if any
        if (xim && XFilterEvent(&ev, None))
        {
            return(false);
        }
    }
    else
    {
        FXWindow* focuswin;
        focuswin = getFocusWindow();
        if (xim && focuswin && XFilterEvent(&ev, (Window)focuswin->id()))
        {
            return(false);
        }
    }
    // !!! End of hack !!!

    // Save expose events for later...
    if ((ev.xany.type == Expose) || (ev.xany.type == GraphicsExpose))
    {
        addRepaint((FXID)ev.xexpose.window, ev.xexpose.x, ev.xexpose.y, ev.xexpose.width, ev.xexpose.height, 0);
        return(false);
    }

    // Compress motion events
    if (ev.xany.type == MotionNotify)
    {
        while (XPending((Display*)display))
        {
            XPeekEvent((Display*)display, &e);
            if ((e.xany.type != MotionNotify) || (ev.xmotion.window != e.xmotion.window) || (ev.xmotion.state != e.xmotion.state))
            {
                break;
            }
            XNextEvent((Display*)display, &ev);
        }
    }

    // Compress wheel events
    else if ((ev.xany.type == ButtonPress) && ((ev.xbutton.button == Button4) || (ev.xbutton.button == Button5)))
    {
        int ticks = 1;
        while (XPending((Display*)display))
        {
            XPeekEvent((Display*)display, &e);
            if (((e.xany.type != ButtonPress) && (e.xany.type != ButtonRelease)) || (ev.xany.window != e.xany.window) || (ev.xbutton.button != e.xbutton.button))
            {
                break;
            }
            ticks += (e.xany.type == ButtonPress);
            XNextEvent((Display*)display, &ev);
        }
        ev.xbutton.subwindow = (Window)ticks;   // Stick it here for later
    }

    // Compress configure events
    else if (ev.xany.type == ConfigureNotify)
    {
        while (XCheckTypedWindowEvent((Display*)display, ev.xconfigure.window, ConfigureNotify, &e))
        {
            ev.xconfigure.width = e.xconfigure.width;
            ev.xconfigure.height = e.xconfigure.height;
            if (e.xconfigure.send_event)
            {
                ev.xconfigure.x = e.xconfigure.x;
                ev.xconfigure.y = e.xconfigure.y;
            }
        }
    }

    // Regular event
    return(true);
}


// Translate key code to utf8 text
FXString translateKeyEvent(FXRawEvent& event)
{
    char    buffer[40];
    KeySym  sym;
    FXwchar w;

    XLookupString(&event.xkey, buffer, sizeof(buffer), &sym, NULL);
    w = fxkeysym2ucs(sym);
    return(FXString(&w, 1));
}


// Get keysym; interprets the modifiers!
static FXuint keysym(FXRawEvent& event)
{
    KeySym sym = KEY_VoidSymbol;
    char   buffer[40];

    XLookupString(&event.xkey, buffer, sizeof(buffer), &sym, NULL);
    return(sym);
}


// Dispatch event to widget
bool FXApp::dispatchEvent(FXRawEvent& ev)
{
    FXWindow* window, *ancestor;
    FXint     tmp_x, tmp_y;
    Atom      answer;
    XEvent    se;
    Window    tmp;

    // Get window
    window = findWindowWithId(ev.xany.window);

    // Was one of our windows, so dispatch
    if (window)
    {
        switch (ev.xany.type)
        {
        // Repaint event
        case GraphicsExpose:
        case Expose:
            event.type = SEL_PAINT;
            event.rect.x = ev.xexpose.x;
            event.rect.y = ev.xexpose.y;
            event.rect.w = ev.xexpose.width;
            event.rect.h = ev.xexpose.height;
            event.synthetic = ev.xexpose.send_event;
            window->handle(this, FXSEL(SEL_PAINT, 0), &event);

        case NoExpose:
            return(true);

        // Keymap Notify
        case KeymapNotify:
            return(true);

        // Keyboard
        case KeyPress:

            // !!! Hack to fix the bug with composed characters !!!
            FXWindow* focuswin;
            focuswin = getFocusWindow();

            if ((ev.xkey.keycode != 0) && focuswin && focuswin->getComposeContext())
            {
                Window w;
                XGetICValues((XIC)focuswin->getComposeContext()->id(), XNFocusWindow, &w, NULL);

                // Mouse pointer is not over the text field
                if (!focuswin->underCursor())
                {
                    if ((focuswin->id() != w) && XFilterEvent(&ev, (Window)focuswin->id()))
                    {
                        return(true);
                    }
                }
            }
        // !!! End of hack !!!

        case KeyRelease:
            event.type = SEL_KEYPRESS+ev.xkey.type-KeyPress;
            event.time = ev.xkey.time;
            event.win_x = ev.xkey.x;
            event.win_y = ev.xkey.y;
            event.root_x = ev.xkey.x_root;
            event.root_y = ev.xkey.y_root;

            // Translate to keysym; must interpret modifiers!
            event.code = keysym(ev);

            // Translate to string on KeyPress
            if (ev.xkey.type == KeyPress)
            {
                if (getFocusWindow() && getFocusWindow()->getComposeContext())
                {
                    event.text = getFocusWindow()->getComposeContext()->translateEvent(ev);
                }
                else
                {
                    event.text = translateKeyEvent(ev);
                }
            }

            // Clear string on KeyRelease
            else
            {
                event.text.clear();
            }

            // Mouse buttons and modifiers but no wheel buttons
            event.state = ev.xkey.state&~(Button4Mask|Button5Mask);

            // Fix modifier state
            if (ev.xkey.type == KeyPress)
            {
                if (event.code == KEY_Shift_L)
                {
                    event.state |= SHIFTMASK;
                }
                else if (event.code == KEY_Shift_R)
                {
                    event.state |= SHIFTMASK;
                }
                else if (event.code == KEY_Control_L)
                {
                    event.state |= CONTROLMASK;
                }
                else if (event.code == KEY_Control_R)
                {
                    event.state |= CONTROLMASK;
                }
                else if (event.code == KEY_F13)
                {
                    event.state |= METAMASK;     // Key between Ctrl and Alt (on most keyboards)
                }
                else if (event.code == KEY_Alt_L)
                {
                    event.state |= ALTMASK;
                }
                else if (event.code == KEY_Alt_R)
                {
                    event.state |= ALTMASK;    // FIXME do we need ALTGR flag instead/in addition?
                }
                else if (event.code == KEY_Num_Lock)
                {
                    event.state |= NUMLOCKMASK;
                }
                else if (event.code == KEY_Caps_Lock)
                {
                    event.state |= CAPSLOCKMASK;
                }
                else if (event.code == KEY_Scroll_Lock)
                {
                    event.state |= SCROLLLOCKMASK;
                }
                else if (event.code == KEY_Super_L)
                {
                    event.state |= METAMASK;
                }
                else if (event.code == KEY_Super_R)
                {
                    event.state |= METAMASK;
                }
                else
                {
                    stickyMods = event.state&(SHIFTMASK|CONTROLMASK|METAMASK|ALTMASK);
                }
            }
            else
            {
                if (event.code == KEY_Shift_L)
                {
                    event.state &= ~SHIFTMASK;
                }
                else if (event.code == KEY_Shift_R)
                {
                    event.state &= ~SHIFTMASK;
                }
                else if (event.code == KEY_Control_L)
                {
                    event.state &= ~CONTROLMASK;
                }
                else if (event.code == KEY_Control_R)
                {
                    event.state &= ~CONTROLMASK;
                }
                else if (event.code == KEY_F13)
                {
                    event.state &= ~METAMASK;    // Key between Ctrl and Alt (on most keyboards)
                }
                else if (event.code == KEY_Alt_L)
                {
                    event.state &= ~ALTMASK;
                }
                else if (event.code == KEY_Alt_R)
                {
                    event.state &= ~ALTMASK;   // FIXME do we need ALTGR flag instead/in addition?
                }
                else if (event.code == KEY_Num_Lock)
                {
                    event.state &= ~NUMLOCKMASK;
                }
                else if (event.code == KEY_Caps_Lock)
                {
                    event.state &= ~CAPSLOCKMASK;
                }
                else if (event.code == KEY_Scroll_Lock)
                {
                    event.state &= ~SCROLLLOCKMASK;
                }
                else if (event.code == KEY_Super_L)
                {
                    event.state &= ~METAMASK;
                }
                else if (event.code == KEY_Super_R)
                {
                    event.state &= ~METAMASK;
                }
                else
                {
                    event.state |= stickyMods;
                    stickyMods = 0;
                }
            }

            // Keyboard grabbed by specific window
            if (keyboardGrabWindow)
            {
                if (keyboardGrabWindow->handle(this, FXSEL(event.type, 0), &event))
                {
                    refresh();
                }
                return(true);
            }

            // Remember window for later
            if (ev.xkey.type == KeyPress)
            {
                keyWindow = activeWindow;
            }

            // Dispatch to key window
            if (keyWindow)
            {
                // FIXME doesSaveUnder test should go away
                // Dispatch if not in a modal loop or in a modal loop for a window containing the focus window
                if (!invocation || (invocation->modality == MODAL_FOR_NONE) || (invocation->window && invocation->window->isOwnerOf(keyWindow)) || keyWindow->getShell()->doesSaveUnder())
                {
                    if (keyWindow->handle(this, FXSEL(event.type, 0), &event))
                    {
                        refresh();
                    }
                    return(TRUE);
                }

                // Beep if outside modal
                if (ev.xany.type == KeyPress)
                {
                    beep();
                }
            }
            return(true);

        // Motion
        case MotionNotify:
            event.type = SEL_MOTION;
            event.time = ev.xmotion.time;
            event.win_x = ev.xmotion.x;
            event.win_y = ev.xmotion.y;
            event.root_x = ev.xmotion.x_root;
            event.root_y = ev.xmotion.y_root;
            event.code = 0;

            // Mouse buttons and modifiers but no wheel buttons
            event.state = (ev.xmotion.state&~(Button4Mask|Button5Mask)) | stickyMods;

            // Moved more that delta
            if ((FXABS(event.root_x-event.rootclick_x) >= dragDelta) || (FXABS(event.root_y-event.rootclick_y) >= dragDelta))
            {
                event.moved = 1;
            }

            // Dispatch to grab window
            if (mouseGrabWindow)
            {
                window->translateCoordinatesTo(event.win_x, event.win_y, mouseGrabWindow, event.win_x, event.win_y);
                if (mouseGrabWindow->handle(this, FXSEL(SEL_MOTION, 0), &event))
                {
                    refresh();
                }
            }

            // FIXME doesSaveUnder test should go away
            // Dispatch if inside model window
            else if (!invocation || (invocation->modality == MODAL_FOR_NONE) || (invocation->window && invocation->window->isOwnerOf(window)) || window->getShell()->doesSaveUnder())
            {
                if (window->handle(this, FXSEL(SEL_MOTION, 0), &event))
                {
                    refresh();
                }
            }

            // Remember last mouse
            event.last_x = event.win_x;
            event.last_y = event.win_y;
            return(true);

        // Button
        case ButtonPress:
        case ButtonRelease:
            event.time = ev.xbutton.time;
            event.win_x = ev.xbutton.x;
            event.win_y = ev.xbutton.y;
            event.root_x = ev.xbutton.x_root;
            event.root_y = ev.xbutton.y_root;

            // Mouse buttons and modifiers but no wheel buttons
            event.state = (ev.xmotion.state&~(Button4Mask|Button5Mask)) | stickyMods;

            // Mouse Wheel
            if ((ev.xbutton.button == Button4) || (ev.xbutton.button == Button5))
            {
                event.type = SEL_MOUSEWHEEL;
                event.code = ((ev.xbutton.button == Button4) ? 120 : -120)*ev.xbutton.subwindow;

                // Dispatch to grab window
                if (mouseGrabWindow)
                {
                    window->translateCoordinatesTo(event.win_x, event.win_y, mouseGrabWindow, event.win_x, event.win_y);
                    if (mouseGrabWindow->handle(this, FXSEL(SEL_MOUSEWHEEL, 0), &event))
                    {
                        refresh();
                    }
                    return(true);
                }

                // Dispatch to window under cursor
                // FIXME doesSaveUnder test should go away
                while (window && (!invocation || invocation->modality == MODAL_FOR_NONE || (invocation->window && invocation->window->isOwnerOf(window)) || window->getShell()->doesSaveUnder()))
                {
                    if (window->handle(this, FXSEL(SEL_MOUSEWHEEL, 0), &event))
                    {
                        refresh();
                        break;
                    }
                    window = window->getParent();
                }
                return(true);
            }

            // Mouse Button
            event.code = ev.xbutton.button;
            if (ev.xbutton.type == ButtonPress)                                // Mouse button press
            {
                if (ev.xbutton.button == Button1)
                {
                    event.type = SEL_LEFTBUTTONPRESS;
                    event.state |= LEFTBUTTONMASK;
                }
                if (ev.xbutton.button == Button2)
                {
                    event.type = SEL_MIDDLEBUTTONPRESS;
                    event.state |= MIDDLEBUTTONMASK;
                }
                if (ev.xbutton.button == Button3)
                {
                    event.type = SEL_RIGHTBUTTONPRESS;
                    event.state |= RIGHTBUTTONMASK;
                }
                if (!event.moved && (event.time-event.click_time < clickSpeed) && (event.code == (FXint)event.click_button))
                {
                    event.click_count++;
                    event.click_time = event.time;
                }
                else
                {
                    event.click_count = 1;
                    event.click_x = event.win_x;
                    event.click_y = event.win_y;
                    event.rootclick_x = event.root_x;
                    event.rootclick_y = event.root_y;
                    event.click_button = event.code;
                    event.click_time = event.time;
                }
                if (!(ev.xbutton.state&(Button1Mask|Button2Mask|Button3Mask)))
                {
                    event.moved = 0;
                }
            }
            else                                                            // Mouse button release
            {
                if (ev.xbutton.button == Button1)
                {
                    event.type = SEL_LEFTBUTTONRELEASE;
                    event.state &= ~LEFTBUTTONMASK;
                }
                if (ev.xbutton.button == Button2)
                {
                    event.type = SEL_MIDDLEBUTTONRELEASE;
                    event.state &= ~MIDDLEBUTTONMASK;
                }
                if (ev.xbutton.button == Button3)
                {
                    event.type = SEL_RIGHTBUTTONRELEASE;
                    event.state &= ~RIGHTBUTTONMASK;
                }
            }

            // Dispatch to grab window
            if (mouseGrabWindow)
            {
                window->translateCoordinatesTo(event.win_x, event.win_y, mouseGrabWindow, event.win_x, event.win_y);
                if (mouseGrabWindow->handle(this, FXSEL(event.type, 0), &event))
                {
                    refresh();
                }
            }

            // Dispatch if inside model window
            // FIXME doesSaveUnder test should go away
            else if (!invocation || (invocation->modality == MODAL_FOR_NONE) || (invocation->window && invocation->window->isOwnerOf(window)) || window->getShell()->doesSaveUnder())
            {
                if (window->handle(this, FXSEL(event.type, 0), &event))
                {
                    refresh();
                }
            }

            // Beep if outside modal window
            else
            {
                if (ev.xany.type == ButtonPress)
                {
                    beep();
                }
            }

            // Remember last mouse
            event.last_x = event.win_x;
            event.last_y = event.win_y;
            return(true);

        // Crossing
        case EnterNotify:
            event.time = ev.xcrossing.time;
            if (cursorWindow != window)
            {
                if ((ev.xcrossing.mode == NotifyGrab) || (ev.xcrossing.mode == NotifyUngrab) || ((ev.xcrossing.mode == NotifyNormal) && (ev.xcrossing.detail != NotifyInferior)))
                {
                    ancestor = FXWindow::commonAncestor(window, cursorWindow);
                    event.root_x = ev.xcrossing.x_root;
                    event.root_y = ev.xcrossing.y_root;
                    event.code = ev.xcrossing.mode;
                    leaveWindow(cursorWindow, ancestor);
                    enterWindow(window, ancestor);
                }
            }
            return(true);

        // Crossing
        case LeaveNotify:
            event.time = ev.xcrossing.time;
            if (cursorWindow == window)
            {
                if ((ev.xcrossing.mode == NotifyGrab) || (ev.xcrossing.mode == NotifyUngrab) || ((ev.xcrossing.mode == NotifyNormal) && (ev.xcrossing.detail != NotifyInferior)))
                {
                    event.root_x = ev.xcrossing.x_root;
                    event.root_y = ev.xcrossing.y_root;
                    event.code = ev.xcrossing.mode;
                    FXASSERT(cursorWindow == window);
                    leaveWindow(window, window->getParent());
                }
            }
            return(true);

        // Focus change on shell window
        case FocusIn:
        case FocusOut:
            window = window->getShell();
            if ((ev.xfocus.type == FocusOut) && (activeWindow == window))
            {
                event.type = SEL_FOCUSOUT;
                if (window->handle(this, FXSEL(SEL_FOCUSOUT, 0), &event))
                {
                    refresh();
                }
                activeWindow = NULL;
            }
            if ((ev.xfocus.type == FocusIn) && (activeWindow != window))
            {
                event.type = SEL_FOCUSIN;
                if (window->handle(this, FXSEL(SEL_FOCUSIN, 0), &event))
                {
                    refresh();
                }
                activeWindow = window;
            }
            return(true);

        // Map
        case MapNotify:
            event.type = SEL_MAP;
            if (window->handle(this, FXSEL(SEL_MAP, 0), &event))
            {
                refresh();
            }
            return(true);

        // Unmap
        case UnmapNotify:
            event.type = SEL_UNMAP;
            if (window->handle(this, FXSEL(SEL_UNMAP, 0), &event))
            {
                refresh();
            }
            return(true);

        // Create
        case CreateNotify:
            event.type = SEL_CREATE;
            if (window->handle(this, FXSEL(SEL_CREATE, 0), &event))
            {
                refresh();
            }
            return(true);

        // Destroy
        case DestroyNotify:
            event.type = SEL_DESTROY;
            if (window->handle(this, FXSEL(SEL_DESTROY, 0), &event))
            {
                refresh();
            }
            return(true);

        // Configure
        case ConfigureNotify:
            event.type = SEL_CONFIGURE;
            // According to the ICCCM, if its synthetic, the coordinates are relative
            // to root window; otherwise, they're relative to the parent; so we use
            // the old coordinates if its not a synthetic configure notify
            if ((window->getShell() == window) && !ev.xconfigure.send_event)
            {
                ev.xconfigure.x = window->getX();
                ev.xconfigure.y = window->getY();
            }
            event.rect.x = ev.xconfigure.x;
            event.rect.y = ev.xconfigure.y;
            event.rect.w = ev.xconfigure.width;
            event.rect.h = ev.xconfigure.height;
            event.synthetic = ev.xconfigure.send_event;
            if (window->handle(this, FXSEL(SEL_CONFIGURE, 0), &event))
            {
                refresh();
            }
            return(true);

        // Circulate
        case CirculateNotify:
            event.type = SEL_RAISED+(ev.xcirculate.place&1);
            if (window->handle(this, FXSEL(event.type, 0), &event))
            {
                refresh();
            }
            return(true);

        // Selection Clear
        case SelectionClear:
            if (ev.xselectionclear.selection == XA_PRIMARY)
            {
                // We lost the primary selection if the new selection owner is different from selectionWindow
                if (selectionWindow && (selectionWindow->id() != XGetSelectionOwner((Display*)display, XA_PRIMARY)))
                {
                    event.type = SEL_SELECTION_LOST;
                    event.time = ev.xselectionclear.time;
                    if (selectionWindow->handle(this, FXSEL(SEL_SELECTION_LOST, 0), &event))
                    {
                        refresh();
                    }
                    selectionWindow = NULL;
                }
                FXFREE(&xselTypeList);
                xselNumTypes = 0;
            }
            else if (ev.xselectionclear.selection == xcbSelection)
            {
                // We lost the clipboard selection if the new clipboard owner is different from clipboardWindow
                if (clipboardWindow && (clipboardWindow->id() != XGetSelectionOwner((Display*)display, xcbSelection)))
                {
                    event.time = ev.xselectionclear.time;
                    event.type = SEL_CLIPBOARD_LOST;
                    if (clipboardWindow->handle(this, FXSEL(SEL_CLIPBOARD_LOST, 0), &event))
                    {
                        refresh();
                    }
                    clipboardWindow = NULL;
                }
                FXFREE(&xcbTypeList);
                xcbNumTypes = 0;
            }
            return(true);

        // Selection Request
        case SelectionRequest:
            answer = None;
            if (ev.xselectionrequest.selection == XA_PRIMARY)
            {
                if (selectionWindow)
                {
                    if (ev.xselectionrequest.target == ddeTargets)             // Request for TYPES
                    {
                        answer = fxsendtypes((Display*)display, ev.xselectionrequest.requestor, ev.xselectionrequest.property, xselTypeList, xselNumTypes);
                    }
                    else                                                    // Request for DATA
                    {
                        event.type = SEL_SELECTION_REQUEST;
                        event.time = ev.xselectionrequest.time;
                        event.target = ev.xselectionrequest.target;
                        ddeData = NULL;
                        ddeSize = 0;
                        selectionWindow->handle(this, FXSEL(SEL_SELECTION_REQUEST, 0), &event);
                        answer = fxsenddata((Display*)display, ev.xselectionrequest.requestor, ev.xselectionrequest.property, ev.xselectionrequest.target, ddeData, ddeSize);
                        FXFREE(&ddeData);
                        ddeData = NULL;
                        ddeSize = 0;
                    }
                }
            }
            else if (ev.xselectionrequest.selection == xcbSelection)
            {
                if (clipboardWindow)
                {
                    if (ev.xselectionrequest.target == ddeTargets)             // Request for TYPES
                    {
                        answer = fxsendtypes((Display*)display, ev.xselectionrequest.requestor, ev.xselectionrequest.property, xcbTypeList, xcbNumTypes);
                    }
                    else                                                    // Request for DATA
                    {
                        event.type = SEL_CLIPBOARD_REQUEST;
                        event.time = ev.xselectionrequest.time;
                        event.target = ev.xselectionrequest.target;
                        ddeData = NULL;
                        ddeSize = 0;
                        clipboardWindow->handle(this, FXSEL(SEL_CLIPBOARD_REQUEST, 0), &event);
                        answer = fxsenddata((Display*)display, ev.xselectionrequest.requestor, ev.xselectionrequest.property, ev.xselectionrequest.target, ddeData, ddeSize);
                        FXFREE(&ddeData);
                        ddeData = NULL;
                        ddeSize = 0;
                    }
                }
            }
            else if (ev.xselectionrequest.selection == xdndSelection)
            {
                if (dragWindow)
                {
                    if (ev.xselectionrequest.target == ddeTargets)             // Request for TYPES
                    {
                        answer = fxsendtypes((Display*)display, ev.xselectionrequest.requestor, ev.xselectionrequest.property, xdndTypeList, xdndNumTypes);
                    }
                    else                                                    // Request for DATA
                    {
                        event.type = SEL_DND_REQUEST;
                        event.time = ev.xselectionrequest.time;
                        event.target = ev.xselectionrequest.target;
                        ddeData = NULL;
                        ddeSize = 0;
                        dragWindow->handle(this, FXSEL(SEL_DND_REQUEST, 0), &event);
                        answer = fxsenddata((Display*)display, ev.xselectionrequest.requestor, ev.xselectionrequest.property, ev.xselectionrequest.target, ddeData, ddeSize);
                        FXFREE(&ddeData);
                        ddeData = NULL;
                        ddeSize = 0;
                    }
                }
            }
            fxsendreply((Display*)display, ev.xselectionrequest.requestor, ev.xselectionrequest.selection, answer, ev.xselectionrequest.target, ev.xselectionrequest.time);
            return(true);

        // Selection Notify
        case SelectionNotify:
            return(true);

        // Client message
        case ClientMessage:

            // WM_PROTOCOLS
            if (ev.xclient.message_type == wmProtocols)
            {
                if ((FXID)ev.xclient.data.l[0] == wmDeleteWindow)            // WM_DELETE_WINDOW
                {
                    event.type = SEL_CLOSE;
                    if (!invocation || (invocation->modality == MODAL_FOR_NONE) || (invocation->window && invocation->window->isOwnerOf(window)))
                    {
                        if (window->handle(this, FXSEL(SEL_CLOSE, 0), &event))
                        {
                            refresh();
                        }
                    }
                    else
                    {
                        beep();
                    }
                }
                else if ((FXID)ev.xclient.data.l[0] == wmQuitApp)            // WM_QUIT_APP
                {
                    event.type = SEL_CLOSE;
                    if (!invocation || (invocation->modality == MODAL_FOR_NONE) || (invocation->window && invocation->window->isOwnerOf(window)))
                    {
                        if (window->handle(this, FXSEL(SEL_CLOSE, 0), &event))
                        {
                            refresh();
                        }
                    }
                    else
                    {
                        beep();
                    }
                }
                else if ((FXID)ev.xclient.data.l[0] == wmTakeFocus)          // WM_TAKE_FOCUS
                {
                    if (invocation && invocation->window && invocation->window->id())
                    {
                        ev.xclient.window = invocation->window->id();
                    }
                    // Assign focus to innermost modal dialog, even when trying to focus
                    // on another window; these other windows are dead to inputs anyway.
                    // XSetInputFocus causes a spurious BadMatch error; we ignore this in xerrorhandler
                    XSetInputFocus((Display*)display, ev.xclient.window, RevertToParent, ev.xclient.data.l[1]);
                }
                else if ((FXID)ev.xclient.data.l[0] == wmNetPing)           // NET_WM_PING
                {
                    se.xclient.type = ClientMessage;
                    se.xclient.display = (Display*)display;                       // This lets a window manager know that
                    se.xclient.message_type = wmProtocols;                        // we're still alive after having received
                    se.xclient.format = 32;                                       // a WM_DELETE_WINDOW message
                    se.xclient.window = XDefaultRootWindow((Display*)display);
                    se.xclient.data.l[0] = ev.xclient.data.l[0];
                    se.xclient.data.l[1] = ev.xclient.data.l[1];
                    se.xclient.data.l[2] = ev.xclient.data.l[2];
                    se.xclient.data.l[3] = 0;
                    se.xclient.data.l[4] = 0;
                    XSendEvent((Display*)display, se.xclient.window, False, SubstructureRedirectMask|SubstructureNotifyMask, &se);
                }
            }

            // XDND Enter from source
            else if (ev.xclient.message_type == xdndEnter)
            {
                FXint ver = (ev.xclient.data.l[1]>>24)&255;
                if (ver > XDND_PROTOCOL_VERSION)
                {
                    return(true);
                }
                xdndSource = ev.xclient.data.l[0];                                  // Now we're talking to this guy
                if (ddeTypeList)
                {
                    FXFREE(&ddeTypeList);
                    ddeNumTypes = 0;
                }
                if (ev.xclient.data.l[1]&1)
                {
                    fxrecvtypes((Display*)display, xdndSource, xdndTypes, ddeTypeList, ddeNumTypes, FALSE);
                }
                else
                {
                    FXMALLOC(&ddeTypeList, FXDragType, 3);
                    ddeNumTypes = 0;
                    if (ev.xclient.data.l[2])
                    {
                        ddeTypeList[0] = ev.xclient.data.l[2];
                        ddeNumTypes++;
                    }
                    if (ev.xclient.data.l[3])
                    {
                        ddeTypeList[1] = ev.xclient.data.l[3];
                        ddeNumTypes++;
                    }
                    if (ev.xclient.data.l[4])
                    {
                        ddeTypeList[2] = ev.xclient.data.l[4];
                        ddeNumTypes++;
                    }
                }
            }

            // XDND Leave from source
            else if (ev.xclient.message_type == xdndLeave)
            {
                if (xdndSource != (FXID)ev.xclient.data.l[0])
                {
                    return(true);   // We're not talking to this guy
                }
                if (dropWindow)
                {
                    event.type = SEL_DND_LEAVE;
                    if (dropWindow->handle(this, FXSEL(SEL_DND_LEAVE, 0), &event))
                    {
                        refresh();
                    }
                    dropWindow = NULL;
                }
                if (ddeTypeList)
                {
                    FXFREE(&ddeTypeList);
                    ddeNumTypes = 0;
                }
                xdndSource = 0;
            }

            // XDND Position from source
            else if (ev.xclient.message_type == xdndPosition)
            {
                if (xdndSource != (FXID)ev.xclient.data.l[0])
                {
                    return(true);   // We're not talking to this guy
                }
                event.time = ev.xclient.data.l[3];
                event.root_x = ((FXuint)ev.xclient.data.l[2])>>16;
                event.root_y = ((FXuint)ev.xclient.data.l[2])&0xffff;
                // Search from target window down; there may be another window
                // (like e.g. the dragged shape window) right under the cursor.
                // Note this is the target window, not the proxy target....
                window = findWindowAt(event.root_x, event.root_y, ev.xclient.window);
                if ((FXID)ev.xclient.data.l[4] == xdndActionCopy)
                {
                    ddeAction = DRAG_COPY;
                }
                else if ((FXID)ev.xclient.data.l[4] == xdndActionMove)
                {
                    ddeAction = DRAG_MOVE;
                }
                else if ((FXID)ev.xclient.data.l[4] == xdndActionLink)
                {
                    ddeAction = DRAG_LINK;
                }
                else if ((FXID)ev.xclient.data.l[4] == xdndActionPrivate)
                {
                    ddeAction = DRAG_PRIVATE;
                }
                else
                {
                    ddeAction = DRAG_COPY;
                }
                ansAction = DRAG_REJECT;
                xdndWantUpdates = TRUE;
                xdndRect.x = event.root_x;
                xdndRect.y = event.root_y;
                xdndRect.w = 1;
                xdndRect.h = 1;
                if (window != dropWindow)
                {
                    if (dropWindow)
                    {
                        event.type = SEL_DND_LEAVE;
                        if (dropWindow->handle(this, FXSEL(SEL_DND_LEAVE, 0), &event))
                        {
                            refresh();
                        }
                    }
                    dropWindow = NULL;
                    if (window && window->isDropEnabled())
                    {
                        dropWindow = window;
                        event.type = SEL_DND_ENTER;
                        if (dropWindow->handle(this, FXSEL(SEL_DND_ENTER, 0), &event))
                        {
                            refresh();
                        }
                    }
                }
                if (dropWindow)
                {
                    event.type = SEL_DND_MOTION;
                    XTranslateCoordinates((Display*)display, XDefaultRootWindow((Display*)display), dropWindow->id(), event.root_x, event.root_y, &event.win_x, &event.win_y, &tmp);
                    if (dropWindow->handle(this, FXSEL(SEL_DND_MOTION, 0), &event))
                    {
                        refresh();
                    }
                    event.last_x = event.win_x;
                    event.last_y = event.win_y;
                }
                se.xclient.type = ClientMessage;
                se.xclient.display = (Display*)display;
                se.xclient.message_type = xdndStatus;
                se.xclient.format = 32;
                se.xclient.window = xdndSource;
                se.xclient.data.l[0] = ev.xclient.window;                   // Proxy Target window
                se.xclient.data.l[1] = 0;
                if (ansAction != DRAG_REJECT)
                {
                    se.xclient.data.l[1] |= 1;       // Target accepted
                }
                if (xdndWantUpdates)
                {
                    se.xclient.data.l[1] |= 2;              // Target wants continuous position updates
                }
                se.xclient.data.l[2] = MKUINT(xdndRect.y, xdndRect.x);
                se.xclient.data.l[3] = MKUINT(xdndRect.h, xdndRect.w);
                if (ansAction == DRAG_COPY)
                {
                    se.xclient.data.l[4] = xdndActionCopy; // Drag and Drop Action accepted
                }
                else if (ansAction == DRAG_MOVE)
                {
                    se.xclient.data.l[4] = xdndActionMove;
                }
                else if (ansAction == DRAG_LINK)
                {
                    se.xclient.data.l[4] = xdndActionLink;
                }
                else if (ansAction == DRAG_PRIVATE)
                {
                    se.xclient.data.l[4] = xdndActionPrivate;
                }
                else
                {
                    se.xclient.data.l[4] = None;
                }
                XSendEvent((Display*)display, xdndSource, True, NoEventMask, &se);
            }

            // XDND Drop from source
            else if (ev.xclient.message_type == xdndDrop)
            {
                if (xdndSource != (FXID)ev.xclient.data.l[0])
                {
                    return(true);   // We're not talking to this guy
                }
                xdndFinishSent = FALSE;
                event.type = SEL_DND_DROP;
                event.time = ev.xclient.data.l[2];
                if (!dropWindow || !dropWindow->handle(this, FXSEL(SEL_DND_DROP, 0), &event))
                {
                    ansAction = DRAG_REJECT;
                }
                if (!xdndFinishSent)
                {
                    se.xclient.type = ClientMessage;
                    se.xclient.display = (Display*)display;
                    se.xclient.message_type = xdndFinished;
                    se.xclient.format = 32;
                    se.xclient.window = xdndSource;
                    se.xclient.data.l[0] = ev.xclient.window;                     // Proxy Target window
                    se.xclient.data.l[1] = (ansAction == DRAG_REJECT) ? 0 : 1;    // Bit #0 means accepted
                    if (ansAction == DRAG_COPY)
                    {
                        se.xclient.data.l[2] = xdndActionCopy;
                    }
                    else if (ansAction == DRAG_MOVE)
                    {
                        se.xclient.data.l[2] = xdndActionMove;
                    }
                    else if (ansAction == DRAG_LINK)
                    {
                        se.xclient.data.l[2] = xdndActionLink;
                    }
                    else if (ansAction == DRAG_PRIVATE)
                    {
                        se.xclient.data.l[2] = xdndActionPrivate;
                    }
                    else
                    {
                        se.xclient.data.l[2] = None;
                    }
                    se.xclient.data.l[3] = 0;
                    se.xclient.data.l[4] = 0;
                    XSendEvent((Display*)display, xdndSource, True, NoEventMask, &se);
                }
                if (ddeTypeList)
                {
                    FXFREE(&ddeTypeList);
                    ddeNumTypes = 0;
                }
                dropWindow = NULL;
                xdndSource = 0;
                refresh();
            }

            // XDND Status from target
            else if (ev.xclient.message_type == xdndStatus)
            {
                // We ignore ev.xclient.data.l[0], because some other
                // toolkits, e.g. Qt, do not place the proper value there;
                // the proper value is xdndTarget, NOT xdndProxyTarget or None
                //if (xdndTarget!=(FXID)ev.xclient.data.l[0]) return true; // We're not talking to this guy
                ansAction = DRAG_REJECT;
                if (ev.xclient.data.l[1]&1)
                {
                    if ((FXID)ev.xclient.data.l[4] == xdndActionCopy)
                    {
                        ansAction = DRAG_COPY;
                    }
                    else if ((FXID)ev.xclient.data.l[4] == xdndActionMove)
                    {
                        ansAction = DRAG_MOVE;
                    }
                    else if ((FXID)ev.xclient.data.l[4] == xdndActionLink)
                    {
                        ansAction = DRAG_LINK;
                    }
                    else if ((FXID)ev.xclient.data.l[4] == xdndActionPrivate)
                    {
                        ansAction = DRAG_PRIVATE;
                    }
                }
                xdndWantUpdates = ev.xclient.data.l[1]&2;
                xdndRect.x = ((FXuint)ev.xclient.data.l[2])>>16;
                xdndRect.y = ((FXuint)ev.xclient.data.l[2])&0xffff;
                xdndRect.w = ((FXuint)ev.xclient.data.l[3])>>16;
                xdndRect.h = ((FXuint)ev.xclient.data.l[3])&0xffff;
                xdndStatusReceived = TRUE;
                xdndStatusPending = FALSE;
            }
            return(true);

        // Property change
        case PropertyNotify:

            event.time = ev.xproperty.time;

            // Update window position after minimize/maximize/restore whatever
            if ((ev.xproperty.atom == wmState) || (ev.xproperty.atom == wmNetState))
            {
                event.type = SEL_CONFIGURE;
                XTranslateCoordinates((Display*)display, ev.xproperty.window, XDefaultRootWindow((Display*)display), 0, 0, &tmp_x, &tmp_y, &tmp);
                event.rect.x = tmp_x;
                event.rect.y = tmp_y;
                event.rect.w = window->getWidth();
                event.rect.h = window->getHeight();
                event.synthetic = ev.xproperty.send_event;
                if (window->handle(this, FXSEL(SEL_CONFIGURE, 0), &event))
                {
                    refresh();
                }
            }
            return(true);

        // Keyboard mapping
        case MappingNotify:
            if (ev.xmapping.request != MappingPointer)
            {
                XRefreshKeyboardMapping(&ev.xmapping);
            }
            return(true);

        // Other events
        default:
#ifdef HAVE_XRANDR_H
            if (ev.type == xrreventbase+RRScreenChangeNotify)
            {
                XRRUpdateConfiguration(&ev);
                root->setWidth(root->getDefaultWidth());
                root->setHeight(root->getDefaultHeight());
            }
#endif
            return(true);
        }
    }
    return(false);
}


//
// Hack of FXScrollArea
//

// This hack allows to scroll in horizontal mode when we are in row and small/big icons mode of a FileList

// Mouse wheel used for vertical scrolling
long FXScrollArea::onVMouseWheel(FXObject* sender, FXSelector sel, void* ptr)
{
    // !!! Hack to scroll in horizontal mode !!!
    if (!(options&ICONLIST_COLUMNS) && options&(ICONLIST_BIG_ICONS|ICONLIST_MINI_ICONS) && streq(this->getClassName(), "FileList"))
    {
        horizontal->handle(sender, sel, ptr);
    }
    else
    {
        // !!! End of hack !!!
        vertical->handle(sender, sel, ptr);
    }

    return(1);
}


//
// Hack of FXButton
//

// This hack fixes a focus problem on the panels when activating a button which is already activated
// Now, the focus on the active panel is not lost anymore


// Pressed mouse button
long FXButton::onLeftBtnPress(FXObject*, FXSelector, void* ptr)
{
    handle(this, FXSEL(SEL_FOCUS_SELF, 0), ptr);
    flags &= ~FLAG_TIP;
    if (isEnabled() && !(flags&FLAG_PRESSED))
    {
        grab();
        if (target && target->tryHandle(this, FXSEL(SEL_LEFTBUTTONPRESS, message), ptr))
        {
            return(1);
        }
        //if (state!=STATE_ENGAGED) // !!! Hack here !!!
        setState(STATE_DOWN);
        flags |= FLAG_PRESSED;
        flags &= ~FLAG_UPDATE;
        return(1);
    }
    return(0);
}


// Hot key combination pressed
long FXButton::onHotKeyPress(FXObject*, FXSelector, void* ptr)
{
    flags &= ~FLAG_TIP;
    handle(this, FXSEL(SEL_FOCUS_SELF, 0), ptr);
    if (isEnabled() && !(flags&FLAG_PRESSED))
    {
        //if (state!=STATE_ENGAGED)  // !!! Hack here !!!
        setState(STATE_DOWN);
        flags &= ~FLAG_UPDATE;
        flags |= FLAG_PRESSED;
    }
    return(1);
}


//
// Hack of FXTopWindow
//

// This hack fixes a problem with some window managers like Icewm or Openbox
// These WMs do not deal with StaticGravity the same way as e.g. Metacity
// and then the window border can be invisible when launching the applications

// Request for toplevel window resize
void FXTopWindow::resize(int w, int h)
{
    if ((flags&FLAG_DIRTY) || (w != width) || (h != height))
    {
        width = FXMAX(w, 1);
        height = FXMAX(h, 1);
        if (xid)
        {
            XWindowChanges changes;
            XSizeHints     size;
            size.flags = USSize|PSize|PWinGravity|USPosition|PPosition;
            size.x = xpos;
            size.y = ypos;
            size.width = width;
            size.height = height;
            size.min_width = 0;
            size.min_height = 0;
            size.max_width = 0;
            size.max_height = 0;
            size.width_inc = 0;
            size.height_inc = 0;
            size.min_aspect.x = 0;
            size.min_aspect.y = 0;
            size.max_aspect.x = 0;
            size.max_aspect.y = 0;
            size.base_width = 0;
            size.base_height = 0;

            // !!! Hack here !!!
            size.win_gravity = NorthWestGravity;                      // Tim Alexeevsky <realtim@mail.ru>
            //size.win_gravity=StaticGravity;                       // Account for border (ICCCM)
            // !!! End of hack !!!

            if (!(options&DECOR_SHRINKABLE))
            {
                if (!(options&DECOR_STRETCHABLE))                       // Cannot change at all
                {
                    size.flags |= PMinSize|PMaxSize;
                    size.min_width = size.max_width = width;
                    size.min_height = size.max_height = height;
                }
                else                                                    // Cannot get smaller than default
                {
                    size.flags |= PMinSize;
                    size.min_width = getDefaultWidth();
                    size.min_height = getDefaultHeight();
                }
            }
            else if (!(options&DECOR_STRETCHABLE))                      // Cannot get larger than default
            {
                size.flags |= PMaxSize;
                size.max_width = getDefaultWidth();
                size.max_height = getDefaultHeight();
            }
            XSetWMNormalHints(DISPLAY(getApp()), xid, &size);
            changes.x = 0;
            changes.y = 0;
            changes.width = width;
            changes.height = height;
            changes.border_width = 0;
            changes.sibling = None;
            changes.stack_mode = Above;
            XReconfigureWMWindow(DISPLAY(getApp()), xid, DefaultScreen(DISPLAY(getApp())), CWWidth|CWHeight, &changes);
            layout();
        }
    }
}


// Request for toplevel window reposition
void FXTopWindow::position(int x, int y, int w, int h)
{
    if ((flags&FLAG_DIRTY) || (x != xpos) || (y != ypos) || (w != width) || (h != height))
    {
        xpos = x;
        ypos = y;
        width = FXMAX(w, 1);
        height = FXMAX(h, 1);
        if (xid)
        {
            XWindowChanges changes;
            XSizeHints     size;
            size.flags = USSize|PSize|PWinGravity|USPosition|PPosition;
            size.x = xpos;
            size.y = ypos;
            size.width = width;
            size.height = height;
            size.min_width = 0;
            size.min_height = 0;
            size.max_width = 0;
            size.max_height = 0;
            size.width_inc = 0;
            size.height_inc = 0;
            size.min_aspect.x = 0;
            size.min_aspect.y = 0;
            size.max_aspect.x = 0;
            size.max_aspect.y = 0;
            size.base_width = 0;
            size.base_height = 0;

            // !!! Hack here !!!
            size.win_gravity = NorthWestGravity;                      // Tim Alexeevsky <realtim@mail.ru>
            //size.win_gravity=StaticGravity;                       // Account for border (ICCCM)
            // !!! End of hack !!!

            if (!(options&DECOR_SHRINKABLE))
            {
                if (!(options&DECOR_STRETCHABLE))                         // Cannot change at all
                {
                    size.flags |= PMinSize|PMaxSize;
                    size.min_width = size.max_width = width;
                    size.min_height = size.max_height = height;
                }
                else                                                      // Cannot get smaller than default
                {
                    size.flags |= PMinSize;
                    size.min_width = getDefaultWidth();
                    size.min_height = getDefaultHeight();
                }
            }
            else if (!(options&DECOR_STRETCHABLE))                        // Cannot get larger than default
            {
                size.flags |= PMaxSize;
                size.max_width = getDefaultWidth();
                size.max_height = getDefaultHeight();
            }
            XSetWMNormalHints(DISPLAY(getApp()), xid, &size);
            changes.x = xpos;
            changes.y = ypos;
            changes.width = width;
            changes.height = height;
            changes.border_width = 0;
            changes.sibling = None;
            changes.stack_mode = Above;
            XReconfigureWMWindow(DISPLAY(getApp()), xid, DefaultScreen(DISPLAY(getApp())), CWX|CWY|CWWidth|CWHeight, &changes);
            layout();
        }
    }
}


// Position the window based on placement
void FXTopWindow::place(FXuint placement)
{
    int       rx, ry, rw, rh, ox, oy, ow, oh, wx, wy, ww, wh, x, y;
    FXuint    state;
    FXWindow* over;

    // Default placement:- leave it where it was
    wx = getX();
    wy = getY();
    ww = getWidth();
    wh = getHeight();

    // Get root window size
    rx = getRoot()->getX();
    ry = getRoot()->getY();
    rw = getRoot()->getWidth();
    rh = getRoot()->getHeight();

    // Placement policy
    switch (placement)
    {
    // Place such that it contains the cursor
    case PLACEMENT_CURSOR:

        // Get dialog location in root coordinates
        translateCoordinatesTo(wx, wy, getRoot(), 0, 0);

        // Where's the mouse?
        getRoot()->getCursorPosition(x, y, state);

        // Place such that mouse in the middle, placing it as
        // close as possible in the center of the owner window.
        // Don't move the window unless the mouse is not inside.

        // !!! Hack here !!!
        //if (!shown() || x<wx || y<wy || wx+ww<=x || wy+wh<=y)
        if ((x < wx) || (y < wy) || (wx+ww <= x) || (wy+wh <= y))
        // !!! End of hack !!!
        {
            // Get the owner
            over = getOwner() ? getOwner() : getRoot();

            // Get owner window size
            ow = over->getWidth();
            oh = over->getHeight();

            // Owner's coordinates to root coordinates
            over->translateCoordinatesTo(ox, oy, getRoot(), 0, 0);

            // Adjust position
            wx = ox+(ow-ww)/2;
            wy = oy+(oh-wh)/2;

            // Move by the minimal amount
            if (x < wx)
            {
                wx = x-20;
            }
            else if (wx+ww <= x)
            {
                wx = x-ww+20;
            }
            if (y < wy)
            {
                wy = y-20;
            }
            else if (wy+wh <= y)
            {
                wy = y-wh+20;
            }
        }

        // Adjust so dialog is fully visible
        if (wx < rx)
        {
            wx = rx+10;
        }
        if (wy < ry)
        {
            wy = ry+10;
        }
        if (wx+ww > rx+rw)
        {
            wx = rx+rw-ww-10;
        }
        if (wy+wh > ry+rh)
        {
            wy = ry+rh-wh-10;
        }
        break;

    // Place centered over the owner
    case PLACEMENT_OWNER:

        // Get the owner
        over = getOwner() ? getOwner() : getRoot();

        // Get owner window size
        ow = over->getWidth();
        oh = over->getHeight();

        // Owner's coordinates to root coordinates
        over->translateCoordinatesTo(ox, oy, getRoot(), 0, 0);

        // Adjust position
        wx = ox+(ow-ww)/2;
        wy = oy+(oh-wh)/2;

        // Adjust so dialog is fully visible
        if (wx < rx)
        {
            wx = rx+10;
        }
        if (wy < ry)
        {
            wy = ry+10;
        }
        if (wx+ww > rx+rw)
        {
            wx = rx+rw-ww-10;
        }
        if (wy+wh > ry+rh)
        {
            wy = ry+rh-wh-10;
        }
        break;

    // Place centered on the screen
    case PLACEMENT_SCREEN:

        // Adjust position
        wx = rx+(rw-ww)/2;
        wy = ry+(rh-wh)/2;
        break;

    // Place to make it fully visible
    case PLACEMENT_VISIBLE:

        // Adjust so dialog is fully visible
        if (wx < rx)
        {
            wx = rx+10;
        }
        if (wy < ry)
        {
            wy = ry+10;
        }
        if (wx+ww > rx+rw)
        {
            wx = rx+rw-ww-10;
        }
        if (wy+wh > ry+rh)
        {
            wy = ry+rh-wh-10;
        }
        break;

    // Place maximized
    case PLACEMENT_MAXIMIZED:
        wx = rx;
        wy = ry;
        ww = rw;                // Yes, I know:- we should substract the borders;
        wh = rh;                // trouble is, no way to know how big those are....
        break;

    // Default placement
    case PLACEMENT_DEFAULT:
    default:
        break;
    }

    // Place it
    position(wx, wy, ww, wh);
}


//
// Hack of FXAccelTable
//

// This hack allows to ignore caps lock when using keyboard shortcuts

#define EMPTYSLOT     0xfffffffe     // Previously used, now empty slot
#define UNUSEDSLOT    0xffffffff     // Unsused slot marker

// Keyboard press; forward to accelerator target
long FXAccelTable::onKeyPress(FXObject* sender, FXSelector, void* ptr)
{
    register FXEvent* event = (FXEvent*)ptr;

    // !!! Hack here !!!
    //register FXuint code=MKUINT(event->code,event->state&(SHIFTMASK|CONTROLMASK|ALTMASK|METAMASK));
    register FXuint code;

    if (event->state&CAPSLOCKMASK && (event->code >= KEY_A) && (event->code <= KEY_Z))
    {
        code = MKUINT(event->code+32, event->state&(SHIFTMASK|CONTROLMASK|ALTMASK|METAMASK));
    }
    else
    {
        code = MKUINT(event->code, event->state&(SHIFTMASK|CONTROLMASK|ALTMASK|METAMASK));
    }
    // !!! End of hack !!!

    register FXuint p = (code*13)&max;
    register FXuint c;
    FXASSERT(code != UNUSEDSLOT);
    FXASSERT(code != EMPTYSLOT);
    while ((c = key[p].code) != code)
    {
        if (c == UNUSEDSLOT)
        {
            return(0);
        }
        p = (p+1)&max;
    }
    if (key[p].target && key[p].messagedn)
    {
        key[p].target->tryHandle(sender, key[p].messagedn, ptr);
    }
    return(1);
}


// Keyboard release; forward to accelerator target
long FXAccelTable::onKeyRelease(FXObject* sender, FXSelector, void* ptr)
{
    register FXEvent* event = (FXEvent*)ptr;

    // !!! Hack here !!!
    //register FXuint code=MKUINT(event->code,event->state&(SHIFTMASK|CONTROLMASK|ALTMASK|METAMASK));
    register FXuint code;

    if (event->state&CAPSLOCKMASK && (event->code >= KEY_A) && (event->code <= KEY_Z))
    {
        code = MKUINT(event->code+32, event->state&(SHIFTMASK|CONTROLMASK|ALTMASK|METAMASK));
    }
    else
    {
        code = MKUINT(event->code, event->state&(SHIFTMASK|CONTROLMASK|ALTMASK|METAMASK));
    }
    // !!! End of hack !!!

    register FXuint p = (code*13)&max;
    register FXuint c;
    FXASSERT(code != UNUSEDSLOT);
    FXASSERT(code != EMPTYSLOT);
    while ((c = key[p].code) != code)
    {
        if (c == UNUSEDSLOT)
        {
            return(0);
        }
        p = (p+1)&max;
    }
    if (key[p].target && key[p].messageup)
    {
        key[p].target->tryHandle(sender, key[p].messageup, ptr);
    }
    return(1);
}


//
// Hack of FXURL
//

// Backport from Fox 1.7.37 to fix a bug when filenames contain '%' characters

// Hexadecimal digit of value
const FXchar value2Digit[36] =
{
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B',
    'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
    'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
};

// Encode control characters and characters from set using %-encoding
FXString FXURL::encode(const FXString& url)
{
    FXString result;

    if (!url.empty())
    {
        register FXint p, q, c;
        for (p = q = 0; p < url.length(); ++p)
        {
            c = (FXuchar)url[p];
            if ((c < 0x20) || (c == '%'))
            {
                q += 3;
                continue;
            }
            q++;
        }
        result.length(q);
        for (p = q = 0; p < url.length(); ++p)
        {
            c = (FXuchar)url[p];
            if ((c < 0x20) || (c == '%'))
            {
                result[q++] = '%';
                result[q++] = value2Digit[c>>4];
                result[q++] = value2Digit[c&15];
                continue;
            }
            result[q++] = c;
        }
    }
    return(result);
}


// Decode string containing %-encoded characters
FXString FXURL::decode(const FXString& url)
{
    FXString result;

    if (!url.empty())
    {
        register FXint p, q, c;
        for (p = q = 0; p < url.length(); ++p)
        {
            c = (FXuchar)url[p];
            if ((c == '%') && Ascii::isHexDigit(url[p+1]) && Ascii::isHexDigit(url[p+2]))
            {
                p += 2;
            }
            q++;
        }
        result.length(q);
        for (p = q = 0; p < url.length(); ++p)
        {
            c = (FXuchar)url[p];
            if ((c == '%') && Ascii::isHexDigit(url[p+1]) && Ascii::isHexDigit(url[p+2]))
            {
                c = (Ascii::digitValue(url[p+1])<<4)+Ascii::digitValue(url[p+2]);
                p += 2;
            }
            result[q++] = c;
        }
    }
    return(result);
}


//
// Hack of FXSpinner
// This hack fixes an issue with the appearance of the spinner textfield
//


#define INTMAX    2147483647
#define INTMIN    (-INTMAX-1)

// Construct spinner out of two buttons and a text field
FXSpinner::FXSpinner(FXComposite* p, FXint cols, FXObject* tgt, FXSelector sel, FXuint opts, FXint x, FXint y, FXint w, FXint h, FXint pl, FXint pr, FXint pt, FXint pb) :
    FXPacker(p, opts, x, y, w, h, 0, 0, 0, 0, 0, 0)
{
    flags |= FLAG_ENABLED;
    target = tgt;
    message = sel;

    // !!! Hack here !!!
    //textField=new FXTextField(this,cols,this,ID_ENTRY,TEXTFIELD_INTEGER|JUSTIFY_RIGHT,0,0,0,0,pl,pr,pt,pb);
    textField = new FXTextField(this, cols, this, ID_ENTRY, TEXTFIELD_INTEGER|JUSTIFY_RIGHT|FRAME_THICK|FRAME_SUNKEN, 0, 0, 0, 0, pl, pr, pt, pb);
    // !!! End of hack !!!

    upButton = new FXArrowButton(this, this, FXSpinner::ID_INCREMENT, FRAME_RAISED|FRAME_THICK|ARROW_UP|ARROW_REPEAT, 0, 0, 0, 0, 0, 0, 0, 0);
    downButton = new FXArrowButton(this, this, FXSpinner::ID_DECREMENT, FRAME_RAISED|FRAME_THICK|ARROW_DOWN|ARROW_REPEAT, 0, 0, 0, 0, 0, 0, 0, 0);
    range[0] = (options&SPIN_NOMIN) ? INTMIN : 0;
    range[1] = (options&SPIN_NOMAX) ? INTMAX : 100;
    textField->setText("0");
    incr = 1;
    pos = 0;
}


//
// Hack of FXMenuCommand, FXPopup, FXMenuCascade, FXMenuBar, FXMenuSeparator
// These hacks replace the reverse arrow cursor (DEF_RARROW_CURSOR) with the normal one (DEF_ARROW_CURSOR)
// when pointing on menu items
//


// Command menu item
FXMenuCommand::FXMenuCommand(FXComposite* p, const FXString& text, FXIcon* ic, FXObject* tgt, FXSelector sel, FXuint opts) :
    FXMenuCaption(p, text, ic, opts)
{
    FXAccelTable* table;
    FXWindow*     own;

    flags |= FLAG_ENABLED;
    defaultCursor = getApp()->getDefaultCursor(DEF_ARROW_CURSOR);
    target = tgt;
    message = sel;
    accel = text.section('\t', 1);
    acckey = parseAccel(accel);
    if (acckey)
    {
        own = getShell()->getOwner();
        if (own)
        {
            table = own->getAccelTable();
            if (table)
            {
                table->addAccel(acckey, this, FXSEL(SEL_COMMAND, ID_ACCEL));
            }
        }
    }
}


// Transient window used for popups
FXPopup::FXPopup(FXWindow* owner, FXuint opts, FXint x, FXint y, FXint w, FXint h) :
    FXShell(owner, opts, x, y, w, h), prevActive(NULL), nextActive(NULL)
{
    defaultCursor = getApp()->getDefaultCursor(DEF_ARROW_CURSOR);
    dragCursor = getApp()->getDefaultCursor(DEF_ARROW_CURSOR);
    flags |= FLAG_ENABLED;
    grabowner = NULL;
    baseColor = getApp()->getBaseColor();
    hiliteColor = getApp()->getHiliteColor();
    shadowColor = getApp()->getShadowColor();
    borderColor = getApp()->getBorderColor();
    border = (options&FRAME_THICK) ? 2 : (options&(FRAME_SUNKEN|FRAME_RAISED)) ? 1 : 0;
}


// Make cascade menu button
FXMenuCascade::FXMenuCascade(FXComposite* p, const FXString& text, FXIcon* ic, FXPopup* pup, FXuint opts) :
    FXMenuCaption(p, text, ic, opts)
{
    defaultCursor = getApp()->getDefaultCursor(DEF_ARROW_CURSOR);
    flags |= FLAG_ENABLED;
    pane = pup;
}


// Make a non-floatable menubar
FXMenuBar::FXMenuBar(FXComposite* p, FXuint opts, FXint x, FXint y, FXint w, FXint h, FXint pl, FXint pr, FXint pt, FXint pb, FXint hs, FXint vs) :
    FXToolBar(p, opts, x, y, w, h, pl, pr, pt, pb, hs, vs)
{
    flags |= FLAG_ENABLED;
    dragCursor = getApp()->getDefaultCursor(DEF_ARROW_CURSOR);
}


// Separator item
FXMenuSeparator::FXMenuSeparator(FXComposite* p, FXuint opts) :
    FXWindow(p, opts, 0, 0, 0, 0)
{
    flags |= FLAG_SHOWN;
    defaultCursor = getApp()->getDefaultCursor(DEF_ARROW_CURSOR);
    hiliteColor = getApp()->getHiliteColor();
    shadowColor = getApp()->getShadowColor();
}


//
// Hack of FxString
// This hack allocates a much longer string
// This is used in the SearchPanel when the path length is huge
//

// Print formatted string a-la vprintf
FXString& FXString::vformat(const FXchar* fmt, va_list args)
{
    register FXint len = 0;

    if (fmt && *fmt)
    {
        register FXint n = strlen(fmt);       // Result is longer than format string

        // !!! Hack here !!!
        //n+=1024;
        n += 8192;                            // Add a lot of slop
        // !!! End of hack

        length(n);
        len = vsprintf(str, fmt, args);

        FXASSERT(0 <= len && len <= n);
    }
    length(len);
    return(*this);
}



//
// Hack of FXIcon
// This hack fixes a Valgrind complaint about uninitialized values
// when allocating an icon
//


#define DARKCOLOR(r,g,b) (((r)+(g)+(b))<thresh)

// Determine threshold for etch mask
static FXshort guessthresh(const FXColor *data,FXint width,FXint height)
{
    register FXint med=(width*height)>>1;
    register FXint cum,i,j;
    register FXshort guess;
    FXint frequency[766];
    memset(frequency,0,sizeof(frequency));
    for(i=0; i<width*height; ++i)
    {
        frequency[((const FXuchar*)(data+i))[0]+((const FXuchar*)(data+i))[1]+((const FXuchar*)(data+i))[2]]++;
    }
    for(i=0,cum=0; i<766; ++i)
    {
        if((cum+=frequency[i])>=med) break;
    }
    for(j=765,cum=0; j>0; --j)
    {
        if((cum+=frequency[j])>=med) break;
    }
    guess=((i+j+1)>>1)+1; // Fanglin Zhu: raise threshold by one in case of single-color image
    return guess;
}

// Render icon X Windows
void FXIcon::render()
{
    if(xid)
    {
        register Visual *vis;
        register XImage *xim=NULL;
        register FXColor *img;
        register FXint x,y;
        register FXshort thresh; // Local variable in 1.6
        XGCValues values;
        GC gc;

        // Render the image pixels
        FXImage::render();

        // Fill with pixels if there is data
        if(data && 0<width && 0<height)
        {
            // Guess threshold
            thresh=guessthresh(data,width,height);

            // Get Visual
            vis=(Visual*)visual->visual;

            // Try create image
            xim=XCreateImage(DISPLAY(getApp()),vis,1,ZPixmap,0,NULL,width,height,32,0);
            if(!xim) fxerror("%s::render: unable to render icon.\n",getClassName());

            // Try create temp pixel store
            
            // !!! Hack here => replace FXMALLOC with FXCALLOC !!!
            if(!FXCALLOC(&xim->data,char,xim->bytes_per_line*height)){ fxerror("%s::render: unable to allocate memory.\n",getClassName()); }
            // !!! End of hack !!!

            // Make GC
            values.foreground=0xffffffff;
            values.background=0xffffffff;
            gc=XCreateGC(DISPLAY(getApp()),shape,GCForeground|GCBackground,&values);

            // Should have succeeded
            FXASSERT(xim);

            // Fill shape mask
            if(options&IMAGE_OPAQUE)                                  // Opaque image
            {
                FXTRACE((150,"Shape rectangle\n"));
                memset(xim->data,0xff,xim->bytes_per_line*height);
            }
            else if(options&(IMAGE_ALPHACOLOR|IMAGE_ALPHAGUESS))      // Transparent color
            {
                FXTRACE((150,"Shape from alpha-color\n"));
                img=data;
                for(y=0; y<height; y++)
                {
                    for(x=0; x<width; x++)
                    {
                        XPutPixel(xim,x,y,(img[x]!=transp));
                    }
                    img+=width;
                }
            }
            else                                                      // Transparency channel
            {
                FXTRACE((150,"Shape from alpha-channel\n"));
                img=data;
                for(y=0; y<height; y++)
                {
                    for(x=0; x<width; x++)
                    {
                        XPutPixel(xim,x,y,(((FXuchar*)(img+x))[3]!=0));
                    }
                    img+=width;
                }
            }

            XPutImage(DISPLAY(getApp()),shape,gc,xim,0,0,0,0,width,height);

            // Fill etch image
            if(options&IMAGE_OPAQUE)                                  // Opaque image
            {
                img=data;
                for(y=0; y<height; y++)
                {
                    for(x=0; x<width; x++)
                    {
                        XPutPixel(xim,x,y,DARKCOLOR(((FXuchar*)(img+x))[0],((FXuchar*)(img+x))[1],((FXuchar*)(img+x))[2]));
                    }
                    img+=width;
                }
            }
            else if(options&(IMAGE_ALPHACOLOR|IMAGE_ALPHAGUESS))      // Transparent color
            {
                img=data;
                for(y=0; y<height; y++)
                {
                    for(x=0; x<width; x++)
                    {
                        XPutPixel(xim,x,y,(img[x]!=transp) && DARKCOLOR(((FXuchar*)(img+x))[0],((FXuchar*)(img+x))[1],((FXuchar*)(img+x))[2]));
                    }
                    img+=width;
                }
            }
            else                                                      // Transparency channel
            {
                img=data;
                for(y=0; y<height; y++)
                {
                    for(x=0; x<width; x++)
                    {
                        XPutPixel(xim,x,y,(((FXuchar*)(img+x))[3]!=0) && DARKCOLOR(((FXuchar*)(img+x))[0],((FXuchar*)(img+x))[1],((FXuchar*)(img+x))[2]));
                    }
                    img+=width;
                }
            }

            // Transfer image
            XPutImage(DISPLAY(getApp()),etch,gc,xim,0,0,0,0,width,height);

            // Clean up
            FXFREE(&xim->data);
            XDestroyImage(xim);
            XFreeGC(DISPLAY(getApp()),gc);
        }
    }
}
// Global icons for all applications

#include <iostream>
#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "xfeutils.h"
#include "icons.h"


// Icons (global variables)

FXIcon *archaddicon, *archexticon, *attribicon, *bigattribicon, *bigblockdevicon, *bigbrokenlinkicon, *bigcdromicon, *bigchardevicon;
FXIcon *bigcompareicon, *bigdocicon, *bigexecicon, *bigfileopenicon, *bigfiltericon, *bigfloppyicon, *bigfolderlockedicon;
FXIcon *bigfolderopenicon, *bigfoldericon, *bigfolderupicon, *bigharddiskicon, *bigiconsicon, *biglinkicon, *bignewfileicon;
FXIcon *bignewfoldericon, *bignewlinkicon, *bignfsdriveicon;
FXIcon *bignfsdriveumticon, *bigpipeicon, *bigsocketicon, *bigzipicon, *cdromicon, *charticon;
FXIcon *closefileicon, *clrbookicon, *collfoldericon, *copy_bigicon, *colltreeicon;
FXIcon *copy_clpicon, *cut_clpicon, *delete_big_permicon, *delete_bigicon, *deselicon, *detailsicon;
FXIcon *dirupicon, *editicon, *entericon, *errorbigicon, *exptreeicon, *compareicon;
FXIcon *filedelete_permicon, *filedeleteicon, *fileopenicon;
FXIcon *viewicon, *filtericon, *find_againicon, *fliplricon, *flipudicon, *floppyicon;
FXIcon *fontsicon, *gotobigicon, *gotodiricon, *gotolineicon, *harddiskicon, *helpicon, *hidehiddenicon;
FXIcon *hidenumbersicon, *hidethumbicon, *homeicon, *infobigicon, *invselicon, *link_bigicon;
FXIcon *locationicon, *lowercaseicon, *maphosticon, *miniappicon, *miniblockdevicon, *minibrokenlinkicon;
FXIcon *minichardevicon, *minidocicon, *miniexecicon, *minifolderclosedicon;
FXIcon *minifolderlockedicon, *minifolderopenicon, *minifoldericon, *minifolderupicon, *minilinkicon;
FXIcon *minipipeicon, *minishellicon, *minisocketicon;
FXIcon *move_bigicon, *moveiticon, *newfileicon, *newfoldericon, *nfsdriveicon, *nfsdriveumticon;
FXIcon *onepanelicon, *packageicon, *paste_clpicon, *prefsicon, *printbigicon, *printicon;
FXIcon *questionbigicon, *quiticon, *redoicon, *reloadicon, *renameiticon, *replaceicon;
FXIcon *reverticon, *rotatelefticon, *rotaterighticon, *runicon, *saveasicon, *savefileicon;
FXIcon *searchnexticon, *searchicon, *searchprevicon, *selallicon, *setbookicon, *shellicon;
FXIcon *showhiddenicon, *shownumbersicon, *showthumbicon, *smalliconsicon, *iconsmenuicon;
FXIcon *trash_full_bigicon, *trash_fullicon, *treeonepanelicon, *treetwopanelsicon, *twopanelsicon;
FXIcon *undoicon, *unmaphosticon, *uppercaseicon, *warningbigicon, *workicon, *wrapofficon, *wraponicon, *xfeicon, *realxfeicon, *xfiicon;
FXIcon *xfpicon, *xfwicon, *zipicon, *zoom100icon, *zoominicon, *zoomouticon, *zoomwinicon;
FXIcon *totrashicon, *dirbackicon, *dirforwardicon, *minixfeicon, *minixferooticon, *filedialogicon, *bigarchaddicon;
FXIcon *switchpanelsicon, *syncpanelsicon, *newlinkicon, *greenbuttonicon, *graybuttonicon, *closeicon, *throbicon, *throbanimicon, *webviewbgicon;
FXIcon *keybindingsicon, *minikeybindingsicon, *filerestoreicon, *restore_bigicon, *vertpanelsicon, *horzpanelsicon, *comboarrowicon;

FXIcon *tbarchaddicon, *tbarchexticon, *tbattribicon/*, *tbbigattribicon, *tbbigblockdevicon, *tbbigbrokenlinkicon, *tbbigcdromicon, *tbbigchardevicon */;
//FXIcon *tbbigcompareicon, *tbbigdocicon, *tbbigexecicon, *tbbigfileopenicon, *tbbigfiltericon, *tbbigfloppyicon, *tbbigfolderlockedicon;
FXIcon /**tbbigfolderopenicon, *tbbigfoldericon, *tbbigfolderupicon, *tbbigharddiskicon, */*tbbigiconsicon/*, *tbbiglinkicon, *tbbignewfileicon*/;
//FXIcon *tbbignewfoldericon, *tbbignewlinkicon, *tbbignfsdriveicon;
FXIcon /* *tbbignfsdriveumticon, *tbbigpipeicon, *tbbigsocketicon, *tbbigzipicon, */ *tbcdromicon, *tbcharticon, *webviewxp;
FXIcon *tbclosefileicon, *tbclrbookicon, *tbcollfoldericon, *tbcopy_bigicon, *tbcolltreeicon;
FXIcon *tbcopy_clpicon, *tbcut_clpicon, *tbdelete_big_permicon, *tbdelete_bigicon, *tbdeselicon, *tbdetailsicon;
FXIcon *tbdirupicon, *tbediticon, *tbentericon, *tberrorbigicon, *tbexptreeicon, *tbcompareicon;
FXIcon *tbfiledelete_permicon, *tbfiledeleteicon, *tbfileopenicon;
FXIcon *tbviewicon, *tbfiltericon, *tbfind_againicon, *tbfliplricon, *tbflipudicon, *tbfloppyicon;
FXIcon *tbfontsicon, *tbgotobigicon, *tbgotodiricon, *tbgotolineicon, *tbharddiskicon, *tbhelpicon, *tbhidehiddenicon;
FXIcon *tbhidenumbersicon, *tbhidethumbicon, *tbhomeicon, *tbinfobigicon, *tbinvselicon, *tblink_bigicon;
FXIcon *tblocationicon, *tblowercaseicon, *tbmaphosticon, *tbminiappicon, *tbminiblockdevicon, *tbminibrokenlinkicon;
FXIcon *tbminichardevicon, *tbminidocicon, *tbminiexecicon, *tbminifolderclosedicon;
FXIcon *tbminifolderlockedicon, *tbminifolderopenicon, *tbminifoldericon, *tbminifolderupicon, *tbminilinkicon;
FXIcon *tbminipipeicon, *tbminishellicon, *tbminisocketicon;
FXIcon *tbmove_bigicon, *tbmoveiticon, *tbnewfileicon, *tbnewfoldericon, *tbnfsdriveicon, *tbnfsdriveumticon;
FXIcon *tbonepanelicon, *tbpackageicon, *tbpaste_clpicon, *tbprefsicon, *tbprintbigicon, *tbprinticon;
FXIcon *tbquestionbigicon, *tbquiticon, *tbredoicon, *tbreloadicon, *tbrenameiticon, *tbreplaceicon;
FXIcon *tbreverticon, *tbrotatelefticon, *tbrotaterighticon, *tbrunicon, *tbsaveasicon, *tbsavefileicon;
FXIcon *tbsearchnexticon, *tbsearchicon, *tbsearchprevicon, *tbselallicon, *tbsetbookicon, *tbshellicon;
FXIcon *tbshowhiddenicon, *tbshownumbersicon, *tbshowthumbicon, *tbsmalliconsicon, *tbiconsmenuicon;
FXIcon *tbtrash_full_bigicon, *tbtrash_fullicon, *tbtreeonepanelicon, *tbtreetwopanelsicon, *tbtwopanelsicon;
FXIcon *tbundoicon, *tbunmaphosticon, *tbuppercaseicon, *tbwarningbigicon, *tbworkicon, *tbwrapofficon, *tbwraponicon, *tbxfeicon, *tbxfiicon;
FXIcon *tbxfpicon, *tbxfwicon, *tbzipicon, *tbzoom100icon, *tbzoominicon, *tbzoomouticon, *tbzoomwinicon;
FXIcon *tbtotrashicon, *tbdirbackicon, *tbdirforwardicon, *tbminixfeicon, *tbminixferooticon, *tbfiledialogicon/*, *tbbigarchaddicon*/;
FXIcon *tbswitchpanelsicon, *tbsyncpanelsicon, *tbnewlinkicon, *tbgreenbuttonicon, *tbgraybuttonicon, *tbcloseicon, *tbthrobicon, *tbthrobanimicon, *tbwebviewbgicon;
FXIcon *tbkeybindingsicon, *tbminikeybindingsicon, *tbfilerestoreicon, *tbrestore_bigicon, *tbvertpanelsicon, *tbhorzpanelsicon, *tbcomboarrowicon, *tbcomputericon;
FXIcon *resizecorner;


// Load all application icons as global variables
FXbool loadAppIcons(FXApp* app)
{
    FXbool success = true;
    FXColor iconhilitecolor = app->getHiliteColor();
    FXColor iconshadowcolor = app->getShadowColor();
    FXColor iconforecolor = app->getForeColor();
    // FXColor iconforecolor = app->getForeColor();
    FXColor backcolor = app->getBackColor();
    FXColor basecolor = app->getBaseColor();

    // Icon path
    FXString iconpath = app->reg().readStringEntry("SETTINGS", "iconpath", DEFAULTICONPATH);

    // Load icons and set the success flag
    success = ((archaddicon = loadiconfile(app, iconpath, "archadd.png", backcolor)) != NULL) & success;
    success = ((archexticon = loadiconfile(app, iconpath, "archext.png", backcolor)) != NULL) & success;
    success = ((attribicon = loadiconfile(app, iconpath, "attrib.png", backcolor)) != NULL) & success;
    success = ((bigattribicon = loadiconfile(app, iconpath, "bigattrib.png", backcolor)) != NULL) & success;
    success = ((bigblockdevicon = loadiconfile(app, iconpath, "bigblockdev.png", backcolor)) != NULL) & success;
    success = ((bigbrokenlinkicon = loadiconfile(app, iconpath, "bigbrokenlink.png", backcolor)) != NULL) & success;
    success = ((bigcdromicon = loadiconfile(app, iconpath, "bigcdrom.png", backcolor)) != NULL) & success;
    success = ((bigchardevicon = loadiconfile(app, iconpath, "bigchardev.png", backcolor)) != NULL) & success;
    success = ((bigcompareicon = loadiconfile(app, iconpath, "bigcompare.png", backcolor)) != NULL) & success;
    success = ((bigdocicon = loadiconfile(app, iconpath, "bigdoc.png", backcolor)) != NULL) & success;
    success = ((bigexecicon = loadiconfile(app, iconpath, "bigexec.png", backcolor)) != NULL) & success;
    success = ((bigfileopenicon = loadiconfile(app, iconpath, "bigfileopen.png", backcolor)) != NULL) & success;
    success = ((bigfiltericon = loadiconfile(app, iconpath, "bigfilter.png", backcolor)) != NULL) & success;
    success = ((bigfloppyicon = loadiconfile(app, iconpath, "bigfloppy.png", backcolor)) != NULL) & success;
    success = ((bigfolderlockedicon = loadiconfile(app, iconpath, "bigfolderlocked.png", backcolor)) != NULL) & success;
    success = ((bigfolderopenicon = loadiconfile(app, iconpath, "bigfolderopen.png", backcolor)) != NULL) & success;
    success = ((bigfoldericon = loadiconfile(app, iconpath, "bigfolder.png", backcolor)) != NULL) & success;
    success = ((bigfolderupicon = loadiconfile(app, iconpath, "bigfolderup.png", backcolor)) != NULL) & success;
    success = ((bigharddiskicon = loadiconfile(app, iconpath, "bigharddisk.png", backcolor)) != NULL) & success;
    success = ((bigiconsicon = loadiconfile(app, iconpath, "bigicons.png", backcolor)) != NULL) & success;
    success = ((biglinkicon = loadiconfile(app, iconpath, "biglink.png", backcolor)) != NULL) & success;
    success = ((bignewfileicon = loadiconfile(app, iconpath, "bignewfile.png", backcolor)) != NULL) & success;
    success = ((bignewfoldericon = loadiconfile(app, iconpath, "bignewfolder.png", backcolor)) != NULL) & success;
    success = ((bignewlinkicon = loadiconfile(app, iconpath, "bignewlink.png", backcolor)) != NULL) & success;
    success = ((bignfsdriveicon = loadiconfile(app, iconpath, "bignfsdrive.png", backcolor)) != NULL) & success;
    success = ((bignfsdriveumticon = loadiconfile(app, iconpath, "bignfsdriveumt.png", backcolor)) != NULL) & success;
    success = ((bigpipeicon = loadiconfile(app, iconpath, "bigpipe.png", backcolor)) != NULL) & success;
    success = ((bigsocketicon = loadiconfile(app, iconpath, "bigsocket.png", backcolor)) != NULL) & success;
    success = ((bigzipicon = loadiconfile(app, iconpath, "bigzip.png", backcolor)) != NULL) & success;
    success = ((cdromicon = loadiconfile(app, iconpath, "cdrom.png", backcolor)) != NULL) & success;
    success = ((charticon = loadiconfile(app, iconpath, "chart.png", backcolor)) != NULL) & success;
    success = ((closefileicon = loadiconfile(app, iconpath, "closefile.png", backcolor)) != NULL) & success;
    success = ((clrbookicon = loadiconfile(app, iconpath, "clrbook.png", backcolor)) != NULL) & success;
    success = ((colltreeicon = loadiconfile(app, iconpath, "colltree.png", backcolor)) != NULL) & success;
    success = ((copy_bigicon = loadiconfile(app, iconpath, "copy_big.png", backcolor)) != NULL) & success;
    success = ((copy_clpicon = loadiconfile(app, iconpath, "copy_clp.png", backcolor)) != NULL) & success;
    success = ((cut_clpicon = loadiconfile(app, iconpath, "cut_clp.png", backcolor)) != NULL) & success;
    success = ((delete_big_permicon = loadiconfile(app, iconpath, "delete_big_perm.png", backcolor)) != NULL) & success;
    success = ((delete_bigicon = loadiconfile(app, iconpath, "delete_big.png", backcolor)) != NULL) & success;
    success = ((deselicon = loadiconfile(app, iconpath, "desel.png", backcolor)) != NULL) & success;
    success = ((detailsicon = loadiconfile(app, iconpath, "details.png", backcolor)) != NULL) & success;
    success = ((dirupicon = loadiconfile(app, iconpath, "dirup.png", backcolor)) != NULL) & success;
    success = ((editicon = loadiconfile(app, iconpath, "edit.png", backcolor)) != NULL) & success;
    success = ((entericon = loadiconfile(app, iconpath, "enter.png", backcolor)) != NULL) & success;
    success = ((errorbigicon = loadiconfile(app, iconpath, "errorbig.png", backcolor)) != NULL) & success;
    success = ((exptreeicon = loadiconfile(app, iconpath, "exptree.png", backcolor)) != NULL) & success;
    success = ((compareicon = loadiconfile(app, iconpath, "compare.png", backcolor)) != NULL) & success;
    success = ((filedelete_permicon = loadiconfile(app, iconpath, "filedelete_perm.png", backcolor)) != NULL) & success;
    success = ((filedeleteicon = loadiconfile(app, iconpath, "filedelete.png", backcolor)) != NULL) & success;
    success = ((fileopenicon = loadiconfile(app, iconpath, "fileopen.png", backcolor)) != NULL) & success;
    success = ((viewicon = loadiconfile(app, iconpath, "view.png", backcolor)) != NULL) & success;
    success = ((filtericon = loadiconfile(app, iconpath, "filter.png", backcolor)) != NULL) & success;
    success = ((find_againicon = loadiconfile(app, iconpath, "find_again.png", backcolor)) != NULL) & success;
    success = ((fliplricon = loadiconfile(app, iconpath, "fliplr.png", backcolor)) != NULL) & success;
    success = ((flipudicon = loadiconfile(app, iconpath, "flipud.png", backcolor)) != NULL) & success;
    success = ((floppyicon = loadiconfile(app, iconpath, "floppy.png", backcolor)) != NULL) & success;
    success = ((fontsicon = loadiconfile(app, iconpath, "fonts.png", backcolor)) != NULL) & success;
    success = ((gotobigicon = loadiconfile(app, iconpath, "gotobig.png", backcolor)) != NULL) & success;
    success = ((gotodiricon = loadiconfile(app, iconpath, "gotodir.png", backcolor)) != NULL) & success;
    success = ((gotolineicon = loadiconfile(app, iconpath, "gotoline.png", backcolor)) != NULL) & success;
    success = ((harddiskicon = loadiconfile(app, iconpath, "harddisk.png", backcolor)) != NULL) & success;
    success = ((helpicon = loadiconfile(app, iconpath, "help.png", backcolor)) != NULL) & success;
    success = ((hidehiddenicon = loadiconfile(app, iconpath, "hidehidden.png", backcolor)) != NULL) & success;
    success = ((hidenumbersicon = loadiconfile(app, iconpath, "hidenumbers.png", backcolor)) != NULL) & success;
    success = ((hidethumbicon = loadiconfile(app, iconpath, "hidethumb.png", backcolor)) != NULL) & success;
    success = ((homeicon = loadiconfile(app, iconpath, "home.png", backcolor)) != NULL) & success;
    success = ((infobigicon = loadiconfile(app, iconpath, "infobig.png", backcolor)) != NULL) & success;
    success = ((invselicon = loadiconfile(app, iconpath, "invsel.png", backcolor)) != NULL) & success;
    success = ((link_bigicon = loadiconfile(app, iconpath, "link_big.png", backcolor)) != NULL) & success;
    success = ((locationicon = loadiconfile(app, iconpath, "location.png", backcolor)) != NULL) & success;
    success = ((lowercaseicon = loadiconfile(app, iconpath, "lowercase.png", backcolor)) != NULL) & success;
    success = ((maphosticon = loadiconfile(app, iconpath, "maphost.png", backcolor)) != NULL) & success;
    success = ((miniappicon = loadiconfile(app, iconpath, "miniapp.png", backcolor)) != NULL) & success;
    success = ((miniblockdevicon = loadiconfile(app, iconpath, "miniblockdev.png", backcolor)) != NULL) & success;
    success = ((minibrokenlinkicon = loadiconfile(app, iconpath, "minibrokenlink.png", backcolor)) != NULL) & success;
    success = ((minichardevicon = loadiconfile(app, iconpath, "minichardev.png", backcolor)) != NULL) & success;
    success = ((minidocicon = loadiconfile(app, iconpath, "minidoc.png", backcolor)) != NULL) & success;
    success = ((miniexecicon = loadiconfile(app, iconpath, "miniexec.png", backcolor)) != NULL) & success;
    success = ((minifolderclosedicon = loadiconfile(app, iconpath, "minifolderclosed.png", backcolor)) != NULL) & success;
    success = ((minifolderlockedicon = loadiconfile(app, iconpath, "minifolderlocked.png", backcolor)) != NULL) & success;
    success = ((minifolderopenicon = loadiconfile(app, iconpath, "minifolderopen.png", backcolor)) != NULL) & success;
    success = ((minifoldericon = loadiconfile(app, iconpath, "minifolder.png", backcolor)) != NULL) & success;
    success = ((minifolderupicon = loadiconfile(app, iconpath, "minifolderup.png", backcolor)) != NULL) & success;
    success = ((minilinkicon = loadiconfile(app, iconpath, "minilink.png", backcolor)) != NULL) & success;
    success = ((minipipeicon = loadiconfile(app, iconpath, "minipipe.png", backcolor)) != NULL) & success;
    success = ((minishellicon = loadiconfile(app, iconpath, "minishell.png", backcolor)) != NULL) & success;
    success = ((minisocketicon = loadiconfile(app, iconpath, "minisocket.png", backcolor)) != NULL) & success;
    success = ((move_bigicon = loadiconfile(app, iconpath, "move_big.png", backcolor)) != NULL) & success;
    success = ((moveiticon = loadiconfile(app, iconpath, "moveit.png", backcolor)) != NULL) & success;
    success = ((newfileicon = loadiconfile(app, iconpath, "newfile.png", backcolor)) != NULL) & success;
    success = ((newfoldericon = loadiconfile(app, iconpath, "newfolder.png", backcolor)) != NULL) & success;
    success = ((nfsdriveicon = loadiconfile(app, iconpath, "nfsdrive.png", backcolor)) != NULL) & success;
    success = ((nfsdriveumticon = loadiconfile(app, iconpath, "nfsdriveumt.png", backcolor)) != NULL) & success;
    success = ((onepanelicon = loadiconfile(app, iconpath, "onepanel.png", backcolor)) != NULL) & success;
    success = ((packageicon = loadiconfile(app, iconpath, "package.png", backcolor)) != NULL) & success;
    success = ((paste_clpicon = loadiconfile(app, iconpath, "paste_clp.png", backcolor)) != NULL) & success;
    success = ((prefsicon = loadiconfile(app, iconpath, "prefs.png", backcolor)) != NULL) & success;
    success = ((printbigicon = loadiconfile(app, iconpath, "printbig.png", backcolor)) != NULL) & success;
    success = ((printicon = loadiconfile(app, iconpath, "print.png", backcolor)) != NULL) & success;
    success = ((questionbigicon = loadiconfile(app, iconpath, "questionbig.png", backcolor)) != NULL) & success;
    success = ((quiticon = loadiconfile(app, iconpath, "quit.png", backcolor)) != NULL) & success;
    success = ((redoicon = loadiconfile(app, iconpath, "redo.png", backcolor)) != NULL) & success;
    success = ((reloadicon = loadiconfile(app, iconpath, "reload.png", backcolor)) != NULL) & success;
    success = ((renameiticon = loadiconfile(app, iconpath, "renameit.png", backcolor)) != NULL) & success;
    success = ((replaceicon = loadiconfile(app, iconpath, "replace.png", backcolor)) != NULL) & success;
    success = ((reverticon = loadiconfile(app, iconpath, "revert.png", backcolor)) != NULL) & success;
    success = ((rotatelefticon = loadiconfile(app, iconpath, "rotateleft.png", backcolor)) != NULL) & success;
    success = ((rotaterighticon = loadiconfile(app, iconpath, "rotateright.png", backcolor)) != NULL) & success;
    success = ((runicon = loadiconfile(app, iconpath, "run.png", backcolor)) != NULL) & success;
    success = ((saveasicon = loadiconfile(app, iconpath, "saveas.png", backcolor)) != NULL) & success;
    success = ((savefileicon = loadiconfile(app, iconpath, "savefile.png", backcolor)) != NULL) & success;
    success = ((searchnexticon = loadiconfile(app, iconpath, "searchnext.png", backcolor)) != NULL) & success;
    success = ((searchicon = loadiconfile(app, iconpath, "search.png", backcolor)) != NULL) & success;
    success = ((searchprevicon = loadiconfile(app, iconpath, "searchprev.png", backcolor)) != NULL) & success;
    success = ((selallicon = loadiconfile(app, iconpath, "selall.png", backcolor)) != NULL) & success;
    success = ((setbookicon = loadiconfile(app, iconpath, "setbook.png", backcolor)) != NULL) & success;
    success = ((shellicon = loadiconfile(app, iconpath, "shell.png", backcolor)) != NULL) & success;
    success = ((showhiddenicon = loadiconfile(app, iconpath, "showhidden.png", backcolor)) != NULL) & success;
    success = ((shownumbersicon = loadiconfile(app, iconpath, "shownumbers.png", backcolor)) != NULL) & success;
    success = ((showthumbicon = loadiconfile(app, iconpath, "showthumb.png", backcolor)) != NULL) & success;
    success = ((smalliconsicon = loadiconfile(app, iconpath, "smallicons.png", backcolor)) != NULL) & success;
    success = ((iconsmenuicon = loadiconfile(app, iconpath, "iconsmenu.png", backcolor, 1)) != NULL) & success;
    success = ((trash_full_bigicon = loadiconfile(app, iconpath, "trash_full_big.png", backcolor)) != NULL) & success;
    success = ((trash_fullicon = loadiconfile(app, iconpath, "trash_full.png", backcolor)) != NULL) & success;
    success = ((treeonepanelicon = loadiconfile(app, iconpath, "treeonepanel.png", backcolor)) != NULL) & success;
    success = ((treetwopanelsicon = loadiconfile(app, iconpath, "treetwopanels.png", backcolor)) != NULL) & success;
    success = ((twopanelsicon = loadiconfile(app, iconpath, "twopanels.png", backcolor)) != NULL) & success;
    success = ((undoicon = loadiconfile(app, iconpath, "undo.png", backcolor)) != NULL) & success;
    success = ((unmaphosticon = loadiconfile(app, iconpath, "unmaphost.png", backcolor)) != NULL) & success;
    success = ((uppercaseicon = loadiconfile(app, iconpath, "uppercase.png", backcolor)) != NULL) & success;
    success = ((warningbigicon = loadiconfile(app, iconpath, "warningbig.png", backcolor)) != NULL) & success;
    success = ((workicon = loadiconfile(app, iconpath, "work.png", backcolor)) != NULL) & success;
    success = ((wrapofficon = loadiconfile(app, iconpath, "wrapoff.png", backcolor)) != NULL) & success;
    success = ((wraponicon = loadiconfile(app, iconpath, "wrapon.png", backcolor)) != NULL) & success;
    success = ((xfeicon = loadiconfile(app, iconpath, "xfe.png", backcolor)) != NULL) & success;
    success = ((realxfeicon = loadiconfile(app, iconpath, "xfe.png", 0)) != NULL) & success;
    success = ((xfiicon = loadiconfile(app, iconpath, "xfi.png", backcolor)) != NULL) & success;
    success = ((xfpicon = loadiconfile(app, iconpath, "xfp.png", backcolor)) != NULL) & success;
    success = ((xfwicon = loadiconfile(app, iconpath, "xfw.png", backcolor)) != NULL) & success;
    success = ((zipicon = loadiconfile(app, iconpath, "zip.png", backcolor)) != NULL) & success;
    success = ((zoom100icon = loadiconfile(app, iconpath, "zoom100.png", backcolor)) != NULL) & success;
    success = ((zoominicon = loadiconfile(app, iconpath, "zoomin.png", backcolor)) != NULL) & success;
    success = ((zoomouticon = loadiconfile(app, iconpath, "zoomout.png", backcolor)) != NULL) & success;
    success = ((zoomwinicon = loadiconfile(app, iconpath, "zoomwin.png", backcolor)) != NULL) & success;
    success = ((totrashicon = loadiconfile(app, iconpath, "totrash.png", backcolor)) != NULL) & success;
    success = ((dirbackicon = loadiconfile(app, iconpath, "dirback.png", backcolor)) != NULL) & success;
    success = ((dirforwardicon = loadiconfile(app, iconpath, "dirforward.png", backcolor)) != NULL) & success;
    success = ((minixferooticon = loadiconfile(app, iconpath, "minixferoot.png", backcolor)) != NULL) & success;
    success = ((minixfeicon = loadiconfile(app, iconpath, "minixfe.png", backcolor)) != NULL) & success;
    success = ((filedialogicon = loadiconfile(app, iconpath, "filedialog.png", backcolor)) != NULL) & success;
    success = ((bigarchaddicon = loadiconfile(app, iconpath, "bigarchadd.png", backcolor)) != NULL) & success;
    success = ((switchpanelsicon = loadiconfile(app, iconpath, "switchpanels.png", backcolor)) != NULL) & success;
    success = ((syncpanelsicon = loadiconfile(app, iconpath, "syncpanels.png", backcolor)) != NULL) & success;
    success = ((newlinkicon = loadiconfile(app, iconpath, "newlink.png", backcolor)) != NULL) & success;
    success = ((greenbuttonicon = loadiconfile(app, iconpath, "greenbutton.png", backcolor)) != NULL) & success;
    success = ((graybuttonicon = loadiconfile(app, iconpath, "graybutton.png", backcolor)) != NULL) & success;
    success = ((keybindingsicon = loadiconfile(app, iconpath, "keybindings.png", backcolor)) != NULL) & success;
    success = ((minikeybindingsicon = loadiconfile(app, iconpath, "minikeybindings.png", backcolor)) != NULL) & success;
    success = ((filerestoreicon = loadiconfile(app, iconpath, "filerestore.png", backcolor)) != NULL) & success;
    success = ((restore_bigicon = loadiconfile(app, iconpath, "restore_big.png", backcolor)) != NULL) & success;
    success = ((horzpanelsicon = loadiconfile(app, iconpath, "horzpanels.png", backcolor)) != NULL) & success;
    success = ((vertpanelsicon = loadiconfile(app, iconpath, "vertpanels.png", backcolor)) != NULL) & success;
    // success = ((comboarrowicon = loadiconfile(app, iconpath, "comboarrow.png", backcolor)) != NULL) & success;
    // success = ((closeicon = loadiconfile(app, iconpath, "close.png", backcolor)) != NULL) & success;
    success = ((throbicon = loadiconfile(app, iconpath, "throb.png", backcolor)) != NULL) & success;
    success = ((throbanimicon = loadiconfile(app, iconpath, "throbanim.png", backcolor)) != NULL) & success;
    success = ((webviewbgicon = loadiconfile(app, iconpath, "webviewbg.png", backcolor)) != NULL) ; success;

    success = ((tbarchaddicon = loadiconfile(app, iconpath, "archadd.png", basecolor)) != NULL) & success;
    success = ((tbarchexticon = loadiconfile(app, iconpath, "archext.png", basecolor)) != NULL) & success;
    success = ((tbattribicon = loadiconfile(app, iconpath, "attrib.png", basecolor)) != NULL) & success;
 /* success = ((tbbigattribicon = loadiconfile(app, iconpath, "bigattrib.png", basecolor)) != NULL) & success;
    success = ((tbbigblockdevicon = loadiconfile(app, iconpath, "bigblockdev.png", basecolor)) != NULL) & success;
    success = ((tbbigbrokenlinkicon = loadiconfile(app, iconpath, "bigbrokenlink.png", basecolor)) != NULL) & success;
    success = ((tbbigcdromicon = loadiconfile(app, iconpath, "bigcdrom.png", basecolor)) != NULL) & success;
    success = ((tbbigchardevicon = loadiconfile(app, iconpath, "bigchardev.png", basecolor)) != NULL) & success;
    success = ((tbbigcompareicon = loadiconfile(app, iconpath, "bigcompare.png", basecolor)) != NULL) & success;
    success = ((tbbigdocicon = loadiconfile(app, iconpath, "bigdoc.png", basecolor)) != NULL) & success;
    success = ((tbbigexecicon = loadiconfile(app, iconpath, "bigexec.png", basecolor)) != NULL) & success;
    success = ((tbbigfileopenicon = loadiconfile(app, iconpath, "bigfileopen.png", basecolor)) != NULL) & success;
    success = ((tbbigfiltericon = loadiconfile(app, iconpath, "bigfilter.png", basecolor)) != NULL) & success;
    success = ((tbbigfloppyicon = loadiconfile(app, iconpath, "bigfloppy.png", basecolor)) != NULL) & success;
    success = ((tbbigfolderlockedicon = loadiconfile(app, iconpath, "bigfolderlocked.png", basecolor)) != NULL) & success;
    success = ((tbbigfolderopenicon = loadiconfile(app, iconpath, "bigfolderopen.png", basecolor)) != NULL) & success;
    success = ((tbbigfoldericon = loadiconfile(app, iconpath, "bigfolder.png", basecolor)) != NULL) & success;
    success = ((tbbigfolderupicon = loadiconfile(app, iconpath, "bigfolderup.png", basecolor)) != NULL) & success;
    success = ((tbbigharddiskicon = loadiconfile(app, iconpath, "bigharddisk.png", basecolor)) != NULL) & success; */
    success = ((tbbigiconsicon = loadiconfile(app, iconpath, "bigicons.png", basecolor)) != NULL) & success; /*
    success = ((tbbiglinkicon = loadiconfile(app, iconpath, "biglink.png", basecolor)) != NULL) & success;
    success = ((tbbignewfileicon = loadiconfile(app, iconpath, "bignewfile.png", basecolor)) != NULL) & success;
    success = ((tbbignewfoldericon = loadiconfile(app, iconpath, "bignewfolder.png", basecolor)) != NULL) & success;
    success = ((tbbignewlinkicon = loadiconfile(app, iconpath, "bignewlink.png", basecolor)) != NULL) & success;
    success = ((tbbignfsdriveicon = loadiconfile(app, iconpath, "bignfsdrive.png", basecolor)) != NULL) & success;
    success = ((tbbignfsdriveumticon = loadiconfile(app, iconpath, "bignfsdriveumt.png", basecolor)) != NULL) & success;
    success = ((tbbigpipeicon = loadiconfile(app, iconpath, "bigpipe.png", basecolor)) != NULL) & success;
    success = ((tbbigsocketicon = loadiconfile(app, iconpath, "bigsocket.png", basecolor)) != NULL) & success;
    success = ((tbbigzipicon = loadiconfile(app, iconpath, "bigzip.png", basecolor)) != NULL) & success; */
    success = ((tbcdromicon = loadiconfile(app, iconpath, "cdrom.png", basecolor)) != NULL) & success;
    success = ((tbcharticon = loadiconfile(app, iconpath, "chart.png", basecolor)) != NULL) & success;
    success = ((tbclosefileicon = loadiconfile(app, iconpath, "closefile.png", basecolor)) != NULL) & success;
    success = ((tbclrbookicon = loadiconfile(app, iconpath, "clrbook.png", basecolor)) != NULL) & success;
    success = ((tbcolltreeicon = loadiconfile(app, iconpath, "colltree.png", basecolor)) != NULL) & success;
    success = ((tbcopy_bigicon = loadiconfile(app, iconpath, "copy_big.png", basecolor)) != NULL) & success;
    success = ((tbcopy_clpicon = loadiconfile(app, iconpath, "copy_clp.png", basecolor)) != NULL) & success;
    success = ((tbcut_clpicon = loadiconfile(app, iconpath, "cut_clp.png", basecolor)) != NULL) & success;
    success = ((tbdelete_big_permicon = loadiconfile(app, iconpath, "delete_big_perm.png", basecolor)) != NULL) & success;
    success = ((tbdelete_bigicon = loadiconfile(app, iconpath, "delete_big.png", basecolor)) != NULL) & success;
    success = ((tbdeselicon = loadiconfile(app, iconpath, "desel.png", basecolor)) != NULL) & success;
    success = ((tbdetailsicon = loadiconfile(app, iconpath, "details.png", basecolor)) != NULL) & success;
    success = ((tbdirupicon = loadiconfile(app, iconpath, "dirup.png", basecolor)) != NULL) & success;
    success = ((tbediticon = loadiconfile(app, iconpath, "edit.png", basecolor)) != NULL) & success;
    success = ((tbentericon = loadiconfile(app, iconpath, "enter.png", basecolor)) != NULL) & success;
    success = ((tberrorbigicon = loadiconfile(app, iconpath, "errorbig.png", basecolor)) != NULL) & success;
    success = ((tbexptreeicon = loadiconfile(app, iconpath, "exptree.png", basecolor)) != NULL) & success;
    success = ((tbcompareicon = loadiconfile(app, iconpath, "compare.png", basecolor)) != NULL) & success;
    success = ((tbfiledelete_permicon = loadiconfile(app, iconpath, "filedelete_perm.png", basecolor)) != NULL) & success;
    success = ((tbfiledeleteicon = loadiconfile(app, iconpath, "filedelete.png", basecolor)) != NULL) & success;
    success = ((tbfileopenicon = loadiconfile(app, iconpath, "fileopen.png", basecolor)) != NULL) & success;
    success = ((tbviewicon = loadiconfile(app, iconpath, "view.png", basecolor)) != NULL) & success;
    success = ((tbfiltericon = loadiconfile(app, iconpath, "filter.png", basecolor)) != NULL) & success;
    success = ((tbfind_againicon = loadiconfile(app, iconpath, "find_again.png", basecolor)) != NULL) & success;
    success = ((tbfliplricon = loadiconfile(app, iconpath, "fliplr.png", basecolor)) != NULL) & success;
    success = ((tbflipudicon = loadiconfile(app, iconpath, "flipud.png", basecolor)) != NULL) & success;
    success = ((tbfloppyicon = loadiconfile(app, iconpath, "floppy.png", basecolor)) != NULL) & success;
    success = ((tbfontsicon = loadiconfile(app, iconpath, "fonts.png", basecolor)) != NULL) & success;
    success = ((tbgotobigicon = loadiconfile(app, iconpath, "gotobig.png", basecolor)) != NULL) & success;
    success = ((tbgotodiricon = loadiconfile(app, iconpath, "gotodir.png", basecolor)) != NULL) & success;
    success = ((tbgotolineicon = loadiconfile(app, iconpath, "gotoline.png", basecolor)) != NULL) & success;
    success = ((tbharddiskicon = loadiconfile(app, iconpath, "harddisk.png", basecolor)) != NULL) & success;
    success = ((tbhelpicon = loadiconfile(app, iconpath, "help.png", basecolor)) != NULL) & success;
    success = ((tbhidehiddenicon = loadiconfile(app, iconpath, "hidehidden.png", basecolor)) != NULL) & success;
    success = ((tbhidenumbersicon = loadiconfile(app, iconpath, "hidenumbers.png", basecolor)) != NULL) & success;
    success = ((tbhidethumbicon = loadiconfile(app, iconpath, "hidethumb.png", basecolor)) != NULL) & success;
    success = ((tbhomeicon = loadiconfile(app, iconpath, "home.png", basecolor)) != NULL) & success;
    success = ((tbinfobigicon = loadiconfile(app, iconpath, "infobig.png", basecolor)) != NULL) & success;
    success = ((tbinvselicon = loadiconfile(app, iconpath, "invsel.png", basecolor)) != NULL) & success;
    success = ((tblink_bigicon = loadiconfile(app, iconpath, "link_big.png", basecolor)) != NULL) & success;
    success = ((tblocationicon = loadiconfile(app, iconpath, "location.png", basecolor)) != NULL) & success;
    success = ((tblowercaseicon = loadiconfile(app, iconpath, "lowercase.png", basecolor)) != NULL) & success;
    success = ((tbmaphosticon = loadiconfile(app, iconpath, "maphost.png", basecolor)) != NULL) & success;
    success = ((tbminiappicon = loadiconfile(app, iconpath, "miniapp.png", basecolor)) != NULL) & success;
    success = ((tbminiblockdevicon = loadiconfile(app, iconpath, "miniblockdev.png", basecolor)) != NULL) & success;
    success = ((tbminibrokenlinkicon = loadiconfile(app, iconpath, "minibrokenlink.png", basecolor)) != NULL) & success;
    success = ((tbminichardevicon = loadiconfile(app, iconpath, "minichardev.png", basecolor)) != NULL) & success;
    success = ((tbminidocicon = loadiconfile(app, iconpath, "minidoc.png", basecolor)) != NULL) & success;
    success = ((tbminiexecicon = loadiconfile(app, iconpath, "miniexec.png", basecolor)) != NULL) & success;
    success = ((tbminifolderclosedicon = loadiconfile(app, iconpath, "minifolderclosed.png", basecolor)) != NULL) & success;
    success = ((tbminifolderlockedicon = loadiconfile(app, iconpath, "minifolderlocked.png", basecolor)) != NULL) & success;
    success = ((tbminifolderopenicon = loadiconfile(app, iconpath, "minifolderopen.png", basecolor)) != NULL) & success;
    success = ((tbminifoldericon = loadiconfile(app, iconpath, "minifolder.png", basecolor)) != NULL) & success;
    success = ((tbminifolderupicon = loadiconfile(app, iconpath, "minifolderup.png", basecolor)) != NULL) & success;
    success = ((tbminilinkicon = loadiconfile(app, iconpath, "minilink.png", basecolor)) != NULL) & success;
    success = ((tbminipipeicon = loadiconfile(app, iconpath, "minipipe.png", basecolor)) != NULL) & success;
    success = ((tbminishellicon = loadiconfile(app, iconpath, "minishell.png", basecolor)) != NULL) & success;
    success = ((tbminisocketicon = loadiconfile(app, iconpath, "minisocket.png", basecolor)) != NULL) & success;
    success = ((tbmove_bigicon = loadiconfile(app, iconpath, "move_big.png", basecolor)) != NULL) & success;
    success = ((tbmoveiticon = loadiconfile(app, iconpath, "moveit.png", basecolor)) != NULL) & success;
    success = ((tbnewfileicon = loadiconfile(app, iconpath, "newfile.png", basecolor)) != NULL) & success;
    success = ((tbnewfoldericon = loadiconfile(app, iconpath, "newfolder.png", basecolor)) != NULL) & success;
    success = ((tbnfsdriveicon = loadiconfile(app, iconpath, "nfsdrive.png", basecolor)) != NULL) & success;
    success = ((tbnfsdriveumticon = loadiconfile(app, iconpath, "nfsdriveumt.png", basecolor)) != NULL) & success;
    success = ((tbonepanelicon = loadiconfile(app, iconpath, "onepanel.png", basecolor)) != NULL) & success;
    success = ((tbpackageicon = loadiconfile(app, iconpath, "package.png", basecolor)) != NULL) & success;
    success = ((tbpaste_clpicon = loadiconfile(app, iconpath, "paste_clp.png", basecolor)) != NULL) & success;
    success = ((tbprefsicon = loadiconfile(app, iconpath, "prefs.png", basecolor)) != NULL) & success;
    success = ((tbprintbigicon = loadiconfile(app, iconpath, "printbig.png", basecolor)) != NULL) & success;
    success = ((tbprinticon = loadiconfile(app, iconpath, "print.png", basecolor)) != NULL) & success;
    success = ((tbquestionbigicon = loadiconfile(app, iconpath, "questionbig.png", basecolor)) != NULL) & success;
    success = ((tbquiticon = loadiconfile(app, iconpath, "quit.png", basecolor)) != NULL) & success;
    success = ((tbredoicon = loadiconfile(app, iconpath, "redo.png", basecolor)) != NULL) & success;
    success = ((tbreloadicon = loadiconfile(app, iconpath, "reload.png", basecolor)) != NULL) & success;
    success = ((tbrenameiticon = loadiconfile(app, iconpath, "renameit.png", basecolor)) != NULL) & success;
    success = ((tbreplaceicon = loadiconfile(app, iconpath, "replace.png", basecolor)) != NULL) & success;
    success = ((tbreverticon = loadiconfile(app, iconpath, "revert.png", basecolor)) != NULL) & success;
    success = ((tbrotatelefticon = loadiconfile(app, iconpath, "rotateleft.png", basecolor)) != NULL) & success;
    success = ((tbrotaterighticon = loadiconfile(app, iconpath, "rotateright.png", basecolor)) != NULL) & success;
    success = ((tbrunicon = loadiconfile(app, iconpath, "run.png", basecolor)) != NULL) & success;
    success = ((tbsaveasicon = loadiconfile(app, iconpath, "saveas.png", basecolor)) != NULL) & success;
    success = ((tbsavefileicon = loadiconfile(app, iconpath, "savefile.png", basecolor)) != NULL) & success;
    success = ((tbsearchnexticon = loadiconfile(app, iconpath, "searchnext.png", basecolor)) != NULL) & success;
    success = ((tbsearchicon = loadiconfile(app, iconpath, "search.png", basecolor)) != NULL) & success;
    success = ((tbsearchprevicon = loadiconfile(app, iconpath, "searchprev.png", basecolor)) != NULL) & success;
    success = ((tbselallicon = loadiconfile(app, iconpath, "selall.png", basecolor)) != NULL) & success;
    success = ((tbsetbookicon = loadiconfile(app, iconpath, "setbook.png", basecolor)) != NULL) & success;
    success = ((tbshellicon = loadiconfile(app, iconpath, "shell.png", basecolor)) != NULL) & success;
    success = ((tbshowhiddenicon = loadiconfile(app, iconpath, "showhidden.png", basecolor)) != NULL) & success;
    success = ((tbshownumbersicon = loadiconfile(app, iconpath, "shownumbers.png", basecolor)) != NULL) & success;
    success = ((tbshowthumbicon = loadiconfile(app, iconpath, "showthumb.png", basecolor)) != NULL) & success;
    success = ((tbsmalliconsicon = loadiconfile(app, iconpath, "smallicons.png", basecolor)) != NULL) & success;
    success = ((tbiconsmenuicon = loadiconfile(app, iconpath, "iconsmenu.png", basecolor, 1)) != NULL) & success;
    success = ((tbtrash_full_bigicon = loadiconfile(app, iconpath, "trash_full_big.png", basecolor)) != NULL) & success;
    success = ((tbtrash_fullicon = loadiconfile(app, iconpath, "trash_full.png", basecolor)) != NULL) & success;
    success = ((tbtreeonepanelicon = loadiconfile(app, iconpath, "treeonepanel.png", basecolor)) != NULL) & success;
    success = ((tbtreetwopanelsicon = loadiconfile(app, iconpath, "treetwopanels.png", basecolor)) != NULL) & success;
    success = ((tbtwopanelsicon = loadiconfile(app, iconpath, "twopanels.png", basecolor)) != NULL) & success;
    success = ((tbundoicon = loadiconfile(app, iconpath, "undo.png", basecolor)) != NULL) & success;
    success = ((tbunmaphosticon = loadiconfile(app, iconpath, "unmaphost.png", basecolor)) != NULL) & success;
    success = ((tbuppercaseicon = loadiconfile(app, iconpath, "uppercase.png", basecolor)) != NULL) & success;
    success = ((tbwarningbigicon = loadiconfile(app, iconpath, "warningbig.png", basecolor)) != NULL) & success;
    success = ((tbworkicon = loadiconfile(app, iconpath, "work.png", basecolor)) != NULL) & success;
    success = ((tbwrapofficon = loadiconfile(app, iconpath, "wrapoff.png", basecolor)) != NULL) & success;
    success = ((tbwraponicon = loadiconfile(app, iconpath, "wrapon.png", basecolor)) != NULL) & success;
    success = ((tbxfeicon = loadiconfile(app, iconpath, "xfe.png", basecolor)) != NULL) & success;
    success = ((tbxfiicon = loadiconfile(app, iconpath, "xfi.png", basecolor)) != NULL) & success;
    success = ((tbxfpicon = loadiconfile(app, iconpath, "xfp.png", basecolor)) != NULL) & success;
    success = ((tbxfwicon = loadiconfile(app, iconpath, "xfw.png", basecolor)) != NULL) & success;
    success = ((tbzipicon = loadiconfile(app, iconpath, "zip.png", basecolor)) != NULL) & success;
    success = ((tbzoom100icon = loadiconfile(app, iconpath, "zoom100.png", basecolor)) != NULL) & success;
    success = ((tbzoominicon = loadiconfile(app, iconpath, "zoomin.png", basecolor)) != NULL) & success;
    success = ((tbzoomouticon = loadiconfile(app, iconpath, "zoomout.png", basecolor)) != NULL) & success;
    success = ((tbzoomwinicon = loadiconfile(app, iconpath, "zoomwin.png", basecolor)) != NULL) & success;
    success = ((tbtotrashicon = loadiconfile(app, iconpath, "totrash.png", basecolor)) != NULL) & success;
    success = ((tbdirbackicon = loadiconfile(app, iconpath, "dirback.png", basecolor)) != NULL) & success;
    success = ((tbdirforwardicon = loadiconfile(app, iconpath, "dirforward.png", basecolor)) != NULL) & success;
    success = ((tbminixferooticon = loadiconfile(app, iconpath, "minixferoot.png", basecolor)) != NULL) & success;
    success = ((tbminixfeicon = loadiconfile(app, iconpath, "minixfe.png", basecolor)) != NULL) & success;
    success = ((tbfiledialogicon = loadiconfile(app, iconpath, "filedialog.png", basecolor)) != NULL) & success;
    // success = ((tbbigarchaddicon = loadiconfile(app, iconpath, "bigarchadd.png", basecolor)) != NULL) & success;
    success = ((tbswitchpanelsicon = loadiconfile(app, iconpath, "switchpanels.png", basecolor)) != NULL) & success;
    success = ((tbsyncpanelsicon = loadiconfile(app, iconpath, "syncpanels.png", basecolor)) != NULL) & success;
    success = ((tbnewlinkicon = loadiconfile(app, iconpath, "newlink.png", basecolor)) != NULL) & success;
    success = ((tbgreenbuttonicon = loadiconfile(app, iconpath, "greenbutton.png", basecolor)) != NULL) & success;

    success = ((tbgraybuttonicon = loadiconfile(app, iconpath, "graybutton.png", basecolor)) != NULL) & success;
    success = ((tbkeybindingsicon = loadiconfile(app, iconpath, "keybindings.png", basecolor)) != NULL) & success;
    success = ((tbminikeybindingsicon = loadiconfile(app, iconpath, "minikeybindings.png", basecolor)) != NULL) & success;
    success = ((tbfilerestoreicon = loadiconfile(app, iconpath, "filerestore.png", basecolor)) != NULL) & success;
    success = ((tbrestore_bigicon = loadiconfile(app, iconpath, "restore_big.png", basecolor)) != NULL) & success;
    success = ((tbhorzpanelsicon = loadiconfile(app, iconpath, "horzpanels.png", basecolor)) != NULL) & success;
    success = ((tbvertpanelsicon = loadiconfile(app, iconpath, "vertpanels.png", basecolor)) != NULL) & success;
    // success = ((tbcomboarrowicon = loadiconfile(app, iconpath, "comboarrow.png", basecolor)) != NULL) & success;
    success = ((tbcomputericon = loadiconfile(app, iconpath, "computer.png", basecolor)) != NULL) & success;
    success = ((tbcloseicon = loadiconfile(app, iconpath, "close.png", basecolor)) != NULL) & success;
    success = ((tbthrobicon = loadiconfile(app, iconpath, "throb.png", basecolor)) != NULL) & success;
    success = ((tbthrobanimicon = loadiconfile(app, iconpath, "throbanim.png", basecolor)) != NULL) & success;
    // success = ((tbwebviewbgicon = loadiconfile(app, iconpath, "webviewbg.png", basecolor)) != NULL) & success;
    // ((tbwebviewbgicon = loadiconfile(app, iconpath, "webviewbg.png", basecolor)) != NULL);
    ((webviewxp = loadiconfile(app, iconpath, "xpwv.png", basecolor)) != NULL);


//resizecorner = new FXIcon(app, NULL, IMAGE_KEEP, 13, 13);
//resizecorner = new FXIcon(app, NULL, FXRGB(255,0,0), IMAGE_KEEP, 13, 13);
//FXIcon* resizecorner = NULL;
//resizecorner = new FXIcon(app, NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP|IMAGE_OPAQUE|IMAGE_OWNED, 13, 13);
//FXColor resizecornerbuff[13*13];

//resizecorner = new FXIcon(app, NULL, 0, IMAGE_OPAQUE|IMAGE_DITHER|IMAGE_KEEP|IMAGE_OWNED|IMAGE_SHMI|IMAGE_SHMP, 13, 13);
resizecorner = new FXIcon(app, NULL, 0, IMAGE_OWNED, 13, 13);
//resizecorner = new FXIcon(app);

resizecorner->resize(13, 13);
//resizecorner->fill(basecolor);
//resizecorner->fill(FXRGB(255,0,0));

//resizecorner->create();

resizecorner->setPixel(11, 0, iconhilitecolor);
resizecorner->setPixel(10, 1, iconhilitecolor);
resizecorner->setPixel(9, 2, iconhilitecolor);
resizecorner->setPixel(8, 3, iconhilitecolor);
resizecorner->setPixel(7, 4, iconhilitecolor);
resizecorner->setPixel(11, 4, iconhilitecolor);
resizecorner->setPixel(6, 5, iconhilitecolor);
resizecorner->setPixel(10, 5, iconhilitecolor);
resizecorner->setPixel(5, 6, iconhilitecolor);
resizecorner->setPixel(9, 6, iconhilitecolor);
resizecorner->setPixel(4, 7, iconhilitecolor);
resizecorner->setPixel(8, 7, iconhilitecolor);
resizecorner->setPixel(3, 8, iconhilitecolor);
resizecorner->setPixel(7, 8, iconhilitecolor);
resizecorner->setPixel(11, 8, iconhilitecolor);
resizecorner->setPixel(2, 9, iconhilitecolor);
resizecorner->setPixel(6, 9, iconhilitecolor);
resizecorner->setPixel(10, 9, iconhilitecolor);
resizecorner->setPixel(1, 10, iconhilitecolor);
resizecorner->setPixel(5, 10, iconhilitecolor);
resizecorner->setPixel(9, 10, iconhilitecolor);
resizecorner->setPixel(0, 11, iconhilitecolor);
resizecorner->setPixel(4, 11, iconhilitecolor);
resizecorner->setPixel(8, 11, iconhilitecolor);

resizecorner->setPixel(11, 1, iconshadowcolor);
resizecorner->setPixel(10, 2, iconshadowcolor);
resizecorner->setPixel(11, 2, iconshadowcolor);
resizecorner->setPixel(9, 3, iconshadowcolor);
resizecorner->setPixel(10, 3, iconshadowcolor);
resizecorner->setPixel(8, 4, iconshadowcolor);
resizecorner->setPixel(9, 4, iconshadowcolor);
resizecorner->setPixel(7, 5, iconshadowcolor);
resizecorner->setPixel(8, 5, iconshadowcolor);
resizecorner->setPixel(11, 5, iconshadowcolor);
resizecorner->setPixel(6, 6, iconshadowcolor);
resizecorner->setPixel(7, 6, iconshadowcolor);
resizecorner->setPixel(10, 6, iconshadowcolor);
resizecorner->setPixel(11, 6, iconshadowcolor);
resizecorner->setPixel(5, 7, iconshadowcolor);
resizecorner->setPixel(6, 7, iconshadowcolor);
resizecorner->setPixel(9, 7, iconshadowcolor);
resizecorner->setPixel(10, 7, iconshadowcolor);
resizecorner->setPixel(4, 8, iconshadowcolor);
resizecorner->setPixel(5, 8, iconshadowcolor);
resizecorner->setPixel(8, 8, iconshadowcolor);
resizecorner->setPixel(9, 8, iconshadowcolor);
resizecorner->setPixel(3, 9, iconshadowcolor);
resizecorner->setPixel(4, 9, iconshadowcolor);
resizecorner->setPixel(7, 9, iconshadowcolor);
resizecorner->setPixel(8, 9, iconshadowcolor);
resizecorner->setPixel(11, 9, iconshadowcolor);
resizecorner->setPixel(2, 10, iconshadowcolor);
resizecorner->setPixel(3, 10, iconshadowcolor);
resizecorner->setPixel(6, 10, iconshadowcolor);
resizecorner->setPixel(7, 10, iconshadowcolor);
resizecorner->setPixel(10, 10, iconshadowcolor);
resizecorner->setPixel(11, 10, iconshadowcolor);
resizecorner->setPixel(1, 11, iconshadowcolor);
resizecorner->setPixel(2, 11, iconshadowcolor);
resizecorner->setPixel(5, 11, iconshadowcolor);
resizecorner->setPixel(6, 11, iconshadowcolor);
resizecorner->setPixel(9, 11, iconshadowcolor);
resizecorner->setPixel(10, 11, iconshadowcolor);

//resizecorner->render();
//resizecorner->create();
resizecorner->create();
//resizecorner->create();
//resizecorner->destroy();
//std::cout << resizecorner;
//printf("\n");

//FXColor comboarrowiconbuff[11*4];

comboarrowicon = new FXIcon(app, NULL, 0, IMAGE_DITHER|IMAGE_KEEP|IMAGE_OWNED|IMAGE_SHMI|IMAGE_SHMP, 11, 4);
//resizecorner = new FXIcon(app);

comboarrowicon->resize(11, 4);

comboarrowicon->setPixel(2, 0, iconforecolor);
comboarrowicon->setPixel(3, 0, iconforecolor);
comboarrowicon->setPixel(4, 0, iconforecolor);
comboarrowicon->setPixel(5, 0, iconforecolor);
comboarrowicon->setPixel(6, 0, iconforecolor);
comboarrowicon->setPixel(7, 0, iconforecolor);
comboarrowicon->setPixel(8, 0, iconforecolor);
comboarrowicon->setPixel(3, 1, iconforecolor);
comboarrowicon->setPixel(4, 1, iconforecolor);
comboarrowicon->setPixel(5, 1, iconforecolor);
comboarrowicon->setPixel(6, 1, iconforecolor);
comboarrowicon->setPixel(7, 1, iconforecolor);
comboarrowicon->setPixel(4, 2, iconforecolor);
comboarrowicon->setPixel(5, 2, iconforecolor);
comboarrowicon->setPixel(6, 2, iconforecolor);
comboarrowicon->setPixel(5, 3, iconforecolor);

comboarrowicon->render();
comboarrowicon->create();

tbcomboarrowicon = new FXIcon(app, NULL, 0, IMAGE_DITHER|IMAGE_KEEP|IMAGE_OWNED|IMAGE_SHMI|IMAGE_SHMP, 11, 4);
tbcomboarrowicon->resize(11, 4);

tbcomboarrowicon->setPixel(2, 0, iconforecolor);
tbcomboarrowicon->setPixel(3, 0, iconforecolor);
tbcomboarrowicon->setPixel(4, 0, iconforecolor);
tbcomboarrowicon->setPixel(5, 0, iconforecolor);
tbcomboarrowicon->setPixel(6, 0, iconforecolor);
tbcomboarrowicon->setPixel(7, 0, iconforecolor);
tbcomboarrowicon->setPixel(8, 0, iconforecolor);
tbcomboarrowicon->setPixel(3, 1, iconforecolor);
tbcomboarrowicon->setPixel(4, 1, iconforecolor);
tbcomboarrowicon->setPixel(5, 1, iconforecolor);
tbcomboarrowicon->setPixel(6, 1, iconforecolor);
tbcomboarrowicon->setPixel(7, 1, iconforecolor);
tbcomboarrowicon->setPixel(4, 2, iconforecolor);
tbcomboarrowicon->setPixel(5, 2, iconforecolor);
tbcomboarrowicon->setPixel(6, 2, iconforecolor);
tbcomboarrowicon->setPixel(5, 3, iconforecolor);

tbcomboarrowicon->render();
tbcomboarrowicon->create();


closeicon = new FXIcon(app, NULL, 0, IMAGE_DITHER|IMAGE_KEEP|IMAGE_OWNED|IMAGE_SHMI|IMAGE_SHMP, 18, 11);
closeicon->setPixel(5, 2, iconforecolor);
closeicon->setPixel(6, 2, iconforecolor);
closeicon->setPixel(11, 2, iconforecolor);
closeicon->setPixel(12, 2, iconforecolor);
closeicon->setPixel(6, 3, iconforecolor);
closeicon->setPixel(7, 3, iconforecolor);
closeicon->setPixel(10, 3, iconforecolor);
closeicon->setPixel(11, 3, iconforecolor);
closeicon->setPixel(7, 4, iconforecolor);
closeicon->setPixel(8, 4, iconforecolor);
closeicon->setPixel(9, 4, iconforecolor);
closeicon->setPixel(10, 4, iconforecolor);
closeicon->setPixel(8, 5, iconforecolor);
closeicon->setPixel(9, 5, iconforecolor);
closeicon->setPixel(7, 6, iconforecolor);
closeicon->setPixel(8, 6, iconforecolor);
closeicon->setPixel(9, 6, iconforecolor);
closeicon->setPixel(10, 6, iconforecolor);
closeicon->setPixel(6, 7, iconforecolor);
closeicon->setPixel(7, 7, iconforecolor);
closeicon->setPixel(10, 7, iconforecolor);
closeicon->setPixel(11, 7, iconforecolor);
closeicon->setPixel(5, 8, iconforecolor);
closeicon->setPixel(6, 8, iconforecolor);
closeicon->setPixel(11, 8, iconforecolor);
closeicon->setPixel(12, 8, iconforecolor);


closeicon->render();
closeicon->create();


/* if (tbiconsmenuicon->getHeight() == 16) {
	tbiconsmenuicon->setPixel(18, 7, iconforecolor);
	tbiconsmenuicon->setPixel(19, 7, iconforecolor);
	tbiconsmenuicon->setPixel(20, 7, iconforecolor);
	tbiconsmenuicon->setPixel(21, 7, iconforecolor);
	tbiconsmenuicon->setPixel(22, 7, iconforecolor);
	tbiconsmenuicon->setPixel(19, 8, iconforecolor);
	tbiconsmenuicon->setPixel(20, 8, iconforecolor);
	tbiconsmenuicon->setPixel(21, 8, iconforecolor);
	tbiconsmenuicon->setPixel(20, 9, iconforecolor);
} else if (tbiconsmenuicon->getHeight() == 24) {
	tbiconsmenuicon->setPixel(26, 12, iconforecolor);
	tbiconsmenuicon->setPixel(27, 12, iconforecolor);
	tbiconsmenuicon->setPixel(28, 12, iconforecolor);
	tbiconsmenuicon->setPixel(29, 12, iconforecolor);
	tbiconsmenuicon->setPixel(30, 12, iconforecolor);
	tbiconsmenuicon->setPixel(27, 13, iconforecolor);
	tbiconsmenuicon->setPixel(28, 13, iconforecolor);
	tbiconsmenuicon->setPixel(29, 13, iconforecolor);
	tbiconsmenuicon->setPixel(28, 14, iconforecolor);
}


tbiconsmenuicon->render();
tbiconsmenuicon->create(); */

    return(success);
}

// Global icons for all applications

#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "xfeutils.h"
#include "icons.h"


// Icons (global variables)

FXIcon *archaddicon, *archexticon, *attribicon, *bigattribicon, *bigblockdevicon, *bigbrokenlinkicon, *bigcdromicon, *bigchardevicon;
FXIcon *bigcompareicon, *bigdocicon, *bigexecicon, *bigfileopenicon, *bigfiltericon, *bigfloppyicon, *bigfolderlockedicon;
FXIcon *bigfolderopenicon, *bigfoldericon, *bigfolderupicon, *bigharddiskicon, *bigiconsicon, *biglinkicon, *bignewfileicon;
FXIcon *bignewfoldericon, *bignewlinkicon, *bignfsdriveicon;
FXIcon *bignfsdriveumticon, *bigpipeicon, *bigsocketicon, *bigzipicon, *cdromicon, *charticon;
FXIcon *closefileicon, *clrbookicon, *collfoldericon, *copy_bigicon, *colltreeicon;
FXIcon *copy_clpicon, *cut_clpicon, *delete_big_permicon, *delete_bigicon, *deselicon, *detailsicon;
FXIcon *dirupicon, *editicon, *entericon, *errorbigicon, *exptreeicon, *compareicon;
FXIcon *filedelete_permicon, *filedeleteicon, *fileopenicon;
FXIcon *viewicon, *filtericon, *find_againicon, *fliplricon, *flipudicon, *floppyicon;
FXIcon *fontsicon, *gotobigicon, *gotodiricon, *gotolineicon, *harddiskicon, *helpicon, *hidehiddenicon;
FXIcon *hidenumbersicon, *hidethumbicon, *homeicon, *infobigicon, *invselicon, *link_bigicon;
FXIcon *locationicon, *lowercaseicon, *maphosticon, *miniappicon, *miniblockdevicon, *minibrokenlinkicon;
FXIcon *minichardevicon, *minidocicon, *miniexecicon, *minifolderclosedicon;
FXIcon *minifolderlockedicon, *minifolderopenicon, *minifoldericon, *minifolderupicon, *minilinkicon;
FXIcon *minipipeicon, *minishellicon, *minisocketicon;
FXIcon *move_bigicon, *moveiticon, *newfileicon, *newfoldericon, *nfsdriveicon, *nfsdriveumticon;
FXIcon *onepanelicon, *packageicon, *paste_clpicon, *prefsicon, *printbigicon, *printicon;
FXIcon *questionbigicon, *quiticon, *redoicon, *reloadicon, *renameiticon, *replaceicon;
FXIcon *reverticon, *rotatelefticon, *rotaterighticon, *runicon, *saveasicon, *savefileicon;
FXIcon *searchnexticon, *searchicon, *searchprevicon, *selallicon, *setbookicon, *shellicon;
FXIcon *showhiddenicon, *shownumbersicon, *showthumbicon, *smalliconsicon, *iconsmenuicon;
FXIcon *trash_full_bigicon, *trash_fullicon, *treeonepanelicon, *treetwopanelsicon, *twopanelsicon;
FXIcon *undoicon, *unmaphosticon, *uppercaseicon, *warningbigicon, *workicon, *wrapofficon, *wraponicon, *xfeicon, *realxfeicon, *xfiicon;
FXIcon *xfpicon, *xfwicon, *zipicon, *zoom100icon, *zoominicon, *zoomouticon, *zoomwinicon;
FXIcon *totrashicon, *dirbackicon, *dirforwardicon, *minixfeicon, *minixferooticon, *filedialogicon, *bigarchaddicon;
FXIcon *switchpanelsicon, *syncpanelsicon, *newlinkicon, *greenbuttonicon, *graybuttonicon, *closeicon, *throbicon, *throbanimicon, *webviewbgicon;
FXIcon *keybindingsicon, *minikeybindingsicon, *filerestoreicon, *restore_bigicon, *vertpanelsicon, *horzpanelsicon, *comboarrowicon;

FXIcon *tbarchaddicon, *tbarchexticon, *tbattribicon/*, *tbbigattribicon, *tbbigblockdevicon, *tbbigbrokenlinkicon, *tbbigcdromicon, *tbbigchardevicon */;
//FXIcon *tbbigcompareicon, *tbbigdocicon, *tbbigexecicon, *tbbigfileopenicon, *tbbigfiltericon, *tbbigfloppyicon, *tbbigfolderlockedicon;
FXIcon /**tbbigfolderopenicon, *tbbigfoldericon, *tbbigfolderupicon, *tbbigharddiskicon, */*tbbigiconsicon/*, *tbbiglinkicon, *tbbignewfileicon*/;
//FXIcon *tbbignewfoldericon, *tbbignewlinkicon, *tbbignfsdriveicon;
FXIcon /* *tbbignfsdriveumticon, *tbbigpipeicon, *tbbigsocketicon, *tbbigzipicon, */ *tbcdromicon, *tbcharticon, *webviewxp;
FXIcon *tbclosefileicon, *tbclrbookicon, *tbcollfoldericon, *tbcopy_bigicon, *tbcolltreeicon;
FXIcon *tbcopy_clpicon, *tbcut_clpicon, *tbdelete_big_permicon, *tbdelete_bigicon, *tbdeselicon, *tbdetailsicon;
FXIcon *tbdirupicon, *tbediticon, *tbentericon, *tberrorbigicon, *tbexptreeicon, *tbcompareicon;
FXIcon *tbfiledelete_permicon, *tbfiledeleteicon, *tbfileopenicon;
FXIcon *tbviewicon, *tbfiltericon, *tbfind_againicon, *tbfliplricon, *tbflipudicon, *tbfloppyicon;
FXIcon *tbfontsicon, *tbgotobigicon, *tbgotodiricon, *tbgotolineicon, *tbharddiskicon, *tbhelpicon, *tbhidehiddenicon;
FXIcon *tbhidenumbersicon, *tbhidethumbicon, *tbhomeicon, *tbinfobigicon, *tbinvselicon, *tblink_bigicon;
FXIcon *tblocationicon, *tblowercaseicon, *tbmaphosticon, *tbminiappicon, *tbminiblockdevicon, *tbminibrokenlinkicon;
FXIcon *tbminichardevicon, *tbminidocicon, *tbminiexecicon, *tbminifolderclosedicon;
FXIcon *tbminifolderlockedicon, *tbminifolderopenicon, *tbminifoldericon, *tbminifolderupicon, *tbminilinkicon;
FXIcon *tbminipipeicon, *tbminishellicon, *tbminisocketicon;
FXIcon *tbmove_bigicon, *tbmoveiticon, *tbnewfileicon, *tbnewfoldericon, *tbnfsdriveicon, *tbnfsdriveumticon;
FXIcon *tbonepanelicon, *tbpackageicon, *tbpaste_clpicon, *tbprefsicon, *tbprintbigicon, *tbprinticon;
FXIcon *tbquestionbigicon, *tbquiticon, *tbredoicon, *tbreloadicon, *tbrenameiticon, *tbreplaceicon;
FXIcon *tbreverticon, *tbrotatelefticon, *tbrotaterighticon, *tbrunicon, *tbsaveasicon, *tbsavefileicon;
FXIcon *tbsearchnexticon, *tbsearchicon, *tbsearchprevicon, *tbselallicon, *tbsetbookicon, *tbshellicon;
FXIcon *tbshowhiddenicon, *tbshownumbersicon, *tbshowthumbicon, *tbsmalliconsicon, *tbiconsmenuicon;
FXIcon *tbtrash_full_bigicon, *tbtrash_fullicon, *tbtreeonepanelicon, *tbtreetwopanelsicon, *tbtwopanelsicon;
FXIcon *tbundoicon, *tbunmaphosticon, *tbuppercaseicon, *tbwarningbigicon, *tbworkicon, *tbwrapofficon, *tbwraponicon, *tbxfeicon, *tbxfiicon;
FXIcon *tbxfpicon, *tbxfwicon, *tbzipicon, *tbzoom100icon, *tbzoominicon, *tbzoomouticon, *tbzoomwinicon;
FXIcon *tbtotrashicon, *tbdirbackicon, *tbdirforwardicon, *tbminixfeicon, *tbminixferooticon, *tbfiledialogicon/*, *tbbigarchaddicon*/;
FXIcon *tbswitchpanelsicon, *tbsyncpanelsicon, *tbnewlinkicon, *tbgreenbuttonicon, *tbgraybuttonicon, *tbcloseicon, *tbthrobicon, *tbthrobanimicon, *tbwebviewbgicon;
FXIcon *tbkeybindingsicon, *tbminikeybindingsicon, *tbfilerestoreicon, *tbrestore_bigicon, *tbvertpanelsicon, *tbhorzpanelsicon, *tbcomboarrowicon;



// Load all application icons as global variables
FXbool loadAppIcons(FXApp* app)
{
    FXbool success = true;

    // Icon path
    FXString iconpath = app->reg().readStringEntry("SETTINGS", "iconpath", DEFAULTICONPATH);

    // Load icons and set the success flag
    success = ((archaddicon = loadiconfile(app, iconpath, "archadd.png", app->getBackColor())) != NULL) & success;
    success = ((archexticon = loadiconfile(app, iconpath, "archext.png", app->getBackColor())) != NULL) & success;
    success = ((attribicon = loadiconfile(app, iconpath, "attrib.png", app->getBackColor())) != NULL) & success;
    success = ((bigattribicon = loadiconfile(app, iconpath, "bigattrib.png", app->getBackColor())) != NULL) & success;
    success = ((bigblockdevicon = loadiconfile(app, iconpath, "bigblockdev.png", app->getBackColor())) != NULL) & success;
    success = ((bigbrokenlinkicon = loadiconfile(app, iconpath, "bigbrokenlink.png", app->getBackColor())) != NULL) & success;
    success = ((bigcdromicon = loadiconfile(app, iconpath, "bigcdrom.png", app->getBackColor())) != NULL) & success;
    success = ((bigchardevicon = loadiconfile(app, iconpath, "bigchardev.png", app->getBackColor())) != NULL) & success;
    success = ((bigcompareicon = loadiconfile(app, iconpath, "bigcompare.png", app->getBackColor())) != NULL) & success;
    success = ((bigdocicon = loadiconfile(app, iconpath, "bigdoc.png", app->getBackColor())) != NULL) & success;
    success = ((bigexecicon = loadiconfile(app, iconpath, "bigexec.png", app->getBackColor())) != NULL) & success;
    success = ((bigfileopenicon = loadiconfile(app, iconpath, "bigfileopen.png", app->getBackColor())) != NULL) & success;
    success = ((bigfiltericon = loadiconfile(app, iconpath, "bigfilter.png", app->getBackColor())) != NULL) & success;
    success = ((bigfloppyicon = loadiconfile(app, iconpath, "bigfloppy.png", app->getBackColor())) != NULL) & success;
    success = ((bigfolderlockedicon = loadiconfile(app, iconpath, "bigfolderlocked.png", app->getBackColor())) != NULL) & success;
    success = ((bigfolderopenicon = loadiconfile(app, iconpath, "bigfolderopen.png", app->getBackColor())) != NULL) & success;
    success = ((bigfoldericon = loadiconfile(app, iconpath, "bigfolder.png", app->getBackColor())) != NULL) & success;
    success = ((bigfolderupicon = loadiconfile(app, iconpath, "bigfolderup.png", app->getBackColor())) != NULL) & success;
    success = ((bigharddiskicon = loadiconfile(app, iconpath, "bigharddisk.png", app->getBackColor())) != NULL) & success;
    success = ((bigiconsicon = loadiconfile(app, iconpath, "bigicons.png", app->getBackColor())) != NULL) & success;
    success = ((biglinkicon = loadiconfile(app, iconpath, "biglink.png", app->getBackColor())) != NULL) & success;
    success = ((bignewfileicon = loadiconfile(app, iconpath, "bignewfile.png", app->getBackColor())) != NULL) & success;
    success = ((bignewfoldericon = loadiconfile(app, iconpath, "bignewfolder.png", app->getBackColor())) != NULL) & success;
    success = ((bignewlinkicon = loadiconfile(app, iconpath, "bignewlink.png", app->getBackColor())) != NULL) & success;
    success = ((bignfsdriveicon = loadiconfile(app, iconpath, "bignfsdrive.png", app->getBackColor())) != NULL) & success;
    success = ((bignfsdriveumticon = loadiconfile(app, iconpath, "bignfsdriveumt.png", app->getBackColor())) != NULL) & success;
    success = ((bigpipeicon = loadiconfile(app, iconpath, "bigpipe.png", app->getBackColor())) != NULL) & success;
    success = ((bigsocketicon = loadiconfile(app, iconpath, "bigsocket.png", app->getBackColor())) != NULL) & success;
    success = ((bigzipicon = loadiconfile(app, iconpath, "bigzip.png", app->getBackColor())) != NULL) & success;
    success = ((cdromicon = loadiconfile(app, iconpath, "cdrom.png", app->getBackColor())) != NULL) & success;
    success = ((charticon = loadiconfile(app, iconpath, "chart.png", app->getBackColor())) != NULL) & success;
    success = ((closefileicon = loadiconfile(app, iconpath, "closefile.png", app->getBackColor())) != NULL) & success;
    success = ((clrbookicon = loadiconfile(app, iconpath, "clrbook.png", app->getBackColor())) != NULL) & success;
    success = ((colltreeicon = loadiconfile(app, iconpath, "colltree.png", app->getBackColor())) != NULL) & success;
    success = ((copy_bigicon = loadiconfile(app, iconpath, "copy_big.png", app->getBackColor())) != NULL) & success;
    success = ((copy_clpicon = loadiconfile(app, iconpath, "copy_clp.png", app->getBackColor())) != NULL) & success;
    success = ((cut_clpicon = loadiconfile(app, iconpath, "cut_clp.png", app->getBackColor())) != NULL) & success;
    success = ((delete_big_permicon = loadiconfile(app, iconpath, "delete_big_perm.png", app->getBackColor())) != NULL) & success;
    success = ((delete_bigicon = loadiconfile(app, iconpath, "delete_big.png", app->getBackColor())) != NULL) & success;
    success = ((deselicon = loadiconfile(app, iconpath, "desel.png", app->getBackColor())) != NULL) & success;
    success = ((detailsicon = loadiconfile(app, iconpath, "details.png", app->getBackColor())) != NULL) & success;
    success = ((dirupicon = loadiconfile(app, iconpath, "dirup.png", app->getBackColor())) != NULL) & success;
    success = ((editicon = loadiconfile(app, iconpath, "edit.png", app->getBackColor())) != NULL) & success;
    success = ((entericon = loadiconfile(app, iconpath, "enter.png", app->getBackColor())) != NULL) & success;
    success = ((errorbigicon = loadiconfile(app, iconpath, "errorbig.png", app->getBackColor())) != NULL) & success;
    success = ((exptreeicon = loadiconfile(app, iconpath, "exptree.png", app->getBackColor())) != NULL) & success;
    success = ((compareicon = loadiconfile(app, iconpath, "compare.png", app->getBackColor())) != NULL) & success;
    success = ((filedelete_permicon = loadiconfile(app, iconpath, "filedelete_perm.png", app->getBackColor())) != NULL) & success;
    success = ((filedeleteicon = loadiconfile(app, iconpath, "filedelete.png", app->getBackColor())) != NULL) & success;
    success = ((fileopenicon = loadiconfile(app, iconpath, "fileopen.png", app->getBackColor())) != NULL) & success;
    success = ((viewicon = loadiconfile(app, iconpath, "view.png", app->getBackColor())) != NULL) & success;
    success = ((filtericon = loadiconfile(app, iconpath, "filter.png", app->getBackColor())) != NULL) & success;
    success = ((find_againicon = loadiconfile(app, iconpath, "find_again.png", app->getBackColor())) != NULL) & success;
    success = ((fliplricon = loadiconfile(app, iconpath, "fliplr.png", app->getBackColor())) != NULL) & success;
    success = ((flipudicon = loadiconfile(app, iconpath, "flipud.png", app->getBackColor())) != NULL) & success;
    success = ((floppyicon = loadiconfile(app, iconpath, "floppy.png", app->getBackColor())) != NULL) & success;
    success = ((fontsicon = loadiconfile(app, iconpath, "fonts.png", app->getBackColor())) != NULL) & success;
    success = ((gotobigicon = loadiconfile(app, iconpath, "gotobig.png", app->getBackColor())) != NULL) & success;
    success = ((gotodiricon = loadiconfile(app, iconpath, "gotodir.png", app->getBackColor())) != NULL) & success;
    success = ((gotolineicon = loadiconfile(app, iconpath, "gotoline.png", app->getBackColor())) != NULL) & success;
    success = ((harddiskicon = loadiconfile(app, iconpath, "harddisk.png", app->getBackColor())) != NULL) & success;
    success = ((helpicon = loadiconfile(app, iconpath, "help.png", app->getBackColor())) != NULL) & success;
    success = ((hidehiddenicon = loadiconfile(app, iconpath, "hidehidden.png", app->getBackColor())) != NULL) & success;
    success = ((hidenumbersicon = loadiconfile(app, iconpath, "hidenumbers.png", app->getBackColor())) != NULL) & success;
    success = ((hidethumbicon = loadiconfile(app, iconpath, "hidethumb.png", app->getBackColor())) != NULL) & success;
    success = ((homeicon = loadiconfile(app, iconpath, "home.png", app->getBackColor())) != NULL) & success;
    success = ((infobigicon = loadiconfile(app, iconpath, "infobig.png", app->getBackColor())) != NULL) & success;
    success = ((invselicon = loadiconfile(app, iconpath, "invsel.png", app->getBackColor())) != NULL) & success;
    success = ((link_bigicon = loadiconfile(app, iconpath, "link_big.png", app->getBackColor())) != NULL) & success;
    success = ((locationicon = loadiconfile(app, iconpath, "location.png", app->getBackColor())) != NULL) & success;
    success = ((lowercaseicon = loadiconfile(app, iconpath, "lowercase.png", app->getBackColor())) != NULL) & success;
    success = ((maphosticon = loadiconfile(app, iconpath, "maphost.png", app->getBackColor())) != NULL) & success;
    success = ((miniappicon = loadiconfile(app, iconpath, "miniapp.png", app->getBackColor())) != NULL) & success;
    success = ((miniblockdevicon = loadiconfile(app, iconpath, "miniblockdev.png", app->getBackColor())) != NULL) & success;
    success = ((minibrokenlinkicon = loadiconfile(app, iconpath, "minibrokenlink.png", app->getBackColor())) != NULL) & success;
    success = ((minichardevicon = loadiconfile(app, iconpath, "minichardev.png", app->getBackColor())) != NULL) & success;
    success = ((minidocicon = loadiconfile(app, iconpath, "minidoc.png", app->getBackColor())) != NULL) & success;
    success = ((miniexecicon = loadiconfile(app, iconpath, "miniexec.png", app->getBackColor())) != NULL) & success;
    success = ((minifolderclosedicon = loadiconfile(app, iconpath, "minifolderclosed.png", app->getBackColor())) != NULL) & success;
    success = ((minifolderlockedicon = loadiconfile(app, iconpath, "minifolderlocked.png", app->getBackColor())) != NULL) & success;
    success = ((minifolderopenicon = loadiconfile(app, iconpath, "minifolderopen.png", app->getBackColor())) != NULL) & success;
    success = ((minifoldericon = loadiconfile(app, iconpath, "minifolder.png", app->getBackColor())) != NULL) & success;
    success = ((minifolderupicon = loadiconfile(app, iconpath, "minifolderup.png", app->getBackColor())) != NULL) & success;
    success = ((minilinkicon = loadiconfile(app, iconpath, "minilink.png", app->getBackColor())) != NULL) & success;
    success = ((minipipeicon = loadiconfile(app, iconpath, "minipipe.png", app->getBackColor())) != NULL) & success;
    success = ((minishellicon = loadiconfile(app, iconpath, "minishell.png", app->getBackColor())) != NULL) & success;
    success = ((minisocketicon = loadiconfile(app, iconpath, "minisocket.png", app->getBackColor())) != NULL) & success;
    success = ((move_bigicon = loadiconfile(app, iconpath, "move_big.png", app->getBackColor())) != NULL) & success;
    success = ((moveiticon = loadiconfile(app, iconpath, "moveit.png", app->getBackColor())) != NULL) & success;
    success = ((newfileicon = loadiconfile(app, iconpath, "newfile.png", app->getBackColor())) != NULL) & success;
    success = ((newfoldericon = loadiconfile(app, iconpath, "newfolder.png", app->getBackColor())) != NULL) & success;
    success = ((nfsdriveicon = loadiconfile(app, iconpath, "nfsdrive.png", app->getBackColor())) != NULL) & success;
    success = ((nfsdriveumticon = loadiconfile(app, iconpath, "nfsdriveumt.png", app->getBackColor())) != NULL) & success;
    success = ((onepanelicon = loadiconfile(app, iconpath, "onepanel.png", app->getBackColor())) != NULL) & success;
    success = ((packageicon = loadiconfile(app, iconpath, "package.png", app->getBackColor())) != NULL) & success;
    success = ((paste_clpicon = loadiconfile(app, iconpath, "paste_clp.png", app->getBackColor())) != NULL) & success;
    success = ((prefsicon = loadiconfile(app, iconpath, "prefs.png", app->getBackColor())) != NULL) & success;
    success = ((printbigicon = loadiconfile(app, iconpath, "printbig.png", app->getBackColor())) != NULL) & success;
    success = ((printicon = loadiconfile(app, iconpath, "print.png", app->getBackColor())) != NULL) & success;
    success = ((questionbigicon = loadiconfile(app, iconpath, "questionbig.png", app->getBackColor())) != NULL) & success;
    success = ((quiticon = loadiconfile(app, iconpath, "quit.png", app->getBackColor())) != NULL) & success;
    success = ((redoicon = loadiconfile(app, iconpath, "redo.png", app->getBackColor())) != NULL) & success;
    success = ((reloadicon = loadiconfile(app, iconpath, "reload.png", app->getBackColor())) != NULL) & success;
    success = ((renameiticon = loadiconfile(app, iconpath, "renameit.png", app->getBackColor())) != NULL) & success;
    success = ((replaceicon = loadiconfile(app, iconpath, "replace.png", app->getBackColor())) != NULL) & success;
    success = ((reverticon = loadiconfile(app, iconpath, "revert.png", app->getBackColor())) != NULL) & success;
    success = ((rotatelefticon = loadiconfile(app, iconpath, "rotateleft.png", app->getBackColor())) != NULL) & success;
    success = ((rotaterighticon = loadiconfile(app, iconpath, "rotateright.png", app->getBackColor())) != NULL) & success;
    success = ((runicon = loadiconfile(app, iconpath, "run.png", app->getBackColor())) != NULL) & success;
    success = ((saveasicon = loadiconfile(app, iconpath, "saveas.png", app->getBackColor())) != NULL) & success;
    success = ((savefileicon = loadiconfile(app, iconpath, "savefile.png", app->getBackColor())) != NULL) & success;
    success = ((searchnexticon = loadiconfile(app, iconpath, "searchnext.png", app->getBackColor())) != NULL) & success;
    success = ((searchicon = loadiconfile(app, iconpath, "search.png", app->getBackColor())) != NULL) & success;
    success = ((searchprevicon = loadiconfile(app, iconpath, "searchprev.png", app->getBackColor())) != NULL) & success;
    success = ((selallicon = loadiconfile(app, iconpath, "selall.png", app->getBackColor())) != NULL) & success;
    success = ((setbookicon = loadiconfile(app, iconpath, "setbook.png", app->getBackColor())) != NULL) & success;
    success = ((shellicon = loadiconfile(app, iconpath, "shell.png", app->getBackColor())) != NULL) & success;
    success = ((showhiddenicon = loadiconfile(app, iconpath, "showhidden.png", app->getBackColor())) != NULL) & success;
    success = ((shownumbersicon = loadiconfile(app, iconpath, "shownumbers.png", app->getBackColor())) != NULL) & success;
    success = ((showthumbicon = loadiconfile(app, iconpath, "showthumb.png", app->getBackColor())) != NULL) & success;
    success = ((smalliconsicon = loadiconfile(app, iconpath, "smallicons.png", app->getBackColor())) != NULL) & success;
    success = ((iconsmenuicon = loadiconfile(app, iconpath, "iconsmenu.png", app->getBackColor())) != NULL) & success;
    success = ((trash_full_bigicon = loadiconfile(app, iconpath, "trash_full_big.png", app->getBackColor())) != NULL) & success;
    success = ((trash_fullicon = loadiconfile(app, iconpath, "trash_full.png", app->getBackColor())) != NULL) & success;
    success = ((treeonepanelicon = loadiconfile(app, iconpath, "treeonepanel.png", app->getBackColor())) != NULL) & success;
    success = ((treetwopanelsicon = loadiconfile(app, iconpath, "treetwopanels.png", app->getBackColor())) != NULL) & success;
    success = ((twopanelsicon = loadiconfile(app, iconpath, "twopanels.png", app->getBackColor())) != NULL) & success;
    success = ((undoicon = loadiconfile(app, iconpath, "undo.png", app->getBackColor())) != NULL) & success;
    success = ((unmaphosticon = loadiconfile(app, iconpath, "unmaphost.png", app->getBackColor())) != NULL) & success;
    success = ((uppercaseicon = loadiconfile(app, iconpath, "uppercase.png", app->getBackColor())) != NULL) & success;
    success = ((warningbigicon = loadiconfile(app, iconpath, "warningbig.png", app->getBackColor())) != NULL) & success;
    success = ((workicon = loadiconfile(app, iconpath, "work.png", app->getBackColor())) != NULL) & success;
    success = ((wrapofficon = loadiconfile(app, iconpath, "wrapoff.png", app->getBackColor())) != NULL) & success;
    success = ((wraponicon = loadiconfile(app, iconpath, "wrapon.png", app->getBackColor())) != NULL) & success;
    success = ((xfeicon = loadiconfile(app, iconpath, "xfe.png", app->getBackColor())) != NULL) & success;
    success = ((realxfeicon = loadiconfile(app, iconpath, "xfe.png", 0)) != NULL) & success;
    success = ((xfiicon = loadiconfile(app, iconpath, "xfi.png", app->getBackColor())) != NULL) & success;
    success = ((xfpicon = loadiconfile(app, iconpath, "xfp.png", app->getBackColor())) != NULL) & success;
    success = ((xfwicon = loadiconfile(app, iconpath, "xfw.png", app->getBackColor())) != NULL) & success;
    success = ((zipicon = loadiconfile(app, iconpath, "zip.png", app->getBackColor())) != NULL) & success;
    success = ((zoom100icon = loadiconfile(app, iconpath, "zoom100.png", app->getBackColor())) != NULL) & success;
    success = ((zoominicon = loadiconfile(app, iconpath, "zoomin.png", app->getBackColor())) != NULL) & success;
    success = ((zoomouticon = loadiconfile(app, iconpath, "zoomout.png", app->getBackColor())) != NULL) & success;
    success = ((zoomwinicon = loadiconfile(app, iconpath, "zoomwin.png", app->getBackColor())) != NULL) & success;
    success = ((totrashicon = loadiconfile(app, iconpath, "totrash.png", app->getBackColor())) != NULL) & success;
    success = ((dirbackicon = loadiconfile(app, iconpath, "dirback.png", app->getBackColor())) != NULL) & success;
    success = ((dirforwardicon = loadiconfile(app, iconpath, "dirforward.png", app->getBackColor())) != NULL) & success;
    success = ((minixferooticon = loadiconfile(app, iconpath, "minixferoot.png", app->getBackColor())) != NULL) & success;
    success = ((minixfeicon = loadiconfile(app, iconpath, "minixfe.png", app->getBackColor())) != NULL) & success;
    success = ((filedialogicon = loadiconfile(app, iconpath, "filedialog.png", app->getBackColor())) != NULL) & success;
    success = ((bigarchaddicon = loadiconfile(app, iconpath, "bigarchadd.png", app->getBackColor())) != NULL) & success;
    success = ((switchpanelsicon = loadiconfile(app, iconpath, "switchpanels.png", app->getBackColor())) != NULL) & success;
    success = ((syncpanelsicon = loadiconfile(app, iconpath, "syncpanels.png", app->getBackColor())) != NULL) & success;
    success = ((newlinkicon = loadiconfile(app, iconpath, "newlink.png", app->getBackColor())) != NULL) & success;
    success = ((greenbuttonicon = loadiconfile(app, iconpath, "greenbutton.png", app->getBackColor())) != NULL) & success;
    success = ((graybuttonicon = loadiconfile(app, iconpath, "graybutton.png", app->getBackColor())) != NULL) & success;
    success = ((keybindingsicon = loadiconfile(app, iconpath, "keybindings.png", app->getBackColor())) != NULL) & success;
    success = ((minikeybindingsicon = loadiconfile(app, iconpath, "minikeybindings.png", app->getBackColor())) != NULL) & success;
    success = ((filerestoreicon = loadiconfile(app, iconpath, "filerestore.png", app->getBackColor())) != NULL) & success;
    success = ((restore_bigicon = loadiconfile(app, iconpath, "restore_big.png", app->getBackColor())) != NULL) & success;
    success = ((horzpanelsicon = loadiconfile(app, iconpath, "horzpanels.png", app->getBackColor())) != NULL) & success;
    success = ((vertpanelsicon = loadiconfile(app, iconpath, "vertpanels.png", app->getBackColor())) != NULL) & success;
    success = ((comboarrowicon = loadiconfile(app, iconpath, "comboarrow.png", app->getBackColor())) != NULL) & success;
    success = ((closeicon = loadiconfile(app, iconpath, "close.png", app->getBackColor())) != NULL) & success;
    success = ((throbicon = loadiconfile(app, iconpath, "throb.png", app->getBackColor())) != NULL) & success;
    success = ((throbanimicon = loadiconfile(app, iconpath, "throbanim.png", app->getBackColor())) != NULL) & success;
    success = ((webviewbgicon = loadiconfile(app, iconpath, "webviewbg.png", app->getBackColor())) != NULL) ; success;

    success = ((tbarchaddicon = loadiconfile(app, iconpath, "archadd.png", app->getBaseColor())) != NULL) & success;
    success = ((tbarchexticon = loadiconfile(app, iconpath, "archext.png", app->getBaseColor())) != NULL) & success;
    success = ((tbattribicon = loadiconfile(app, iconpath, "attrib.png", app->getBaseColor())) != NULL) & success;
 /* success = ((tbbigattribicon = loadiconfile(app, iconpath, "bigattrib.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigblockdevicon = loadiconfile(app, iconpath, "bigblockdev.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigbrokenlinkicon = loadiconfile(app, iconpath, "bigbrokenlink.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigcdromicon = loadiconfile(app, iconpath, "bigcdrom.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigchardevicon = loadiconfile(app, iconpath, "bigchardev.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigcompareicon = loadiconfile(app, iconpath, "bigcompare.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigdocicon = loadiconfile(app, iconpath, "bigdoc.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigexecicon = loadiconfile(app, iconpath, "bigexec.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigfileopenicon = loadiconfile(app, iconpath, "bigfileopen.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigfiltericon = loadiconfile(app, iconpath, "bigfilter.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigfloppyicon = loadiconfile(app, iconpath, "bigfloppy.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigfolderlockedicon = loadiconfile(app, iconpath, "bigfolderlocked.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigfolderopenicon = loadiconfile(app, iconpath, "bigfolderopen.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigfoldericon = loadiconfile(app, iconpath, "bigfolder.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigfolderupicon = loadiconfile(app, iconpath, "bigfolderup.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigharddiskicon = loadiconfile(app, iconpath, "bigharddisk.png", app->getBaseColor())) != NULL) & success; */
    success = ((tbbigiconsicon = loadiconfile(app, iconpath, "bigicons.png", app->getBaseColor())) != NULL) & success; /*
    success = ((tbbiglinkicon = loadiconfile(app, iconpath, "biglink.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbignewfileicon = loadiconfile(app, iconpath, "bignewfile.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbignewfoldericon = loadiconfile(app, iconpath, "bignewfolder.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbignewlinkicon = loadiconfile(app, iconpath, "bignewlink.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbignfsdriveicon = loadiconfile(app, iconpath, "bignfsdrive.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbignfsdriveumticon = loadiconfile(app, iconpath, "bignfsdriveumt.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigpipeicon = loadiconfile(app, iconpath, "bigpipe.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigsocketicon = loadiconfile(app, iconpath, "bigsocket.png", app->getBaseColor())) != NULL) & success;
    success = ((tbbigzipicon = loadiconfile(app, iconpath, "bigzip.png", app->getBaseColor())) != NULL) & success; */
    success = ((tbcdromicon = loadiconfile(app, iconpath, "cdrom.png", app->getBaseColor())) != NULL) & success;
    success = ((tbcharticon = loadiconfile(app, iconpath, "chart.png", app->getBaseColor())) != NULL) & success;
    success = ((tbclosefileicon = loadiconfile(app, iconpath, "closefile.png", app->getBaseColor())) != NULL) & success;
    success = ((tbclrbookicon = loadiconfile(app, iconpath, "clrbook.png", app->getBaseColor())) != NULL) & success;
    success = ((tbcolltreeicon = loadiconfile(app, iconpath, "colltree.png", app->getBaseColor())) != NULL) & success;
    success = ((tbcopy_bigicon = loadiconfile(app, iconpath, "copy_big.png", app->getBaseColor())) != NULL) & success;
    success = ((tbcopy_clpicon = loadiconfile(app, iconpath, "copy_clp.png", app->getBaseColor())) != NULL) & success;
    success = ((tbcut_clpicon = loadiconfile(app, iconpath, "cut_clp.png", app->getBaseColor())) != NULL) & success;
    success = ((tbdelete_big_permicon = loadiconfile(app, iconpath, "delete_big_perm.png", app->getBaseColor())) != NULL) & success;
    success = ((tbdelete_bigicon = loadiconfile(app, iconpath, "delete_big.png", app->getBaseColor())) != NULL) & success;
    success = ((tbdeselicon = loadiconfile(app, iconpath, "desel.png", app->getBaseColor())) != NULL) & success;
    success = ((tbdetailsicon = loadiconfile(app, iconpath, "details.png", app->getBaseColor())) != NULL) & success;
    success = ((tbdirupicon = loadiconfile(app, iconpath, "dirup.png", app->getBaseColor())) != NULL) & success;
    success = ((tbediticon = loadiconfile(app, iconpath, "edit.png", app->getBaseColor())) != NULL) & success;
    success = ((tbentericon = loadiconfile(app, iconpath, "enter.png", app->getBaseColor())) != NULL) & success;
    success = ((tberrorbigicon = loadiconfile(app, iconpath, "errorbig.png", app->getBaseColor())) != NULL) & success;
    success = ((tbexptreeicon = loadiconfile(app, iconpath, "exptree.png", app->getBaseColor())) != NULL) & success;
    success = ((tbcompareicon = loadiconfile(app, iconpath, "compare.png", app->getBaseColor())) != NULL) & success;
    success = ((tbfiledelete_permicon = loadiconfile(app, iconpath, "filedelete_perm.png", app->getBaseColor())) != NULL) & success;
    success = ((tbfiledeleteicon = loadiconfile(app, iconpath, "filedelete.png", app->getBaseColor())) != NULL) & success;
    success = ((tbfileopenicon = loadiconfile(app, iconpath, "fileopen.png", app->getBaseColor())) != NULL) & success;
    success = ((tbviewicon = loadiconfile(app, iconpath, "view.png", app->getBaseColor())) != NULL) & success;
    success = ((tbfiltericon = loadiconfile(app, iconpath, "filter.png", app->getBaseColor())) != NULL) & success;
    success = ((tbfind_againicon = loadiconfile(app, iconpath, "find_again.png", app->getBaseColor())) != NULL) & success;
    success = ((tbfliplricon = loadiconfile(app, iconpath, "fliplr.png", app->getBaseColor())) != NULL) & success;
    success = ((tbflipudicon = loadiconfile(app, iconpath, "flipud.png", app->getBaseColor())) != NULL) & success;
    success = ((tbfloppyicon = loadiconfile(app, iconpath, "floppy.png", app->getBaseColor())) != NULL) & success;
    success = ((tbfontsicon = loadiconfile(app, iconpath, "fonts.png", app->getBaseColor())) != NULL) & success;
    success = ((tbgotobigicon = loadiconfile(app, iconpath, "gotobig.png", app->getBaseColor())) != NULL) & success;
    success = ((tbgotodiricon = loadiconfile(app, iconpath, "gotodir.png", app->getBaseColor())) != NULL) & success;
    success = ((tbgotolineicon = loadiconfile(app, iconpath, "gotoline.png", app->getBaseColor())) != NULL) & success;
    success = ((tbharddiskicon = loadiconfile(app, iconpath, "harddisk.png", app->getBaseColor())) != NULL) & success;
    success = ((tbhelpicon = loadiconfile(app, iconpath, "help.png", app->getBaseColor())) != NULL) & success;
    success = ((tbhidehiddenicon = loadiconfile(app, iconpath, "hidehidden.png", app->getBaseColor())) != NULL) & success;
    success = ((tbhidenumbersicon = loadiconfile(app, iconpath, "hidenumbers.png", app->getBaseColor())) != NULL) & success;
    success = ((tbhidethumbicon = loadiconfile(app, iconpath, "hidethumb.png", app->getBaseColor())) != NULL) & success;
    success = ((tbhomeicon = loadiconfile(app, iconpath, "home.png", app->getBaseColor())) != NULL) & success;
    success = ((tbinfobigicon = loadiconfile(app, iconpath, "infobig.png", app->getBaseColor())) != NULL) & success;
    success = ((tbinvselicon = loadiconfile(app, iconpath, "invsel.png", app->getBaseColor())) != NULL) & success;
    success = ((tblink_bigicon = loadiconfile(app, iconpath, "link_big.png", app->getBaseColor())) != NULL) & success;
    success = ((tblocationicon = loadiconfile(app, iconpath, "location.png", app->getBaseColor())) != NULL) & success;
    success = ((tblowercaseicon = loadiconfile(app, iconpath, "lowercase.png", app->getBaseColor())) != NULL) & success;
    success = ((tbmaphosticon = loadiconfile(app, iconpath, "maphost.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminiappicon = loadiconfile(app, iconpath, "miniapp.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminiblockdevicon = loadiconfile(app, iconpath, "miniblockdev.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminibrokenlinkicon = loadiconfile(app, iconpath, "minibrokenlink.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminichardevicon = loadiconfile(app, iconpath, "minichardev.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminidocicon = loadiconfile(app, iconpath, "minidoc.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminiexecicon = loadiconfile(app, iconpath, "miniexec.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminifolderclosedicon = loadiconfile(app, iconpath, "minifolderclosed.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminifolderlockedicon = loadiconfile(app, iconpath, "minifolderlocked.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminifolderopenicon = loadiconfile(app, iconpath, "minifolderopen.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminifoldericon = loadiconfile(app, iconpath, "minifolder.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminifolderupicon = loadiconfile(app, iconpath, "minifolderup.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminilinkicon = loadiconfile(app, iconpath, "minilink.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminipipeicon = loadiconfile(app, iconpath, "minipipe.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminishellicon = loadiconfile(app, iconpath, "minishell.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminisocketicon = loadiconfile(app, iconpath, "minisocket.png", app->getBaseColor())) != NULL) & success;
    success = ((tbmove_bigicon = loadiconfile(app, iconpath, "move_big.png", app->getBaseColor())) != NULL) & success;
    success = ((tbmoveiticon = loadiconfile(app, iconpath, "moveit.png", app->getBaseColor())) != NULL) & success;
    success = ((tbnewfileicon = loadiconfile(app, iconpath, "newfile.png", app->getBaseColor())) != NULL) & success;
    success = ((tbnewfoldericon = loadiconfile(app, iconpath, "newfolder.png", app->getBaseColor())) != NULL) & success;
    success = ((tbnfsdriveicon = loadiconfile(app, iconpath, "nfsdrive.png", app->getBaseColor())) != NULL) & success;
    success = ((tbnfsdriveumticon = loadiconfile(app, iconpath, "nfsdriveumt.png", app->getBaseColor())) != NULL) & success;
    success = ((tbonepanelicon = loadiconfile(app, iconpath, "onepanel.png", app->getBaseColor())) != NULL) & success;
    success = ((tbpackageicon = loadiconfile(app, iconpath, "package.png", app->getBaseColor())) != NULL) & success;
    success = ((tbpaste_clpicon = loadiconfile(app, iconpath, "paste_clp.png", app->getBaseColor())) != NULL) & success;
    success = ((tbprefsicon = loadiconfile(app, iconpath, "prefs.png", app->getBaseColor())) != NULL) & success;
    success = ((tbprintbigicon = loadiconfile(app, iconpath, "printbig.png", app->getBaseColor())) != NULL) & success;
    success = ((tbprinticon = loadiconfile(app, iconpath, "print.png", app->getBaseColor())) != NULL) & success;
    success = ((tbquestionbigicon = loadiconfile(app, iconpath, "questionbig.png", app->getBaseColor())) != NULL) & success;
    success = ((tbquiticon = loadiconfile(app, iconpath, "quit.png", app->getBaseColor())) != NULL) & success;
    success = ((tbredoicon = loadiconfile(app, iconpath, "redo.png", app->getBaseColor())) != NULL) & success;
    success = ((tbreloadicon = loadiconfile(app, iconpath, "reload.png", app->getBaseColor())) != NULL) & success;
    success = ((tbrenameiticon = loadiconfile(app, iconpath, "renameit.png", app->getBaseColor())) != NULL) & success;
    success = ((tbreplaceicon = loadiconfile(app, iconpath, "replace.png", app->getBaseColor())) != NULL) & success;
    success = ((tbreverticon = loadiconfile(app, iconpath, "revert.png", app->getBaseColor())) != NULL) & success;
    success = ((tbrotatelefticon = loadiconfile(app, iconpath, "rotateleft.png", app->getBaseColor())) != NULL) & success;
    success = ((tbrotaterighticon = loadiconfile(app, iconpath, "rotateright.png", app->getBaseColor())) != NULL) & success;
    success = ((tbrunicon = loadiconfile(app, iconpath, "run.png", app->getBaseColor())) != NULL) & success;
    success = ((tbsaveasicon = loadiconfile(app, iconpath, "saveas.png", app->getBaseColor())) != NULL) & success;
    success = ((tbsavefileicon = loadiconfile(app, iconpath, "savefile.png", app->getBaseColor())) != NULL) & success;
    success = ((tbsearchnexticon = loadiconfile(app, iconpath, "searchnext.png", app->getBaseColor())) != NULL) & success;
    success = ((tbsearchicon = loadiconfile(app, iconpath, "search.png", app->getBaseColor())) != NULL) & success;
    success = ((tbsearchprevicon = loadiconfile(app, iconpath, "searchprev.png", app->getBaseColor())) != NULL) & success;
    success = ((tbselallicon = loadiconfile(app, iconpath, "selall.png", app->getBaseColor())) != NULL) & success;
    success = ((tbsetbookicon = loadiconfile(app, iconpath, "setbook.png", app->getBaseColor())) != NULL) & success;
    success = ((tbshellicon = loadiconfile(app, iconpath, "shell.png", app->getBaseColor())) != NULL) & success;
    success = ((tbshowhiddenicon = loadiconfile(app, iconpath, "showhidden.png", app->getBaseColor())) != NULL) & success;
    success = ((tbshownumbersicon = loadiconfile(app, iconpath, "shownumbers.png", app->getBaseColor())) != NULL) & success;
    success = ((tbshowthumbicon = loadiconfile(app, iconpath, "showthumb.png", app->getBaseColor())) != NULL) & success;
    success = ((tbsmalliconsicon = loadiconfile(app, iconpath, "smallicons.png", app->getBaseColor())) != NULL) & success;
    success = ((tbiconsmenuicon = loadiconfile(app, iconpath, "iconsmenu.png", app->getBaseColor())) != NULL) & success;
    success = ((tbtrash_full_bigicon = loadiconfile(app, iconpath, "trash_full_big.png", app->getBaseColor())) != NULL) & success;
    success = ((tbtrash_fullicon = loadiconfile(app, iconpath, "trash_full.png", app->getBaseColor())) != NULL) & success;
    success = ((tbtreeonepanelicon = loadiconfile(app, iconpath, "treeonepanel.png", app->getBaseColor())) != NULL) & success;
    success = ((tbtreetwopanelsicon = loadiconfile(app, iconpath, "treetwopanels.png", app->getBaseColor())) != NULL) & success;
    success = ((tbtwopanelsicon = loadiconfile(app, iconpath, "twopanels.png", app->getBaseColor())) != NULL) & success;
    success = ((tbundoicon = loadiconfile(app, iconpath, "undo.png", app->getBaseColor())) != NULL) & success;
    success = ((tbunmaphosticon = loadiconfile(app, iconpath, "unmaphost.png", app->getBaseColor())) != NULL) & success;
    success = ((tbuppercaseicon = loadiconfile(app, iconpath, "uppercase.png", app->getBaseColor())) != NULL) & success;
    success = ((tbwarningbigicon = loadiconfile(app, iconpath, "warningbig.png", app->getBaseColor())) != NULL) & success;
    success = ((tbworkicon = loadiconfile(app, iconpath, "work.png", app->getBaseColor())) != NULL) & success;
    success = ((tbwrapofficon = loadiconfile(app, iconpath, "wrapoff.png", app->getBaseColor())) != NULL) & success;
    success = ((tbwraponicon = loadiconfile(app, iconpath, "wrapon.png", app->getBaseColor())) != NULL) & success;
    success = ((tbxfeicon = loadiconfile(app, iconpath, "xfe.png", app->getBaseColor())) != NULL) & success;
    success = ((tbxfiicon = loadiconfile(app, iconpath, "xfi.png", app->getBaseColor())) != NULL) & success;
    success = ((tbxfpicon = loadiconfile(app, iconpath, "xfp.png", app->getBaseColor())) != NULL) & success;
    success = ((tbxfwicon = loadiconfile(app, iconpath, "xfw.png", app->getBaseColor())) != NULL) & success;
    success = ((tbzipicon = loadiconfile(app, iconpath, "zip.png", app->getBaseColor())) != NULL) & success;
    success = ((tbzoom100icon = loadiconfile(app, iconpath, "zoom100.png", app->getBaseColor())) != NULL) & success;
    success = ((tbzoominicon = loadiconfile(app, iconpath, "zoomin.png", app->getBaseColor())) != NULL) & success;
    success = ((tbzoomouticon = loadiconfile(app, iconpath, "zoomout.png", app->getBaseColor())) != NULL) & success;
    success = ((tbzoomwinicon = loadiconfile(app, iconpath, "zoomwin.png", app->getBaseColor())) != NULL) & success;
    success = ((tbtotrashicon = loadiconfile(app, iconpath, "totrash.png", app->getBaseColor())) != NULL) & success;
    success = ((tbdirbackicon = loadiconfile(app, iconpath, "dirback.png", app->getBaseColor())) != NULL) & success;
    success = ((tbdirforwardicon = loadiconfile(app, iconpath, "dirforward.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminixferooticon = loadiconfile(app, iconpath, "minixferoot.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminixfeicon = loadiconfile(app, iconpath, "minixfe.png", app->getBaseColor())) != NULL) & success;
    success = ((tbfiledialogicon = loadiconfile(app, iconpath, "filedialog.png", app->getBaseColor())) != NULL) & success;
    // success = ((tbbigarchaddicon = loadiconfile(app, iconpath, "bigarchadd.png", app->getBaseColor())) != NULL) & success;
    success = ((tbswitchpanelsicon = loadiconfile(app, iconpath, "switchpanels.png", app->getBaseColor())) != NULL) & success;
    success = ((tbsyncpanelsicon = loadiconfile(app, iconpath, "syncpanels.png", app->getBaseColor())) != NULL) & success;
    success = ((tbnewlinkicon = loadiconfile(app, iconpath, "newlink.png", app->getBaseColor())) != NULL) & success;
    success = ((tbgreenbuttonicon = loadiconfile(app, iconpath, "greenbutton.png", app->getBaseColor())) != NULL) & success;
    success = ((tbgraybuttonicon = loadiconfile(app, iconpath, "graybutton.png", app->getBaseColor())) != NULL) & success;
    success = ((tbkeybindingsicon = loadiconfile(app, iconpath, "keybindings.png", app->getBaseColor())) != NULL) & success;
    success = ((tbminikeybindingsicon = loadiconfile(app, iconpath, "minikeybindings.png", app->getBaseColor())) != NULL) & success;
    success = ((tbfilerestoreicon = loadiconfile(app, iconpath, "filerestore.png", app->getBaseColor())) != NULL) & success;
    success = ((tbrestore_bigicon = loadiconfile(app, iconpath, "restore_big.png", app->getBaseColor())) != NULL) & success;
    success = ((tbhorzpanelsicon = loadiconfile(app, iconpath, "horzpanels.png", app->getBaseColor())) != NULL) & success;
    success = ((tbvertpanelsicon = loadiconfile(app, iconpath, "vertpanels.png", app->getBaseColor())) != NULL) & success;
    success = ((tbcomboarrowicon = loadiconfile(app, iconpath, "comboarrow.png", app->getBaseColor())) != NULL) & success;
    success = ((tbcloseicon = loadiconfile(app, iconpath, "close.png", app->getBaseColor())) != NULL) & success;
    success = ((tbthrobicon = loadiconfile(app, iconpath, "throb.png", app->getBaseColor())) != NULL) & success;
    success = ((tbthrobanimicon = loadiconfile(app, iconpath, "throbanim.png", app->getBaseColor())) != NULL) & success;
    success = ((tbwebviewbgicon = loadiconfile(app, iconpath, "webviewbg.png", app->getBaseColor())) != NULL) & success;
    success = ((webviewxp = loadiconfile(app, iconpath, "xpwv.png", app->getBaseColor())) != NULL) & success;

    return(success);
}
// Global icons for all applications

#include <iostream>
#include "config.h"
#include "i18n.h"

#include <fx.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "xfeutils.h"
#include "icons.h"


// Icons (global variables)

FXIcon *archaddicon, *archexticon, *attribicon, *bigattribicon, *bigblockdevicon, *bigbrokenlinkicon, *bigcdromicon, *bigchardevicon;
FXIcon *bigcompareicon, *bigdocicon, *bigexecicon, *bigfileopenicon, *bigfiltericon, *bigfloppyicon, *bigfolderlockedicon;
FXIcon *bigfolderopenicon, *bigfoldericon, *bigfolderupicon, *bigharddiskicon, *bigiconsicon, *biglinkicon, *bignewfileicon;
FXIcon *bignewfoldericon, *bignewlinkicon, *bignfsdriveicon;
FXIcon *bignfsdriveumticon, *bigpipeicon, *bigsocketicon, *bigzipicon, *cdromicon, *charticon;
FXIcon *closefileicon, *clrbookicon, *collfoldericon, *copy_bigicon, *colltreeicon;
FXIcon *copy_clpicon, *cut_clpicon, *delete_big_permicon, *delete_bigicon, *deselicon, *detailsicon;
FXIcon *dirupicon, *editicon, *entericon, *errorbigicon, *exptreeicon, *compareicon;
FXIcon *filedelete_permicon, *filedeleteicon, *fileopenicon;
FXIcon *viewicon, *filtericon, *find_againicon, *fliplricon, *flipudicon, *floppyicon;
FXIcon *fontsicon, *gotobigicon, *gotodiricon, *gotolineicon, *harddiskicon, *helpicon, *hidehiddenicon;
FXIcon *hidenumbersicon, *hidethumbicon, *homeicon, *infobigicon, *invselicon, *link_bigicon;
FXIcon *locationicon, *lowercaseicon, *maphosticon, *miniappicon, *miniblockdevicon, *minibrokenlinkicon;
FXIcon *minichardevicon, *minidocicon, *miniexecicon, *minifolderclosedicon;
FXIcon *minifolderlockedicon, *minifolderopenicon, *minifoldericon, *minifolderupicon, *minilinkicon;
FXIcon *minipipeicon, *minishellicon, *minisocketicon;
FXIcon *move_bigicon, *moveiticon, *newfileicon, *newfoldericon, *nfsdriveicon, *nfsdriveumticon;
FXIcon *onepanelicon, *packageicon, *paste_clpicon, *prefsicon, *printbigicon, *printicon;
FXIcon *questionbigicon, *quiticon, *redoicon, *reloadicon, *renameiticon, *replaceicon;
FXIcon *reverticon, *rotatelefticon, *rotaterighticon, *runicon, *saveasicon, *savefileicon;
FXIcon *searchnexticon, *searchicon, *searchprevicon, *selallicon, *setbookicon, *shellicon;
FXIcon *showhiddenicon, *shownumbersicon, *showthumbicon, *smalliconsicon, *iconsmenuicon;
FXIcon *trash_full_bigicon, *trash_fullicon, *treeonepanelicon, *treetwopanelsicon, *twopanelsicon;
FXIcon *undoicon, *unmaphosticon, *uppercaseicon, *warningbigicon, *workicon, *wrapofficon, *wraponicon, *xfeicon, *realxfeicon, *xfiicon;
FXIcon *xfpicon, *xfwicon, *zipicon, *zoom100icon, *zoominicon, *zoomouticon, *zoomwinicon;
FXIcon *totrashicon, *dirbackicon, *dirforwardicon, *minixfeicon, *minixferooticon, *filedialogicon, *bigarchaddicon;
FXIcon *switchpanelsicon, *syncpanelsicon, *newlinkicon, *greenbuttonicon, *graybuttonicon, *closeicon, *throbicon, *throbanimicon, *webviewbgicon;
FXIcon *keybindingsicon, *minikeybindingsicon, *filerestoreicon, *restore_bigicon, *vertpanelsicon, *horzpanelsicon, *comboarrowicon;

FXIcon *tbarchaddicon, *tbarchexticon, *tbattribicon/*, *tbbigattribicon, *tbbigblockdevicon, *tbbigbrokenlinkicon, *tbbigcdromicon, *tbbigchardevicon */;
//FXIcon *tbbigcompareicon, *tbbigdocicon, *tbbigexecicon, *tbbigfileopenicon, *tbbigfiltericon, *tbbigfloppyicon, *tbbigfolderlockedicon;
FXIcon /**tbbigfolderopenicon, *tbbigfoldericon, *tbbigfolderupicon, *tbbigharddiskicon, */*tbbigiconsicon/*, *tbbiglinkicon, *tbbignewfileicon*/;
//FXIcon *tbbignewfoldericon, *tbbignewlinkicon, *tbbignfsdriveicon;
FXIcon /* *tbbignfsdriveumticon, *tbbigpipeicon, *tbbigsocketicon, *tbbigzipicon, */ *tbcdromicon, *tbcharticon, *webviewxp;
FXIcon *tbclosefileicon, *tbclrbookicon, *tbcollfoldericon, *tbcopy_bigicon, *tbcolltreeicon;
FXIcon *tbcopy_clpicon, *tbcut_clpicon, *tbdelete_big_permicon, *tbdelete_bigicon, *tbdeselicon, *tbdetailsicon;
FXIcon *tbdirupicon, *tbediticon, *tbentericon, *tberrorbigicon, *tbexptreeicon, *tbcompareicon;
FXIcon *tbfiledelete_permicon, *tbfiledeleteicon, *tbfileopenicon;
FXIcon *tbviewicon, *tbfiltericon, *tbfind_againicon, *tbfliplricon, *tbflipudicon, *tbfloppyicon;
FXIcon *tbfontsicon, *tbgotobigicon, *tbgotodiricon, *tbgotolineicon, *tbharddiskicon, *tbhelpicon, *tbhidehiddenicon;
FXIcon *tbhidenumbersicon, *tbhidethumbicon, *tbhomeicon, *tbinfobigicon, *tbinvselicon, *tblink_bigicon;
FXIcon *tblocationicon, *tblowercaseicon, *tbmaphosticon, *tbminiappicon, *tbminiblockdevicon, *tbminibrokenlinkicon;
FXIcon *tbminichardevicon, *tbminidocicon, *tbminiexecicon, *tbminifolderclosedicon;
FXIcon *tbminifolderlockedicon, *tbminifolderopenicon, *tbminifoldericon, *tbminifolderupicon, *tbminilinkicon;
FXIcon *tbminipipeicon, *tbminishellicon, *tbminisocketicon;
FXIcon *tbmove_bigicon, *tbmoveiticon, *tbnewfileicon, *tbnewfoldericon, *tbnfsdriveicon, *tbnfsdriveumticon;
FXIcon *tbonepanelicon, *tbpackageicon, *tbpaste_clpicon, *tbprefsicon, *tbprintbigicon, *tbprinticon;
FXIcon *tbquestionbigicon, *tbquiticon, *tbredoicon, *tbreloadicon, *tbrenameiticon, *tbreplaceicon;
FXIcon *tbreverticon, *tbrotatelefticon, *tbrotaterighticon, *tbrunicon, *tbsaveasicon, *tbsavefileicon;
FXIcon *tbsearchnexticon, *tbsearchicon, *tbsearchprevicon, *tbselallicon, *tbsetbookicon, *tbshellicon;
FXIcon *tbshowhiddenicon, *tbshownumbersicon, *tbshowthumbicon, *tbsmalliconsicon, *tbiconsmenuicon;
FXIcon *tbtrash_full_bigicon, *tbtrash_fullicon, *tbtreeonepanelicon, *tbtreetwopanelsicon, *tbtwopanelsicon;
FXIcon *tbundoicon, *tbunmaphosticon, *tbuppercaseicon, *tbwarningbigicon, *tbworkicon, *tbwrapofficon, *tbwraponicon, *tbxfeicon, *tbxfiicon;
FXIcon *tbxfpicon, *tbxfwicon, *tbzipicon, *tbzoom100icon, *tbzoominicon, *tbzoomouticon, *tbzoomwinicon;
FXIcon *tbtotrashicon, *tbdirbackicon, *tbdirforwardicon, *tbminixfeicon, *tbminixferooticon, *tbfiledialogicon/*, *tbbigarchaddicon*/;
FXIcon *tbswitchpanelsicon, *tbsyncpanelsicon, *tbnewlinkicon, *tbgreenbuttonicon, *tbgraybuttonicon, *tbcloseicon, *tbthrobicon, *tbthrobanimicon, *tbwebviewbgicon;
FXIcon *tbkeybindingsicon, *tbminikeybindingsicon, *tbfilerestoreicon, *tbrestore_bigicon, *tbvertpanelsicon, *tbhorzpanelsicon, *tbcomboarrowicon, *tbcomputericon;
FXIcon *resizecorner, *arrowicon;


const FXString ext = ".png";

// Load all application icons as global variables
FXbool loadAppIcons(FXApp* app)
{
    FXbool success = true;
    FXColor iconhilitecolor = app->getHiliteColor();
    FXColor iconshadowcolor = app->getShadowColor();
    FXColor iconforecolor = app->getForeColor();
    // FXColor iconforecolor = app->getForeColor();
    FXColor backcolor = app->getBackColor();
    FXColor basecolor = app->getBaseColor();

    // Icon path
    FXString iconpath = app->reg().readStringEntry("SETTINGS", "iconpath", DEFAULTICONPATH);

    // Load icons and set the success flag
    success = ((archaddicon = loadiconfile(app, iconpath, "archadd" + ext, backcolor)) != NULL) & success;
    success = ((archexticon = loadiconfile(app, iconpath, "archext" + ext, backcolor)) != NULL) & success;
    success = ((attribicon = loadiconfile(app, iconpath, "attrib" + ext, backcolor)) != NULL) & success;
    success = ((bigattribicon = loadiconfile(app, iconpath, "bigattrib" + ext, backcolor)) != NULL) & success;
    success = ((bigblockdevicon = loadiconfile(app, iconpath, "bigblockdev" + ext, backcolor)) != NULL) & success;
    success = ((bigbrokenlinkicon = loadiconfile(app, iconpath, "bigbrokenlink" + ext, backcolor)) != NULL) & success;
    success = ((bigcdromicon = loadiconfile(app, iconpath, "bigcdrom" + ext, backcolor)) != NULL) & success;
    success = ((bigchardevicon = loadiconfile(app, iconpath, "bigchardev" + ext, backcolor)) != NULL) & success;
    success = ((bigcompareicon = loadiconfile(app, iconpath, "bigcompare" + ext, backcolor)) != NULL) & success;
    success = ((bigdocicon = loadiconfile(app, iconpath, "bigdoc" + ext, backcolor)) != NULL) & success;
    success = ((bigexecicon = loadiconfile(app, iconpath, "bigexec" + ext, backcolor)) != NULL) & success;
    success = ((bigfileopenicon = loadiconfile(app, iconpath, "bigfileopen" + ext, backcolor)) != NULL) & success;
    success = ((bigfiltericon = loadiconfile(app, iconpath, "bigfilter" + ext, backcolor)) != NULL) & success;
    success = ((bigfloppyicon = loadiconfile(app, iconpath, "bigfloppy" + ext, backcolor)) != NULL) & success;
    success = ((bigfolderlockedicon = loadiconfile(app, iconpath, "bigfolderlocked" + ext, backcolor)) != NULL) & success;
    success = ((bigfolderopenicon = loadiconfile(app, iconpath, "bigfolderopen" + ext, backcolor)) != NULL) & success;
    success = ((bigfoldericon = loadiconfile(app, iconpath, "bigfolder" + ext, backcolor)) != NULL) & success;
    success = ((bigfolderupicon = loadiconfile(app, iconpath, "bigfolderup" + ext, backcolor)) != NULL) & success;
    success = ((bigharddiskicon = loadiconfile(app, iconpath, "bigharddisk" + ext, backcolor)) != NULL) & success;
    success = ((bigiconsicon = loadiconfile(app, iconpath, "bigicons" + ext, backcolor)) != NULL) & success;
    success = ((biglinkicon = loadiconfile(app, iconpath, "biglink" + ext, backcolor)) != NULL) & success;
    success = ((bignewfileicon = loadiconfile(app, iconpath, "bignewfile" + ext, backcolor)) != NULL) & success;
    success = ((bignewfoldericon = loadiconfile(app, iconpath, "bignewfolder" + ext, backcolor)) != NULL) & success;
    success = ((bignewlinkicon = loadiconfile(app, iconpath, "bignewlink" + ext, backcolor)) != NULL) & success;
    success = ((bignfsdriveicon = loadiconfile(app, iconpath, "bignfsdrive" + ext, backcolor)) != NULL) & success;
    success = ((bignfsdriveumticon = loadiconfile(app, iconpath, "bignfsdriveumt" + ext, backcolor)) != NULL) & success;
    success = ((bigpipeicon = loadiconfile(app, iconpath, "bigpipe" + ext, backcolor)) != NULL) & success;
    success = ((bigsocketicon = loadiconfile(app, iconpath, "bigsocket" + ext, backcolor)) != NULL) & success;
    success = ((bigzipicon = loadiconfile(app, iconpath, "bigzip" + ext, backcolor)) != NULL) & success;
    success = ((cdromicon = loadiconfile(app, iconpath, "cdrom" + ext, backcolor)) != NULL) & success;
    success = ((charticon = loadiconfile(app, iconpath, "chart" + ext, backcolor)) != NULL) & success;
    success = ((closefileicon = loadiconfile(app, iconpath, "closefile" + ext, backcolor)) != NULL) & success;
    success = ((clrbookicon = loadiconfile(app, iconpath, "clrbook" + ext, backcolor)) != NULL) & success;
    success = ((colltreeicon = loadiconfile(app, iconpath, "colltree" + ext, backcolor)) != NULL) & success;
    success = ((copy_bigicon = loadiconfile(app, iconpath, "copy_big" + ext, backcolor)) != NULL) & success;
    success = ((copy_clpicon = loadiconfile(app, iconpath, "copy_clp" + ext, backcolor)) != NULL) & success;
    success = ((cut_clpicon = loadiconfile(app, iconpath, "cut_clp" + ext, backcolor)) != NULL) & success;
    success = ((delete_big_permicon = loadiconfile(app, iconpath, "delete_big_perm" + ext, backcolor)) != NULL) & success;
    success = ((delete_bigicon = loadiconfile(app, iconpath, "delete_big" + ext, backcolor)) != NULL) & success;
    success = ((deselicon = loadiconfile(app, iconpath, "desel" + ext, backcolor)) != NULL) & success;
    success = ((detailsicon = loadiconfile(app, iconpath, "details" + ext, backcolor)) != NULL) & success;
    success = ((dirupicon = loadiconfile(app, iconpath, "dirup" + ext, backcolor)) != NULL) & success;
    success = ((editicon = loadiconfile(app, iconpath, "edit" + ext, backcolor)) != NULL) & success;
    success = ((entericon = loadiconfile(app, iconpath, "enter" + ext, backcolor)) != NULL) & success;
    success = ((errorbigicon = loadiconfile(app, iconpath, "errorbig" + ext, backcolor)) != NULL) & success;
    success = ((exptreeicon = loadiconfile(app, iconpath, "exptree" + ext, backcolor)) != NULL) & success;
    success = ((compareicon = loadiconfile(app, iconpath, "compare" + ext, backcolor)) != NULL) & success;
    success = ((filedelete_permicon = loadiconfile(app, iconpath, "filedelete_perm" + ext, backcolor)) != NULL) & success;
    success = ((filedeleteicon = loadiconfile(app, iconpath, "filedelete" + ext, backcolor)) != NULL) & success;
    success = ((fileopenicon = loadiconfile(app, iconpath, "fileopen" + ext, backcolor)) != NULL) & success;
    success = ((viewicon = loadiconfile(app, iconpath, "view" + ext, backcolor)) != NULL) & success;
    success = ((filtericon = loadiconfile(app, iconpath, "filter" + ext, backcolor)) != NULL) & success;
    success = ((find_againicon = loadiconfile(app, iconpath, "find_again" + ext, backcolor)) != NULL) & success;
    success = ((fliplricon = loadiconfile(app, iconpath, "fliplr" + ext, backcolor)) != NULL) & success;
    success = ((flipudicon = loadiconfile(app, iconpath, "flipud" + ext, backcolor)) != NULL) & success;
    success = ((floppyicon = loadiconfile(app, iconpath, "floppy" + ext, backcolor)) != NULL) & success;
    success = ((fontsicon = loadiconfile(app, iconpath, "fonts" + ext, backcolor)) != NULL) & success;
    success = ((gotobigicon = loadiconfile(app, iconpath, "gotobig" + ext, backcolor)) != NULL) & success;
    success = ((gotodiricon = loadiconfile(app, iconpath, "gotodir" + ext, backcolor)) != NULL) & success;
    success = ((gotolineicon = loadiconfile(app, iconpath, "gotoline" + ext, backcolor)) != NULL) & success;
    success = ((harddiskicon = loadiconfile(app, iconpath, "harddisk" + ext, backcolor)) != NULL) & success;
    success = ((helpicon = loadiconfile(app, iconpath, "help" + ext, backcolor)) != NULL) & success;
    success = ((hidehiddenicon = loadiconfile(app, iconpath, "hidehidden" + ext, backcolor)) != NULL) & success;
    success = ((hidenumbersicon = loadiconfile(app, iconpath, "hidenumbers" + ext, backcolor)) != NULL) & success;
    success = ((hidethumbicon = loadiconfile(app, iconpath, "hidethumb" + ext, backcolor)) != NULL) & success;
    success = ((homeicon = loadiconfile(app, iconpath, "home" + ext, backcolor)) != NULL) & success;
    success = ((infobigicon = loadiconfile(app, iconpath, "infobig" + ext, backcolor)) != NULL) & success;
    success = ((invselicon = loadiconfile(app, iconpath, "invsel" + ext, backcolor)) != NULL) & success;
    success = ((link_bigicon = loadiconfile(app, iconpath, "link_big" + ext, backcolor)) != NULL) & success;
    success = ((locationicon = loadiconfile(app, iconpath, "location" + ext, backcolor)) != NULL) & success;
    success = ((lowercaseicon = loadiconfile(app, iconpath, "lowercase" + ext, backcolor)) != NULL) & success;
    success = ((maphosticon = loadiconfile(app, iconpath, "maphost" + ext, backcolor)) != NULL) & success;
    success = ((miniappicon = loadiconfile(app, iconpath, "miniapp" + ext, backcolor)) != NULL) & success;
    success = ((miniblockdevicon = loadiconfile(app, iconpath, "miniblockdev" + ext, backcolor)) != NULL) & success;
    success = ((minibrokenlinkicon = loadiconfile(app, iconpath, "minibrokenlink" + ext, backcolor)) != NULL) & success;
    success = ((minichardevicon = loadiconfile(app, iconpath, "minichardev" + ext, backcolor)) != NULL) & success;
    success = ((minidocicon = loadiconfile(app, iconpath, "minidoc" + ext, backcolor)) != NULL) & success;
    success = ((miniexecicon = loadiconfile(app, iconpath, "miniexec" + ext, backcolor)) != NULL) & success;
    success = ((minifolderclosedicon = loadiconfile(app, iconpath, "minifolderclosed" + ext, backcolor)) != NULL) & success;
    success = ((minifolderlockedicon = loadiconfile(app, iconpath, "minifolderlocked" + ext, backcolor)) != NULL) & success;
    success = ((minifolderopenicon = loadiconfile(app, iconpath, "minifolderopen" + ext, backcolor)) != NULL) & success;
    success = ((minifoldericon = loadiconfile(app, iconpath, "minifolder" + ext, backcolor)) != NULL) & success;
    success = ((minifolderupicon = loadiconfile(app, iconpath, "minifolderup" + ext, backcolor)) != NULL) & success;
    success = ((minilinkicon = loadiconfile(app, iconpath, "minilink" + ext, backcolor)) != NULL) & success;
    success = ((minipipeicon = loadiconfile(app, iconpath, "minipipe" + ext, backcolor)) != NULL) & success;
    success = ((minishellicon = loadiconfile(app, iconpath, "minishell" + ext, backcolor)) != NULL) & success;
    success = ((minisocketicon = loadiconfile(app, iconpath, "minisocket" + ext, backcolor)) != NULL) & success;
    success = ((move_bigicon = loadiconfile(app, iconpath, "move_big" + ext, backcolor)) != NULL) & success;
    success = ((moveiticon = loadiconfile(app, iconpath, "moveit" + ext, backcolor)) != NULL) & success;
    success = ((newfileicon = loadiconfile(app, iconpath, "newfile" + ext, backcolor)) != NULL) & success;
    success = ((newfoldericon = loadiconfile(app, iconpath, "newfolder" + ext, backcolor)) != NULL) & success;
    success = ((nfsdriveicon = loadiconfile(app, iconpath, "nfsdrive" + ext, backcolor)) != NULL) & success;
    success = ((nfsdriveumticon = loadiconfile(app, iconpath, "nfsdriveumt" + ext, backcolor)) != NULL) & success;
    success = ((onepanelicon = loadiconfile(app, iconpath, "onepanel" + ext, backcolor)) != NULL) & success;
    success = ((packageicon = loadiconfile(app, iconpath, "package" + ext, backcolor)) != NULL) & success;
    success = ((paste_clpicon = loadiconfile(app, iconpath, "paste_clp" + ext, backcolor)) != NULL) & success;
    success = ((prefsicon = loadiconfile(app, iconpath, "prefs" + ext, backcolor)) != NULL) & success;
    success = ((printbigicon = loadiconfile(app, iconpath, "printbig" + ext, backcolor)) != NULL) & success;
    success = ((printicon = loadiconfile(app, iconpath, "print" + ext, backcolor)) != NULL) & success;
    success = ((questionbigicon = loadiconfile(app, iconpath, "questionbig" + ext, backcolor)) != NULL) & success;
    success = ((quiticon = loadiconfile(app, iconpath, "quit" + ext, backcolor)) != NULL) & success;
    success = ((redoicon = loadiconfile(app, iconpath, "redo" + ext, backcolor)) != NULL) & success;
    success = ((reloadicon = loadiconfile(app, iconpath, "reload" + ext, backcolor)) != NULL) & success;
    success = ((renameiticon = loadiconfile(app, iconpath, "renameit" + ext, backcolor)) != NULL) & success;
    success = ((replaceicon = loadiconfile(app, iconpath, "replace" + ext, backcolor)) != NULL) & success;
    success = ((reverticon = loadiconfile(app, iconpath, "revert" + ext, backcolor)) != NULL) & success;
    success = ((rotatelefticon = loadiconfile(app, iconpath, "rotateleft" + ext, backcolor)) != NULL) & success;
    success = ((rotaterighticon = loadiconfile(app, iconpath, "rotateright" + ext, backcolor)) != NULL) & success;
    success = ((runicon = loadiconfile(app, iconpath, "run" + ext, backcolor)) != NULL) & success;
    success = ((saveasicon = loadiconfile(app, iconpath, "saveas" + ext, backcolor)) != NULL) & success;
    success = ((savefileicon = loadiconfile(app, iconpath, "savefile" + ext, backcolor)) != NULL) & success;
    success = ((searchnexticon = loadiconfile(app, iconpath, "searchnext" + ext, backcolor)) != NULL) & success;
    success = ((searchicon = loadiconfile(app, iconpath, "search" + ext, backcolor)) != NULL) & success;
    success = ((searchprevicon = loadiconfile(app, iconpath, "searchprev" + ext, backcolor)) != NULL) & success;
    success = ((selallicon = loadiconfile(app, iconpath, "selall" + ext, backcolor)) != NULL) & success;
    success = ((setbookicon = loadiconfile(app, iconpath, "setbook" + ext, backcolor)) != NULL) & success;
    success = ((shellicon = loadiconfile(app, iconpath, "shell" + ext, backcolor)) != NULL) & success;
    success = ((showhiddenicon = loadiconfile(app, iconpath, "showhidden" + ext, backcolor)) != NULL) & success;
    success = ((shownumbersicon = loadiconfile(app, iconpath, "shownumbers" + ext, backcolor)) != NULL) & success;
    success = ((showthumbicon = loadiconfile(app, iconpath, "showthumb" + ext, backcolor)) != NULL) & success;
    success = ((smalliconsicon = loadiconfile(app, iconpath, "smallicons" + ext, backcolor)) != NULL) & success;
    success = ((iconsmenuicon = loadiconfile(app, iconpath, "iconsmenu" + ext, backcolor, 1)) != NULL) & success;
    success = ((trash_full_bigicon = loadiconfile(app, iconpath, "trash_full_big" + ext, backcolor)) != NULL) & success;
    success = ((trash_fullicon = loadiconfile(app, iconpath, "trash_full" + ext, backcolor)) != NULL) & success;
    success = ((treeonepanelicon = loadiconfile(app, iconpath, "treeonepanel" + ext, backcolor)) != NULL) & success;
    success = ((treetwopanelsicon = loadiconfile(app, iconpath, "treetwopanels" + ext, backcolor)) != NULL) & success;
    success = ((twopanelsicon = loadiconfile(app, iconpath, "twopanels" + ext, backcolor)) != NULL) & success;
    success = ((undoicon = loadiconfile(app, iconpath, "undo" + ext, backcolor)) != NULL) & success;
    success = ((unmaphosticon = loadiconfile(app, iconpath, "unmaphost" + ext, backcolor)) != NULL) & success;
    success = ((uppercaseicon = loadiconfile(app, iconpath, "uppercase" + ext, backcolor)) != NULL) & success;
    success = ((warningbigicon = loadiconfile(app, iconpath, "warningbig" + ext, backcolor)) != NULL) & success;
    success = ((workicon = loadiconfile(app, iconpath, "work" + ext, backcolor)) != NULL) & success;
    success = ((wrapofficon = loadiconfile(app, iconpath, "wrapoff" + ext, backcolor)) != NULL) & success;
    success = ((wraponicon = loadiconfile(app, iconpath, "wrapon" + ext, backcolor)) != NULL) & success;
    success = ((xfeicon = loadiconfile(app, iconpath, "xfe" + ext, backcolor)) != NULL) & success;
    success = ((realxfeicon = loadiconfile(app, iconpath, "xfe" + ext, 0)) != NULL) & success;
    success = ((xfiicon = loadiconfile(app, iconpath, "xfi" + ext, backcolor)) != NULL) & success;
    success = ((xfpicon = loadiconfile(app, iconpath, "xfp" + ext, backcolor)) != NULL) & success;
    success = ((xfwicon = loadiconfile(app, iconpath, "xfw" + ext, backcolor)) != NULL) & success;
    success = ((zipicon = loadiconfile(app, iconpath, "zip" + ext, backcolor)) != NULL) & success;
    success = ((zoom100icon = loadiconfile(app, iconpath, "zoom100" + ext, backcolor)) != NULL) & success;
    success = ((zoominicon = loadiconfile(app, iconpath, "zoomin" + ext, backcolor)) != NULL) & success;
    success = ((zoomouticon = loadiconfile(app, iconpath, "zoomout" + ext, backcolor)) != NULL) & success;
    success = ((zoomwinicon = loadiconfile(app, iconpath, "zoomwin" + ext, backcolor)) != NULL) & success;
    success = ((totrashicon = loadiconfile(app, iconpath, "totrash" + ext, backcolor)) != NULL) & success;
    success = ((dirbackicon = loadiconfile(app, iconpath, "dirback" + ext, backcolor)) != NULL) & success;
    success = ((dirforwardicon = loadiconfile(app, iconpath, "dirforward" + ext, backcolor)) != NULL) & success;
    success = ((minixferooticon = loadiconfile(app, iconpath, "minixferoot" + ext, backcolor)) != NULL) & success;
    success = ((minixfeicon = loadiconfile(app, iconpath, "minixfe" + ext, backcolor)) != NULL) & success;
    success = ((filedialogicon = loadiconfile(app, iconpath, "filedialog" + ext, backcolor)) != NULL) & success;
    success = ((bigarchaddicon = loadiconfile(app, iconpath, "bigarchadd" + ext, backcolor)) != NULL) & success;
    success = ((switchpanelsicon = loadiconfile(app, iconpath, "switchpanels" + ext, backcolor)) != NULL) & success;
    success = ((syncpanelsicon = loadiconfile(app, iconpath, "syncpanels" + ext, backcolor)) != NULL) & success;
    success = ((newlinkicon = loadiconfile(app, iconpath, "newlink" + ext, backcolor)) != NULL) & success;
    success = ((greenbuttonicon = loadiconfile(app, iconpath, "greenbutton" + ext, backcolor)) != NULL) & success;
    success = ((graybuttonicon = loadiconfile(app, iconpath, "graybutton" + ext, backcolor)) != NULL) & success;
    success = ((keybindingsicon = loadiconfile(app, iconpath, "keybindings" + ext, backcolor)) != NULL) & success;
    success = ((minikeybindingsicon = loadiconfile(app, iconpath, "minikeybindings" + ext, backcolor)) != NULL) & success;
    success = ((filerestoreicon = loadiconfile(app, iconpath, "filerestore" + ext, backcolor)) != NULL) & success;
    success = ((restore_bigicon = loadiconfile(app, iconpath, "restore_big" + ext, backcolor)) != NULL) & success;
    success = ((horzpanelsicon = loadiconfile(app, iconpath, "horzpanels" + ext, backcolor)) != NULL) & success;
    success = ((vertpanelsicon = loadiconfile(app, iconpath, "vertpanels" + ext, backcolor)) != NULL) & success;
    // success = ((comboarrowicon = loadiconfile(app, iconpath, "comboarrow" + ext, backcolor)) != NULL) & success;
    // success = ((closeicon = loadiconfile(app, iconpath, "close" + ext, backcolor)) != NULL) & success;
    success = ((throbicon = loadiconfile(app, iconpath, "throb" + ext, backcolor)) != NULL) & success;
    success = ((throbanimicon = loadiconfile(app, iconpath, "throbanim" + ext, backcolor)) != NULL) & success;
    success = ((webviewbgicon = loadiconfile(app, iconpath, "webviewbg" + ext, backcolor)) != NULL) ; success;

    success = ((tbarchaddicon = loadiconfile(app, iconpath, "archadd" + ext, basecolor)) != NULL) & success;
    success = ((tbarchexticon = loadiconfile(app, iconpath, "archext" + ext, basecolor)) != NULL) & success;
    success = ((tbattribicon = loadiconfile(app, iconpath, "attrib" + ext, basecolor)) != NULL) & success;
 /* success = ((tbbigattribicon = loadiconfile(app, iconpath, "bigattrib" + ext, basecolor)) != NULL) & success;
    success = ((tbbigblockdevicon = loadiconfile(app, iconpath, "bigblockdev" + ext, basecolor)) != NULL) & success;
    success = ((tbbigbrokenlinkicon = loadiconfile(app, iconpath, "bigbrokenlink" + ext, basecolor)) != NULL) & success;
    success = ((tbbigcdromicon = loadiconfile(app, iconpath, "bigcdrom" + ext, basecolor)) != NULL) & success;
    success = ((tbbigchardevicon = loadiconfile(app, iconpath, "bigchardev" + ext, basecolor)) != NULL) & success;
    success = ((tbbigcompareicon = loadiconfile(app, iconpath, "bigcompare" + ext, basecolor)) != NULL) & success;
    success = ((tbbigdocicon = loadiconfile(app, iconpath, "bigdoc" + ext, basecolor)) != NULL) & success;
    success = ((tbbigexecicon = loadiconfile(app, iconpath, "bigexec" + ext, basecolor)) != NULL) & success;
    success = ((tbbigfileopenicon = loadiconfile(app, iconpath, "bigfileopen" + ext, basecolor)) != NULL) & success;
    success = ((tbbigfiltericon = loadiconfile(app, iconpath, "bigfilter" + ext, basecolor)) != NULL) & success;
    success = ((tbbigfloppyicon = loadiconfile(app, iconpath, "bigfloppy" + ext, basecolor)) != NULL) & success;
    success = ((tbbigfolderlockedicon = loadiconfile(app, iconpath, "bigfolderlocked" + ext, basecolor)) != NULL) & success;
    success = ((tbbigfolderopenicon = loadiconfile(app, iconpath, "bigfolderopen" + ext, basecolor)) != NULL) & success;
    success = ((tbbigfoldericon = loadiconfile(app, iconpath, "bigfolder" + ext, basecolor)) != NULL) & success;
    success = ((tbbigfolderupicon = loadiconfile(app, iconpath, "bigfolderup" + ext, basecolor)) != NULL) & success;
    success = ((tbbigharddiskicon = loadiconfile(app, iconpath, "bigharddisk" + ext, basecolor)) != NULL) & success; */
    success = ((tbbigiconsicon = loadiconfile(app, iconpath, "bigicons" + ext, basecolor)) != NULL) & success; /*
    success = ((tbbiglinkicon = loadiconfile(app, iconpath, "biglink" + ext, basecolor)) != NULL) & success;
    success = ((tbbignewfileicon = loadiconfile(app, iconpath, "bignewfile" + ext, basecolor)) != NULL) & success;
    success = ((tbbignewfoldericon = loadiconfile(app, iconpath, "bignewfolder" + ext, basecolor)) != NULL) & success;
    success = ((tbbignewlinkicon = loadiconfile(app, iconpath, "bignewlink" + ext, basecolor)) != NULL) & success;
    success = ((tbbignfsdriveicon = loadiconfile(app, iconpath, "bignfsdrive" + ext, basecolor)) != NULL) & success;
    success = ((tbbignfsdriveumticon = loadiconfile(app, iconpath, "bignfsdriveumt" + ext, basecolor)) != NULL) & success;
    success = ((tbbigpipeicon = loadiconfile(app, iconpath, "bigpipe" + ext, basecolor)) != NULL) & success;
    success = ((tbbigsocketicon = loadiconfile(app, iconpath, "bigsocket" + ext, basecolor)) != NULL) & success;
    success = ((tbbigzipicon = loadiconfile(app, iconpath, "bigzip" + ext, basecolor)) != NULL) & success; */
    success = ((tbcdromicon = loadiconfile(app, iconpath, "cdrom" + ext, basecolor)) != NULL) & success;
    success = ((tbcharticon = loadiconfile(app, iconpath, "chart" + ext, basecolor)) != NULL) & success;
    success = ((tbclosefileicon = loadiconfile(app, iconpath, "closefile" + ext, basecolor)) != NULL) & success;
    success = ((tbclrbookicon = loadiconfile(app, iconpath, "clrbook" + ext, basecolor)) != NULL) & success;
    success = ((tbcolltreeicon = loadiconfile(app, iconpath, "colltree" + ext, basecolor)) != NULL) & success;
    success = ((tbcopy_bigicon = loadiconfile(app, iconpath, "copy_big" + ext, basecolor)) != NULL) & success;
    success = ((tbcopy_clpicon = loadiconfile(app, iconpath, "copy_clp" + ext, basecolor)) != NULL) & success;
    success = ((tbcut_clpicon = loadiconfile(app, iconpath, "cut_clp" + ext, basecolor)) != NULL) & success;
    success = ((tbdelete_big_permicon = loadiconfile(app, iconpath, "delete_big_perm" + ext, basecolor)) != NULL) & success;
    success = ((tbdelete_bigicon = loadiconfile(app, iconpath, "delete_big" + ext, basecolor)) != NULL) & success;
    success = ((tbdeselicon = loadiconfile(app, iconpath, "desel" + ext, basecolor)) != NULL) & success;
    success = ((tbdetailsicon = loadiconfile(app, iconpath, "details" + ext, basecolor)) != NULL) & success;
    success = ((tbdirupicon = loadiconfile(app, iconpath, "dirup" + ext, basecolor)) != NULL) & success;
    success = ((tbediticon = loadiconfile(app, iconpath, "edit" + ext, basecolor)) != NULL) & success;
    success = ((tbentericon = loadiconfile(app, iconpath, "enter" + ext, basecolor)) != NULL) & success;
    success = ((tberrorbigicon = loadiconfile(app, iconpath, "errorbig" + ext, basecolor)) != NULL) & success;
    success = ((tbexptreeicon = loadiconfile(app, iconpath, "exptree" + ext, basecolor)) != NULL) & success;
    success = ((tbcompareicon = loadiconfile(app, iconpath, "compare" + ext, basecolor)) != NULL) & success;
    success = ((tbfiledelete_permicon = loadiconfile(app, iconpath, "filedelete_perm" + ext, basecolor)) != NULL) & success;
    success = ((tbfiledeleteicon = loadiconfile(app, iconpath, "filedelete" + ext, basecolor)) != NULL) & success;
    success = ((tbfileopenicon = loadiconfile(app, iconpath, "fileopen" + ext, basecolor)) != NULL) & success;
    success = ((tbviewicon = loadiconfile(app, iconpath, "view" + ext, basecolor)) != NULL) & success;
    success = ((tbfiltericon = loadiconfile(app, iconpath, "filter" + ext, basecolor)) != NULL) & success;
    success = ((tbfind_againicon = loadiconfile(app, iconpath, "find_again" + ext, basecolor)) != NULL) & success;
    success = ((tbfliplricon = loadiconfile(app, iconpath, "fliplr" + ext, basecolor)) != NULL) & success;
    success = ((tbflipudicon = loadiconfile(app, iconpath, "flipud" + ext, basecolor)) != NULL) & success;
    success = ((tbfloppyicon = loadiconfile(app, iconpath, "floppy" + ext, basecolor)) != NULL) & success;
    success = ((tbfontsicon = loadiconfile(app, iconpath, "fonts" + ext, basecolor)) != NULL) & success;
    success = ((tbgotobigicon = loadiconfile(app, iconpath, "gotobig" + ext, basecolor)) != NULL) & success;
    success = ((tbgotodiricon = loadiconfile(app, iconpath, "gotodir" + ext, basecolor)) != NULL) & success;
    success = ((tbgotolineicon = loadiconfile(app, iconpath, "gotoline" + ext, basecolor)) != NULL) & success;
    success = ((tbharddiskicon = loadiconfile(app, iconpath, "harddisk" + ext, basecolor)) != NULL) & success;
    success = ((tbhelpicon = loadiconfile(app, iconpath, "help" + ext, basecolor)) != NULL) & success;
    success = ((tbhidehiddenicon = loadiconfile(app, iconpath, "hidehidden" + ext, basecolor)) != NULL) & success;
    success = ((tbhidenumbersicon = loadiconfile(app, iconpath, "hidenumbers" + ext, basecolor)) != NULL) & success;
    success = ((tbhidethumbicon = loadiconfile(app, iconpath, "hidethumb" + ext, basecolor)) != NULL) & success;
    success = ((tbhomeicon = loadiconfile(app, iconpath, "home" + ext, basecolor)) != NULL) & success;
    success = ((tbinfobigicon = loadiconfile(app, iconpath, "infobig" + ext, basecolor)) != NULL) & success;
    success = ((tbinvselicon = loadiconfile(app, iconpath, "invsel" + ext, basecolor)) != NULL) & success;
    success = ((tblink_bigicon = loadiconfile(app, iconpath, "link_big" + ext, basecolor)) != NULL) & success;
    success = ((tblocationicon = loadiconfile(app, iconpath, "location" + ext, basecolor)) != NULL) & success;
    success = ((tblowercaseicon = loadiconfile(app, iconpath, "lowercase" + ext, basecolor)) != NULL) & success;
    success = ((tbmaphosticon = loadiconfile(app, iconpath, "maphost" + ext, basecolor)) != NULL) & success;
    success = ((tbminiappicon = loadiconfile(app, iconpath, "miniapp" + ext, basecolor)) != NULL) & success;
    success = ((tbminiblockdevicon = loadiconfile(app, iconpath, "miniblockdev" + ext, basecolor)) != NULL) & success;
    success = ((tbminibrokenlinkicon = loadiconfile(app, iconpath, "minibrokenlink" + ext, basecolor)) != NULL) & success;
    success = ((tbminichardevicon = loadiconfile(app, iconpath, "minichardev" + ext, basecolor)) != NULL) & success;
    success = ((tbminidocicon = loadiconfile(app, iconpath, "minidoc" + ext, basecolor)) != NULL) & success;
    success = ((tbminiexecicon = loadiconfile(app, iconpath, "miniexec" + ext, basecolor)) != NULL) & success;
    success = ((tbminifolderclosedicon = loadiconfile(app, iconpath, "minifolderclosed" + ext, basecolor)) != NULL) & success;
    success = ((tbminifolderlockedicon = loadiconfile(app, iconpath, "minifolderlocked" + ext, basecolor)) != NULL) & success;
    success = ((tbminifolderopenicon = loadiconfile(app, iconpath, "minifolderopen" + ext, basecolor)) != NULL) & success;
    success = ((tbminifoldericon = loadiconfile(app, iconpath, "minifolder" + ext, basecolor)) != NULL) & success;
    success = ((tbminifolderupicon = loadiconfile(app, iconpath, "minifolderup" + ext, basecolor)) != NULL) & success;
    success = ((tbminilinkicon = loadiconfile(app, iconpath, "minilink" + ext, basecolor)) != NULL) & success;
    success = ((tbminipipeicon = loadiconfile(app, iconpath, "minipipe" + ext, basecolor)) != NULL) & success;
    success = ((tbminishellicon = loadiconfile(app, iconpath, "minishell" + ext, basecolor)) != NULL) & success;
    success = ((tbminisocketicon = loadiconfile(app, iconpath, "minisocket" + ext, basecolor)) != NULL) & success;
    success = ((tbmove_bigicon = loadiconfile(app, iconpath, "move_big" + ext, basecolor)) != NULL) & success;
    success = ((tbmoveiticon = loadiconfile(app, iconpath, "moveit" + ext, basecolor)) != NULL) & success;
    success = ((tbnewfileicon = loadiconfile(app, iconpath, "newfile" + ext, basecolor)) != NULL) & success;
    success = ((tbnewfoldericon = loadiconfile(app, iconpath, "newfolder" + ext, basecolor)) != NULL) & success;
    success = ((tbnfsdriveicon = loadiconfile(app, iconpath, "nfsdrive" + ext, basecolor)) != NULL) & success;
    success = ((tbnfsdriveumticon = loadiconfile(app, iconpath, "nfsdriveumt" + ext, basecolor)) != NULL) & success;
    success = ((tbonepanelicon = loadiconfile(app, iconpath, "onepanel" + ext, basecolor)) != NULL) & success;
    success = ((tbpackageicon = loadiconfile(app, iconpath, "package" + ext, basecolor)) != NULL) & success;
    success = ((tbpaste_clpicon = loadiconfile(app, iconpath, "paste_clp" + ext, basecolor)) != NULL) & success;
    success = ((tbprefsicon = loadiconfile(app, iconpath, "prefs" + ext, basecolor)) != NULL) & success;
    success = ((tbprintbigicon = loadiconfile(app, iconpath, "printbig" + ext, basecolor)) != NULL) & success;
    success = ((tbprinticon = loadiconfile(app, iconpath, "print" + ext, basecolor)) != NULL) & success;
    success = ((tbquestionbigicon = loadiconfile(app, iconpath, "questionbig" + ext, basecolor)) != NULL) & success;
    success = ((tbquiticon = loadiconfile(app, iconpath, "quit" + ext, basecolor)) != NULL) & success;
    success = ((tbredoicon = loadiconfile(app, iconpath, "redo" + ext, basecolor)) != NULL) & success;
    success = ((tbreloadicon = loadiconfile(app, iconpath, "reload" + ext, basecolor)) != NULL) & success;
    success = ((tbrenameiticon = loadiconfile(app, iconpath, "renameit" + ext, basecolor)) != NULL) & success;
    success = ((tbreplaceicon = loadiconfile(app, iconpath, "replace" + ext, basecolor)) != NULL) & success;
    success = ((tbreverticon = loadiconfile(app, iconpath, "revert" + ext, basecolor)) != NULL) & success;
    success = ((tbrotatelefticon = loadiconfile(app, iconpath, "rotateleft" + ext, basecolor)) != NULL) & success;
    success = ((tbrotaterighticon = loadiconfile(app, iconpath, "rotateright" + ext, basecolor)) != NULL) & success;
    success = ((tbrunicon = loadiconfile(app, iconpath, "run" + ext, basecolor)) != NULL) & success;
    success = ((tbsaveasicon = loadiconfile(app, iconpath, "saveas" + ext, basecolor)) != NULL) & success;
    success = ((tbsavefileicon = loadiconfile(app, iconpath, "savefile" + ext, basecolor)) != NULL) & success;
    success = ((tbsearchnexticon = loadiconfile(app, iconpath, "searchnext" + ext, basecolor)) != NULL) & success;
    success = ((tbsearchicon = loadiconfile(app, iconpath, "search" + ext, basecolor)) != NULL) & success;
    success = ((tbsearchprevicon = loadiconfile(app, iconpath, "searchprev" + ext, basecolor)) != NULL) & success;
    success = ((tbselallicon = loadiconfile(app, iconpath, "selall" + ext, basecolor)) != NULL) & success;
    success = ((tbsetbookicon = loadiconfile(app, iconpath, "setbook" + ext, basecolor)) != NULL) & success;
    success = ((tbshellicon = loadiconfile(app, iconpath, "shell" + ext, basecolor)) != NULL) & success;
    success = ((tbshowhiddenicon = loadiconfile(app, iconpath, "showhidden" + ext, basecolor)) != NULL) & success;
    success = ((tbshownumbersicon = loadiconfile(app, iconpath, "shownumbers" + ext, basecolor)) != NULL) & success;
    success = ((tbshowthumbicon = loadiconfile(app, iconpath, "showthumb" + ext, basecolor)) != NULL) & success;
    success = ((tbsmalliconsicon = loadiconfile(app, iconpath, "smallicons" + ext, basecolor)) != NULL) & success;
    success = ((tbiconsmenuicon = loadiconfile(app, iconpath, "iconsmenu" + ext, basecolor, 1)) != NULL) & success;
    success = ((tbtrash_full_bigicon = loadiconfile(app, iconpath, "trash_full_big" + ext, basecolor)) != NULL) & success;
    success = ((tbtrash_fullicon = loadiconfile(app, iconpath, "trash_full" + ext, basecolor)) != NULL) & success;
    success = ((tbtreeonepanelicon = loadiconfile(app, iconpath, "treeonepanel" + ext, basecolor)) != NULL) & success;
    success = ((tbtreetwopanelsicon = loadiconfile(app, iconpath, "treetwopanels" + ext, basecolor)) != NULL) & success;
    success = ((tbtwopanelsicon = loadiconfile(app, iconpath, "twopanels" + ext, basecolor)) != NULL) & success;
    success = ((tbundoicon = loadiconfile(app, iconpath, "undo" + ext, basecolor)) != NULL) & success;
    success = ((tbunmaphosticon = loadiconfile(app, iconpath, "unmaphost" + ext, basecolor)) != NULL) & success;
    success = ((tbuppercaseicon = loadiconfile(app, iconpath, "uppercase" + ext, basecolor)) != NULL) & success;
    success = ((tbwarningbigicon = loadiconfile(app, iconpath, "warningbig" + ext, basecolor)) != NULL) & success;
    success = ((tbworkicon = loadiconfile(app, iconpath, "work" + ext, basecolor)) != NULL) & success;
    success = ((tbwrapofficon = loadiconfile(app, iconpath, "wrapoff" + ext, basecolor)) != NULL) & success;
    success = ((tbwraponicon = loadiconfile(app, iconpath, "wrapon" + ext, basecolor)) != NULL) & success;
    success = ((tbxfeicon = loadiconfile(app, iconpath, "xfe" + ext, basecolor)) != NULL) & success;
    success = ((tbxfiicon = loadiconfile(app, iconpath, "xfi" + ext, basecolor)) != NULL) & success;
    success = ((tbxfpicon = loadiconfile(app, iconpath, "xfp" + ext, basecolor)) != NULL) & success;
    success = ((tbxfwicon = loadiconfile(app, iconpath, "xfw" + ext, basecolor)) != NULL) & success;
    success = ((tbzipicon = loadiconfile(app, iconpath, "zip" + ext, basecolor)) != NULL) & success;
    success = ((tbzoom100icon = loadiconfile(app, iconpath, "zoom100" + ext, basecolor)) != NULL) & success;
    success = ((tbzoominicon = loadiconfile(app, iconpath, "zoomin" + ext, basecolor)) != NULL) & success;
    success = ((tbzoomouticon = loadiconfile(app, iconpath, "zoomout" + ext, basecolor)) != NULL) & success;
    success = ((tbzoomwinicon = loadiconfile(app, iconpath, "zoomwin" + ext, basecolor)) != NULL) & success;
    success = ((tbtotrashicon = loadiconfile(app, iconpath, "totrash" + ext, basecolor)) != NULL) & success;
    success = ((tbdirbackicon = loadiconfile(app, iconpath, "dirback" + ext, basecolor)) != NULL) & success;
    success = ((tbdirforwardicon = loadiconfile(app, iconpath, "dirforward" + ext, basecolor)) != NULL) & success;
    success = ((tbminixferooticon = loadiconfile(app, iconpath, "minixferoot" + ext, basecolor)) != NULL) & success;
    success = ((tbminixfeicon = loadiconfile(app, iconpath, "minixfe" + ext, basecolor)) != NULL) & success;
    success = ((tbfiledialogicon = loadiconfile(app, iconpath, "filedialog" + ext, basecolor)) != NULL) & success;
    // success = ((tbbigarchaddicon = loadiconfile(app, iconpath, "bigarchadd" + ext, basecolor)) != NULL) & success;
    success = ((tbswitchpanelsicon = loadiconfile(app, iconpath, "switchpanels" + ext, basecolor)) != NULL) & success;
    success = ((tbsyncpanelsicon = loadiconfile(app, iconpath, "syncpanels" + ext, basecolor)) != NULL) & success;
    success = ((tbnewlinkicon = loadiconfile(app, iconpath, "newlink" + ext, basecolor)) != NULL) & success;
    success = ((tbgreenbuttonicon = loadiconfile(app, iconpath, "greenbutton" + ext, basecolor)) != NULL) & success;

    success = ((tbgraybuttonicon = loadiconfile(app, iconpath, "graybutton" + ext, basecolor)) != NULL) & success;
    success = ((tbkeybindingsicon = loadiconfile(app, iconpath, "keybindings" + ext, basecolor)) != NULL) & success;
    success = ((tbminikeybindingsicon = loadiconfile(app, iconpath, "minikeybindings" + ext, basecolor)) != NULL) & success;
    success = ((tbfilerestoreicon = loadiconfile(app, iconpath, "filerestore" + ext, basecolor)) != NULL) & success;
    success = ((tbrestore_bigicon = loadiconfile(app, iconpath, "restore_big" + ext, basecolor)) != NULL) & success;
    success = ((tbhorzpanelsicon = loadiconfile(app, iconpath, "horzpanels" + ext, basecolor)) != NULL) & success;
    success = ((tbvertpanelsicon = loadiconfile(app, iconpath, "vertpanels" + ext, basecolor)) != NULL) & success;
    // success = ((tbcomboarrowicon = loadiconfile(app, iconpath, "comboarrow" + ext, basecolor)) != NULL) & success;
    success = ((tbcomputericon = loadiconfile(app, iconpath, "computer" + ext, basecolor)) != NULL) & success;
    success = ((tbcloseicon = loadiconfile(app, iconpath, "close" + ext, basecolor)) != NULL) & success;
    success = ((tbthrobicon = loadiconfile(app, iconpath, "throb" + ext, basecolor)) != NULL) & success;
    success = ((tbthrobanimicon = loadiconfile(app, iconpath, "throbanim" + ext, basecolor)) != NULL) & success;
    // success = ((tbwebviewbgicon = loadiconfile(app, iconpath, "webviewbg" + ext, basecolor)) != NULL) & success;
    // ((tbwebviewbgicon = loadiconfile(app, iconpath, "webviewbg" + ext, basecolor)) != NULL);
    ((webviewxp = loadiconfile(app, iconpath, "xpwv" + ext, basecolor)) != NULL);


//resizecorner = new FXIcon(app, NULL, IMAGE_KEEP, 13, 13);
//resizecorner = new FXIcon(app, NULL, FXRGB(255,0,0), IMAGE_KEEP, 13, 13);
//FXIcon* resizecorner = NULL;
//resizecorner = new FXIcon(app, NULL, IMAGE_KEEP|IMAGE_SHMI|IMAGE_SHMP|IMAGE_OPAQUE|IMAGE_OWNED, 13, 13);
//FXColor resizecornerbuff[13*13];

//resizecorner = new FXIcon(app, NULL, 0, IMAGE_OPAQUE|IMAGE_DITHER|IMAGE_KEEP|IMAGE_OWNED|IMAGE_SHMI|IMAGE_SHMP, 13, 13);
resizecorner = new FXIcon(app, NULL, 0, IMAGE_OWNED, 13, 13);
//resizecorner = new FXIcon(app);

resizecorner->resize(13, 13);
//resizecorner->fill(basecolor);
//resizecorner->fill(FXRGB(255,0,0));

//resizecorner->create();

resizecorner->setPixel(11, 0, iconhilitecolor);
resizecorner->setPixel(10, 1, iconhilitecolor);
resizecorner->setPixel(9, 2, iconhilitecolor);
resizecorner->setPixel(8, 3, iconhilitecolor);
resizecorner->setPixel(7, 4, iconhilitecolor);
resizecorner->setPixel(11, 4, iconhilitecolor);
resizecorner->setPixel(6, 5, iconhilitecolor);
resizecorner->setPixel(10, 5, iconhilitecolor);
resizecorner->setPixel(5, 6, iconhilitecolor);
resizecorner->setPixel(9, 6, iconhilitecolor);
resizecorner->setPixel(4, 7, iconhilitecolor);
resizecorner->setPixel(8, 7, iconhilitecolor);
resizecorner->setPixel(3, 8, iconhilitecolor);
resizecorner->setPixel(7, 8, iconhilitecolor);
resizecorner->setPixel(11, 8, iconhilitecolor);
resizecorner->setPixel(2, 9, iconhilitecolor);
resizecorner->setPixel(6, 9, iconhilitecolor);
resizecorner->setPixel(10, 9, iconhilitecolor);
resizecorner->setPixel(1, 10, iconhilitecolor);
resizecorner->setPixel(5, 10, iconhilitecolor);
resizecorner->setPixel(9, 10, iconhilitecolor);
resizecorner->setPixel(0, 11, iconhilitecolor);
resizecorner->setPixel(4, 11, iconhilitecolor);
resizecorner->setPixel(8, 11, iconhilitecolor);

resizecorner->setPixel(11, 1, iconshadowcolor);
resizecorner->setPixel(10, 2, iconshadowcolor);
resizecorner->setPixel(11, 2, iconshadowcolor);
resizecorner->setPixel(9, 3, iconshadowcolor);
resizecorner->setPixel(10, 3, iconshadowcolor);
resizecorner->setPixel(8, 4, iconshadowcolor);
resizecorner->setPixel(9, 4, iconshadowcolor);
resizecorner->setPixel(7, 5, iconshadowcolor);
resizecorner->setPixel(8, 5, iconshadowcolor);
resizecorner->setPixel(11, 5, iconshadowcolor);
resizecorner->setPixel(6, 6, iconshadowcolor);
resizecorner->setPixel(7, 6, iconshadowcolor);
resizecorner->setPixel(10, 6, iconshadowcolor);
resizecorner->setPixel(11, 6, iconshadowcolor);
resizecorner->setPixel(5, 7, iconshadowcolor);
resizecorner->setPixel(6, 7, iconshadowcolor);
resizecorner->setPixel(9, 7, iconshadowcolor);
resizecorner->setPixel(10, 7, iconshadowcolor);
resizecorner->setPixel(4, 8, iconshadowcolor);
resizecorner->setPixel(5, 8, iconshadowcolor);
resizecorner->setPixel(8, 8, iconshadowcolor);
resizecorner->setPixel(9, 8, iconshadowcolor);
resizecorner->setPixel(3, 9, iconshadowcolor);
resizecorner->setPixel(4, 9, iconshadowcolor);
resizecorner->setPixel(7, 9, iconshadowcolor);
resizecorner->setPixel(8, 9, iconshadowcolor);
resizecorner->setPixel(11, 9, iconshadowcolor);
resizecorner->setPixel(2, 10, iconshadowcolor);
resizecorner->setPixel(3, 10, iconshadowcolor);
resizecorner->setPixel(6, 10, iconshadowcolor);
resizecorner->setPixel(7, 10, iconshadowcolor);
resizecorner->setPixel(10, 10, iconshadowcolor);
resizecorner->setPixel(11, 10, iconshadowcolor);
resizecorner->setPixel(1, 11, iconshadowcolor);
resizecorner->setPixel(2, 11, iconshadowcolor);
resizecorner->setPixel(5, 11, iconshadowcolor);
resizecorner->setPixel(6, 11, iconshadowcolor);
resizecorner->setPixel(9, 11, iconshadowcolor);
resizecorner->setPixel(10, 11, iconshadowcolor);

//resizecorner->render();
//resizecorner->create();
resizecorner->create();
//resizecorner->create();
//resizecorner->destroy();
//std::cout << resizecorner;
//printf("\n");

//FXColor comboarrowiconbuff[11*4];


arrowicon = new FXIcon(app, NULL, 0, IMAGE_DITHER|IMAGE_KEEP|IMAGE_OWNED|IMAGE_SHMI|IMAGE_SHMP, 5, 3);

arrowicon->resize(5, 3);

arrowicon->setPixel(0, 0, iconforecolor);
arrowicon->setPixel(1, 0, iconforecolor);
arrowicon->setPixel(2, 0, iconforecolor);
arrowicon->setPixel(3, 0, iconforecolor);
arrowicon->setPixel(4, 0, iconforecolor);
arrowicon->setPixel(1, 1, iconforecolor);
arrowicon->setPixel(2, 1, iconforecolor);
arrowicon->setPixel(3, 1, iconforecolor);
arrowicon->setPixel(2, 2, iconforecolor);


comboarrowicon = new FXIcon(app, NULL, 0, IMAGE_DITHER|IMAGE_KEEP|IMAGE_OWNED|IMAGE_SHMI|IMAGE_SHMP, 12, 4);
//resizecorner = new FXIcon(app);

comboarrowicon->resize(12, 4);

comboarrowicon->setPixel(2, 0, iconforecolor);
comboarrowicon->setPixel(3, 0, iconforecolor);
comboarrowicon->setPixel(4, 0, iconforecolor);
comboarrowicon->setPixel(5, 0, iconforecolor);
comboarrowicon->setPixel(6, 0, iconforecolor);
comboarrowicon->setPixel(7, 0, iconforecolor);
comboarrowicon->setPixel(8, 0, iconforecolor);
comboarrowicon->setPixel(3, 1, iconforecolor);
comboarrowicon->setPixel(4, 1, iconforecolor);
comboarrowicon->setPixel(5, 1, iconforecolor);
comboarrowicon->setPixel(6, 1, iconforecolor);
comboarrowicon->setPixel(7, 1, iconforecolor);
comboarrowicon->setPixel(4, 2, iconforecolor);
comboarrowicon->setPixel(5, 2, iconforecolor);
comboarrowicon->setPixel(6, 2, iconforecolor);
comboarrowicon->setPixel(5, 3, iconforecolor);

comboarrowicon->render();
comboarrowicon->create();

tbcomboarrowicon = new FXIcon(app, NULL, 0, IMAGE_DITHER|IMAGE_KEEP|IMAGE_OWNED|IMAGE_SHMI|IMAGE_SHMP, 11, 4);
tbcomboarrowicon->resize(11, 4);

tbcomboarrowicon->setPixel(2, 0, iconforecolor);
tbcomboarrowicon->setPixel(3, 0, iconforecolor);
tbcomboarrowicon->setPixel(4, 0, iconforecolor);
tbcomboarrowicon->setPixel(5, 0, iconforecolor);
tbcomboarrowicon->setPixel(6, 0, iconforecolor);
tbcomboarrowicon->setPixel(7, 0, iconforecolor);
tbcomboarrowicon->setPixel(8, 0, iconforecolor);
tbcomboarrowicon->setPixel(3, 1, iconforecolor);
tbcomboarrowicon->setPixel(4, 1, iconforecolor);
tbcomboarrowicon->setPixel(5, 1, iconforecolor);
tbcomboarrowicon->setPixel(6, 1, iconforecolor);
tbcomboarrowicon->setPixel(7, 1, iconforecolor);
tbcomboarrowicon->setPixel(4, 2, iconforecolor);
tbcomboarrowicon->setPixel(5, 2, iconforecolor);
tbcomboarrowicon->setPixel(6, 2, iconforecolor);
tbcomboarrowicon->setPixel(5, 3, iconforecolor);

tbcomboarrowicon->render();
tbcomboarrowicon->create();


closeicon = new FXIcon(app, NULL, 0, IMAGE_DITHER|IMAGE_KEEP|IMAGE_OWNED|IMAGE_SHMI|IMAGE_SHMP, 18, 11);
closeicon->setPixel(5, 2, iconforecolor);
closeicon->setPixel(6, 2, iconforecolor);
closeicon->setPixel(11, 2, iconforecolor);
closeicon->setPixel(12, 2, iconforecolor);
closeicon->setPixel(6, 3, iconforecolor);
closeicon->setPixel(7, 3, iconforecolor);
closeicon->setPixel(10, 3, iconforecolor);
closeicon->setPixel(11, 3, iconforecolor);
closeicon->setPixel(7, 4, iconforecolor);
closeicon->setPixel(8, 4, iconforecolor);
closeicon->setPixel(9, 4, iconforecolor);
closeicon->setPixel(10, 4, iconforecolor);
closeicon->setPixel(8, 5, iconforecolor);
closeicon->setPixel(9, 5, iconforecolor);
closeicon->setPixel(7, 6, iconforecolor);
closeicon->setPixel(8, 6, iconforecolor);
closeicon->setPixel(9, 6, iconforecolor);
closeicon->setPixel(10, 6, iconforecolor);
closeicon->setPixel(6, 7, iconforecolor);
closeicon->setPixel(7, 7, iconforecolor);
closeicon->setPixel(10, 7, iconforecolor);
closeicon->setPixel(11, 7, iconforecolor);
closeicon->setPixel(5, 8, iconforecolor);
closeicon->setPixel(6, 8, iconforecolor);
closeicon->setPixel(11, 8, iconforecolor);
closeicon->setPixel(12, 8, iconforecolor);


closeicon->render();
closeicon->create();


/* if (tbiconsmenuicon->getHeight() == 16) {
	tbiconsmenuicon->setPixel(18, 7, iconforecolor);
	tbiconsmenuicon->setPixel(19, 7, iconforecolor);
	tbiconsmenuicon->setPixel(20, 7, iconforecolor);
	tbiconsmenuicon->setPixel(21, 7, iconforecolor);
	tbiconsmenuicon->setPixel(22, 7, iconforecolor);
	tbiconsmenuicon->setPixel(19, 8, iconforecolor);
	tbiconsmenuicon->setPixel(20, 8, iconforecolor);
	tbiconsmenuicon->setPixel(21, 8, iconforecolor);
	tbiconsmenuicon->setPixel(20, 9, iconforecolor);
} else if (tbiconsmenuicon->getHeight() == 24) {
	tbiconsmenuicon->setPixel(26, 12, iconforecolor);
	tbiconsmenuicon->setPixel(27, 12, iconforecolor);
	tbiconsmenuicon->setPixel(28, 12, iconforecolor);
	tbiconsmenuicon->setPixel(29, 12, iconforecolor);
	tbiconsmenuicon->setPixel(30, 12, iconforecolor);
	tbiconsmenuicon->setPixel(27, 13, iconforecolor);
	tbiconsmenuicon->setPixel(28, 13, iconforecolor);
	tbiconsmenuicon->setPixel(29, 13, iconforecolor);
	tbiconsmenuicon->setPixel(28, 14, iconforecolor);
}


tbiconsmenuicon->render();
tbiconsmenuicon->create(); */

    return(success);
}

#include "config.h"
#include "i18n.h"

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <string.h>
#include <time.h>

#include <fx.h>
#include <fxkeys.h>
#include <FXPNGIcon.h>

#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "startupnotification.h"
#include "MessageBox.h"
#include "FilePanel.h"
#include "XFileExplorer.h"


// Add FOX hacks
#include "foxhacks.cpp"
#include "clearlooks.cpp"

// Main window
FXMainWindow* mainWindow;


// Startup notification
#ifdef STARTUP_NOTIFICATION

static time_t startup_end = 0;
static int    error_trap_depth = 0;

static int x_error_handler(Display* xdisplay, XErrorEvent* error)
{
    char buf[64];

    XGetErrorText(xdisplay, error->error_code, buf, 63);

    if (error_trap_depth == 0)
    {
        // XSetInputFocus can cause BadMatch errors
        // we ignore this in x_error_handler
        if (error->request_code == 42)
        {
            return(0);
        }

        fprintf(stderr, "Unexpected X error: %s serial %ld error_code %d request_code %d minor_code %d)\n",
                buf,
                error->serial,
                error->error_code,
                error->request_code,
                error->minor_code);
        //exit(EXIT_FAILURE);
    }

    return(1); // Return value is meaningless
}


static void error_trap_push(SnDisplay* display, Display*   xdisplay)
{
    ++error_trap_depth;
}


static void error_trap_pop(SnDisplay* display, Display*   xdisplay)
{
    if (error_trap_depth == 0)
    {
        fprintf(stderr, "Error: Trap underflow\n");
        exit(EXIT_FAILURE);
    }

    XSync(xdisplay, False);  // Get all errors out of the queue
    --error_trap_depth;
}


// Startup notification monitoring function
static void snmonitor(SnMonitorEvent* event, void* user_data)
{
    //SnMonitorContext *context;
    //SnStartupSequence *sequence;

    //context = sn_monitor_event_get_context (event);
    //sequence = sn_monitor_event_get_startup_sequence (event);
    sn_monitor_event_get_context(event);
    sn_monitor_event_get_startup_sequence(event);

    switch (sn_monitor_event_get_type(event))
    {
    case SN_MONITOR_EVENT_INITIATED:
    case SN_MONITOR_EVENT_CHANGED:

        // Startup timeout time
        time_t t;
        t = time(NULL);
        startup_end = t+STARTUP_TIMEOUT;

        ::setWaitCursor(mainWindow->getApp(), BEGIN_CURSOR);

        /* For debugging purpose
         *
         * const char *s;
         *
         * if (sn_monitor_event_get_type (event) == SN_MONITOR_EVENT_INITIATED)
         *  fprintf(stderr,"Initiated sequence %s\n",sn_startup_sequence_get_id (sequence));
         * else
         *  fprintf(stderr,"Changed sequence %s\n",sn_startup_sequence_get_id (sequence));
         *
         * s = sn_startup_sequence_get_id (sequence);
         * fprintf(stderr," id %s\n", s ? s : "(unset)");
         *
         * s = sn_startup_sequence_get_name (sequence);
         * fprintf(stderr," name %s\n", s ? s : "(unset)");
         *
         * s = sn_startup_sequence_get_description (sequence);
         * fprintf(stderr," description %s\n", s ? s : "(unset)");
         *
         * fprintf(stderr," workspace %d\n", sn_startup_sequence_get_workspace (sequence));
         *
         * s = sn_startup_sequence_get_binary_name (sequence);
         * fprintf(stderr," binary name %s\n", s ? s : "(unset)");
         *
         * s = sn_startup_sequence_get_icon_name (sequence);
         * fprintf(stderr," icon name %s\n", s ? s : "(unset)");
         *
         * s = sn_startup_sequence_get_wmclass (sequence);
         * fprintf(stderr," wm class %s\n", s ? s : "(unset)");
         *
         */

        break;

    case SN_MONITOR_EVENT_COMPLETED:

           ::setWaitCursor(mainWindow->getApp(), END_CURSOR);

        break;

    case SN_MONITOR_EVENT_CANCELED:

           ::setWaitCursor(mainWindow->getApp(), END_CURSOR);

        break;
    }
}


// Perform one event dispatch with startup notification
bool FXApp::runOneEvent(bool blocking)
{
    FXRawEvent ev;

    // We have to select for property events on at least one
    // root window (but not all as INITIATE messages go to
    // all root windows)

    static FXbool     firstcall = true;
    static SnDisplay* sndisplay;

    //static SnMonitorContext *context;
    if (firstcall)
    {
        XSetErrorHandler(x_error_handler);
        XSelectInput((Display*)display, DefaultRootWindow((Display*)display), PropertyChangeMask);
        sndisplay = sn_display_new((Display*)display, error_trap_push, error_trap_pop);
        //context = sn_monitor_context_new (sndisplay, DefaultScreen ((Display*)display),snmonitor,NULL, NULL);
        sn_monitor_context_new(sndisplay, DefaultScreen((Display*)display), snmonitor, NULL, NULL);
        firstcall = false;
    }

    if (getNextEvent(ev, blocking))
    {
        // Check if startup timeout expired
        time_t t;
        t = time(NULL);
        if ((startup_end != 0) && (startup_end-t < 0))
        {
            ::setWaitCursor(mainWindow->getApp(), END_CURSOR);
            startup_end = 0;
        }

        sn_display_process_event(sndisplay, &ev);

        dispatchEvent(ev);
        return(true);
    }

    return(false);
}


#endif


// Global variables
char** args;
FXbool xim_used = false;

#if defined(linux)
FXuint pkg_format;
#endif

// Base directories (according to the Freedesktop specification version 0.7)
FXString homedir;
FXString xdgdatahome;
FXString xdgconfighome;

// Used to force panel view mode from command line
int panel_mode = -1;


// Hand cursor replacement
#define hand_width     32
#define hand_height    32
#define hand_x_hot     6
#define hand_y_hot     1
static const FXuchar hand_bits[] =
{
    0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00,
    0x90, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x90, 0x07, 0x00, 0x00,
    0x97, 0x1a, 0x00, 0x00, 0x99, 0x2a, 0x00, 0x00, 0x11, 0x28, 0x00, 0x00,
    0x12, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00,
    0x04, 0x20, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00,
    0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const FXuchar hand_mask_bits[] =
{
    0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
    0xf0, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00,
    0xf7, 0x1f, 0x00, 0x00, 0xff, 0x3f, 0x00, 0x00, 0xff, 0x3f, 0x00, 0x00,
    0xfe, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00,
    0xfc, 0x3f, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00,
    0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Usage message
#define USAGE_MSG    _("\
\nUsage: xfe [options...] [FOLDER|FILE...]\n\
\n\
    [options...] are the following:\n\
\n\
        -h,   --help         Print (this) help screen and exit.\n\
        -v,   --version      Print version information and exit.\n\
        -i,   --iconic       Start iconified.\n\
        -m,   --maximized    Start maximized.\n\
        -p n, --panel n      Force panel view mode to n (n=0 => Tree and one panel,\n\
                             n=1 => One panel, n=2 => Two panels, n=3 => Tree and two panels).\n\
\n\
    [FOLDER|FILE...] is a list of folders or files to open on startup.\n\
    The first two folders are displayed in the file panels, the others are ignored.\n\
    The number of files to open is not limited.\n\
\n")



int main(int argc, char* argv[])
{
    const char* title = "Xfe";
    const char* appname = "xfe";
    const char* vdrname = "Xfe";
    int         i;
    FXbool      loadicons;
    FXString    startfiledir1 = "";
    FXString    startdir2 = "";
    FXbool      iconic = false;
    FXbool      maximized = false;
    FXString    xmodifiers;
    FXString	cmd;

    // Vector of URIs to open on startup
    vector_FXString startURIs;

    // Get environment variables $HOME, $XDG_DATA_HOME and $XDG_CONFIG_HOME
    homedir = FXSystem::getHomeDirectory();
    if (homedir == "")
    {
        homedir = ROOTDIR;
    }
    xdgdatahome = getenv("XDG_DATA_HOME");
    if (xdgdatahome == "")
    {
        xdgdatahome = homedir + PATHSEPSTRING DATAPATH;
    }
    xdgconfighome = getenv("XDG_CONFIG_HOME");
    if (xdgconfighome == "")
    {
        xdgconfighome = homedir + PATHSEPSTRING CONFIGPATH;
    }

    // Detect if an X input method is used
    xmodifiers = getenv("XMODIFIERS");
    if ((xmodifiers == "") || (xmodifiers == "@im=none"))
    {
        xim_used = false;
    }
    else
    {
        xim_used = true;
    }

#ifdef HAVE_SETLOCALE
    // Set locale via LC_ALL.
    setlocale(LC_ALL, "");
#endif

#if ENABLE_NLS
    // Set the text message domain.
    bindtextdomain(PACKAGE, LOCALEDIR);
    bind_textdomain_codeset(PACKAGE, "utf-8");
    textdomain(PACKAGE);
#endif

#if defined(linux)
    // For package query on Linux systems, try to guess if the default package format is deb or rpm:
    //   - if dpkg exists then the system uses deb packages
    //   - else if rpm exists, then the system uses rpm packages
    //   - else another (unsupported) package manager is used

    cmd = "dpkg --version";
    FXString str = getCommandOutput(cmd);

    if (str.find("Debian") != -1)
    {
        pkg_format = DEB_PKG; // deb based system
    }
    else
    {
        cmd = "rpm --version";
        str = getCommandOutput(cmd);

        if (str.find("RPM") != -1)
        {
            pkg_format = RPM_PKG; // rpm based system
        }
        else
        {
            pkg_format = OTHER_PKG; // other (unsupported) package system
        }
    }
#endif

    // Parse basic arguments
    for (i = 1; i < argc; ++i)
    {
        if ((compare(argv[i], "-v") == 0) || (compare(argv[i], "--version") == 0))
        {
            fprintf(stdout, "%s version %s\n", PACKAGE, VERSION);
            exit(EXIT_SUCCESS);
        }
        else if ((compare(argv[i], "-h") == 0) || (compare(argv[i], "--help") == 0))
        {
            fprintf(stdout, USAGE_MSG);
            exit(EXIT_SUCCESS);
        }
        else if ((compare(argv[i], "-i") == 0) || (compare(argv[i], "--iconic") == 0))
        {
            iconic = true;
        }
        else if ((compare(argv[i], "-m") == 0) || (compare(argv[i], "--maximized") == 0))
        {
            maximized = true;
        }
        else if ((compare(argv[i], "-p") == 0) || (compare(argv[i], "--panel") == 0) || (compare(argv[i], "--panels") == 0))
        {
            if (++i < argc)
            {
                panel_mode = atoi(argv[i]);
            }
            if ((panel_mode < 0) || (panel_mode > 3))
            {
                fprintf(stderr, _("Warning: Unknown panel mode, revert to last saved panel mode\n"));
                panel_mode = -1;
            }
        }
        else if (compare(argv[i], "-p0") == 0)
        {
            panel_mode = 0;
        }
        else if (compare(argv[i], "-p1") == 0)
        {
            panel_mode = 1;
        }
        else if (compare(argv[i], "-p2") == 0)
        {
            panel_mode = 2;
        }
        else if (compare(argv[i], "-p3") == 0)
        {
            panel_mode = 3;
        }
        else
        {
            // Starting URIs, if any
            startURIs.push_back(::filePath(::fileFromURI(argv[i])));
        }
    }

    // Global variable (used to properly restart Xfe)
    args = argv;

    // Application creation
    FXApp* application = new FXApp(appname, vdrname);
    application->init(argc, argv);

    // Redefine the default hand cursor
    FXCursor* hand = new FXCursor(application, hand_bits, hand_mask_bits, hand_width, hand_height, hand_x_hot, hand_y_hot);
    application->setDefaultCursor(DEF_HAND_CURSOR, hand);

    // Read registry thru foxhacks
    application->reg().read();

    // Set base color (to change the default base color at first run)
    FXColor basecolor = application->reg().readColorEntry("SETTINGS", "basecolor", FXRGB(237, 233, 227));
    application->setBaseColor(basecolor);

    // Load all application icons
    loadicons = loadAppIcons(application);

    // Set normal font
    FXString fontspec;
    fontspec = application->reg().readStringEntry("SETTINGS", "font", DEFAULT_NORMAL_FONT);
    if (!fontspec.empty())
    {
        FXFont* normalFont = new FXFont(application, fontspec);
        application->setNormalFont(normalFont);
    }

    // If root
    if (getuid() == 0)
    {
        title = "Xfe (root)";
    }

    // Create and run application
    mainWindow = new XFileExplorer(application, startURIs, iconic, maximized, title, realxfeicon, minixfeicon);

    // Catch SIGCHLD to harvest zombie child processes
    application->addSignal(SIGCHLD, mainWindow, XFileExplorer::ID_HARVEST, true);

    // Also catch interrupt so we can gracefully terminate
    application->addSignal(SIGINT, mainWindow, XFileExplorer::ID_QUIT);

    application->create();

    // Tooltips setup time and duration
    application->setTooltipPause(TOOLTIP_PAUSE);
    application->setTooltipTime(TOOLTIP_TIME);

    if (!loadicons)
    {
        MessageBox::error(application, BOX_OK, _("Error loading icons"), _("Unable to load some icons. Please check your icons path!"));
    }

    return(application->run());
}
#include "config.h"
#include "i18n.h"

#include <stdlib.h>
#include <sys/time.h>
#include <unistd.h>
#include <errno.h>
#include <assert.h>

#include <fx.h>

#include "xfedefs.h"
#include "xfeutils.h"
#include "startupnotification.h"



#ifdef STARTUP_NOTIFICATION  // Use startup notification


// Indicate that launchee has completed startup
void startup_completed(void)
{
    SnLauncheeContext* launchee;
    Display*           xdisplay;
    SnDisplay*         display;

    // Open display
    xdisplay = XOpenDisplay(NULL);
    if (xdisplay != NULL)
    {
        // Create startup notification context
        display = sn_display_new(xdisplay, NULL, NULL);
        launchee = sn_launchee_context_new_from_environment(display, DefaultScreen(xdisplay));

        // Indicate startup has completed and free resources
        if (launchee)
        {
            sn_launchee_context_complete(launchee);
            sn_launchee_context_unref(launchee);
        }
        sn_display_unref(display);
        XCloseDisplay(xdisplay);
    }
}


// Hack to obtain a timestamp for startup notification
// Create a fake window and set up a property change event
// Code snippet borrowed from the Internet
Time gettimestamp(Display *display)
{
    Window   window;
    XEvent   event;
    Atom     atom_name, atom_type;

    window = XCreateWindow(display, DefaultRootWindow(display), 0, 0, 1, 1, 0, 0, InputOnly, 0, 0, NULL);
    XSelectInput(display, window, PropertyChangeMask);
    atom_name = XInternAtom(display, "_NET_WM_USER_TIME_WINDOW", False);
    atom_type = XInternAtom(display, "WINDOW", true);
    XChangeProperty(display, window, atom_name, atom_type, 8, PropModeReplace, (const FXuchar*)&window, 1);
    XNextEvent(display, &event);
    assert(event.type == PropertyNotify);

    return(((XPropertyEvent*)&event)->time);
}


// Launch a command and initiate a startup notification
int runcmd(FXString cmd, FXString cmdname, FXString dir, FXString startdir, FXbool usesn = true, FXString snexcepts = "")
{
    int ret;

    // Change to current directory
    ret = chdir(dir.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            fprintf(stderr, _("Error: Can't enter folder %s: %s"), dir.text(), strerror(errcode));
        }
        else
        {
            fprintf(stderr, _("Error: Can't enter folder %s"), dir.text());
        }

        return(-1);
    }

    // Get rid of possible command options
    cmdname = cmdname.before(' ');

    // Check if command is in the startup notification exception list
    FXbool startup_notify = true;
    if (snexcepts != "")
    {
        FXString entry;
        for (int i = 0; ; i++)
        {
            entry = snexcepts.section(':', i);
            if (streq(entry.text(), ""))
            {
                break;
            }
            if (streq(entry.text(), cmdname.text()))
            {
                startup_notify = false;
                break;
            }
        }
    }

    // Run command with startup notification
    if (usesn && startup_notify)
    {
        Display*           xdisplay;
        SnDisplay*         display;
        SnLauncherContext* context;
        Time               timestamp;

        // Open display
        xdisplay = XOpenDisplay(NULL);
        if (xdisplay == NULL)
        {
            fprintf(stderr, _("Error: Can't open display\n"));
            ret = chdir(startdir.text());
            if (ret < 0)
            {
                int errcode = errno;
                if (errcode)
                {
                    fprintf(stderr, _("Error: Can't enter folder %s: %s"), startdir.text(), strerror(errcode));
                }
                else
                {
                    fprintf(stderr, _("Error: Can't enter folder %s"), startdir.text());
                }
            }
            return(-1);
        }

        // Message displayed in the task bar (if any)
        FXString message;
        message.format(_("Start of %s"), cmdname.text());

        // Initiate launcher context
        display = sn_display_new(xdisplay, NULL, NULL);
        context = sn_launcher_context_new(display, DefaultScreen(xdisplay));
        sn_launcher_context_set_name(context, message.text());
        sn_launcher_context_set_binary_name(context, cmdname.text());
        sn_launcher_context_set_description(context, message.text());
        sn_launcher_context_set_icon_name(context, cmdname.text());
        timestamp = gettimestamp(xdisplay);
        sn_launcher_context_initiate(context, "Xfe", cmd.text(), timestamp);

        // Run command in background
        cmd += " &";

        static pid_t child_pid = 0;
        switch ((child_pid = fork()))
        {
        case -1:
            fprintf(stderr, _("Error: Fork failed: %s\n"), strerror(errno));
            break;

        case 0: // Child
            sn_launcher_context_setup_child_process(context);
            execl("/bin/sh", "sh", "-c", cmd.text(), (char*)NULL);
            _exit(EXIT_SUCCESS);
            break;
        }
        sn_launcher_context_unref(context);
        XCloseDisplay(xdisplay);
    }

    // Run command without startup notification
    else
    {
        // Run command in background
        cmd += " &";
        ret = system(cmd.text());
        if (ret < 0)
        {
            fprintf(stderr, _("Error: Can't execute command %s"), cmd.text());
            return(-1);
        }

        // Just display the wait cursor during a second
        sleep(1);
    }

    // Go back to startup directory
    ret = chdir(startdir.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            fprintf(stderr, _("Error: Can't enter folder %s: %s"), startdir.text(), strerror(errcode));
        }
        else
        {
            fprintf(stderr, _("Error: Can't enter folder %s"), startdir.text());
        }

        return(-1);
    }

    return(0);
}


#else  // Don't use startup notification

// Run a command and simulate a startup time
int runcmd(FXString cmd, FXString dir, FXString startdir)
{
    int ret;

    // Change to current directory
    ret = chdir(dir.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            fprintf(stderr, _("Error: Can't enter folder %s: %s"), dir.text(), strerror(errcode));
        }
        else
        {
            fprintf(stderr, _("Error: Can't enter folder %s"), dir.text());
        }

        return(-1);
    }

    // Run the command in background
    cmd += " &";
    ret = system(cmd.text());
    if (ret < 0)
    {
        fprintf(stderr, _("Error: Can't execute command %s"), cmd.text());
        return(-1);
    }

    // Very ugly simulation of a startup time!!!
    sleep(SIMULATED_STARTUP_TIME);

    // Go back to startup directory
    ret = chdir(startdir.text());
    if (ret < 0)
    {
        int errcode = errno;
        if (errcode)
        {
            fprintf(stderr, _("Error: Can't enter folder %s: %s"), startdir.text(), strerror(errcode));
        }
        else
        {
            fprintf(stderr, _("Error: Can't enter folder %s"), startdir.text());
        }

        return(-1);
    }

    return(0);
}


#endif
// Switch between the four possible panel views
long XFileExplorer::onCmdShowPanels(FXObject* sender,FXSelector sel,void* ptr)
{
    // Get window width and height
    int window_width=getWidth();
    int window_height=getHeight();

    switch(FXSELID(sel))
    {
    case ID_SHOW_ONE_PANEL:
        panel_view=ONE_PANEL;
        if (dirpanel->shown())
            dirpanel->handle(sender,FXSEL(SEL_COMMAND,DirPanel::ID_TOGGLE_TREE),ptr);
        if (rpanel->shown())
            rpanel->handle(sender,FXSEL(SEL_COMMAND,FXWindow::ID_TOGGLESHOWN),ptr);
        // Handle drag corner
        rpanel->showCorner(false);
        lpanel->showCorner(true);
        // Handle active icon
        lpanel->showActiveIcon(false);

        break;

    case ID_SHOW_TWO_PANELS:
        panel_view=TWO_PANELS;
        if (vertpanels)
            lpanel->setWidth((int)round(twopanels_lpanel_pct*window_width));
        else
            lpanel->setHeight((int)round(twopanels_lpanel_pct*window_height));
        if (dirpanel->shown())
            dirpanel->handle(sender,FXSEL(SEL_COMMAND,DirPanel::ID_TOGGLE_TREE),ptr);
        if (!rpanel->shown())
            rpanel->handle(sender,FXSEL(SEL_COMMAND,FXWindow::ID_TOGGLESHOWN),ptr);
        // Handle drag corner
        rpanel->showCorner(true);
        lpanel->showCorner(false);
        // Handle active icon
        lpanel->showActiveIcon(true);
        break;

    case ID_SHOW_TREE_PANEL:
        panel_view=TREE_PANEL;
        dirpanel->setWidth((int)round(treepanel_tree_pct*window_width) );
        if (!dirpanel->shown())
            dirpanel->handle(sender,FXSEL(SEL_COMMAND,DirPanel::ID_TOGGLE_TREE),ptr);
        if (rpanel->shown())
            rpanel->handle(sender,FXSEL(SEL_COMMAND,FXWindow::ID_TOGGLESHOWN),ptr);
        // Handle drag corner
        rpanel->showCorner(false);
        lpanel->showCorner(true);
        // Handle active icon
        lpanel->showActiveIcon(true);
        break;

    case ID_SHOW_TREE_TWO_PANELS:
        panel_view=TREE_TWO_PANELS;
        dirpanel->setWidth((int)round(treetwopanels_tree_pct*window_width) );
        if (vertpanels)
            lpanel->setWidth((int)round(treetwopanels_lpanel_pct*window_width));
        else
            lpanel->setHeight((int)round(treetwopanels_lpanel_pct*window_height));
        if (!dirpanel->shown())
            dirpanel->handle(sender,FXSEL(SEL_COMMAND,DirPanel::ID_TOGGLE_TREE),ptr);
        if (!rpanel->shown())
            rpanel->handle(sender,FXSEL(SEL_COMMAND,FXWindow::ID_TOGGLESHOWN),ptr);
        // Handle drag corner
        lpanel->showCorner(false);
        rpanel->showCorner(true);
        // Handle active icon
        lpanel->showActiveIcon(true);
        break;
    }

    // Set focus on current panel
    lpanel->getCurrent()->setFocusOnList();

    return 1;
}
// Helper functions for various purposes
// Some helper functions are also added to get large files support
// Also supports a timeout on the stat and lstat function (this is the reason
// why some standard FOX function cannot be used and are rewritten here)


#include "config.h"
#include "i18n.h"


#include <sys/time.h>
#include <sys/wait.h>
#include <time.h>
#include <libgen.h>

#include <fx.h>
#include <FXId.h>

#include <fxkeys.h>
#include <FXPNGIcon.h>
#include <FXGIFIcon.h>


#include "xfedefs.h"
#include "icons.h"
#include "xfeutils.h"
#include "../st/st.h"
#include <string>

bool hasEnding (std::string const &fullString, std::string const &ending) {
    if (fullString.length() >= ending.length()) {
        return (0 == fullString.compare (fullString.length() - ending.length(), ending.length(), ending));
    } else {
        return false;
    }
}



// Decode filename to get original again
FXString FXPath::dequote(const FXString& file)
{
    FXString result(file);

    if (0 < result.length())
    {
        register int e = result.length();
        register int b = 0;
        register int r = 0;
        register int q = 0;

        // Trim tail
        while (0 < e && Ascii::isSpace(result[e-1]))
        {
            --e;
        }

        // Trim head
        while (b < e && Ascii::isSpace(result[b]))
        {
            ++b;
        }

        // Dequote the rest
        while (b < e)
        {
            if (result[b] == '\'')
            {
                q = !q;
                b++;
                continue;
            }
            if ((result[b] == '\\') && (result[b+1] == '\'') && !q)
            {
                b++;
            }
            result[r++] = result[b++];
        }

        // Trunc to size
        result.trunc(r);
    }
    return(result);
}


// Note : the original function from FXAccelTable is buggy!!
// Parse accelerator from string
FXHotKey _parseAccel(const FXString& string)
{
    register FXuint code = 0, mods = 0;
    register int    pos = 0;

    // Parse leading space
    while (pos < string.length() && Ascii::isSpace(string[pos]))
    {
        pos++;
    }

    // Parse modifiers
    while (pos < string.length())
    {
        // Modifier
        if (comparecase(&string[pos], "ctl", 3) == 0)
        {
            mods |= CONTROLMASK;
            pos += 3;
        }
        else if (comparecase(&string[pos], "ctrl", 4) == 0)
        {
            mods |= CONTROLMASK;
            pos += 4;
        }
        else if (comparecase(&string[pos], "alt", 3) == 0)
        {
            mods |= ALTMASK;
            pos += 3;
        }
        else if (comparecase(&string[pos], "meta", 4) == 0)
        {
            mods |= METAMASK;
            pos += 4;
        }
        else if (comparecase(&string[pos], "shift", 5) == 0)
        {
            mods |= SHIFTMASK;
            pos += 5;
        }
        else
        {
            break;
        }

        // Separator
        if ((string[pos] == '+') || (string[pos] == '-') || Ascii::isSpace(string[pos]))
        {
            pos++;
        }
    }

    // Test for some special keys
    if (comparecase(&string[pos], "home", 4) == 0)
    {
        code = KEY_Home;
    }
    else if (comparecase(&string[pos], "end", 3) == 0)
    {
        code = KEY_End;
    }
    else if (comparecase(&string[pos], "pgup", 4) == 0)
    {
        code = KEY_Page_Up;
    }
    else if (comparecase(&string[pos], "pgdn", 4) == 0)
    {
        code = KEY_Page_Down;
    }
    else if (comparecase(&string[pos], "left", 4) == 0)
    {
        code = KEY_Left;
    }
    else if (comparecase(&string[pos], "right", 5) == 0)
    {
        code = KEY_Right;
    }
    else if (comparecase(&string[pos], "up", 2) == 0)
    {
        code = KEY_Up;
    }
    else if (comparecase(&string[pos], "down", 4) == 0)
    {
        code = KEY_Down;
    }
    else if (comparecase(&string[pos], "ins", 3) == 0)
    {
        code = KEY_Insert;
    }
    else if (comparecase(&string[pos], "del", 3) == 0)
    {
        code = KEY_Delete;
    }
    else if (comparecase(&string[pos], "esc", 3) == 0)
    {
        code = KEY_Escape;
    }
    else if (comparecase(&string[pos], "tab", 3) == 0)
    {
        code = KEY_Tab;
    }
    else if (comparecase(&string[pos], "return", 6) == 0)
    {
        code = KEY_Return;
    }
    else if (comparecase(&string[pos], "enter", 5) == 0)
    {
        code = KEY_Return;
    }
    else if (comparecase(&string[pos], "back", 4) == 0)
    {
        code = KEY_BackSpace;
    }
    else if (comparecase(&string[pos], "spc", 3) == 0)
    {
        code = KEY_space;
    }
    else if (comparecase(&string[pos], "space", 5) == 0)
    {
        code = KEY_space;
    }

    // Test for function keys
    else if ((Ascii::toLower(string[pos]) == 'f') && Ascii::isDigit(string[pos+1]))
    {
        if (Ascii::isDigit(string[pos+2]))
        {
            // !!!! Hack to fix a bug in FOX !!!!
            code = KEY_F1+10*(string[pos+1]-'0')+(string[pos+2]-'0')-1;
            // !!!! End of hack !!!!
        }
        else
        {
            code = KEY_F1+string[pos+1]-'1';
        }
    }
    // Test if hexadecimal code designator
    else if (string[pos] == '#')
    {
        code = strtoul(&string[pos+1], NULL, 16);
    }

    // Test if its a single character accelerator
    else if (Ascii::isPrint(string[pos]))
    {
        if (mods&SHIFTMASK)
        {
            code = Ascii::toUpper(string[pos])+KEY_space-' ';
        }
        else
        {
            code = Ascii::toLower(string[pos])+KEY_space-' ';
        }
    }
    return(MKUINT(code, mods));
}


// Find if the specified command exists
FXbool existCommand(const FXString cmd)
{
    struct stat linfo;

    // Command file path
    FXString cmdpath = cmd.before(' ');

    // If first character is '/' then cmdpath is an absolute path
    if (cmdpath[0] == PATHSEPCHAR)
    {
        // Check if command file name exists and is not a directory
        if (!cmdpath.empty() && (lstatrep(cmdpath.text(), &linfo) == 0) && !S_ISDIR(linfo.st_mode))
        {
            return(true);
        }
    }

    // If first character is '~' then cmdpath is a path relative to home directory
    else if (cmdpath[0] == '~')
    {
        // Form command absolute path
        cmdpath = FXSystem::getHomeDirectory() + cmdpath.after('~');

        // Check if command file name exists and is not a directory
        if (!cmdpath.empty() && (lstatrep(cmdpath.text(), &linfo) == 0) && !S_ISDIR(linfo.st_mode))
        {
            return(true);
        }
    }

    // Simple command name or path relative to the exec path
    else
    {
        // Get exec path
        FXString execpath = FXSystem::getExecPath();

        if (execpath != "")
        {
			// Number of delimiters
			int nbseps = execpath.contains(':');

            // Loop over path components
            for (int i = 0; i <= nbseps; i++)
            {
                // Obtain path component
                FXString path = execpath.section(':', i);

                // Form command absolute path
                path += PATHSEPSTRING + cmdpath;

                // Check if command file name exists and is not a directory
                if (!path.empty() && (lstatrep(path.text(), &linfo) == 0) && !S_ISDIR(linfo.st_mode))
                {
                    return(true);
                }
            }
        }
    }

    return(false);
}


// Get key binding string from user input
// Code adapted from FXAccelTable::unparseAccel() and modified to get strings like 'Ctrl-A' instead of 'ctrl+a'
FXString getKeybinding(FXEvent* event)
{
    // Get modifiers and key
    int mods = event->state;
    int code = event->code;

    char     buffer[64];
    FXString s;

    // Handle modifier keys
    if (mods&CONTROLMASK)
    {
        s += "Ctrl-";
    }
    if (mods&ALTMASK)
    {
        s += "Alt-";
    }
    if (mods&SHIFTMASK)
    {
        s += "Shift-";
    }
    if (mods&METAMASK)
    {
        s += "Meta-";
    }

    // Handle some special keys
    switch (code)
    {
    case KEY_Home:
        s += "Home";
        break;

    case KEY_End:
        s += "End";
        break;

    case KEY_Page_Up:
        s += "PgUp";
        break;

    case KEY_Page_Down:
        s += "PgDn";
        break;

    case KEY_Left:
        s += "Left";
        break;

    case KEY_Right:
        s += "Right";
        break;

    case KEY_Up:
        s += "Up";
        break;

    case KEY_Down:
        s += "Down";
        break;

    case KEY_Insert:
        s += "Ins";
        break;

    case KEY_Delete:
        s += "Del";
        break;

    case KEY_Escape:
        s += "Esc";
        break;

    case KEY_Tab:
        s += "Tab";
        break;

    case KEY_Return:
        s += "Return";
        break;

    case KEY_BackSpace:
        s += "Back";
        break;

    case KEY_space:
        s += "Space";
        break;

    case KEY_F1:
    case KEY_F2:
    case KEY_F3:
    case KEY_F4:
    case KEY_F5:
    case KEY_F6:
    case KEY_F7:
    case KEY_F8:
    case KEY_F9:
    case KEY_F10:
    case KEY_F11:
    case KEY_F12:
    case KEY_F13:
    case KEY_F14:
    case KEY_F15:
    case KEY_F16:
    case KEY_F17:
    case KEY_F18:
    case KEY_F19:
    case KEY_F20:
    case KEY_F21:
    case KEY_F22:
    case KEY_F23:
    case KEY_F24:
    case KEY_F25:
    case KEY_F26:
    case KEY_F27:
    case KEY_F28:
    case KEY_F29:
    case KEY_F30:
    case KEY_F31:
    case KEY_F32:
    case KEY_F33:
    case KEY_F34:
    case KEY_F35:
        snprintf(buffer, sizeof(buffer)-1, "F%d", code-KEY_F1+1);
        s += buffer;
        break;

    default:
        if (Ascii::isPrint(code))
        {
            s += Ascii::toUpper(code);
        }
        else
        {
            s = "";  // Invalid case
        }
        break;
    }

    return(s);
}


// Create a directory with its path, like 'mkdir -p'
// Return 0 if success or -1 if fail
// Original author : Niall O'Higgins */
// http://niallohiggins.com/2009/01/08/mkpath-mkdir-p-alike-in-c-for-unix
int mkpath(const char* s, mode_t mode)
{
    char* q, *r = NULL, *path = NULL, *up = NULL;
    int   rv;

    rv = -1;
    if ((strcmp(s, ".") == 0) || (strcmp(s, "/") == 0))
    {
        return(0);
    }

    if ((path = strdup(s)) == NULL)
    {
        exit(EXIT_FAILURE);
    }

    if ((q = strdup(s)) == NULL)
    {
        exit(EXIT_FAILURE);
    }

    if ((r = (char*)dirname(q)) == NULL)
    {
        goto out;
    }

    if ((up = strdup(r)) == NULL)
    {
        exit(EXIT_FAILURE);
    }

    if ((mkpath(up, mode) == -1) && (errno != EEXIST))
    {
        goto out;
    }

    if ((mkdir(path, mode) == -1) && (errno != EEXIST))
    {
        rv = -1;
    }
    else
    {
        rv = 0;
    }

out:
    if (up != NULL)
    {
        free(up);
    }
    free(q);
    free(path);
    return(rv);
}


// Obtain a unique trash files path name based on the file path name
FXString createTrashpathname(FXString pathname, FXString trashfileslocation)
{
    // Initial trash files path name
    FXString trashpathname = trashfileslocation+PATHSEPSTRING+FXPath::name(pathname);

    // Eventually modify the trash files path name by adding a suffix like '_1', '_2', etc.,
    // if the file already exists in the trash can files directory
    for (int i = 1; ; i++)
    {
        if (::exists(trashpathname))
        {
            char suffix[32];
            snprintf(suffix, sizeof(suffix)-1, "_%d", i);
            FXString prefix = trashpathname.rbefore('_');
            if (prefix == "")
            {
                prefix = trashpathname;
            }
            trashpathname = prefix+suffix;
        }
        else
        {
            break;
        }
    }

    return(trashpathname);
}


// Create trashinfo file based on the pathname and the trashpathname
int createTrashinfo(FXString pathname, FXString trashpathname, FXString trashfileslocation, FXString trashinfolocation)
{
    // Create trash can files if it doesn't exist
    if (!exists(trashfileslocation))
    {
        int mask = umask(0);
        umask(mask);
        int ret = mkpath(trashfileslocation.text(), 511 & ~mask);
        return(ret);
    }

    // Create trash can info if it doesn't exist
    if (!exists(trashinfolocation))
    {
        int mask = umask(0);
        umask(mask);
        int ret = mkpath(trashinfolocation.text(), 511 & ~mask);
        return(ret);
    }

    // Deletion date
    struct timeval tv;
    gettimeofday(&tv, NULL);
    FXString deldate = FXSystem::time("%FT%T", tv.tv_sec);

    // Trash info path name
    FXString trashinfopathname = trashinfolocation+PATHSEPSTRING+FXPath::name(trashpathname)+".trashinfo";

    // Create trash info file
    FILE* fp;
    int   ret;
    if ((fp = fopen(trashinfopathname.text(), "w")) != NULL)
    {
        fprintf(fp, "[Trash Info]\n");
        fprintf(fp, "Path=%s\n", pathname.text());
        fprintf(fp, "DeletionDate=%s\n", deldate.text());
        fclose(fp);
        ret = 0;
    }
    else
    {
        ret = -1;
    }

    return(ret);
}


// Return mime type of a file
// Makes use of the Unix file command, thus this function may be slow
FXString mimetype(FXString pathname)
{
    FXString cmd = "/usr/bin/file -b -i " + pathname;
    FILE*    filecmd = popen(cmd.text(), "r");

    if (!filecmd)
    {
        perror("popen");
        exit(EXIT_FAILURE);
    }
    char     text[128] = { 0 };
    FXString buf;
    while (fgets(text, sizeof(text), filecmd))
    {
        buf += text;
    }
    pclose(filecmd);

    return(buf.rbefore('\n'));
}


// Quote a filename against shell substitutions
// Thanks to Glynn Clements <glynnc@users.sourceforge.net>
FXString quote(FXString str)
{
    FXString    result = "'";
    const char* p;

    for (p = str.text(); *p; p++)
    {
        if (*p == '\'')
        {
            result += "'\\''";
        }
        else
        {
            result += *p;
        }
    }

    result += '\'';
    return(result);
}


// Test if a string is encoded in UTF-8
// "length" is the number of bytes of the string to consider
// Taken from the weechat project. Original author FlashCode <flashcode@flashtux.org>
FXbool isUtf8(const char* string, FXuint length)
{
    FXuint n = 0;

    while (n < length)
    {
        // UTF-8, 2 bytes, should be: 110vvvvv 10vvvvvv
        if (((FXuchar)(string[0]) & 0xE0) == 0xC0)
        {
            if (!string[1] || (((FXuchar)(string[1]) & 0xC0) != 0x80))
            {
                return(false);
            }
            string += 2;
            n += 2;
        }
        // UTF-8, 3 bytes, should be: 1110vvvv 10vvvvvv 10vvvvvv
        else if (((FXuchar)(string[0]) & 0xF0) == 0xE0)
        {
            if (!string[1] || !string[2] ||
                (((FXuchar)(string[1]) & 0xC0) != 0x80) ||
                (((FXuchar)(string[2]) & 0xC0) != 0x80))
            {
                return(false);
            }
            string += 3;
            n += 3;
        }
        // UTF-8, 4 bytes, should be: 11110vvv 10vvvvvv 10vvvvvv 10vvvvvv
        else if (((FXuchar)(string[0]) & 0xF8) == 0xF0)
        {
            if (!string[1] || !string[2] || !string[3] ||
                (((FXuchar)(string[1]) & 0xC0) != 0x80) ||
                (((FXuchar)(string[2]) & 0xC0) != 0x80) ||
                (((FXuchar)(string[3]) & 0xC0) != 0x80))
            {
                return(false);
            }
            string += 4;
            n += 4;
        }
        // UTF-8, 1 byte, should be: 0vvvvvvv
        else if ((FXuchar)(string[0]) >= 0x80)
        {
            return(false);
        }
        // Next byte
        else
        {
            string++;
            n++;
        }
    }
    return(true);
}


#if defined(linux)
// Stat function used to test if a mount point is up or down
// Actually, this is simply the lstat() function
int lstatmt(const char* filename, struct stat* buf)
{
    return(lstat(filename, buf));
}
#endif


#if !defined (__OpenBSD__)
// Safe strcpy function (Public domain, by C.B. Falconer)
// The destination string is always null terminated
// Size sz must be equal to strlen(src)+1
size_t strlcpy(char* dst, const char* src, size_t sz)
{
    const char* start = src;

    if (src && sz--)
    {
        while ((*dst++ = *src))
        {
            if (sz--)
            {
                src++;
            }
            else
            {
                *(--dst) = '\0';
                break;
            }
        }
    }
    if (src)
    {
        while (*src++)
        {
            continue;
        }
        return(src - start - 1);
    }
    else if (sz)
    {
        *dst = '\0';
    }
    return(0);
}

// Safe strcat function (Public domain, by C.B. Falconer)
// The destination string is always null terminated
size_t strlcat(char* dst, const char* src, size_t sz)
{
    char* start = dst;

    while (*dst++)      // assumes sz >= strlen(dst)
    {
        if (sz)
        {
            sz--;          // i.e. well formed string
        }
    }
    dst--;
    return(dst - start + strlcpy(dst, src, sz));
}
#endif

// Obtain the non recursive size of a directory
FXulong dirsize(const char* path)
{
    DIR* dp;
    struct dirent* dirp;
    struct stat statbuf;
    char buf[MAXPATHLEN];
    FXulong dsize = 0;
    int ret;

    if ((dp = opendir(path)) == NULL)
    {
        return(0);
    }

    while ((dirp = readdir(dp)))
    {
        if (streq(dirp->d_name, ".") || streq(dirp->d_name, ".."))
        {
            continue;
        }

        if (streq(path, ROOTDIR))
        {
            snprintf(buf, sizeof(buf)-1, "%s%s", path, dirp->d_name);
        }
        else
        {
            snprintf(buf, sizeof(buf)-1, "%s/%s", path, dirp->d_name);
        }

#if defined(linux)
        // Mount points are not processed to improve performances
        if (mtdevices->find(buf))
        {
            continue;
        }
#endif

        ret = lstatrep(buf, &statbuf);
        if (ret == 0)
        {
            if (!S_ISDIR(statbuf.st_mode))
            {
                dsize += (FXulong)statbuf.st_size;
            }
        }
    }
    if (closedir(dp) < 0)
    {
        fprintf(stderr, _("Error: Can't close folder %s\n"), path);
    }
    return(dsize);
}


// Obtain the recursive size of a directory
// The number of files and the number of sub directories is also stored in the nbfiles and nbsubdirs pointers
// Caution: this only works if nbfiles and nbsubdirs are initialized to 0 in the calling function
// After that, nbfiles contains the total number of files (including the count of sub directories),
// nbsubdirs contains the number of sub directories and totalsize the total directory size
// The pipes are used to write partial results, for inter process communication
FXulong pathsize(char* path, FXuint* nbfiles, FXuint* nbsubdirs, FXulong *totalsize, int pipes[2])
{
    struct stat statbuf;
    struct dirent* dirp;
    char* ptr;
    DIR* dp;
    FXulong dsize;
    int ret;
	
	char buf[256];

    ret = lstatrep(path, &statbuf);
    if (ret < 0)
    {
        return(0);
    }
    dsize = (FXulong)statbuf.st_size;
	(*totalsize) += dsize;
    (*nbfiles)++;

	// Write to pipe, if requested
	if (pipes != NULL)
	{
#if __WORDSIZE == 64
    {
		snprintf(buf,sizeof(buf),"%lu %u %u/", *totalsize, *nbfiles, *nbsubdirs);
    }
#else
    {
		snprintf(buf,sizeof(buf),"%llu %u %u/", *totalsize, *nbfiles, *nbsubdirs);
    }
#endif
		if (write(pipes[1], buf, strlen(buf)) == -1)
		{
			perror("write");
			exit(EXIT_FAILURE);
		};
	}

    // Not a directory
    if (!S_ISDIR(statbuf.st_mode))
    {
       return(dsize);
    }

    // Directory
    (*nbsubdirs)++;

    ptr = (char*)path + strlen(path);
    if (ptr[-1] != '/')
    {
        *ptr++ = '/';
        *ptr = '\0';
    }

    if ((dp = opendir(path)) == NULL)
    {
        return(0);
    }

    while ((dirp = readdir(dp)))
    {
        if (streq(dirp->d_name, ".") || streq(dirp->d_name, ".."))
        {
            continue;
        }
        strlcpy(ptr, dirp->d_name, strlen(dirp->d_name)+1);

        // Recursive call
        dsize += pathsize(path, nbfiles, nbsubdirs, totalsize, pipes);
    }

    ptr[-1] = '\0'; // ??

    if (closedir(dp) < 0)
    {
        fprintf(stderr, _("Error: Can't close folder %s\n"), path);
    }

    return(dsize);
}


// Write the file size in human readable form (bytes, kBytes, MBytes, GBytes)
// We use a decimal basis for kB, MB, GB count
FXString hSize(char* size)
{
    int flag = 0;
    char suf[64];
    char buf[128];
    FXString hsize;

    FXulong lsize = strtoull(size, NULL, 10);
    float fsize = 0.0;

    strlcpy(suf, _("bytes"), sizeof(suf));
    if (lsize > 1e9)
    {
        fsize = lsize/1e9;
        strlcpy(suf, _("GB"), sizeof(suf));
        flag = 1;
    }
    else if (lsize > 1e6)
    {
        fsize = lsize/1e6;
        strlcpy(suf, _("MB"), sizeof(suf));
        flag = 1;
    }
    else if (lsize > 1e3)
    {
        fsize = lsize/1e3;
        strlcpy(suf, _("kB"), sizeof(suf));
        flag = 1;
    }

    if (flag)
    {
        if (fsize == (int)fsize)
        {
            snprintf(buf, sizeof(buf), "%.0f %s", fsize, suf);
        }
        else
        {
            snprintf(buf, sizeof(buf), "%.1f %s", fsize, suf);
        }
    }
    else

#if __WORDSIZE == 64
    {
        snprintf(buf, sizeof(buf), "%lu %s", lsize, suf);
    }
#else
    {
        snprintf(buf, sizeof(buf), "%llu %s", lsize, suf);
    }
#endif

    hsize = buf;
    return(hsize);
}


// Remove terminating '/' on a path string to simplify a file or directory path
// Thus '/bla/bla////' becomes '/bla/bla'
// Special case : '/' stays to '/'
FXString cleanPath(const FXString path)
{
    FXString in = path, out = path;

    while (1)
    {
        if ((in[in.length()-1] == '/') && (in.length() != 1))
        {
            out = in.trunc(in.length()-1);
            in = out;
        }
        else
        {
            break;
        }
    }
    return(out);
}


// Return the absolute path, based on the current directory path
// Remove terminating '/' on a path string to simplify a file or directory path
// Thus '/bla/bla////' becomes '/bla/bla'
// Special case : '/' stays to '/'
FXString filePath(const FXString path)
{
    FXString in = path, out = path;

    while (1)
    {
        if ((in[in.length()-1] == '/') && (in.length() != 1))
        {
            out = in.trunc(in.length()-1);
            in = out;
        }
        else
        {
            break;
        }
    }
    FXString dir = FXSystem::getCurrentDirectory();

    // If absolute path
    if (ISPATHSEP(out[0]))
    {
        return(out);
    }
    else
    {
        return(dir+PATHSEPSTRING+out);
    }
}


// Return the absolute path, based on the specified directory path
// Remove terminating '/' on a path string to simplify a file or directory path
// Thus '/bla/bla////' becomes '/bla/bla'
// Special case : '/' stays to '/'
FXString filePath(const FXString path, const FXString dir)
{
    FXString in = path, out = path;

    while (1)
    {
        if ((in[in.length()-1] == '/') && (in.length() != 1))
        {
            out = in.trunc(in.length()-1);
            in = out;
        }
        else
        {
            break;
        }
    }
    // If absolute path
    if (ISPATHSEP(out[0]))
    {
        return(out);
    }
    else
    {
        return(dir+PATHSEPSTRING+out);
    }
}


// Obtain file path from URI specified as file:///bla/bla/bla...
// If no 'file:' prefix is found, return the input string as is
FXString fileFromURI(FXString uri)
{
    if (comparecase("file:", uri, 5) == 0)
    {
        if ((uri[5] == PATHSEPCHAR) && (uri[6] == PATHSEPCHAR))
        {
            return(uri.mid(7, uri.length()-7));
        }
        return(uri.mid(5, uri.length()-5));
    }

    return(uri);
}


// Return URI of filename
FXString fileToURI(const FXString& file)
{
    return("file://"+file);
}


// Construct a target name by adding a suffix that tells it's a copy of the original target file name
FXString buildCopyName(const FXString& target)
{
    const FXString suffix = _("copy");

    FXString copytarget;
    FXString copystr = " (" + suffix;
    FXString name = FXPath::name(target);

    // Get file extensions
    FXString ext1 = name.rafter('.', 1);
    FXString ext2 = name.rafter('.', 2);
    FXString ext3 = ext2.before('.');
    FXString ext4 = name.before('.');
    
    // Case of dot file names (hidden files or folders)
    if (name.before('.') == "")
    {
		int pos = target.rfind(copystr);

		// First copy
		if (pos < 0)
		{
			copytarget = target + copystr + ")";
		}

		// Add a number to the suffix for next copies
		else
		{
			FXString strnum = target.mid(pos+copystr.length(), target.length()-pos-copystr.length());
			FXuint num = FXUIntVal(strnum);
			num = (num == 0 ? num +2 : num +1);
			copytarget = target.left(pos) + copystr + " " + FXStringVal(num) + ")";
		}
	}
    
    // Case of compressed tar archive names
    else if (ext3.lower() == "tar")
    {
        FXString basename = target.rbefore('.', 2);
        int pos = basename.rfind(copystr);

        if (pos < 0)
        {
            copytarget = basename + copystr + ")." + ext2;
        }

        else
        {
            // Add a number if it's not the first copy
            FXString strnum = target.mid(pos+copystr.length(), target.length()-pos-copystr.length()-ext2.length()-1);
            FXuint num = FXUIntVal(strnum);
            num = (num == 0 ? num +2 : num +1);

            copytarget = target.left(pos) + copystr + " " + FXStringVal(num) + ")." + ext2;
        }
    }

    // Other cases
    else
    {
        // File name has no extension
        if (ext1 == name)
        {
            int pos = target.rfind(copystr);

            // First copy
            if (pos < 0)
            {
                copytarget = target + copystr + ")";
            }

            // Add a number to the suffix for next copies
            else
            {
                FXString strnum = target.mid(pos+copystr.length(), target.length()-pos-copystr.length());
                FXuint num = FXUIntVal(strnum);
                num = (num == 0 ? num +2 : num +1);
                copytarget = target.left(pos) + copystr + " " + FXStringVal(num) + ")";
            }
        }

        // File name has an extension
        else
        {
            FXString basename = target.rbefore('.', 1);
            int pos = basename.rfind(copystr);

            // First copy
            if (pos < 0)
            {
                copytarget = basename + copystr + ")." + ext1;
            }

            // Add a number to the suffix for next copies
            else
            {
                FXString strnum = target.mid(pos+copystr.length(), target.length()-pos-copystr.length()-ext1.length()-1);
                FXuint num = FXUIntVal(strnum);
                num = (num == 0 ? 2 : num +1);
                copytarget = target.left(pos) + copystr + " " + FXStringVal(num) + ")." + ext1;
            }
        }
    }

    // Recursive call to avoid existing file names
    if (::exists(copytarget))
    {
        copytarget = buildCopyName(copytarget);
    }

    return(copytarget);
}


// Convert the deletion date to the number of seconds since the epoch
// The string representing the deletion date must be in the format YYYY-MM-DDThh:mm:ss
FXlong deltime(FXString delstr)
{
    // Decompose the date into year, month, day, hour, minutes and seconds
    FXString year = delstr.mid(0, 4);
    FXString mon = delstr.mid(5, 2);
    FXString mday = delstr.mid(8, 2);
    FXString hour = delstr.mid(11, 2);
    FXString min = delstr.mid(14, 2);
    FXString sec = delstr.mid(17, 2);

    // Convert date using mktime()
    tm tmval;

    tmval.tm_sec = atoi(sec.text());
    tmval.tm_min = atoi(min.text());
    tmval.tm_hour = atoi(hour.text())-1;
    tmval.tm_mday = atoi(mday.text());
    tmval.tm_mon = atoi(mon.text())-1;
    tmval.tm_year = atoi(year.text())-1900;
    tmval.tm_isdst = 0;
    FXlong t = (FXlong)mktime(&tmval);

    // If conversion failed, return 0
    if (t < 0)
    {
        t = 0;
    }

    return(t);
}


// Test if a directory is empty
// Return -1 if not a directory, 1 if empty and 0 if not empty
int isEmptyDir(const FXString directory)
{
    int ret = -1;
    DIR* dir;
    struct dirent* entry;
    int n = 0;

    if ((dir = opendir(directory.text())) != NULL)
    {
        // Skip . and .. and read the third entry
        while (n < 3)
        {
            entry = readdir(dir);
            n++;
        }
        if (entry == NULL)
        {
            ret = 1;
        }
        else
        {
            ret = 0;
        }
    }
    if (dir)
    {
        closedir(dir);
    }
    return(ret);
}


// Test if a directory has sub-directories
// Return -1 if not a directory, 1 if has sub-directories, 0 if does not have
int hasSubDirs(const FXString directory)
{
    int ret = -1;
    DIR* dir;
    struct dirent* entry;

    if ((dir = opendir(directory.text())) != NULL)
    {
        ret = 0;

        // Process directory entries
        while (1)
        {
            entry = readdir(dir);

            // No more entries
            if (entry == NULL)
            {
                break;
            }

            // Entry is . or ..
            else if ((strcmp(entry->d_name, ".") == 0) || (strcmp(entry->d_name, "..") == 0))
            {
                continue;
            }

            // Regular entry
            // We don't use dirent.d_type anymore because of portability issues
            // (e.g. reiserfs don't know dirent.d_type)
            else
            {
                // Stat entry
                struct stat entrystat;
                FXString entrypath = directory + PATHSEPSTRING + entry->d_name;
                if (statrep(entrypath.text(), &entrystat) != 0)
                {
                    continue;
                }

                // If directory
                if (S_ISDIR(entrystat.st_mode))
                {
                    ret = 1;
                    break;
                }
            }
        }
    }
    if (dir)
    {
        closedir(dir);
    }
    return(ret);
}


// Check if file exists
FXbool exists(const FXString& file)
{
    struct stat linfo;

    return(!file.empty() && (lstatrep(file.text(), &linfo) == 0));
}


// Check if the file represents a directory
FXbool isDirectory(const FXString& file)
{
    struct stat info;

    return(!file.empty() && (statrep(file.text(), &info) == 0) && S_ISDIR(info.st_mode));
}


// Check if file represents a file
FXbool isFile(const FXString& file)
{
    struct stat info;

    return(!file.empty() && (statrep(file.text(), &info) == 0) && S_ISREG(info.st_mode));
}


// Check if current user is member of gid
// (thanks to Armin Buehler <abuehler@users.sourceforge.net>)
FXbool isGroupMember(gid_t gid)
{
    static int ngroups = 0;
    static gid_t* gids = NULL;
    int i;
    int ret;

    // First call : initialization of the number of supplementary groups and the group list
    if (ngroups == 0)
    {
        ngroups = getgroups(0, gids);

        if (ngroups < 0)
        {
            goto err;
        }
        else
        {
            gids = new gid_t[ngroups];
            ret = getgroups(ngroups, gids);
            if (ret < 0)
            {
                goto err;
            }
        }
    }
    if (ngroups == 0)
    {
        return(false);
    }

    // Check if the group id is contained within the group list
    i = ngroups;
    while (i--)
    {
        if (gid == gids[i])
        {
            return(true);
        }
    }

err:
    int errcode = errno;
    if (errcode)
    {
        fprintf(stderr, _("Error: Can't read group list: %s"), strerror(errcode));
    }
    else
    {
        fprintf(stderr, _("Error: Can't read group list"));
    }

    return(false);
}


// Check if the file or the link refered file is readable AND executable
// Function used to test if we can enter a directory
// Uses the access() system function
FXbool isReadExecutable(const FXString& file)
{
    struct stat info;

    // File exists and can be stated
    if (!file.empty() && (statrep(file.text(), &info) == 0))
    {
        int ret = access(file.text(), R_OK|X_OK);
        if (ret == 0)
        {
            return(true);
        }
        else
        {
            return(false);
        }
    }

    // File doesn't exist
    else
    {
        return(false);
    }
}


// Check if file is readable
FXbool isReadable(const FXString& file)
{
    struct stat info;

    // File exists and can be stated
    if (!file.empty() && (statrep(file.text(), &info) == 0))
    {
        int ret = access(file.text(), R_OK);
        if (ret == 0)
        {
            return(true);
        }
        else
        {
            return(false);
        }
    }

    // File doesn't exist
    else
    {
        return(false);
    }
}


// Check if file is writable
FXbool isWritable(const FXString& file)
{
    struct stat info;

    // File exists and can be stated
    if (!file.empty() && (statrep(file.text(), &info) == 0))
    {
        int ret = access(file.text(), W_OK);
        if (ret == 0)
        {
            return(true);
        }
        else
        {
            return(false);
        }
    }

    // File doesn't exist
    else
    {
        return(false);
    }
}


// Check if file represents a link
FXbool isLink(const FXString& file)
{
    struct stat linfo;

    return(!file.empty() && (lstatrep(file.text(), &linfo) == 0) && S_ISLNK(linfo.st_mode));
}


// Get file info (file or link refered file)
FXbool info(const FXString& file, struct stat& inf)
{
    return(!file.empty() && (statrep(file.text(), &inf) == 0));
}


// Return permissions string
// (the FOX function FXSystem::modeString() seems to use another format for the mode field)
FXString permissions(FXuint mode)
{
    char result[11];

    result[0] = S_ISLNK(mode) ? 'l' : S_ISREG(mode) ? '-' : S_ISDIR(mode) ? 'd' : S_ISCHR(mode) ? 'c' : S_ISBLK(mode) ? 'b' : S_ISFIFO(mode) ? 'p' : S_ISSOCK(mode) ? 's' : '?';
    result[1] = (mode&S_IRUSR) ? 'r' : '-';
    result[2] = (mode&S_IWUSR) ? 'w' : '-';
    result[3] = (mode&S_ISUID) ? 's' : (mode&S_IXUSR) ? 'x' : '-';
    result[4] = (mode&S_IRGRP) ? 'r' : '-';
    result[5] = (mode&S_IWGRP) ? 'w' : '-';
    result[6] = (mode&S_ISGID) ? 's' : (mode&S_IXGRP) ? 'x' : '-';
    result[7] = (mode&S_IROTH) ? 'r' : '-';
    result[8] = (mode&S_IWOTH) ? 'w' : '-';
    result[9] = (mode&S_ISVTX) ? 't' : (mode&S_IXOTH) ? 'x' : '-';
    result[10] = 0;
    return(result);
}


// Read symbolic link
FXString readLink(const FXString& file)
{
    char lnk[MAXPATHLEN+1];
    int len = readlink(file.text(), lnk, MAXPATHLEN);

    if (0 <= len)
    {
        return(FXString(lnk, len));
    }
    else
    {
        return(FXString::null);
    }
}


// Return true if files are identical
// Compare file names and inodes for case insensitive filesystems
FXbool identical(const FXString& file1, const FXString& file2)
{
    if (file1 != file2)
    {
        struct stat linfo1, linfo2;
        return(!::lstatrep(file1.text(), &linfo1) && !::lstatrep(file2.text(), &linfo2) && linfo1.st_ino == linfo2.st_ino && linfo1.st_dev == linfo2.st_dev);
    }
    return(true);
}


// Start or stop wait cursor (start if type is BEGIN_CURSOR, stop if type is END_CURSOR)
// Do nothing if type is QUERY_CURSOR or anything different from BEGIN_CURSOR and END_CURSOR)
// Return wait cursor count (0 means wait cursor is not set)
int setWaitCursor(FXApp* app, FXuint type)
{
    static int waitcount = 0;

    // Begin wait cursor
    if (type == BEGIN_CURSOR)
    {
        app->beginWaitCursor();
        waitcount++;
    }

    // End wait cursor
    else if (type == END_CURSOR)
    {
        app->endWaitCursor();
        if (waitcount >= 1)
        {
            waitcount--;
        }
        else
        {
            waitcount = 0;
        }
    }

    // Other cases : do nothing
    else
    {
    }

    return(waitcount);
}


// Run a command in an internal st terminal
// Return 0 if success, -1 else
// N.B.: zombie process should be dealt with in the main application class
int runst(FXString cmd)
{
    FXString str1, str2;
    int nbargs, i, j;

    // First pass to find the number of commmand arguments
    nbargs = 0;
    i = 0;
    j = 1;
    while (1)
    {
        str1 = cmd.section(' ', i);
        if (str1[0] == '\'')       // If a ' is found, ignore the spaces till the next '
        {
            str2 = cmd.section('\'', j);
            j += 2;
            i += str2.contains(' ');
            nbargs++;
        }
        else
        {
            nbargs++;
        }

        if (streq(str1.text(), ""))
        {
            break;
        }

        i++;
    }
    nbargs--;

    // Second pass to allocate the argument strings
    char** args = (char**)malloc((nbargs + 1)*sizeof(char*));
    nbargs = 0;
    i = 0;
    j = 1;
    while (1)
    {
        str1 = cmd.section(' ', i);
        if (str1[0] == '\'')
        {
            str2 = cmd.section('\'', j);
            j += 2;
            i += str2.contains(' ');
            args[nbargs] = (char*)malloc(str2.length()+1);
            strlcpy(args[nbargs], str2.text(), str2.length()+1);
            nbargs++;
        }
        else
        {
            args[nbargs] = (char*)malloc(str1.length()+1);
            strlcpy(args[nbargs], str1.text(), str1.length()+1);
            nbargs++;
        }

        if (streq(str1.text(), ""))
        {
            break;
        }

        i++;
    }
    nbargs--;
    args[nbargs] = NULL;

    // Launch the command in an internal st terminal
    int res;
    static pid_t childpid = 0;
    childpid = fork();

    // Fork succeeded
    if (childpid >= 0)
    {
        if (childpid == 0) // Child
        {
            st(nbargs, args);
            exit(EXIT_SUCCESS);
        }
        else // Parent
        {
            // Non blocking wait for child
            //if (waitpid(childpid, NULL, WNOHANG) < 0)
            if (waitpid(childpid, NULL, 0) < 0)
            {
                res = -1;
            }
            else
            {
                res = 0;
            }
        }
    }

    // Fork failed
    else
    {
        fprintf(stderr, _("Error: Fork failed: %s\n"), strerror(errno));
        res = -1;
    }

    // Free allocated strings
    for (int i = 0; i < nbargs; i++)
    {
        free(args[i]);
    }
    free(args);
    
    return(res);
}


// Get the output of a Unix command
// Return the command output or the error message id any
FXString getCommandOutput(FXString cmd)
{
    FXString data;
    FILE* stream;

    const int max_buffer = 1024;
    char buffer[max_buffer];

    cmd += " 2>&1";

    stream = popen(cmd.text(), "r");
    if (stream)
    {
        while (!feof(stream))
        {
            if (fgets(buffer, max_buffer, stream) != NULL)
            {
                data += buffer;
            }
        }
        pclose(stream);
    }
    return(data);
}

char* trim(const char* str) {
    // Check if the input string is NULL or empty
    if (str == NULL || *str == '\0') {
        return strdup("");  // Return an empty string if input is NULL or empty
    }

    // Remove leading spaces
    const char* start = str;
    while (*start && isspace((unsigned char)*start)) {
        start++;
    }

    // If the string becomes empty after removing leading spaces, return empty string
    if (*start == '\0') {
        return strdup("");  // Return an empty string
    }

    // Remove trailing spaces by finding the last non-space character
    const char* end = str + strlen(str) - 1;
    while (end > start && isspace((unsigned char)*end)) {
        end--;
    }

    // Calculate the length of the trimmed string
    size_t len = end - start + 1;

    // Allocate memory for the trimmed string
    char* trimmed = (char*)malloc(len + 1);  // +1 for the null terminator
    if (trimmed == NULL) {
        return NULL;  // Return NULL if memory allocation fails
    }

    // Copy the trimmed string into the new memory
    strncpy(trimmed, start, len);
    trimmed[len] = '\0';  // Null-terminate the string

    return trimmed;  // Return the newly allocated trimmed string
}

// Load a PNG icon from a file in the icon path
FXIcon* loadiconfile(FXApp* app, const FXString iconpath, const FXString iconname, FXColor blendcolor, int arrow)
{

    // Icon name is empty
    if (iconname.length() == 0)
    {
        return(NULL);
    }



    // New PNG icon
    FXIcon* icon = NULL;
    if ( hasEnding(iconname.text(), ".png") ) {
    	icon = new FXPNGIcon(app);
    } else {
    	icon = new FXGIFIcon(app);
    }
    if (icon)
    {
        // Find icon in the icon directory
        FXString iconfile = FXPath::search(iconpath, iconname.text());

        if (!iconfile.empty())
        {
            FXFileStream str;

            // Try open the file
            if (str.open(iconfile, FXStreamLoad))
            {
                // Load it
                icon->loadPixels(str);

//printf("%s\n", iconname.text());

//		if ( trim(iconname.text()) == "iconsmenu.png" ) {

	FXColor iconforecolor = app->getForeColor();
if (arrow = 1) {
if (icon->getWidth() == 23) {
	icon->setPixel(18, 7, iconforecolor);
	icon->setPixel(19, 7, iconforecolor);
	icon->setPixel(20, 7, iconforecolor);
	icon->setPixel(21, 7, iconforecolor);
	icon->setPixel(22, 7, iconforecolor);
	icon->setPixel(19, 8, iconforecolor);
	icon->setPixel(20, 8, iconforecolor);
	icon->setPixel(21, 8, iconforecolor);
	icon->setPixel(20, 9, iconforecolor);
} else if (icon->getWidth() == 31) {
	icon->setPixel(26, 12, iconforecolor);
	icon->setPixel(27, 12, iconforecolor);
	icon->setPixel(28, 12, iconforecolor);
	icon->setPixel(29, 12, iconforecolor);
	icon->setPixel(30, 12, iconforecolor);
	icon->setPixel(27, 13, iconforecolor);
	icon->setPixel(28, 13, iconforecolor);
	icon->setPixel(29, 13, iconforecolor);
	icon->setPixel(28, 14, iconforecolor);
}
}


                // Create it
		if ( blendcolor != 0 ) {
			icon->blend(blendcolor);
		}

//printf("%s\n", iconname.text());

                icon->create();
                // Done
                str.close();

                return(icon);
            }
        }

        // Failed, delete the icon
        delete icon;
    }
    return(NULL);
}

// Load a PNG icon from a file in the icon path
FXIcon* createResizeCorner(FXApp* app, const FXString iconpath, const FXString iconname, FXColor blendcolor)
{
FXIcon* gresizecorner = NULL;
gresizecorner = new FXIcon(app);

gresizecorner->resize(13, 13);
gresizecorner->fill(app->getBaseColor());

gresizecorner->setPixel(11, 0, app->getHiliteColor());
gresizecorner->setPixel(10, 1, app->getHiliteColor());
gresizecorner->setPixel(9, 2, app->getHiliteColor());
gresizecorner->setPixel(8, 3, app->getHiliteColor());
gresizecorner->setPixel(7, 4, app->getHiliteColor());
gresizecorner->setPixel(11, 4, app->getHiliteColor());
gresizecorner->setPixel(6, 5, app->getHiliteColor());
gresizecorner->setPixel(10, 5, app->getHiliteColor());
gresizecorner->setPixel(5, 6, app->getHiliteColor());
gresizecorner->setPixel(9, 6, app->getHiliteColor());
gresizecorner->setPixel(4, 7, app->getHiliteColor());
gresizecorner->setPixel(8, 7, app->getHiliteColor());
gresizecorner->setPixel(3, 8, app->getHiliteColor());
gresizecorner->setPixel(7, 8, app->getHiliteColor());
gresizecorner->setPixel(11, 8, app->getHiliteColor());
gresizecorner->setPixel(2, 9, app->getHiliteColor());
gresizecorner->setPixel(6, 9, app->getHiliteColor());
gresizecorner->setPixel(10, 9, app->getHiliteColor());
gresizecorner->setPixel(1, 10, app->getHiliteColor());
gresizecorner->setPixel(5, 10, app->getHiliteColor());
gresizecorner->setPixel(9, 10, app->getHiliteColor());
gresizecorner->setPixel(0, 11, app->getHiliteColor());
gresizecorner->setPixel(4, 11, app->getHiliteColor());
gresizecorner->setPixel(8, 11, app->getHiliteColor());

gresizecorner->setPixel(11, 1, app->getShadowColor());
gresizecorner->setPixel(10, 2, app->getShadowColor());
gresizecorner->setPixel(11, 2, app->getShadowColor());
gresizecorner->setPixel(9, 3, app->getShadowColor());
gresizecorner->setPixel(10, 3, app->getShadowColor());
gresizecorner->setPixel(8, 4, app->getShadowColor());
gresizecorner->setPixel(9, 4, app->getShadowColor());
gresizecorner->setPixel(7, 5, app->getShadowColor());
gresizecorner->setPixel(8, 5, app->getShadowColor());
gresizecorner->setPixel(11, 5, app->getShadowColor());
gresizecorner->setPixel(6, 6, app->getShadowColor());
gresizecorner->setPixel(7, 6, app->getShadowColor());
gresizecorner->setPixel(10, 6, app->getShadowColor());
gresizecorner->setPixel(11, 6, app->getShadowColor());
gresizecorner->setPixel(5, 7, app->getShadowColor());
gresizecorner->setPixel(6, 7, app->getShadowColor());
gresizecorner->setPixel(9, 7, app->getShadowColor());
gresizecorner->setPixel(10, 7, app->getShadowColor());
gresizecorner->setPixel(4, 8, app->getShadowColor());
gresizecorner->setPixel(5, 8, app->getShadowColor());
gresizecorner->setPixel(8, 8, app->getShadowColor());
gresizecorner->setPixel(9, 8, app->getShadowColor());
gresizecorner->setPixel(3, 9, app->getShadowColor());
gresizecorner->setPixel(4, 9, app->getShadowColor());
gresizecorner->setPixel(7, 9, app->getShadowColor());
gresizecorner->setPixel(8, 9, app->getShadowColor());
gresizecorner->setPixel(11, 9, app->getShadowColor());
gresizecorner->setPixel(2, 10, app->getShadowColor());
gresizecorner->setPixel(3, 10, app->getShadowColor());
gresizecorner->setPixel(6, 10, app->getShadowColor());
gresizecorner->setPixel(7, 10, app->getShadowColor());
gresizecorner->setPixel(10, 10, app->getShadowColor());
gresizecorner->setPixel(11, 10, app->getShadowColor());
gresizecorner->setPixel(1, 11, app->getShadowColor());
gresizecorner->setPixel(2, 11, app->getShadowColor());
gresizecorner->setPixel(5, 11, app->getShadowColor());
gresizecorner->setPixel(6, 11, app->getShadowColor());
gresizecorner->setPixel(9, 11, app->getShadowColor());
gresizecorner->setPixel(10, 11, app->getShadowColor());

gresizecorner->create();
}

// Load a XBM icon from a file in the icon path
FXIcon* loadxbmiconfile(FXApp* app, const FXString iconpath, const FXString iconname, FXColor blendcolor)
{
    // Icon name is empty
    if (iconname.length() == 0)
    {
        return(NULL);
    }

    // New XBM icon
    FXIcon* icon = NULL;
    icon = new FXXBMIcon(app, NULL, NULL, FXRGB(255,255,255));
    if (icon)
    {
        // Find icon in the icon directory
        FXString iconfile = FXPath::search(iconpath, iconname.text());

        if (!iconfile.empty())
        {
            FXFileStream str;

            // Try open the file
            if (str.open(iconfile, FXStreamLoad))
            {
                // Load it
                icon->loadPixels(str);

                // Create it
                icon->create();
                // Done
                str.close();

                return(icon);
            }
        }

        // Failed, delete the icon
        delete icon;
    }
    return(NULL);
}


// Truncate a string to the specified number of UTF-8 characters
// and adds "..." to the end
FXString truncLine(FXString str, FXuint maxlinesize)
{
    if (str.count() <= (int)maxlinesize)
    {
        return(str);
    }

    return(str.trunc(str.validate(maxlinesize)) + "...");
}


// Insert line breaks as needed to allow displaying string using lines
// of specified maximum number of UTF-8 characters
FXString multiLines(FXString str, FXuint maxlinesize)
{
    int pos1 = 0;
    int pos2;

    while (1)
    {
        // No more line breaks found
        pos2 = str.find('\n', pos1);
        if (pos2 < 0)
        {
            int nbc = str.count(pos1, str.length());
            if (nbc > (int)maxlinesize)
            {
                int nbl = nbc/maxlinesize;
                for (int n = 1; n <= nbl; n++)
                {
                    str.insert(str.validate(pos1+n*maxlinesize), '\n'); // Use a valid UTF-8 position
                }
            }

            break;
        }

        // Line break found
        else
        {
            int nbc = str.count(pos1, pos2);
            if (nbc > (int)maxlinesize)
            {
                int nbl = nbc/maxlinesize;
                for (int n = 1; n <= nbl; n++)
                {
                    str.insert(str.validate(pos1+n*maxlinesize), '\n'); // Use a valid UTF-8 position
                    pos2++;
                }
            }
            pos1 = pos2 + 1;
        }
    }

    return(str);
}
