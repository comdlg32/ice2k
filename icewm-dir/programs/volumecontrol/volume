#!/usr/bin/env wish
#wm overrideredirect . 1

set tempdir "/tmp/ice2k-$env(USER)"

file mkdir $tempdir
set pidfile [open "$tempdir/volume.pid" w+]
puts $pidfile [pid]
close $pidfile

package require tktray
wm withdraw .

wm attributes . -type notification

cd [file dirname [file normalize [info script]]]

image create photo icon -file "volume.png"
tktray::icon .volumeicon -class volumeicon -image icon

wm title .volumeicon "volumeicon"

global Muted


bind .volumeicon <Button-4> {
	exec amixer -q sset Master 3%+
}

bind .volumeicon <Button-5> {
	exec amixer -q sset Master 3%-
}

bind .volumeicon <Button-1> {
	#exec ./volume &
	wm geometry . 81x136+[expr {[winfo pointerx .] - 40}]+[expr {[winfo pointery .] - 140}]

	mutestart
	setslider
	wm state . normal

	focus -force .
}


bind .volumeicon <Button-3> {
	exec ~/.icewm/programs/panel/volumemixer &
}


bind . <FocusOut> {wm withdraw .}

wm resizable . 0 0

#wm attributes . -toolwindow 1
#set t [toplevel .abc]

#wm transient $t .

global backgroundColor
global lightShadowColor
global shadowColor
global lightColor
global foregroundColor
global windowColor

proc getline {number string} {
	set number2 [expr $number - 1]
  
	set lines [split $string "\n"]
	#puts $lines
  
	set line [lindex $lines $number2]
  
	return "$line"
}

set colors [read [open "colors" r]]

set backgroundColor [getline 1 $colors]
set foregroundColor [getline 2 $colors]
set lightShadowColor [getline 3 $colors]
set shadowColor [getline 4 $colors]
set lightColor [getline 5 $colors]
set windowColor [getline 6 $colors]
#set backgroundColor {#d4d0c8}
#set lightShadowColor {#808080}
#set shadowColor {#404040}
#set lightColor {#FFFFFF}
#set foregroundColor {#000000}
#set windowColor {#FFFFFF}

option add *background $backgroundColor
option add *foreground $foregroundColor

#wm geometry . 81x136+[expr {[winfo pointerx .] - 40}]+[expr {[winfo pointery .] - 140}]

#wm geometry . 81x136+1820+921

frame .container

#font create mainfont -family {Tahoma} -size {8}
font create mainfont -family {Helvetica} -size {8}

proc getWindowColor {} {
	upvar windowColor windowColorCont
	return $windowColorCont
}

proc getForegroundColor {} {
	upvar foregroundColor foregroundColorCont
	return $foregroundColorCont
}

proc getBackgroundColor {} {
	upvar backgroundColor backgroundColorCont
	return $backgroundColorCont
}


proc setslider {} {
	set getvolume [regsub -all {\[|\]|%} [lindex [regexp -inline {\d+%} [exec amixer sget Master]] 0] ""]
	place .container.slider -x 29 -y [expr { round(100 - double($getvolume) * 57 / 100) - 9 } ]
}



#proc setmute {} {
#	if {$Muted == {True}} {
#		.container.mute itemconfig checkbox -state hidden
#		set Muted {False}
#		exec amixer set Master unmute
#	} else {
#		.container.mute itemconfig checkbox -state normal
#		set Muted {True}
#		exec amixer set Master mute
#	}			
#}

proc getmute {} {
	if { [regexp {\[on\]} [string range [exec amixer get Master] end-4 end]] == 1 } {
		return 0
	} else {
		return 1
	}
}

#puts [getmute]

proc mutestart {} {
	upvar foregroundColor foregroundColorCont

	if {[getmute] == 1 } {
		set Muted {True}
	} else {
		set Muted {False}
	}

	if {$Muted == {True}} {
		.container.mute itemconfig checkbox -state normal
		#.container.mute create bitmap 3 3 -anchor nw -tags checkbox -foreground $foregroundColorCont -bitmap @checkbox.xbm -state hidden
	} else {
		.container.mute itemconfig checkbox -state hidden
		#.container.mute create bitmap 3 3 -anchor nw -tags checkbox -foreground $foregroundColorCont -bitmap @checkbox.xbm -state hidden
	}
}

proc createBorders {} {
	upvar backgroundColor backgroundColorCont
	upvar foregroundColor foregroundColorCont
	upvar shadowColor shadowColorCont
	upvar lightShadowColor lightShadowColorCont
	upvar lightColor lightColorCont
	upvar windowColor windowColorCont

	canvas .container.borders -highlightthickness 0 -height 136 -width 81
	.container.borders create line 1 1 79 1 -fill $lightColorCont
	.container.borders create line 1 1 1 134 -fill $lightColorCont

	.container.borders create line 81 135 0 135 -fill $shadowColorCont
	.container.borders create line 80 0 80 135 -fill $shadowColorCont

	.container.borders create line 79 1 79 135 -fill $lightShadowColorCont
	.container.borders create line 80 134 1 134 -fill $lightShadowColorCont

	.container.borders create text 40 17 -text "Volume" -font mainfont -fill $foregroundColorCont

	.container.borders create line 11 34 21 97 -fill $lightColorCont
	.container.borders create line 11 34 21 34 -fill $lightColorCont
	.container.borders create line 21 34 21 99 -fill $lightShadowColorCont
	.container.borders create line 21 99 21 100 -fill $lightColorCont

	.container.borders create line 38 36 38 98 -fill $shadowColorCont
#	.container.borders create line 39 36 39 98 -fill $backgroundColorCont
	.container.borders create line 37 35 37 99 -fill $lightShadowColorCont
	.container.borders create line 40 35 40 100 -fill $lightColorCont
	.container.borders create line 37 35 40 35 -fill $lightShadowColorCont
	.container.borders create line 37 99 40 99 -fill $lightColorCont

	canvas .container.slider -highlightthickness 0 -width 21 -height 11
	.container.slider create line 0 0 20 0 -fill $lightColorCont
	.container.slider create line 0 1 0 10 -fill $lightColorCont
	.container.slider create line 0 10 20 10 -fill $shadowColorCont
	.container.slider create line 1 9 20 9 -fill $lightShadowColorCont
	.container.slider create line 20 0 20 11 -fill $shadowColorCont
	.container.slider create line 19 1 19 10 -fill $lightShadowColorCont
	#.container.slider create line 11 10 11 20 -fill $shadowColorCont

	global Holding
	set Holding {False}

	bind .container.slider <ButtonPress-1> {
		set Holding {True}
	}

	bind .container.slider <ButtonRelease-1> {
		set Holding {False}
		exec aplay $::env(ICE2KSYS_SOUND_DING) 2>/dev/null &
	}

	bind .container.slider <Motion> {
		if {$Holding == {True}} {
			set sliderlocation [expr {[winfo pointery .container.slider] - [winfo rooty .] - 4}]

			if { $sliderlocation > 34 } {
				if { 91 < $sliderlocation } {
					set sliderlocation {91}
				}
			} else {
				set sliderlocation {34}
			}
			set volume [expr { 100 - round((( double($sliderlocation) - 34) / 57 ) * 100) } ]

			exec amixer sset 'Master' $volume%%

	
			place .container.slider -y $sliderlocation
		}
	}

	pack .container.borders -side top

	canvas .container.mute -highlightthickness 0 -width 70 -height 17

	bind . <Alt-m> {
		if {[getmute] == 1} {
			.container.mute itemconfig checkbox -state hidden
			set Muted2 {False}
			exec amixer set Master unmute
		} else {
			.container.mute itemconfig checkbox -state normal
			set Muted2 {True}
			exec amixer set Master mute
		}			
	}

	bind . <Alt-M> {
		if {[getmute] == 1} {
			.container.mute itemconfig checkbox -state hidden
			set Muted2 {False}
			exec amixer set Master unmute
		} else {
			.container.mute itemconfig checkbox -state normal
			set Muted2 {True}
			exec amixer set Master mute
		}			
	}

	global Hovering

	proc hoverState {status} {
		if {$status == {true}} {
			set Hovering {True}
		} elseif {$status == {get}} {
			return $Hovering
		} else {
			set Hovering {False}
		}
	}

	bind .container.mute <ButtonRelease-1> {
		.container.mute itemconfig cbBox -outline [getWindowColor] -fill [getWindowColor]
#		if {[hoverState get] == {True}} {
			if {[getmute] == 1 } {	
				.container.mute itemconfig checkbox -state hidden
				set Muted2 {False}
				exec amixer set Master unmute
			} else {
				.container.mute itemconfig checkbox -state normal
				set Muted2 {True}
				exec amixer set Master mute
			}
#		}
	}

	bind .container.mute <ButtonPress-1> {
		hoverState true
		.container.mute itemconfig cbBox -outline [getBackgroundColor] -fill [getBackgroundColor]
	}

	bind .container.mute <Leave> {
		hoverState false
	}

	.container.mute create line 0 0 12 0 -fill $lightShadowColorCont
	.container.mute create line 0 0 0 12 -fill $lightShadowColorCont

	.container.mute create line 1 1 1 11 -fill $shadowColorCont
	.container.mute create line 1 1 11 1 -fill $shadowColorCont

	.container.mute create line 12 0 12 13 -fill $lightColorCont
	.container.mute create line 12 0 12 13 -fill $lightColorCont

	.container.mute create line 0 12 12 12 -fill $lightColorCont

	.container.mute create rectangle 2 2 10 10 -fill $windowColorCont -outline $windowColorCont -tags cbBox

	.container.mute create text 18 7 -anchor w -text {Mute} -font mainfont -underline 0 -fill $foregroundColorCont

#	image create bitmap checkbox -file [file dirname [file normalize [info script]]]/checkbox.xbm

	if { [getmute] == 1 } {
		.container.mute create bitmap 3 3 -anchor nw -tags checkbox -foreground $foregroundColorCont -bitmap @checkbox.xbm -state normal
	} else {
		.container.mute create bitmap 3 3 -anchor nw -tags checkbox -foreground $foregroundColorCont -bitmap @checkbox.xbm -state hidden
	}

	place .container.mute -x 9 -y 117
}

pack .container

#proc createWedge {
#	canvas .wedge
#	
#}


createBorders

wm withdraw .
